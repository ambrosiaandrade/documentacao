# üîå M√≥dulo 12.8: Connection Pooling & Performance

> **Objetivo:** Dominar HikariCP, pool sizing, prepared statements e monitoramento de conex√µes.

---

## üìë √çndice

1. [HikariCP Fundamentals](#1-hikaricp-fundamentals)
2. [Pool Sizing](#2-pool-sizing)
3. [Configuration Tuning](#3-configuration-tuning)
4. [Prepared Statements](#4-prepared-statements)
5. [Monitoring](#5-monitoring)
6. [Troubleshooting](#6-troubleshooting)

---

## 1. HikariCP Fundamentals

### 1.1 Por Que Connection Pool?

```java
/**
 * ‚ùå SEM Pool: Criar conex√£o a cada request
 *
 * Problemas:
 * - Lat√™ncia alta (TCP handshake, autentica√ß√£o)
 * - Overhead de recursos (CPU, mem√≥ria)
 * - Escalabilidade limitada
 */
public class NaiveConnection {
    public void queryWithoutPool() throws SQLException {
        // Cria conex√£o (lento: 50-200ms)
        try (var conn = DriverManager.getConnection(url, user, pass);
             var stmt = conn.createStatement();
             var rs = stmt.executeQuery("SELECT * FROM users")) {

            // Processa resultado (r√°pido: 1-5ms)
            while (rs.next()) {
                // ...
            }
        }
        // Fecha conex√£o (desperdi√ßa recursos)
    }
}

/**
 * ‚úÖ COM Pool: Reutilizar conex√µes
 *
 * Benef√≠cios:
 * - Lat√™ncia baixa (conex√£o j√° aberta)
 * - Menos overhead (conex√µes reutilizadas)
 * - Escalabilidade melhor (pool limitado)
 */
@Service
public class PooledConnection {

    @Autowired
    private DataSource dataSource;  // HikariCP

    public void queryWithPool() throws SQLException {
        // Pega conex√£o do pool (r√°pido: <1ms)
        try (var conn = dataSource.getConnection();
             var stmt = conn.createStatement();
             var rs = stmt.executeQuery("SELECT * FROM users")) {

            // Processa resultado
            while (rs.next()) {
                // ...
            }
        }
        // Retorna conex√£o ao pool (n√£o fecha conex√£o real)
    }
}
```

---

### 1.2 HikariCP vs Outros Pools

| Pool            | Performance | Configura√ß√£o | Observabilidade | Status             |
| --------------- | ----------- | ------------ | --------------- | ------------------ |
| **HikariCP**    | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  | Simples      | Excelente       | Padr√£o Spring Boot |
| **Tomcat JDBC** | ‚≠ê‚≠ê‚≠ê      | M√©dia        | Boa             | Legacy             |
| **C3P0**        | ‚≠ê‚≠ê        | Complexa     | Limitada        | Obsoleto           |
| **DBCP2**       | ‚≠ê‚≠ê‚≠ê      | M√©dia        | Boa             | Apache Commons     |

**HikariCP √© padr√£o Spring Boot 2+ por ser o mais r√°pido e confi√°vel.**

---

## 2. Pool Sizing

### 2.1 F√≥rmula de Pool Size

```java
/**
 * F√ìRMULA (PostgreSQL Wiki):
 *
 * connections = ((core_count * 2) + effective_spindle_count)
 *
 * Onde:
 * - core_count: CPUs da m√°quina de BD
 * - effective_spindle_count: Discos f√≠sicos (SSD = 1, HDD = N)
 *
 * Exemplo:
 * - BD com 4 cores + SSD ‚Üí pool = (4 * 2) + 1 = 9 conex√µes
 * - BD com 8 cores + SSD ‚Üí pool = (8 * 2) + 1 = 17 conex√µes
 *
 * ‚ö†Ô∏è IMPORTANTE:
 * - Mais conex√µes ‚â† melhor performance
 * - Overhead de context switching aumenta
 * - Conten√ß√£o por locks aumenta
 */

/**
 * REGRA PR√ÅTICA:
 *
 * - API REST t√≠pica: 10-20 conex√µes
 * - App com alto concorr√™ncia: 20-50 conex√µes
 * - Microservice: 5-10 conex√µes (cada inst√¢ncia)
 *
 * ‚ö†Ô∏è Evitar: >100 conex√µes (conten√ß√£o excessiva)
 */
```

---

### 2.2 Sizing por Carga

```yaml
# application.yml

# Ambiente DEV (baixa carga)
spring:
  datasource:
    hikari:
      maximum-pool-size: 5
      minimum-idle: 2

# Ambiente STAGING (carga m√©dia)
spring:
  datasource:
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5

# Ambiente PROD (alta carga)
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
```

---

## 3. Configuration Tuning

### 3.1 Configura√ß√£o Completa

```yaml
# application.yml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydb
    username: user
    password: pass
    hikari:
      # Pool Size
      maximum-pool-size: 20 # Max conex√µes no pool
      minimum-idle: 10 # M√≠n conex√µes idle (recomendado = max)

      # Timeouts
      connection-timeout: 30000 # 30s - Timeout para pegar conex√£o do pool
      idle-timeout: 600000 # 10min - Timeout para conex√£o idle (sem uso)
      max-lifetime: 1800000 # 30min - Tempo m√°ximo de vida da conex√£o

      # Validation
      connection-test-query: SELECT 1 # Query para validar conex√£o (desnecess√°rio para PostgreSQL)
      validation-timeout: 5000 # 5s - Timeout para query de valida√ß√£o

      # Leak Detection
      leak-detection-threshold: 60000 # 1min - Detecta conex√£o n√£o fechada

      # Connection Init
      connection-init-sql: SET TIME ZONE 'UTC' # SQL executado ao criar conex√£o

      # Pool Name (√∫til para logs)
      pool-name: MyAppHikariPool

      # Auto Commit
      auto-commit: true # Auto-commit por padr√£o (recomendado false com Spring)

      # Read Only
      read-only: false # Marcar conex√µes como read-only
```

---

### 3.2 Configura√ß√£o Otimizada

```yaml
# Configura√ß√£o RECOMENDADA para produ√ß√£o

spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 20 # ‚úÖ Mesmo valor que max (evita criar/destruir)

      connection-timeout: 20000 # 20s (falha r√°pido se pool exausto)
      idle-timeout: 0 # 0 = desabilita (n√£o remove conex√µes idle)
      max-lifetime: 1800000 # 30min (for√ßa rota√ß√£o de conex√µes)

      leak-detection-threshold: 60000 # 1min (alerta de memory leak)


      # PostgreSQL/MySQL: N√£o precisa connection-test-query
      # Hikari valida conex√µes automaticamente
```

---

### 3.3 Configura√ß√£o Program√°tica

```java
/**
 * Configura√ß√£o avan√ßada via c√≥digo
 */
@Configuration
public class HikariConfig {

    @Bean
    public DataSource dataSource() {
        var config = new com.zaxxer.hikari.HikariConfig();

        config.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        config.setUsername("user");
        config.setPassword("pass");

        // Pool sizing
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(20);

        // Timeouts
        config.setConnectionTimeout(20000);
        config.setIdleTimeout(0);
        config.setMaxLifetime(1800000);

        // Leak detection
        config.setLeakDetectionThreshold(60000);

        // Health check (PostgreSQL)
        config.setConnectionTestQuery(null);  // Deixar null (Hikari usa JDBC4 isValid())

        // Pool name
        config.setPoolName("MyAppPool");

        // M√©tricas (Micrometer)
        config.setMetricRegistry(new MetricRegistry());

        // Custom properties (PostgreSQL espec√≠fico)
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");

        return new HikariDataSource(config);
    }
}
```

---

## 4. Prepared Statements

### 4.1 Prepared Statement Cache

```yaml
# PostgreSQL JDBC Driver properties
spring:
  datasource:
    hikari:
      data-source-properties:
        cachePrepStmts: true # Habilita cache de prepared statements
        prepStmtCacheSize: 250 # Quantos statements cachear
        prepStmtCacheSqlLimit: 2048 # Tamanho m√°ximo do SQL (bytes)
        useServerPrepStmts: true # Usar server-side prepared statements
```

```java
/**
 * Prepared Statements: Performance melhor que Statement
 */
@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * ‚úÖ Prepared Statement: SQL parseado 1x, reutilizado
     *
     * - Melhor performance (parse cacheado)
     * - Seguro contra SQL injection
     */
    public User findByEmail(String email) {
        return jdbcTemplate.queryForObject(
            "SELECT * FROM users WHERE email = ?",  // Placeholder ?
            (rs, rowNum) -> mapUser(rs),
            email  // Par√¢metro safe
        );
    }

    /**
     * ‚ùå Statement din√¢mico: Parse a cada execu√ß√£o
     *
     * - Pior performance
     * - Risco de SQL injection
     */
    public User findByEmailUnsafe(String email) {
        var sql = "SELECT * FROM users WHERE email = '" + email + "'";  // ‚ùå Concatena√ß√£o
        return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> mapUser(rs));
    }

    /**
     * Batch com Prepared Statement
     */
    public void batchInsert(List<User> users) {
        var sql = "INSERT INTO users (email, name) VALUES (?, ?)";

        jdbcTemplate.batchUpdate(sql, users, users.size(),
            (ps, user) -> {
                ps.setString(1, user.getEmail());
                ps.setString(2, user.getName());
            }
        );

        // Hikari + PreparedStatement cache = performance m√°xima
    }
}
```

---

## 5. Monitoring

### 5.1 M√©tricas Hikari com Micrometer

```java
/**
 * Expor m√©tricas Hikari para Prometheus/Grafana
 */
@Configuration
public class HikariMetricsConfig {

    @Bean
    public MeterRegistryCustomizer<MeterRegistry> hikariMetrics(
            DataSource dataSource) {

        return registry -> {
            if (dataSource instanceof HikariDataSource hikari) {
                hikari.setMetricRegistry(registry);
            }
        };
    }
}

/**
 * M√©tricas dispon√≠veis:
 *
 * hikaricp_connections_active         - Conex√µes ativas (em uso)
 * hikaricp_connections_idle           - Conex√µes idle (dispon√≠veis)
 * hikaricp_connections_total          - Total de conex√µes no pool
 * hikaricp_connections_pending        - Threads aguardando conex√£o
 * hikaricp_connections_timeout_total  - Timeouts ao pegar conex√£o
 * hikaricp_connections_creation_ms    - Tempo para criar conex√£o
 * hikaricp_connections_usage_ms       - Tempo de uso da conex√£o
 * hikaricp_connections_acquire_ms     - Tempo para adquirir conex√£o do pool
 */
```

---

### 5.2 Health Check Endpoint

```java
/**
 * Health indicator customizado
 */
@Component
public class DataSourceHealthIndicator implements HealthIndicator {

    @Autowired
    private DataSource dataSource;

    @Override
    public Health health() {
        try {
            if (dataSource instanceof HikariDataSource hikari) {
                var poolStats = hikari.getHikariPoolMXBean();

                var details = Map.of(
                    "active", poolStats.getActiveConnections(),
                    "idle", poolStats.getIdleConnections(),
                    "total", poolStats.getTotalConnections(),
                    "pending", poolStats.getThreadsAwaitingConnection(),
                    "maxPoolSize", hikari.getMaximumPoolSize()
                );

                // Alertar se pool > 80% ocupado
                var utilization = (double) poolStats.getActiveConnections() / hikari.getMaximumPoolSize();

                if (utilization > 0.8) {
                    return Health.up()
                                 .withDetails(details)
                                 .withDetail("warning", "Pool utilization > 80%")
                                 .build();
                }

                return Health.up().withDetails(details).build();
            }

            return Health.up().build();

        } catch (Exception e) {
            return Health.down().withException(e).build();
        }
    }
}
```

---

### 5.3 Actuator Endpoint

```java
/**
 * Endpoint customizado para estat√≠sticas do pool
 */
@RestController
@RequestMapping("/actuator/hikari")
public class HikariStatsEndpoint {

    @Autowired
    private DataSource dataSource;

    @GetMapping
    public Map<String, Object> getPoolStats() {
        if (dataSource instanceof HikariDataSource hikari) {
            var pool = hikari.getHikariPoolMXBean();

            return Map.of(
                "poolName", hikari.getPoolName(),
                "active", pool.getActiveConnections(),
                "idle", pool.getIdleConnections(),
                "total", pool.getTotalConnections(),
                "pending", pool.getThreadsAwaitingConnection(),
                "maxPoolSize", hikari.getMaximumPoolSize(),
                "minIdle", hikari.getMinimumIdle(),
                "connectionTimeout", hikari.getConnectionTimeout(),
                "maxLifetime", hikari.getMaxLifetime()
            );
        }

        return Map.of("error", "Not using HikariCP");
    }
}
```

---

## 6. Troubleshooting

### 6.1 Pool Exhaustion

```java
/**
 * PROBLEMA: Pool esgotado (todas conex√µes em uso)
 *
 * Sintomas:
 * - Logs: "Connection is not available, request timed out after 30000ms"
 * - M√©tricas: hikaricp_connections_pending > 0
 * - Threads bloqueadas aguardando conex√£o
 *
 * Causas:
 * 1. Pool muito pequeno (aumentar maximum-pool-size)
 * 2. Conex√µes n√£o fechadas (leak)
 * 3. Queries lentas (otimizar SQL)
 * 4. Transa√ß√µes longas (quebrar em menores)
 */

/**
 * SOLU√á√ÉO 1: Aumentar pool size
 */
@Configuration
public class HikariConfigFix {

    @Bean
    public DataSource dataSource() {
        var config = new HikariConfig();

        // De 10 para 20 conex√µes
        config.setMaximumPoolSize(20);

        return new HikariDataSource(config);
    }
}

/**
 * SOLU√á√ÉO 2: Detectar leaks
 */
@Configuration
public class LeakDetectionConfig {

    @Bean
    public DataSource dataSource() {
        var config = new HikariConfig();

        // Alertar se conex√£o n√£o retornada em 60s
        config.setLeakDetectionThreshold(60000);

        return new HikariDataSource(config);
    }
}

/**
 * SOLU√á√ÉO 3: Timeout mais baixo (fail fast)
 */
spring:
  datasource:
    hikari:
      connection-timeout: 10000  # 10s (padr√£o 30s)
```

---

### 6.2 Connection Leaks

```java
/**
 * PROBLEMA: Conex√£o n√£o retornada ao pool
 *
 * Sintomas:
 * - Log: "Connection leak detected"
 * - M√©tricas: hikaricp_connections_idle diminuindo gradualmente
 * - Pool esgota eventualmente
 */

/**
 * ‚ùå CAUSA: N√£o fechar conex√£o
 */
@Service
public class BadService {

    @Autowired
    private DataSource dataSource;

    public void badMethod() throws SQLException {
        var conn = dataSource.getConnection();
        var stmt = conn.createStatement();
        var rs = stmt.executeQuery("SELECT * FROM users");

        // ‚ùå N√£o fecha conex√£o (LEAK!)
        // Conex√£o nunca retorna ao pool
    }
}

/**
 * ‚úÖ SOLU√á√ÉO: Try-with-resources
 */
@Service
public class GoodService {

    @Autowired
    private DataSource dataSource;

    public void goodMethod() throws SQLException {
        try (var conn = dataSource.getConnection();
             var stmt = conn.createStatement();
             var rs = stmt.executeQuery("SELECT * FROM users")) {

            // Processa resultado
            while (rs.next()) {
                // ...
            }

            // ‚úÖ Conex√£o fechada automaticamente (retorna ao pool)
        }
    }
}

/**
 * ‚úÖ MELHOR: Usar JdbcTemplate (gerencia conex√µes automaticamente)
 */
@Service
public class BestService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<User> bestMethod() {
        // JdbcTemplate fecha conex√£o automaticamente
        return jdbcTemplate.query("SELECT * FROM users",
            (rs, rowNum) -> mapUser(rs));
    }
}
```

---

### 6.3 Slow Queries

```java
/**
 * PROBLEMA: Queries lentas segurando conex√µes
 *
 * Sintomas:
 * - M√©tricas: hikaricp_connections_usage_ms alta
 * - Pool se esgota durante picos
 */

/**
 * SOLU√á√ÉO 1: Statement timeout
 */
@Configuration
public class QueryTimeoutConfig {

    @Bean
    public DataSource dataSource() {
        var config = new HikariConfig();

        // Timeout de query (PostgreSQL)
        config.addDataSourceProperty("socketTimeout", "30");  // 30s

        return new HikariDataSource(config);
    }
}

/**
 * SOLU√á√ÉO 2: Timeout no JdbcTemplate
 */
@Configuration
public class JdbcConfig {

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        var template = new JdbcTemplate(dataSource);

        // Timeout de query (segundos)
        template.setQueryTimeout(30);

        return template;
    }
}

/**
 * SOLU√á√ÉO 3: Otimizar queries lentas
 */
@Service
public class OptimizedService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * ‚ùå Query lenta: Sem √≠ndice, N+1
     */
    public List<Order> slowQuery() {
        return jdbcTemplate.query("SELECT * FROM orders", this::mapOrder);
        // Para cada order, busca customer (N+1)
    }

    /**
     * ‚úÖ Query otimizada: JOIN, √≠ndices
     */
    public List<Order> fastQuery() {
        return jdbcTemplate.query("""
            SELECT o.*, c.name AS customer_name
            FROM orders o
            INNER JOIN customers c ON o.customer_id = c.id
            WHERE o.created_at > NOW() - INTERVAL '30 days'
            """, this::mapOrderWithCustomer);
    }
}
```

---

## üìä Checklist de Qualidade

- [ ] Pool size baseado em f√≥rmula (n√£o "chute")
- [ ] minimum-idle = maximum-pool-size (evita oscila√ß√£o)
- [ ] leak-detection-threshold habilitado (60s)
- [ ] M√©tricas Hikari expostas (Prometheus/Grafana)
- [ ] Alertas: Pool utilization > 80%, pending threads > 0
- [ ] Try-with-resources ou JdbcTemplate (evita leaks)
- [ ] Prepared statement cache habilitado (PostgreSQL/MySQL)
- [ ] Statement timeout configurado (30s recomendado)
- [ ] Health check monitora pool stats
- [ ] Load tests validam pool sizing

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Configurar HikariCP com m√©tricas
2. **Intermedi√°rio**: Simular pool exhaustion e resolver
3. **Avan√ßado**: Load test para determinar pool size ideal

---

## üìö Refer√™ncias

- [HikariCP Documentation](https://github.com/brettwooldridge/HikariCP)
- [PostgreSQL Connection Pool Sizing](https://wiki.postgresql.org/wiki/Number_Of_Database_Connections)
- [Hikari Best Practices](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)

---

**Anterior:** [12.7 - Triggers & Procedures](12.7-triggers-procedures.md)  
**Pr√≥ximo:** [12.9 - Multi-Tenancy](12.9-multi-tenancy.md)
