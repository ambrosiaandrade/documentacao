# üóÑÔ∏è 12.1 SQL Avan√ßado & PostgreSQL - Conceitos S√™nior/Arquiteto

## √çndice

1. [Introdu√ß√£o](#1-introdu√ß√£o)
2. [Window Functions](#2-window-functions)
3. [CTEs e Recurs√£o](#3-ctes-e-recurs√£o)
4. [Constraints e Integridade](#4-constraints-e-integridade)
5. [Concorr√™ncia e Locking](#5-concorr√™ncia-e-locking)
6. [Isolation Levels e MVCC](#6-isolation-levels-e-mvcc)
7. [Performance e Otimiza√ß√£o](#7-performance-e-otimiza√ß√£o)
8. [Particionamento](#8-particionamento)
9. [Boas Pr√°ticas](#9-boas-pr√°ticas)

---

## 1. Introdu√ß√£o

### Por que PostgreSQL?

**PostgreSQL** √© considerado o RDBMS open source mais avan√ßado, com features enterprise-grade:

- ‚úÖ **ACID completo** com MVCC (Multi-Version Concurrency Control)
- ‚úÖ **Extensibilidade** (tipos customizados, operadores, √≠ndices)
- ‚úÖ **JSON nativo** (JSONB) para dados semi-estruturados
- ‚úÖ **Window functions**, CTEs recursivas, full-text search
- ‚úÖ **Replica√ß√£o** (streaming, logical) e HA (Patroni, Stolon)
- ‚úÖ **Performance** compar√°vel a solu√ß√µes comerciais

### Diferen√ßas PostgreSQL vs MySQL

| Feature               | PostgreSQL                  | MySQL (InnoDB)          |
| --------------------- | --------------------------- | ----------------------- |
| **Concurrency**       | MVCC (melhor)               | Locking (mais locks)    |
| **Isolation Default** | Read Committed              | Repeatable Read         |
| **Window Functions**  | ‚úÖ Completo                 | ‚úÖ (desde 8.0)          |
| **CTEs Recursivas**   | ‚úÖ Sim                      | ‚úÖ Sim                  |
| **JSON**              | JSONB (index√°vel)           | JSON (menos eficiente)  |
| **Full-Text Search**  | Nativo (tsvector)           | Limitado                |
| **Extens√µes**         | PostGIS, pg_stat_statements | Limitado                |
| **Transa√ß√µes DDL**    | ‚úÖ Sim (rollback schema)    | ‚ùå N√£o                  |
| **Stored Procedures** | PL/pgSQL, Python, etc       | MySQL stored procedures |

**Recomenda√ß√£o:** PostgreSQL para aplica√ß√µes enterprise, MySQL para casos simples ou legado.

---

## 2. Window Functions

### O que s√£o Window Functions?

Fun√ß√µes que operam sobre **conjunto de linhas relacionadas** sem agrupar resultados (diferente de `GROUP BY`).

**Sintaxe:**

```sql
fun√ß√£o_window() OVER (
    [PARTITION BY coluna]
    [ORDER BY coluna]
    [ROWS/RANGE frame]
)
```

### 2.1 ROW_NUMBER, RANK, DENSE_RANK

**Problema:** Numerar pedidos por cliente ordenados por data.

```sql
-- Schema
CREATE TABLE orders (
    id BIGSERIAL PRIMARY KEY,
    customer_id BIGINT NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL
);

-- Dados de exemplo
INSERT INTO orders (customer_id, order_date, total_amount) VALUES
(1, '2024-01-15', 100.00),
(1, '2024-02-20', 150.00),
(1, '2024-03-10', 200.00),
(2, '2024-01-05', 300.00),
(2, '2024-01-05', 300.00), -- mesmo valor e data
(2, '2024-02-15', 250.00);
```

**Query com Window Functions:**

```sql
SELECT
    customer_id,
    order_date,
    total_amount,
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date) AS row_num,
    RANK() OVER (PARTITION BY customer_id ORDER BY order_date) AS rank,
    DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY order_date) AS dense_rank
FROM orders
ORDER BY customer_id, order_date;
```

**Resultado:**

| customer_id | order_date | total_amount | row_num | rank | dense_rank |
| ----------- | ---------- | ------------ | ------- | ---- | ---------- |
| 1           | 2024-01-15 | 100.00       | 1       | 1    | 1          |
| 1           | 2024-02-20 | 150.00       | 2       | 2    | 2          |
| 1           | 2024-03-10 | 200.00       | 3       | 3    | 3          |
| 2           | 2024-01-05 | 300.00       | 1       | 1    | 1          |
| 2           | 2024-01-05 | 300.00       | 2       | 1    | 1          |
| 2           | 2024-02-15 | 250.00       | 3       | 3    | 2          |

**Diferen√ßas:**

- `ROW_NUMBER()`: Sempre √∫nico (1, 2, 3...)
- `RANK()`: Pula posi√ß√µes em empates (1, 1, 3...)
- `DENSE_RANK()`: N√£o pula posi√ß√µes (1, 1, 2...)

### 2.2 LAG e LEAD

**Problema:** Comparar valor atual com anterior/pr√≥ximo.

```sql
-- Calcular varia√ß√£o de vendas m√™s a m√™s
SELECT
    customer_id,
    order_date,
    total_amount,
    LAG(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS prev_amount,
    total_amount - LAG(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS diff,
    LEAD(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS next_amount
FROM orders
ORDER BY customer_id, order_date;
```

**Resultado:**

| customer_id | order_date | total_amount | prev_amount | diff  | next_amount |
| ----------- | ---------- | ------------ | ----------- | ----- | ----------- |
| 1           | 2024-01-15 | 100.00       | NULL        | NULL  | 150.00      |
| 1           | 2024-02-20 | 150.00       | 100.00      | 50.00 | 200.00      |
| 1           | 2024-03-10 | 200.00       | 150.00      | 50.00 | NULL        |

### 2.3 NTILE

**Problema:** Dividir clientes em quartis de gasto.

```sql
SELECT
    customer_id,
    SUM(total_amount) AS total_spent,
    NTILE(4) OVER (ORDER BY SUM(total_amount) DESC) AS quartile
FROM orders
GROUP BY customer_id
ORDER BY total_spent DESC;
```

### 2.4 Aggregate Window Functions

**Problema:** Running totals e m√©dias m√≥veis.

```sql
-- Running total e m√©dia m√≥vel de 3 pedidos
SELECT
    customer_id,
    order_date,
    total_amount,
    SUM(total_amount) OVER (
        PARTITION BY customer_id
        ORDER BY order_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total,
    AVG(total_amount) OVER (
        PARTITION BY customer_id
        ORDER BY order_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3
FROM orders
ORDER BY customer_id, order_date;
```

**Frame Clauses:**

```sql
-- Diferentes tipos de frames
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW      -- Do in√≠cio at√© atual
ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING              -- 2 antes e 2 depois
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING      -- Atual at√© final
RANGE BETWEEN INTERVAL '1 month' PRECEDING AND CURRENT ROW  -- √öltimo m√™s
```

### 2.5 Caso de Uso Real: Top N por Grupo

**Problema:** Pegar os 3 maiores pedidos de cada cliente.

```sql
WITH ranked_orders AS (
    SELECT
        customer_id,
        order_date,
        total_amount,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY total_amount DESC) AS rn
    FROM orders
)
SELECT
    customer_id,
    order_date,
    total_amount
FROM ranked_orders
WHERE rn <= 3
ORDER BY customer_id, rn;
```

---

## 3. CTEs e Recurs√£o

### 3.1 CTEs B√°sicos (Common Table Expressions)

**Vantagem:** Melhor legibilidade vs subqueries aninhadas.

```sql
-- Sem CTE (dif√≠cil ler)
SELECT c.name, o.total
FROM customers c
JOIN (
    SELECT customer_id, SUM(total_amount) AS total
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total_amount) > 1000
) o ON c.id = o.customer_id;

-- Com CTE (mais claro)
WITH high_value_customers AS (
    SELECT
        customer_id,
        SUM(total_amount) AS total
    FROM orders
    GROUP BY customer_id
    HAVING SUM(total_amount) > 1000
)
SELECT
    c.name,
    hvc.total
FROM customers c
JOIN high_value_customers hvc ON c.id = hvc.customer_id;
```

### 3.2 CTEs Recursivas

**Problema:** Estruturas hier√°rquicas (√°rvores, grafos).

**Schema:**

```sql
CREATE TABLE employees (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    manager_id BIGINT REFERENCES employees(id),
    salary DECIMAL(10, 2)
);

INSERT INTO employees (id, name, manager_id, salary) VALUES
(1, 'CEO', NULL, 200000),
(2, 'CTO', 1, 150000),
(3, 'CFO', 1, 150000),
(4, 'Tech Lead', 2, 120000),
(5, 'Senior Dev', 4, 100000),
(6, 'Junior Dev', 4, 60000),
(7, 'Accountant', 3, 80000);
```

**Query Recursiva: √Årvore Organizacional**

```sql
WITH RECURSIVE org_chart AS (
    -- Caso base: CEO (sem manager)
    SELECT
        id,
        name,
        manager_id,
        salary,
        0 AS level,
        ARRAY[id] AS path,
        name::TEXT AS hierarchy
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Caso recursivo: subordinados
    SELECT
        e.id,
        e.name,
        e.manager_id,
        e.salary,
        oc.level + 1,
        oc.path || e.id,
        oc.hierarchy || ' > ' || e.name
    FROM employees e
    JOIN org_chart oc ON e.manager_id = oc.id
)
SELECT
    REPEAT('  ', level) || name AS employee,
    level,
    salary,
    hierarchy
FROM org_chart
ORDER BY path;
```

**Resultado:**

```
employee              | level | salary    | hierarchy
----------------------|-------|-----------|---------------------------
CEO                   | 0     | 200000.00 | CEO
  CTO                 | 1     | 150000.00 | CEO > CTO
    Tech Lead         | 2     | 120000.00 | CEO > CTO > Tech Lead
      Senior Dev      | 3     | 100000.00 | CEO > CTO > Tech Lead > Senior Dev
      Junior Dev      | 3     | 60000.00  | CEO > CTO > Tech Lead > Junior Dev
  CFO                 | 1     | 150000.00 | CEO > CFO
    Accountant        | 2     | 80000.00  | CEO > CFO > Accountant
```

### 3.3 Casos de Uso: Grafos

**Problema:** Encontrar todos os caminhos em um grafo.

```sql
CREATE TABLE connections (
    from_node INT,
    to_node INT,
    cost INT
);

INSERT INTO connections VALUES
(1, 2, 5), (1, 3, 10),
(2, 3, 2), (2, 4, 8),
(3, 4, 3), (4, 5, 1);

-- Encontrar todos os caminhos de 1 at√© 5
WITH RECURSIVE paths AS (
    SELECT
        from_node,
        to_node,
        cost,
        ARRAY[from_node, to_node] AS path,
        cost AS total_cost
    FROM connections
    WHERE from_node = 1

    UNION ALL

    SELECT
        c.from_node,
        c.to_node,
        c.cost,
        p.path || c.to_node,
        p.total_cost + c.cost
    FROM connections c
    JOIN paths p ON c.from_node = p.to_node
    WHERE NOT c.to_node = ANY(p.path) -- Evitar ciclos
)
SELECT
    path,
    total_cost
FROM paths
WHERE to_node = 5
ORDER BY total_cost;
```

---

## 4. Constraints e Integridade

### 4.1 Tipos de Constraints

| Constraint      | Descri√ß√£o                                    | Exemplo                              |
| --------------- | -------------------------------------------- | ------------------------------------ |
| **PRIMARY KEY** | Identifica unicamente cada registro          | `id BIGSERIAL PRIMARY KEY`           |
| **FOREIGN KEY** | Refer√™ncia a outra tabela                    | `REFERENCES users(id)`               |
| **UNIQUE**      | Valores √∫nicos (permite NULL m√∫ltiplos)      | `UNIQUE(email)`                      |
| **NOT NULL**    | N√£o permite valores nulos                    | `name VARCHAR(100) NOT NULL`         |
| **CHECK**       | Valida√ß√£o customizada                        | `CHECK (age >= 18)`                  |
| **EXCLUSION**   | Exclus√£o de intervalos (PostgreSQL-specific) | `EXCLUDE USING gist (range WITH &&)` |

### 4.2 Foreign Keys com Cascading

```sql
CREATE TABLE authors (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE books (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    author_id BIGINT NOT NULL,
    CONSTRAINT fk_author FOREIGN KEY (author_id)
        REFERENCES authors(id)
        ON DELETE CASCADE        -- Deleta livros quando autor √© deletado
        ON UPDATE CASCADE        -- Atualiza author_id se authors.id mudar
);
```

**Op√ß√µes de Cascading:**

- `ON DELETE CASCADE`: Deleta registros dependentes
- `ON DELETE SET NULL`: Define FK como NULL
- `ON DELETE SET DEFAULT`: Define FK como valor default
- `ON DELETE RESTRICT`: Pro√≠be dele√ß√£o (padr√£o)
- `ON DELETE NO ACTION`: Similar a RESTRICT (verifica no fim da transa√ß√£o)

### 4.3 CHECK Constraints

```sql
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    discount_percent INT,
    stock_quantity INT NOT NULL,

    -- Constraints
    CONSTRAINT chk_price_positive CHECK (price > 0),
    CONSTRAINT chk_discount_range CHECK (discount_percent BETWEEN 0 AND 100),
    CONSTRAINT chk_stock_non_negative CHECK (stock_quantity >= 0)
);

-- Tentar inserir dados inv√°lidos
INSERT INTO products (name, price, discount_percent, stock_quantity)
VALUES ('Product A', -10.00, 50, 100);
-- ERROR: new row violates check constraint "chk_price_positive"
```

### 4.4 EXCLUSION Constraints (PostgreSQL)

**Problema:** Evitar overlapping de intervalos de tempo.

```sql
CREATE EXTENSION btree_gist; -- Necess√°rio para EXCLUSION

CREATE TABLE room_bookings (
    id BIGSERIAL PRIMARY KEY,
    room_id INT NOT NULL,
    guest_name VARCHAR(100) NOT NULL,
    check_in DATE NOT NULL,
    check_out DATE NOT NULL,

    -- Garantir que n√£o h√° reservas sobrepostas para mesma sala
    CONSTRAINT no_overlap EXCLUDE USING gist (
        room_id WITH =,
        daterange(check_in, check_out, '[]') WITH &&
    )
);

-- Inser√ß√µes v√°lidas
INSERT INTO room_bookings (room_id, guest_name, check_in, check_out)
VALUES (1, 'Alice', '2024-01-01', '2024-01-05');

INSERT INTO room_bookings (room_id, guest_name, check_in, check_out)
VALUES (1, 'Bob', '2024-01-05', '2024-01-10'); -- OK: n√£o sobrep√µe

-- Tentativa de overlap
INSERT INTO room_bookings (room_id, guest_name, check_in, check_out)
VALUES (1, 'Charlie', '2024-01-03', '2024-01-07'); -- ERRO!
-- ERROR: conflicting key value violates exclusion constraint "no_overlap"
```

### 4.5 Deferred Constraints

```sql
CREATE TABLE parent (
    id INT PRIMARY KEY
);

CREATE TABLE child (
    id INT PRIMARY KEY,
    parent_id INT,
    CONSTRAINT fk_parent FOREIGN KEY (parent_id)
        REFERENCES parent(id)
        DEFERRABLE INITIALLY DEFERRED  -- Valida no COMMIT
);

BEGIN;
    -- Inserir filho antes do pai (temporariamente viola constraint)
    INSERT INTO child VALUES (1, 100);
    INSERT INTO parent VALUES (100);
COMMIT; -- Valida√ß√£o acontece aqui - OK!
```

---

## 5. Concorr√™ncia e Locking

### 5.1 Tipos de Locks no PostgreSQL

| Lock Mode            | Conflita Com                    | Uso                          |
| -------------------- | ------------------------------- | ---------------------------- |
| **ACCESS SHARE**     | ACCESS EXCLUSIVE                | SELECT                       |
| **ROW SHARE**        | EXCLUSIVE, ACCESS EXCLUSIVE     | SELECT FOR UPDATE            |
| **ROW EXCLUSIVE**    | SHARE, SHARE ROW EXCLUSIVE, ... | INSERT, UPDATE, DELETE       |
| **SHARE**            | ROW EXCLUSIVE, ...              | CREATE INDEX                 |
| **ACCESS EXCLUSIVE** | Todos                           | DROP TABLE, TRUNCATE, VACUUM |

### 5.2 Pessimistic Locking (Expl√≠cito)

**SELECT FOR UPDATE:**

```sql
-- Session 1
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Lock adquirido - outras sess√µes aguardam
```

```sql
-- Session 2 (bloqueada at√© Session 1 fazer COMMIT)
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Aguardando...
```

**Varia√ß√µes:**

```sql
-- FOR UPDATE NOWAIT - Falha imediatamente se locked
SELECT * FROM accounts WHERE id = 1 FOR UPDATE NOWAIT;
-- ERROR: could not obtain lock on row

-- FOR UPDATE SKIP LOCKED - Pula linhas locadas
SELECT * FROM queue WHERE processed = false
FOR UPDATE SKIP LOCKED
LIMIT 10;
-- √ötil para work queues distribu√≠das
```

### 5.3 Optimistic Locking com @Version

**Java (JPA):**

```java
@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private BigDecimal price;

    @Version  // Optimistic locking autom√°tico
    private Long version;

    // getters/setters
}
```

**SQL Gerado:**

```sql
-- Ao atualizar, JPA inclui vers√£o no WHERE
UPDATE products
SET name = 'New Name', price = 99.99, version = 2
WHERE id = 1 AND version = 1;

-- Se version mudou (outro update concorrente), retorna 0 linhas
-- JPA lan√ßa OptimisticLockException
```

**Teste:**

```java
@Test
void deveDetectar_ConcurrentUpdate_ComOptimisticLocking() {
    // Arrange
    var product1 = productRepository.findById(1L).orElseThrow();
    var product2 = productRepository.findById(1L).orElseThrow();

    // Act - Update 1 sucede
    product1.setPrice(new BigDecimal("99.99"));
    productRepository.save(product1);

    // Act - Update 2 falha (vers√£o desatualizada)
    product2.setPrice(new BigDecimal("88.88"));

    // Assert
    assertThatThrownBy(() -> productRepository.save(product2))
        .isInstanceOf(OptimisticLockingFailureException.class);
}
```

### 5.4 Deadlocks

**Exemplo de Deadlock:**

```sql
-- Session 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Aguarda 2 segundos
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- Session 2 (executando simultaneamente)
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
UPDATE accounts SET balance = balance + 50 WHERE id = 1;

-- DEADLOCK detectado!
-- ERROR: deadlock detected
```

**PostgreSQL detecta deadlocks automaticamente e aborta uma das transa√ß√µes.**

**Solu√ß√£o: Ordenar locks**

```sql
-- Sempre fazer updates em ordem de ID
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

### 5.5 Detectar Deadlocks

```sql
-- Ver locks ativos
SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    wait_event_type,
    wait_event
FROM pg_stat_activity
WHERE wait_event IS NOT NULL;

-- Matar sess√£o em deadlock
SELECT pg_terminate_backend(pid);
```

**Log de Deadlocks:**

```sql
-- postgresql.conf
log_lock_waits = on
deadlock_timeout = 1s
log_statement = 'all'
```

---

## 6. Isolation Levels e MVCC

### 6.1 Isolation Levels (ANSI SQL)

| Isolation Level      | Dirty Read | Non-Repeatable Read | Phantom Read | Performance    |
| -------------------- | ---------- | ------------------- | ------------ | -------------- |
| **Read Uncommitted** | ‚ùå Sim     | ‚ùå Sim              | ‚ùå Sim       | ‚ö° R√°pido      |
| **Read Committed**   | ‚úÖ N√£o     | ‚ùå Sim              | ‚ùå Sim       | ‚ö°‚ö° M√©dio     |
| **Repeatable Read**  | ‚úÖ N√£o     | ‚úÖ N√£o              | ‚ùå Sim       | ‚ö°‚ö°‚ö° Lento   |
| **Serializable**     | ‚úÖ N√£o     | ‚úÖ N√£o              | ‚úÖ N√£o       | üê¢ Muito Lento |

**PostgreSQL:**

- Suporta apenas **Read Committed** (padr√£o) e **Repeatable Read** e **Serializable**
- N√£o implementa Read Uncommitted (mapeia para Read Committed)

### 6.2 Problemas de Concorr√™ncia

**1. Dirty Read (nunca ocorre no PostgreSQL):**

```sql
-- Session 1
BEGIN;
UPDATE accounts SET balance = 1000 WHERE id = 1;
-- Ainda n√£o fez COMMIT

-- Session 2
SELECT balance FROM accounts WHERE id = 1;
-- PostgreSQL: Retorna valor antigo (MVCC)
-- MySQL (Read Uncommitted): Retorna 1000 (dirty read!)
```

**2. Non-Repeatable Read:**

```sql
-- Session 1 (Read Committed - padr√£o)
BEGIN;
SELECT balance FROM accounts WHERE id = 1;  -- Retorna 500

-- Session 2
UPDATE accounts SET balance = 1000 WHERE id = 1;
COMMIT;

-- Session 1 (mesma transa√ß√£o)
SELECT balance FROM accounts WHERE id = 1;  -- Retorna 1000 (mudou!)
COMMIT;
```

**3. Phantom Read:**

```sql
-- Session 1
BEGIN;
SELECT COUNT(*) FROM orders WHERE status = 'PENDING';  -- Retorna 10

-- Session 2
INSERT INTO orders (status) VALUES ('PENDING');
COMMIT;

-- Session 1
SELECT COUNT(*) FROM orders WHERE status = 'PENDING';  -- Retorna 11 (phantom!)
COMMIT;
```

### 6.3 MVCC (Multi-Version Concurrency Control)

**Como funciona:**

1. Cada transa√ß√£o v√™ um **snapshot** consistente do banco
2. Updates criam **nova vers√£o** da linha (n√£o sobrescreve)
3. Antigas vers√µes s√£o mantidas at√© n√£o serem mais necess√°rias
4. **VACUUM** remove vers√µes antigas (dead tuples)

**Vantagem:** Leitores n√£o bloqueiam escritores (e vice-versa).

**Desvantagem:** Table bloat (necessita VACUUM).

**Visualizar Dead Tuples:**

```sql
SELECT
    schemaname,
    tablename,
    n_live_tup AS live_tuples,
    n_dead_tup AS dead_tuples,
    ROUND(n_dead_tup * 100.0 / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
ORDER BY n_dead_tup DESC;
```

### 6.4 Configurar Isolation Level

**Java (JPA):**

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void processOrder(Long orderId) {
    var order = orderRepository.findById(orderId).orElseThrow();
    // Garantia de leitura consistente
    order.setStatus(OrderStatus.PROCESSING);
    orderRepository.save(order);
}
```

**SQL:**

```sql
-- Por transa√ß√£o
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM accounts WHERE id = 1;
COMMIT;

-- Por sess√£o
SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

### 6.5 Serializable Snapshot Isolation (SSI)

**PostgreSQL 9.1+:** Serializable implementado com SSI (performance melhor que 2PL tradicional).

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    var from = accountRepository.findById(fromId).orElseThrow();
    var to = accountRepository.findById(toId).orElseThrow();

    from.setBalance(from.getBalance().subtract(amount));
    to.setBalance(to.getBalance().add(amount));

    accountRepository.saveAll(List.of(from, to));
}
// Se conflito detectado, lan√ßa SerializationFailureException
// Application deve retry a transa√ß√£o
```

---

## 7. Performance e Otimiza√ß√£o

### 7.1 EXPLAIN e EXPLAIN ANALYZE

**EXPLAIN:** Mostra plano de execu√ß√£o (sem executar).

```sql
EXPLAIN
SELECT * FROM orders WHERE customer_id = 123;
```

**Resultado:**

```
Seq Scan on orders  (cost=0.00..35.50 rows=10 width=100)
  Filter: (customer_id = 123)
```

**EXPLAIN ANALYZE:** Executa query e mostra tempo real.

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 123;
```

**Resultado:**

```
Seq Scan on orders  (cost=0.00..35.50 rows=10 width=100) (actual time=0.012..0.145 rows=10 loops=1)
  Filter: (customer_id = 123)
  Rows Removed by Filter: 990
Planning Time: 0.082 ms
Execution Time: 0.167 ms
```

**Termos Importantes:**

- **cost**: Estimativa de custo (n√£o √© tempo real)
- **rows**: Estimativa de linhas retornadas
- **width**: Tamanho m√©dio de cada linha (bytes)
- **actual time**: Tempo real de execu√ß√£o
- **loops**: N√∫mero de vezes que o n√≥ foi executado

### 7.2 Tipos de Scan

| Scan Type           | Descri√ß√£o                               | Performance       |
| ------------------- | --------------------------------------- | ----------------- |
| **Seq Scan**        | L√™ todas as linhas da tabela            | üê¢ Lento          |
| **Index Scan**      | Usa √≠ndice para localizar linhas        | ‚ö° R√°pido         |
| **Index Only Scan** | Dados v√™m apenas do √≠ndice (sem tabela) | ‚ö°‚ö° Muito R√°pido |
| **Bitmap Scan**     | Usa m√∫ltiplos √≠ndices combinados        | ‚ö° M√©dio          |

### 7.3 √çndices

**Criar √çndice:**

```sql
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
```

**Antes:**

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 123;
-- Seq Scan (100ms)
```

**Depois:**

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 123;
-- Index Scan using idx_orders_customer_id (5ms)
```

**Tipos de √çndices PostgreSQL:**

| Tipo       | Uso                                       | Exemplo                                 |
| ---------- | ----------------------------------------- | --------------------------------------- |
| **B-Tree** | Padr√£o, bom para ordena√ß√£o e ranges       | `CREATE INDEX idx ON t(col)`            |
| **Hash**   | Apenas igualdade (=)                      | `CREATE INDEX idx ON t USING hash(col)` |
| **GiST**   | Geometria, full-text, ranges              | `CREATE INDEX idx ON t USING gist(col)` |
| **GIN**    | Arrays, JSONB, full-text                  | `CREATE INDEX idx ON t USING gin(col)`  |
| **BRIN**   | Muito grandes, ordenados cronologicamente | `CREATE INDEX idx ON t USING brin(col)` |

**√çndice Composto:**

```sql
CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);

-- Usar√° √≠ndice (esquerda para direita)
SELECT * FROM orders WHERE customer_id = 123;
SELECT * FROM orders WHERE customer_id = 123 AND order_date > '2024-01-01';

-- N√£o usar√° √≠ndice (precisa de customer_id primeiro)
SELECT * FROM orders WHERE order_date > '2024-01-01';
```

**√çndice Parcial:**

```sql
-- Apenas para pedidos ativos
CREATE INDEX idx_active_orders ON orders(customer_id) WHERE status = 'ACTIVE';
```

**√çndice em Express√£o:**

```sql
-- Busca case-insensitive
CREATE INDEX idx_email_lower ON users(LOWER(email));

SELECT * FROM users WHERE LOWER(email) = 'user@example.com';
```

### 7.4 pg_stat_statements

**Extens√£o para estat√≠sticas de queries:**

```sql
-- Ativar extens√£o
CREATE EXTENSION pg_stat_statements;

-- Ver queries mais lentas
SELECT
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;
```

### 7.5 Detectar Missing Indexes

**Script √∫til:**

```sql
SELECT
    schemaname,
    tablename,
    attname,
    n_distinct,
    most_common_vals,
    correlation
FROM pg_stats
WHERE schemaname = 'public'
AND tablename = 'orders'
ORDER BY n_distinct DESC;
```

**√çndices n√£o usados:**

```sql
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan AS scans,
    idx_tup_read AS tuples_read,
    idx_tup_fetch AS tuples_fetched
FROM pg_stat_user_indexes
WHERE idx_scan = 0
AND indexrelname NOT LIKE 'pg_toast%'
ORDER BY schemaname, tablename;
```

---

## 8. Particionamento

### 8.1 Quando Particionar?

**Sinais:**

- ‚úÖ Tabelas com 100M+ linhas
- ‚úÖ Queries lentas mesmo com √≠ndices
- ‚úÖ Dados acessados por faixa de tempo (logs, m√©tricas)
- ‚úÖ DELETE de grandes volumes (arquivamento)

**Benef√≠cios:**

- ‚ö° Queries mais r√°pidas (partition pruning)
- üóëÔ∏è DROP partition vs DELETE (instant√¢neo)
- üì¶ Manuten√ß√£o paralela (VACUUM por partition)

### 8.2 Range Partitioning

**Exemplo: Logs por m√™s**

```sql
-- Tabela pai
CREATE TABLE logs (
    id BIGSERIAL,
    user_id BIGINT NOT NULL,
    action VARCHAR(100) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    data JSONB
) PARTITION BY RANGE (created_at);

-- Parti√ß√µes
CREATE TABLE logs_2024_01 PARTITION OF logs
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE logs_2024_02 PARTITION OF logs
    FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');

CREATE TABLE logs_2024_03 PARTITION OF logs
    FOR VALUES FROM ('2024-03-01') TO ('2024-04-01');

-- Criar √≠ndices em cada partition
CREATE INDEX idx_logs_2024_01_user ON logs_2024_01(user_id);
CREATE INDEX idx_logs_2024_02_user ON logs_2024_02(user_id);
CREATE INDEX idx_logs_2024_03_user ON logs_2024_03(user_id);
```

**Insert autom√°tico:**

```sql
INSERT INTO logs (user_id, action, created_at, data)
VALUES (123, 'LOGIN', '2024-02-15 10:00:00', '{}');
-- Vai para logs_2024_02 automaticamente
```

**Partition Pruning:**

```sql
EXPLAIN ANALYZE
SELECT * FROM logs
WHERE created_at BETWEEN '2024-02-01' AND '2024-02-28';

-- PostgreSQL escaneia apenas logs_2024_02 (n√£o outras partitions)
```

### 8.3 List Partitioning

**Exemplo: Usuarios por regi√£o**

```sql
CREATE TABLE users (
    id BIGSERIAL,
    name VARCHAR(100) NOT NULL,
    region VARCHAR(10) NOT NULL,
    email VARCHAR(100) NOT NULL
) PARTITION BY LIST (region);

CREATE TABLE users_north PARTITION OF users
    FOR VALUES IN ('north');

CREATE TABLE users_south PARTITION OF users
    FOR VALUES IN ('south', 'southeast');

CREATE TABLE users_other PARTITION OF users
    DEFAULT;  -- Catch-all para valores n√£o mapeados
```

### 8.4 Hash Partitioning

**Exemplo: Distribui√ß√£o uniforme**

```sql
CREATE TABLE events (
    id BIGSERIAL,
    event_type VARCHAR(50),
    event_data JSONB
) PARTITION BY HASH (id);

CREATE TABLE events_0 PARTITION OF events
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE events_1 PARTITION OF events
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE events_2 PARTITION OF events
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE events_3 PARTITION OF events
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

### 8.5 Automa√ß√£o de Cria√ß√£o de Partitions

**pg_partman Extension:**

```sql
CREATE EXTENSION pg_partman;

-- Criar partitions automaticamente
SELECT partman.create_parent(
    p_parent_table := 'public.logs',
    p_control := 'created_at',
    p_type := 'native',
    p_interval := '1 month',
    p_premake := 3  -- Criar 3 meses antecipadamente
);

-- Manuten√ß√£o peri√≥dica (cron)
SELECT partman.run_maintenance();
```

---

## 9. Boas Pr√°ticas

### ‚úÖ DO

1. **Use √çndices, mas com modera√ß√£o**

   ```sql
   -- √çndices demais = INSERT/UPDATE lentos
   -- Regra: M√°ximo 5-7 √≠ndices por tabela
   ```

2. **Connection Pooling (HikariCP)**

   ```yaml
   spring.datasource.hikari.maximum-pool-size=10
   spring.datasource.hikari.minimum-idle=5
   ```

3. **Prepared Statements sempre**

   ```java
   // ‚úÖ Seguro e mais r√°pido
   jdbcTemplate.query("SELECT * FROM users WHERE id = ?", id);

   // ‚ùå SQL Injection + lento
   jdbcTemplate.query("SELECT * FROM users WHERE id = " + id);
   ```

4. **VACUUM regularmente**

   ```sql
   -- Autom√°tico (recomendado)
   autovacuum = on

   -- Manual (ocasional)
   VACUUM ANALYZE;
   ```

5. **Monitorar Slow Queries**
   ```sql
   log_min_duration_statement = 1000  -- Log queries > 1s
   ```

### ‚ùå DON'T

1. **N√£o use SELECT \***

   ```sql
   -- ‚ùå Ruim
   SELECT * FROM orders;

   -- ‚úÖ Bom
   SELECT id, customer_id, total_amount FROM orders;
   ```

2. **N√£o fa√ßa N+1 Queries**

   ```java
   // ‚ùå N+1 Problem
   var orders = orderRepository.findAll();
   orders.forEach(o -> o.getCustomer().getName()); // Query por ordem!

   // ‚úÖ JOIN Fetch
   @Query("SELECT o FROM Order o JOIN FETCH o.customer")
   List<Order> findAllWithCustomer();
   ```

3. **N√£o ignore EXPLAIN**

   ```sql
   -- Sempre valide antes de deploy
   EXPLAIN ANALYZE <sua query>;
   ```

4. **N√£o use triggers para l√≥gica complexa**

   ```sql
   -- Melhor: Domain Events na aplica√ß√£o
   ```

5. **N√£o particione prematuramente**
   ```sql
   -- Apenas se tabela > 100M linhas
   ```

---

## üìä M√©tricas Recomendadas

| M√©trica                  | Coleta               | Meta        |
| ------------------------ | -------------------- | ----------- |
| **Query Execution Time** | pg_stat_statements   | p95 < 100ms |
| **Deadlock Rate**        | pg_stat_database     | < 1/dia     |
| **Connection Usage**     | pg_stat_activity     | < 80% pool  |
| **Cache Hit Ratio**      | pg_stat_database     | > 99%       |
| **Table Bloat**          | pg_stat_user_tables  | < 20%       |
| **Index Usage**          | pg_stat_user_indexes | All used    |
| **Replication Lag**      | pg_stat_replication  | < 1s        |

**Script de Monitoramento:**

```sql
-- Cache Hit Ratio
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit)  as heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
FROM pg_statio_user_tables;

-- Connection Count
SELECT COUNT(*) as connections, state
FROM pg_stat_activity
GROUP BY state;
```

---

## üéØ Checklist Final

- [ ] Window functions dominadas (ROW_NUMBER, LAG, LEAD)
- [ ] CTEs recursivas implementadas
- [ ] Constraints avan√ßados (CHECK, EXCLUSION)
- [ ] Locks pessimistas e otimistas entendidos
- [ ] Isolation levels e MVCC compreendidos
- [ ] EXPLAIN ANALYZE usado rotineiramente
- [ ] √çndices apropriados criados
- [ ] pg_stat_statements configurado
- [ ] Particionamento avaliado
- [ ] M√©tricas de performance coletadas

---

**Pr√≥ximo M√≥dulo:** [12.2 JPA & Hibernate Profundo](12.2-jpa-hibernate.md)
