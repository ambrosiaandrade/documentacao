# üìã M√≥dulo 12.2: Anota√ß√µes JPA/Hibernate - Guia Completo (B√°sico ‚Üí Avan√ßado)

> **Objetivo:** Dominar todas as anota√ß√µes JPA/Hibernate com exemplos pr√°ticos, explica√ß√µes linha por linha, e justificativas t√©cnicas para cada escolha arquitetural.

---

## üìë √çndice

1. [Entity e Identificadores](#1-entity-e-identificadores)
2. [Mapeamento de Colunas](#2-mapeamento-de-colunas)
3. [Relacionamentos](#3-relacionamentos)
4. [Heran√ßa](#4-heran√ßa)
5. [Auditing e Lifecycle](#5-auditing-e-lifecycle)
6. [Performance e Cache](#6-performance-e-cache)
7. [Valida√ß√µes e Constraints](#7-valida√ß√µes-e-constraints)
8. [Tabela Refer√™ncia Completa](#8-tabela-refer√™ncia-completa)

---

## 1. Entity e Identificadores

### 1.1 Entity B√°sica com AUTO_INCREMENT

```java
import jakarta.persistence.*;
import java.time.LocalDateTime;

/**
 * Entity b√°sica com ID auto-incrementado.
 *
 * ‚ö†Ô∏è ATEN√á√ÉO: Usar IDENTITY para PostgreSQL/MySQL.
 * Para Oracle, usar SEQUENCE.
 */
@Entity  // Marca classe como entidade JPA
@Table(name = "users")  // Nome da tabela no banco (opcional se igual ao nome da classe)
public class User {

    /**
     * @Id: Marca campo como chave prim√°ria
     * @GeneratedValue: Estrat√©gia de gera√ß√£o autom√°tica
     *
     * IDENTITY: Delega ao banco (AUTO_INCREMENT/SERIAL)
     * - Vantagem: Simples, funciona com PostgreSQL/MySQL
     * - Desvantagem: Desabilita batch insert (Hibernate precisa do ID imediatamente)
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @Column: Customiza mapeamento da coluna
     *
     * - nullable = false: NOT NULL no DDL
     * - unique = true: Cria √≠ndice √∫nico
     * - length = 100: VARCHAR(100)
     */
    @Column(nullable = false, unique = true, length = 100)
    private String email;

    /**
     * Sem @Column: Hibernate usa nome do campo como padr√£o
     */
    private String name;

    /**
     * @Column com name: Mapeia para coluna com nome diferente
     * √ötil quando banco usa snake_case e Java usa camelCase
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // Construtores, getters, setters omitidos para brevidade
}
```

---

### 1.2 Entity com UUID (Recomendado para Produ√ß√£o)

```java
import jakarta.persistence.*;
import java.util.UUID;

/**
 * Entity usando UUID como identificador.
 *
 * ‚úÖ VANTAGENS:
 * - Seguran√ßa: IDs n√£o sequenciais dificultam enumera√ß√£o de recursos
 * - Distribui√ß√£o: IDs gerados no app, sem depender do banco
 * - Batch Insert: Habilitado (Hibernate conhece ID antes do INSERT)
 * - Merge/Replica√ß√£o: Sem conflito entre ambientes
 *
 * ‚ö†Ô∏è DESVANTAGENS:
 * - Tamanho: 16 bytes vs 8 bytes (BIGINT)
 * - Performance √≠ndice: B-tree menos eficiente com UUIDs aleat√≥rios
 * - Legibilidade: IDs longos em logs/URLs
 */
@Entity
@Table(name = "products")
public class Product {

    /**
     * UUID gerado automaticamente pelo Java (n√£o pelo banco)
     *
     * GenerationType.AUTO: Hibernate escolhe estrat√©gia (usa UUID para tipo UUID)
     * @Column(updatable = false): Previne mudan√ßa acidental do ID
     */
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(updatable = false, nullable = false)
    private UUID id;

    @Column(nullable = false, length = 200)
    private String name;

    // Construtor com gera√ß√£o expl√≠cita de UUID (recomendado)
    public Product() {
        this.id = UUID.randomUUID();  // Gera UUID antes de persistir
    }
}
```

---

### 1.3 Entity com Sequence (Oracle/PostgreSQL)

```java
/**
 * Estrat√©gia SEQUENCE: Usa sequ√™ncia do banco de dados.
 *
 * ‚úÖ VANTAGENS:
 * - Portabilidade: Funciona em Oracle, PostgreSQL, H2
 * - Batch Insert: Hibernate pode pr√©-alocar IDs (allocationSize)
 * - Performance: Menos round-trips ao banco
 *
 * üí° DICA: allocationSize deve corresponder ao INCREMENT BY da sequence
 */
@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "order_seq")
    @SequenceGenerator(
        name = "order_seq",               // Nome do gerador (referenciado em @GeneratedValue)
        sequenceName = "order_id_seq",    // Nome da sequence no banco
        allocationSize = 50               // Pr√©-aloca 50 IDs (reduz queries)
    )
    private Long id;

    /**
     * @Column com columnDefinition: SQL customizado para DDL
     * √ötil para tipos espec√≠ficos do banco
     */
    @Column(columnDefinition = "VARCHAR(50) DEFAULT 'PENDING'")
    private String status;
}
```

---

### 1.4 Entity com Chave Composta

```java
import jakarta.persistence.*;
import java.io.Serializable;
import java.util.Objects;

/**
 * Classe de chave composta.
 *
 * ‚ö†Ô∏è REQUISITOS:
 * - Implementar Serializable
 * - Sobrescrever equals() e hashCode()
 * - Construtor sem argumentos
 */
@Embeddable  // Marca como chave composta embut√≠vel
public class OrderItemId implements Serializable {

    @Column(name = "order_id")
    private Long orderId;

    @Column(name = "product_id")
    private Long productId;

    // Construtor padr√£o obrigat√≥rio
    public OrderItemId() {}

    public OrderItemId(Long orderId, Long productId) {
        this.orderId = orderId;
        this.productId = productId;
    }

    // equals() e hashCode() essenciais para compara√ß√£o
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof OrderItemId that)) return false;
        return Objects.equals(orderId, that.orderId) &&
               Objects.equals(productId, that.productId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(orderId, productId);
    }
}

@Entity
@Table(name = "order_items")
public class OrderItem {

    /**
     * @EmbeddedId: Usa chave composta embutida
     *
     * Alternativa: @IdClass (menos comum, mant√©m campos separados)
     */
    @EmbeddedId
    private OrderItemId id;

    @Column(nullable = false)
    private Integer quantity;

    /**
     * @MapsId: Mapeia parte da chave composta para relacionamento
     * Evita duplica√ß√£o do campo order_id
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("orderId")  // Refere ao campo 'orderId' em OrderItemId
    @JoinColumn(name = "order_id")
    private Order order;
}
```

---

## 2. Mapeamento de Colunas

### 2.1 Tipos B√°sicos e Temporais

```java
import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.*;

@Entity
@Table(name = "transactions")
public class Transaction {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * BigDecimal: Tipo recomendado para valores monet√°rios
     *
     * precision = 19: Total de d√≠gitos (incluindo decimais)
     * scale = 4: D√≠gitos ap√≥s a v√≠rgula
     * Exemplo: 999999999999999.9999
     */
    @Column(precision = 19, scale = 4, nullable = false)
    private BigDecimal amount;

    /**
     * LocalDateTime: Armazena data/hora sem timezone
     * Mapeado para TIMESTAMP no banco
     *
     * ‚ö†Ô∏è ATEN√á√ÉO: Para sistemas globais, usar ZonedDateTime ou OffsetDateTime
     */
    private LocalDateTime processedAt;

    /**
     * LocalDate: Apenas data (sem hora)
     * Mapeado para DATE no banco
     */
    private LocalDate transactionDate;

    /**
     * LocalTime: Apenas hora (sem data)
     * Mapeado para TIME no banco
     */
    private LocalTime processedTime;

    /**
     * Instant: Timestamp UTC (epoch milliseconds)
     * Ideal para auditoria e eventos distribu√≠dos
     */
    private Instant createdAt;

    /**
     * @Enumerated: Mapeia enum para banco
     *
     * EnumType.STRING: Armazena nome do enum ("CREDIT", "DEBIT")
     *   ‚úÖ Vantagem: Leg√≠vel, refactoring-safe
     *   ‚ö†Ô∏è Desvantagem: Ocupa mais espa√ßo
     *
     * EnumType.ORDINAL: Armazena posi√ß√£o (0, 1, 2...)
     *   ‚ö†Ô∏è PERIGO: Mudar ordem quebra dados existentes
     */
    @Enumerated(EnumType.STRING)
    @Column(length = 20)
    private TransactionType type;
}

enum TransactionType {
    CREDIT, DEBIT, TRANSFER
}
```

---

### 2.2 LOBs e Tipos Grandes

```java
/**
 * Entity com tipos LOB (Large Objects).
 *
 * ‚ö†Ô∏è CUIDADO: LOBs podem causar problemas de performance.
 * Considere armazenar em servi√ßos externos (S3, MinIO).
 */
@Entity
@Table(name = "documents")
public class Document {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    /**
     * @Lob: Large Object
     *
     * Para String: Mapeia para TEXT/CLOB (texto grande)
     * Para byte[]: Mapeia para BLOB (bin√°rio grande)
     *
     * üí° ALTERNATIVA: Armazenar apenas URL/path, guardar arquivo externamente
     */
    @Lob
    @Column(columnDefinition = "TEXT")
    private String content;

    /**
     * @Lob com byte[]: Armazena arquivo bin√°rio (PDF, imagem, etc.)
     *
     * ‚ö†Ô∏è PERFORMANCE:
     * - Aumenta tamanho da entity
     * - Lazy fetch recomendado (mas complexo de implementar)
     * - Melhor: usar servi√ßo de storage externo
     */
    @Lob
    @Basic(fetch = FetchType.LAZY)  // Tenta carregar sob demanda
    private byte[] fileData;

    /**
     * @Column com columnDefinition customizado para JSON no PostgreSQL
     */
    @Column(columnDefinition = "jsonb")
    private String metadata;  // Armazena JSON como texto
}
```

---

## 3. Relacionamentos

### 3.1 @ManyToOne (N:1) - Relacionamento Mais Comum

```java
/**
 * @ManyToOne: V√°rios posts pertencem a um autor.
 *
 * üí° REGRA: Sempre usar FetchType.LAZY em relacionamentos
 * - EAGER: Carrega autor automaticamente (causa N+1 queries)
 * - LAZY: Carrega autor sob demanda (performance melhor)
 */
@Entity
@Table(name = "posts")
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    /**
     * @ManyToOne: Lado "dono" do relacionamento (possui FK)
     *
     * fetch = LAZY: N√£o carrega autor automaticamente
     * optional = false: NOT NULL (autor obrigat√≥rio)
     *
     * @JoinColumn: Customiza coluna FK
     * - name: Nome da coluna no banco
     * - nullable: Se FK pode ser NULL
     * - foreignKey: Nome da constraint (√∫til para migrations)
     */
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(
        name = "author_id",
        nullable = false,
        foreignKey = @ForeignKey(name = "fk_post_author")
    )
    private User author;

    /**
     * M√©todo helper para evitar NullPointerException em Lazy Loading
     */
    public String getAuthorName() {
        return author != null ? author.getName() : "Unknown";
    }
}
```

---

### 3.2 @OneToMany (1:N) - Lado Inverso

```java
/**
 * @OneToMany: Um autor possui v√°rios posts.
 *
 * ‚ö†Ô∏è ATEN√á√ÉO: Lado inverso do relacionamento (n√£o possui FK)
 */
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    /**
     * @OneToMany: Cole√ß√£o de posts do autor
     *
     * mappedBy: Campo na classe Post que mapeia este relacionamento
     *   - Indica que Post.author √© o dono da FK
     *   - User n√£o possui coluna FK, apenas refer√™ncia l√≥gica
     *
     * cascade: Opera√ß√µes propagadas automaticamente
     *   - ALL: Propaga tudo (persist, merge, remove, refresh, detach)
     *   - PERSIST: Ao salvar User, salva posts automaticamente
     *   - REMOVE: Ao deletar User, deleta posts (equivale a ON DELETE CASCADE)
     *
     * orphanRemoval: Remove post se removido da cole√ß√£o
     *   - user.getPosts().remove(post) ‚Üí DELETE FROM posts WHERE id = ?
     *
     * fetch = LAZY: N√£o carrega posts automaticamente (padr√£o para collections)
     */
    @OneToMany(
        mappedBy = "author",
        cascade = CascadeType.ALL,
        orphanRemoval = true,
        fetch = FetchType.LAZY
    )
    private List<Post> posts = new ArrayList<>();

    /**
     * M√©todo helper bidireccional: Mant√©m consist√™ncia
     */
    public void addPost(Post post) {
        posts.add(post);
        post.setAuthor(this);  // Define lado owner
    }

    public void removePost(Post post) {
        posts.remove(post);
        post.setAuthor(null);
    }
}
```

---

### 3.3 @ManyToMany com Tabela de Jun√ß√£o

```java
/**
 * @ManyToMany: Estudantes podem ter v√°rios cursos, cursos t√™m v√°rios estudantes.
 *
 * Cria tabela intermedi√°ria: student_courses (student_id, course_id)
 */
@Entity
@Table(name = "students")
public class Student {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @ManyToMany: Lado "dono" do relacionamento
     *
     * @JoinTable: Customiza tabela de jun√ß√£o
     * - name: Nome da tabela intermedi√°ria
     * - joinColumns: FK que aponta para Student
     * - inverseJoinColumns: FK que aponta para Course
     */
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(
        name = "student_courses",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>();

    // Usar Set ao inv√©s de List para evitar duplicatas
}

@Entity
@Table(name = "courses")
public class Course {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @ManyToMany: Lado inverso (mappedBy)
     *
     * ‚ö†Ô∏è IMPORTANTE: N√£o usar CascadeType.REMOVE em ManyToMany
     * - Deletar Student n√£o deve deletar Course (compartilhado)
     */
    @ManyToMany(mappedBy = "courses")
    private Set<Student> students = new HashSet<>();
}
```

---

### 3.4 @ManyToMany com Atributos Extras (Tabela de Associa√ß√£o)

```java
/**
 * Cen√°rio: Matr√≠cula com nota (n√£o √© simples ManyToMany)
 *
 * Solu√ß√£o: Criar entity para tabela de jun√ß√£o
 */
@Entity
@Table(name = "enrollments")
public class Enrollment {

    @EmbeddedId
    private EnrollmentId id;

    /**
     * Nota espec√≠fica da matr√≠cula (campo extra)
     */
    @Column(nullable = false)
    private BigDecimal grade;

    private LocalDate enrolledAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("studentId")
    @JoinColumn(name = "student_id")
    private Student student;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("courseId")
    @JoinColumn(name = "course_id")
    private Course course;
}

@Embeddable
class EnrollmentId implements Serializable {
    private Long studentId;
    private Long courseId;

    // equals(), hashCode() obrigat√≥rios
}
```

---

### 3.5 @OneToOne

```java
/**
 * @OneToOne: Relacionamento 1:1
 *
 * Exemplo: User possui um √∫nico Profile
 */
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @OneToOne com FK no lado User (owner)
     *
     * cascade = ALL: Opera√ß√µes propagadas para Profile
     * orphanRemoval = true: Deleta Profile se desassociado
     *
     * @JoinColumn: FK user.profile_id ‚Üí profile.id
     */
    @OneToOne(
        cascade = CascadeType.ALL,
        orphanRemoval = true,
        fetch = FetchType.LAZY
    )
    @JoinColumn(name = "profile_id", unique = true)
    private Profile profile;
}

@Entity
@Table(name = "profiles")
public class Profile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;

    /**
     * @OneToOne: Lado inverso (opcional)
     *
     * mappedBy: Referencia User.profile
     */
    @OneToOne(mappedBy = "profile", fetch = FetchType.LAZY)
    private User user;
}
```

---

## 4. Heran√ßa

### 4.1 SINGLE_TABLE (Padr√£o)

```java
/**
 * SINGLE_TABLE: Todas as subclasses em uma tabela
 *
 * ‚úÖ VANTAGENS:
 * - Performance: Sem JOINs
 * - Simples de consultar
 *
 * ‚ö†Ô∏è DESVANTAGENS:
 * - Colunas de subclasses s√£o nullable
 * - Tabela grande e esparsa
 */
@Entity
@Table(name = "payments")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "payment_type", discriminatorType = DiscriminatorType.STRING)
public abstract class Payment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private BigDecimal amount;
}

@Entity
@DiscriminatorValue("CREDIT_CARD")
class CreditCardPayment extends Payment {
    private String cardNumber;
    private String cvv;
}

@Entity
@DiscriminatorValue("PIX")
class PixPayment extends Payment {
    private String pixKey;
}
```

---

### 4.2 JOINED

```java
/**
 * JOINED: Tabela por classe (com JOIN)
 *
 * ‚úÖ VANTAGENS:
 * - Normalizado
 * - Colunas espec√≠ficas NOT NULL
 *
 * ‚ö†Ô∏è DESVANTAGENS:
 * - Performance: Requer JOINs
 */
@Entity
@Table(name = "vehicles")
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class Vehicle {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String brand;
}

@Entity
@Table(name = "cars")
class Car extends Vehicle {
    private Integer doors;
}

@Entity
@Table(name = "motorcycles")
class Motorcycle extends Vehicle {
    private Integer cylinderCapacity;
}
```

---

## 5. Auditing e Lifecycle

### 5.1 Auditing com Spring Data JPA

```java
import org.springframework.data.annotation.*;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

/**
 * Auditing autom√°tico com Spring Data JPA.
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO: Habilitar @EnableJpaAuditing na classe de configura√ß√£o
 */
@Entity
@Table(name = "articles")
@EntityListeners(AuditingEntityListener.class)  // Ativa listeners de auditoria
public class Article {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @CreatedDate: Preenchido automaticamente na cria√ß√£o
     *
     * updatable = false: Garante imutabilidade
     */
    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;

    /**
     * @LastModifiedDate: Atualizado automaticamente
     */
    @LastModifiedDate
    @Column(nullable = false)
    private Instant updatedAt;

    /**
     * @CreatedBy: Usu√°rio que criou (requer AuditorAware bean)
     */
    @CreatedBy
    @Column(updatable = false)
    private String createdBy;

    /**
     * @LastModifiedBy: √öltimo usu√°rio que modificou
     */
    @LastModifiedBy
    private String lastModifiedBy;

    /**
     * @Version: Locking otimista (concorr√™ncia)
     *
     * - Incrementado automaticamente a cada UPDATE
     * - Previne lost updates (duas transa√ß√µes concorrentes)
     * - Lan√ßa OptimisticLockException se vers√£o divergir
     */
    @Version
    private Long version;
}
```

---

### 5.2 Callbacks de Lifecycle

```java
/**
 * Callbacks executados em momentos espec√≠ficos do ciclo de vida.
 */
@Entity
@Table(name = "notifications")
public class Notification {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    private String message;
    private String recipientEmail;

    @Column(updatable = false)
    private Instant createdAt;

    /**
     * @PrePersist: Executado ANTES de INSERT
     *
     * Uso: Inicializar timestamps, valida√ß√µes customizadas
     */
    @PrePersist
    void prePersist() {
        if (createdAt == null) {
            createdAt = Instant.now();
        }
        // Valida√ß√£o custom
        if (recipientEmail == null || !recipientEmail.contains("@")) {
            throw new IllegalStateException("Email inv√°lido");
        }
    }

    /**
     * @PostPersist: Executado AP√ìS INSERT (ID j√° dispon√≠vel)
     *
     * Uso: Logs, eventos, notifica√ß√µes
     */
    @PostPersist
    void postPersist() {
        System.out.println("Notifica√ß√£o criada: " + id);
        // Publicar evento de dom√≠nio
    }

    /**
     * @PreUpdate: Antes de UPDATE
     */
    @PreUpdate
    void preUpdate() {
        // Valida√ß√µes antes de atualizar
    }

    /**
     * @PostUpdate: Ap√≥s UPDATE
     */
    @PostUpdate
    void postUpdate() {
        // Log de auditoria
    }

    /**
     * @PreRemove: Antes de DELETE
     */
    @PreRemove
    void preRemove() {
        // Limpar recursos relacionados
    }

    /**
     * @PostLoad: Ap√≥s carregar do banco
     */
    @PostLoad
    void postLoad() {
        // Descriptografar dados sens√≠veis
    }
}
```

---

## 6. Performance e Cache

### 6.1 Fetch Strategies

```java
/**
 * Controle de carregamento de relacionamentos.
 */
@Entity
@Table(name = "departments")
public class Department {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * FetchType.LAZY: Padr√£o para collections
     * - Carrega sob demanda (proxy)
     * - Evita N+1 queries
     *
     * ‚ö†Ô∏è CUIDADO: Requer sess√£o aberta (LazyInitializationException)
     */
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List<Employee> employees = new ArrayList<>();

    /**
     * FetchType.EAGER: Carrega imediatamente
     *
     * ‚ö†Ô∏è EVITAR: Causa problemas de performance
     * - M√∫ltiplos EAGERs ‚Üí Produto cartesiano
     * - Uso excessivo de mem√≥ria
     *
     * üí° ALTERNATIVA: EntityGraph ou JOIN FETCH em queries
     */
    @ManyToOne(fetch = FetchType.EAGER)  // ‚ùå N√£o recomendado
    private Company company;
}
```

---

### 6.2 @BatchSize e @Fetch

```java
/**
 * Otimiza√ß√µes para N+1 queries.
 */
@Entity
@Table(name = "authors")
public class Author {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @BatchSize: Carrega m√∫ltiplas collections em batches
     *
     * Sem BatchSize (N+1):
     *   SELECT * FROM authors         ‚Üí 1 query
     *   SELECT * FROM books WHERE author_id = 1  ‚Üí N queries
     *   SELECT * FROM books WHERE author_id = 2
     *   ...
     *
     * Com BatchSize(10):
     *   SELECT * FROM authors         ‚Üí 1 query
     *   SELECT * FROM books WHERE author_id IN (1,2,...,10)  ‚Üí N/10 queries
     */
    @OneToMany(mappedBy = "author")
    @BatchSize(size = 10)
    private List<Book> books = new ArrayList<>();
}
```

---

### 6.3 Cache de Segundo N√≠vel

```java
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;

/**
 * Cache L2: Compartilhado entre sess√µes/transa√ß√µes
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO:
 * - spring.jpa.properties.hibernate.cache.use_second_level_cache=true
 * - spring.jpa.properties.hibernate.cache.region.factory_class=...EhcacheRegionFactory
 */
@Entity
@Table(name = "categories")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)  // Estrat√©gia de cache
public class Category {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    /**
     * CacheConcurrencyStrategy:
     *
     * - READ_ONLY: Dados imut√°veis (melhor performance)
     * - READ_WRITE: Dados alter√°veis (usa locks)
     * - NONSTRICT_READ_WRITE: Sem locks (pode ter stale data)
     * - TRANSACTIONAL: JTA transactional cache (raro)
     */
}
```

---

## 7. Valida√ß√µes e Constraints

### 7.1 Bean Validation

```java
import jakarta.validation.constraints.*;

/**
 * Valida√ß√µes com Bean Validation (JSR 380).
 *
 * ‚öôÔ∏è Validado automaticamente com @Valid em controllers
 */
@Entity
@Table(name = "customers")
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @NotNull: N√£o pode ser null
     * @NotBlank: N√£o pode ser null/empty/whitespace (apenas Strings)
     * @Size: Tamanho da String
     */
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    private String name;

    /**
     * @Email: Valida formato de email
     */
    @Email(message = "Email inv√°lido")
    @NotBlank
    private String email;

    /**
     * @Pattern: Regex customizado
     */
    @Pattern(regexp = "\\d{11}", message = "CPF deve ter 11 d√≠gitos")
    private String cpf;

    /**
     * @Min/@Max: Valores num√©ricos
     */
    @Min(value = 18, message = "Idade m√≠nima: 18 anos")
    @Max(value = 120, message = "Idade m√°xima: 120 anos")
    private Integer age;

    /**
     * @DecimalMin/@DecimalMax: Para BigDecimal
     */
    @DecimalMin(value = "0.0", inclusive = false, message = "Saldo deve ser positivo")
    private BigDecimal balance;

    /**
     * @Future/@Past: Valida√ß√µes de data
     */
    @Future(message = "Data deve ser no futuro")
    private LocalDate nextAppointment;
}
```

---

## 8. Tabela Refer√™ncia Completa

| Anota√ß√£o               | N√≠vel        | Prop√≥sito                          | Exemplo                                                    |
| ---------------------- | ------------ | ---------------------------------- | ---------------------------------------------------------- |
| `@Entity`              | Classe       | Marca como entidade JPA            | `@Entity`                                                  |
| `@Table`               | Classe       | Nome e schema da tabela            | `@Table(name="users", schema="public")`                    |
| `@Id`                  | Campo        | Chave prim√°ria                     | `@Id`                                                      |
| `@GeneratedValue`      | Campo        | Gera√ß√£o autom√°tica de ID           | `(strategy=IDENTITY/SEQUENCE/UUID/AUTO)`                   |
| `@SequenceGenerator`   | Campo        | Configura√ß√£o de sequence           | `(name="seq", sequenceName="user_seq", allocationSize=50)` |
| `@Column`              | Campo        | Customiza√ß√£o de coluna             | `(name="email", unique=true, nullable=false, length=100)`  |
| `@Transient`           | Campo        | N√£o persiste no banco              | `@Transient private String temp;`                          |
| `@Enumerated`          | Campo        | Enum ‚Üí DB                          | `(EnumType.STRING/ORDINAL)`                                |
| `@Lob`                 | Campo        | Large Object (TEXT/BLOB)           | `@Lob private String content;`                             |
| `@Temporal`            | Campo        | Data/hora (legacy)                 | `@Temporal(TemporalType.TIMESTAMP)` - Use LocalDateTime    |
| `@ManyToOne`           | Campo        | Relacionamento N:1                 | `@ManyToOne(fetch=LAZY)`                                   |
| `@OneToMany`           | Campo        | Relacionamento 1:N                 | `@OneToMany(mappedBy="owner", cascade=ALL)`                |
| `@ManyToMany`          | Campo        | Relacionamento N:N                 | `@ManyToMany(cascade={PERSIST, MERGE})`                    |
| `@OneToOne`            | Campo        | Relacionamento 1:1                 | `@OneToOne(cascade=ALL, orphanRemoval=true)`               |
| `@JoinColumn`          | Campo        | FK customizada                     | `(name="author_id", nullable=false)`                       |
| `@JoinTable`           | Campo        | Tabela de jun√ß√£o ManyToMany        | `(name="student_courses", joinColumns=...)`                |
| `@EmbeddedId`          | Campo        | Chave composta                     | `@EmbeddedId private OrderItemId id;`                      |
| `@Embeddable`          | Classe       | Classe embut√≠vel                   | `@Embeddable class Address {...}`                          |
| `@MapsId`              | Campo        | Mapeia parte da chave composta     | `@MapsId("orderId")`                                       |
| `@Version`             | Campo        | Locking otimista                   | `@Version private Long version;`                           |
| `@CreatedDate`         | Campo        | Timestamp de cria√ß√£o (Spring Data) | `@CreatedDate private Instant createdAt;`                  |
| `@LastModifiedDate`    | Campo        | Timestamp de modifica√ß√£o           | `@LastModifiedDate private Instant updatedAt;`             |
| `@CreatedBy`           | Campo        | Usu√°rio criador (auditing)         | `@CreatedBy private String createdBy;`                     |
| `@LastModifiedBy`      | Campo        | √öltimo usu√°rio modificador         | `@LastModifiedBy private String lastModifiedBy;`           |
| `@EntityListeners`     | Classe       | Listeners de lifecycle             | `@EntityListeners(AuditingEntityListener.class)`           |
| `@PrePersist`          | M√©todo       | Antes de INSERT                    | `@PrePersist void onCreate() {...}`                        |
| `@PostPersist`         | M√©todo       | Ap√≥s INSERT                        | `@PostPersist void afterCreate() {...}`                    |
| `@PreUpdate`           | M√©todo       | Antes de UPDATE                    | `@PreUpdate void onUpdate() {...}`                         |
| `@PostUpdate`          | M√©todo       | Ap√≥s UPDATE                        | `@PostUpdate void afterUpdate() {...}`                     |
| `@PreRemove`           | M√©todo       | Antes de DELETE                    | `@PreRemove void onDelete() {...}`                         |
| `@PostLoad`            | M√©todo       | Ap√≥s carregar do banco             | `@PostLoad void afterLoad() {...}`                         |
| `@Inheritance`         | Classe       | Estrat√©gia de heran√ßa              | `(strategy=SINGLE_TABLE/JOINED/TABLE_PER_CLASS)`           |
| `@DiscriminatorColumn` | Classe       | Coluna discriminadora              | `(name="type", discriminatorType=STRING)`                  |
| `@DiscriminatorValue`  | Classe       | Valor do discriminador             | `@DiscriminatorValue("CREDIT_CARD")`                       |
| `@Cache`               | Classe       | Cache L2 (Hibernate)               | `@Cache(usage=READ_WRITE)`                                 |
| `@BatchSize`           | Campo        | Batch loading                      | `@BatchSize(size=10)`                                      |
| `@Fetch`               | Campo        | Modo de fetch (Hibernate)          | `@Fetch(FetchMode.JOIN/SELECT/SUBSELECT)`                  |
| `@Formula`             | Campo        | Coluna calculada                   | `@Formula("(price * quantity)")`                           |
| `@Where`               | Classe/Campo | Filtro SQL autom√°tico              | `@Where(clause="deleted = false")`                         |
| `@Filter`              | Classe       | Filtro din√¢mico (Hibernate)        | `@Filter(name="activeOnly", condition="active=1")`         |
| `@NotNull`             | Campo        | Valida√ß√£o: n√£o nulo                | `@NotNull(message="Campo obrigat√≥rio")`                    |
| `@NotBlank`            | Campo        | Valida√ß√£o: n√£o vazio (String)      | `@NotBlank`                                                |
| `@Size`                | Campo        | Valida√ß√£o: tamanho                 | `@Size(min=3, max=100)`                                    |
| `@Email`               | Campo        | Valida√ß√£o: email                   | `@Email`                                                   |
| `@Pattern`             | Campo        | Valida√ß√£o: regex                   | `@Pattern(regexp="\\d{11}")`                               |
| `@Min/@Max`            | Campo        | Valida√ß√£o: num√©rica                | `@Min(18) @Max(120)`                                       |

---

## üìä Checklist de Qualidade

- [ ] Usar `UUID` para IDs em produ√ß√£o (seguran√ßa)
- [ ] Sempre definir `FetchType.LAZY` em relacionamentos
- [ ] Evitar `CascadeType.REMOVE` em `@ManyToMany`
- [ ] Implementar `equals()` e `hashCode()` baseados em ID
- [ ] Usar `@Version` para locking otimista
- [ ] Habilitar auditing com `@EntityListeners`
- [ ] Validar campos com Bean Validation (`@NotBlank`, `@Email`)
- [ ] Usar `@BatchSize` para prevenir N+1
- [ ] Preferir `Set` ao inv√©s de `List` em `@ManyToMany`
- [ ] Documentar justificativas t√©cnicas (seguran√ßa, performance)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Criar `Customer` com UUID, auditing e valida√ß√µes
2. **Intermedi√°rio**: Implementar `Order` ‚Üí `OrderItem` com chave composta
3. **Avan√ßado**: Modelar heran√ßa `Payment` com SINGLE_TABLE e cache L2

---

## üìö Refer√™ncias

- [Jakarta Persistence Specification](https://jakarta.ee/specifications/persistence/)
- [Hibernate Documentation](https://hibernate.org/orm/documentation/)
- [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
- [Bean Validation (JSR 380)](https://beanvalidation.org/2.0/)

---

**Pr√≥ximo:** [12.3 - Spring Data & Repositories](12.3-spring-data-repositories.md)
