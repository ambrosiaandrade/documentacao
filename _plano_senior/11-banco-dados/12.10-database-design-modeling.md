# üèóÔ∏è M√≥dulo 12.10: Database Design & Modeling

> **Objetivo:** Dominar design de schemas, normaliza√ß√£o, CQRS e event sourcing.

---

## üìë √çndice

1. [Normalization](#1-normalization)
2. [Denormalization](#2-denormalization)
3. [CQRS](#3-cqrs)
4. [Event Sourcing](#4-event-sourcing)
5. [Domain Modeling](#5-domain-modeling)

---

## 1. Normalization

### 1.1 Formas Normais

```sql
/**
 * DESNORMALIZADO: Dados duplicados, anomalias
 */
CREATE TABLE orders_denormalized (
    order_id BIGSERIAL PRIMARY KEY,
    customer_name VARCHAR(100),      -- ‚ùå Duplicado para cada pedido
    customer_email VARCHAR(100),     -- ‚ùå Duplicado
    customer_address TEXT,           -- ‚ùå Duplicado
    product_name VARCHAR(100),       -- ‚ùå Duplicado para cada item
    product_price NUMERIC(10,2),     -- ‚ùå Pode ficar desatualizado
    quantity INT,
    total NUMERIC(10,2)
);

/**
 * Problemas:
 * - Insert Anomaly: N√£o posso cadastrar cliente sem pedido
 * - Update Anomaly: Atualizar email exige UPDATE em N linhas
 * - Delete Anomaly: Deletar √∫ltimo pedido apaga dados do cliente
 * - Redund√¢ncia: Mesmo dado replicado v√°rias vezes
 */
```

---

### 1.2 1NF (First Normal Form)

```sql
/**
 * 1NF: Valores at√¥micos (n√£o arrays, n√£o multivalorados)
 */

-- ‚ùå Viola√ß√£o 1NF: M√∫ltiplos telefones em uma coluna
CREATE TABLE customers_bad (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    phones TEXT  -- "11999999999,11888888888" ‚ùå
);

-- ‚úÖ 1NF: Tabela separada para telefones
CREATE TABLE customers (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

CREATE TABLE customer_phones (
    customer_id BIGINT REFERENCES customers(id),
    phone VARCHAR(20),
    phone_type VARCHAR(10),  -- 'mobile', 'home', 'work'
    PRIMARY KEY (customer_id, phone)
);
```

---

### 1.3 2NF (Second Normal Form)

```sql
/**
 * 2NF: 1NF + sem depend√™ncias parciais
 * (Colunas n√£o-chave dependem da chave completa)
 */

-- ‚ùå Viola√ß√£o 2NF: product_name depende s√≥ de product_id
CREATE TABLE order_items_bad (
    order_id BIGINT,
    product_id BIGINT,
    product_name VARCHAR(100),  -- ‚ùå Depende s√≥ de product_id
    quantity INT,
    price NUMERIC(10,2),
    PRIMARY KEY (order_id, product_id)
);

-- ‚úÖ 2NF: Separar em duas tabelas
CREATE TABLE products (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    price NUMERIC(10,2)
);

CREATE TABLE order_items (
    order_id BIGINT REFERENCES orders(id),
    product_id BIGINT REFERENCES products(id),
    quantity INT,
    unit_price NUMERIC(10,2),  -- Snapshot do pre√ßo na compra
    PRIMARY KEY (order_id, product_id)
);
```

---

### 1.4 3NF (Third Normal Form)

```sql
/**
 * 3NF: 2NF + sem depend√™ncias transitivas
 * (Colunas n√£o-chave n√£o dependem de outras colunas n√£o-chave)
 */

-- ‚ùå Viola√ß√£o 3NF: city_name depende de zip_code (transitiva)
CREATE TABLE customers_bad (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    zip_code VARCHAR(10),
    city_name VARCHAR(100),  -- ‚ùå Depende de zip_code
    state VARCHAR(2)         -- ‚ùå Depende de zip_code
);

-- ‚úÖ 3NF: Tabela separada para endere√ßos
CREATE TABLE zip_codes (
    zip_code VARCHAR(10) PRIMARY KEY,
    city VARCHAR(100),
    state VARCHAR(2)
);

CREATE TABLE customers (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    zip_code VARCHAR(10) REFERENCES zip_codes(zip_code)
);
```

---

### 1.5 BCNF, 4NF, 5NF

```sql
/**
 * BCNF (Boyce-Codd): 3NF + toda depend√™ncia funcional tem chave candidata
 *
 * Aplica√ß√£o pr√°tica: Rara em sistemas OLTP comuns
 */

/**
 * 4NF: BCNF + sem depend√™ncias multivaloradas
 *
 * Exemplo: Professores ensinam m√∫ltiplas mat√©rias em m√∫ltiplas turmas
 * (mat√©ria e turma s√£o independentes)
 */

-- ‚ùå Viola√ß√£o 4NF: Duplica√ß√£o desnecess√°ria
CREATE TABLE teacher_assignments_bad (
    teacher_id BIGINT,
    subject VARCHAR(50),
    class VARCHAR(10)
    -- Professor A, Math, Turma 1
    -- Professor A, Math, Turma 2
    -- Professor A, Physics, Turma 1  ‚ùå Duplica√ß√£o
    -- Professor A, Physics, Turma 2
);

-- ‚úÖ 4NF: Separar depend√™ncias multivaloradas
CREATE TABLE teacher_subjects (
    teacher_id BIGINT,
    subject VARCHAR(50),
    PRIMARY KEY (teacher_id, subject)
);

CREATE TABLE teacher_classes (
    teacher_id BIGINT,
    class VARCHAR(10),
    PRIMARY KEY (teacher_id, class)
);

/**
 * 5NF: 4NF + sem depend√™ncias de join
 *
 * Aplica√ß√£o pr√°tica: Muito rara, geralmente over-engineering
 */
```

---

## 2. Denormalization

### 2.1 Quando Desnormalizar

```java
/**
 * REGRA: Normalizar primeiro, desnormalizar quando necess√°rio
 *
 * Motivos para desnormalizar:
 * - Performance: Evitar JOINs complexos
 * - Simplicidade: Queries mais diretas
 * - Leitura >> Escrita (read-heavy workloads)
 *
 * Trade-offs:
 * - Redund√¢ncia de dados
 * - Complexidade de writes (manter consist√™ncia)
 * - Risco de dados obsoletos
 */

/**
 * EXEMPLO: Desnormalizar contadores
 */

-- ‚ùå Normalizado: JOIN a cada consulta
SELECT
    c.name,
    COUNT(o.id) AS order_count
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.name;

-- ‚úÖ Desnormalizado: Coluna order_count na tabela customers
CREATE TABLE customers (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    order_count INT DEFAULT 0  -- ‚Üê Desnormalizado
);

-- Trigger para manter atualizado
CREATE OR REPLACE FUNCTION update_order_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE customers
        SET order_count = order_count + 1
        WHERE id = NEW.customer_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE customers
        SET order_count = order_count - 1
        WHERE id = OLD.customer_id;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_order_count
AFTER INSERT OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION update_order_count();
```

---

### 2.2 Materialized Views

```sql
/**
 * Desnormaliza√ß√£o com Materialized Views
 *
 * Vantagens:
 * - Query complexa pr√©-computada
 * - Refresh controlado (on-demand ou scheduled)
 * - Schema normalizado intacto
 */

-- View complexa: Sales por categoria
CREATE MATERIALIZED VIEW sales_by_category AS
SELECT
    c.name AS category,
    COUNT(oi.id) AS total_items,
    SUM(oi.quantity * oi.unit_price) AS total_revenue,
    AVG(oi.quantity * oi.unit_price) AS avg_order_value
FROM categories c
INNER JOIN products p ON c.id = p.category_id
INNER JOIN order_items oi ON p.id = oi.product_id
INNER JOIN orders o ON oi.order_id = o.id
WHERE o.created_at >= NOW() - INTERVAL '30 days'
GROUP BY c.id, c.name;

-- √çndice na materialized view
CREATE INDEX idx_sales_category ON sales_by_category(category);

-- Refresh di√°rio (cron)
REFRESH MATERIALIZED VIEW sales_by_category;
```

```java
/**
 * Spring: Refresh materialized view via job
 */
@Service
public class MaterializedViewRefreshService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Scheduled(cron = "0 0 2 * * *")  // 02:00 AM diariamente
    public void refreshSalesView() {
        jdbcTemplate.execute("REFRESH MATERIALIZED VIEW sales_by_category");
    }
}
```

---

## 3. CQRS

### 3.1 CQRS Pattern

```java
/**
 * CQRS: Command Query Responsibility Segregation
 *
 * Princ√≠pio: Separar models de escrita (Command) e leitura (Query)
 *
 * Benef√≠cios:
 * - Otimizar read/write independentemente
 * - Escalar reads separadamente (replicas)
 * - Queries simples (dados desnormalizados)
 * - Commands focados em regras de neg√≥cio
 */

/**
 * COMMAND MODEL (Write): Normalizado, regras de neg√≥cio
 */
@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long customerId;
    private OrderStatus status;
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> items;

    // Regras de neg√≥cio
    public void addItem(Product product, int quantity) {
        if (status != OrderStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify confirmed order");
        }

        var item = new OrderItem(this, product, quantity);
        items.add(item);
    }

    public void confirm() {
        if (items.isEmpty()) {
            throw new IllegalStateException("Cannot confirm empty order");
        }

        this.status = OrderStatus.CONFIRMED;
    }
}

/**
 * QUERY MODEL (Read): Desnormalizado, read-optimized
 */
@Entity
@Table(name = "order_summaries")  -- Tabela desnormalizada
@Immutable  -- Read-only
public class OrderSummary {
    @Id
    private Long orderId;

    private String customerName;
    private String customerEmail;
    private OrderStatus status;
    private BigDecimal totalAmount;
    private int itemCount;
    private LocalDateTime createdAt;

    // Sem setters (imut√°vel)
}

/**
 * COMMAND SERVICE: Escrita
 */
@Service
public class OrderCommandService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    @Transactional
    public Order createOrder(CreateOrderCommand cmd) {
        var order = new Order();
        order.setCustomerId(cmd.customerId());
        order.setStatus(OrderStatus.DRAFT);

        for (var item : cmd.items()) {
            order.addItem(item.product(), item.quantity());
        }

        order = orderRepository.save(order);

        // Publicar evento para atualizar query model
        eventPublisher.publishEvent(new OrderCreatedEvent(order));

        return order;
    }
}

/**
 * QUERY SERVICE: Leitura
 */
@Service
public class OrderQueryService {

    @Autowired
    private OrderSummaryRepository summaryRepository;

    public Page<OrderSummary> findRecentOrders(Pageable pageable) {
        // Query simples: Tabela desnormalizada
        return summaryRepository.findByCreatedAtAfter(
            LocalDateTime.now().minusDays(30),
            pageable
        );
    }

    public OrderSummary findOrderSummary(Long orderId) {
        return summaryRepository.findById(orderId)
                                .orElseThrow(() -> new OrderNotFoundException(orderId));
    }
}

/**
 * EVENT HANDLER: Sincronizar query model
 */
@Component
public class OrderProjection {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @TransactionalEventListener
    public void onOrderCreated(OrderCreatedEvent event) {
        var order = event.order();

        // Proje√ß√£o: Atualizar order_summaries (desnormalizado)
        jdbcTemplate.update("""
            INSERT INTO order_summaries
                (order_id, customer_name, customer_email, status, total_amount, item_count, created_at)
            SELECT
                o.id,
                c.name,
                c.email,
                o.status,
                SUM(oi.quantity * oi.unit_price),
                COUNT(oi.id),
                o.created_at
            FROM orders o
            INNER JOIN customers c ON o.customer_id = c.id
            LEFT JOIN order_items oi ON o.id = oi.order_id
            WHERE o.id = ?
            GROUP BY o.id, c.name, c.email, o.status, o.created_at
            """, order.getId());
    }
}
```

---

### 3.2 CQRS com Bancos Separados

```yaml
# application.yml

spring:
  datasource:
    # Write Database (PostgreSQL)
    write:
      url: jdbc:postgresql://localhost:5432/app_write
      username: write_user
      password: pass
      hikari:
        maximum-pool-size: 20

    # Read Database (PostgreSQL Replica)
    read:
      url: jdbc:postgresql://replica:5432/app_read
      username: read_user
      password: pass
      hikari:
        maximum-pool-size: 50 # Mais conex√µes para reads
```

```java
/**
 * Configura√ß√£o de m√∫ltiplos datasources
 */
@Configuration
public class CqrsDataSourceConfig {

    @Bean
    @Primary
    @ConfigurationProperties("spring.datasource.write")
    public DataSource writeDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.read")
    public DataSource readDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public JdbcTemplate writeJdbcTemplate(@Qualifier("writeDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }

    @Bean
    public JdbcTemplate readJdbcTemplate(@Qualifier("readDataSource") DataSource ds) {
        return new JdbcTemplate(ds);
    }
}

/**
 * Service usa datasources espec√≠ficos
 */
@Service
public class OrderService {

    @Autowired
    @Qualifier("writeJdbcTemplate")
    private JdbcTemplate writeTemplate;

    @Autowired
    @Qualifier("readJdbcTemplate")
    private JdbcTemplate readTemplate;

    @Transactional
    public void createOrder(Order order) {
        writeTemplate.update(
            "INSERT INTO orders (customer_id, status) VALUES (?, ?)",
            order.getCustomerId(),
            order.getStatus()
        );
    }

    @Transactional(readOnly = true)
    public List<OrderSummary> findOrders() {
        // L√™ de replica (eventual consistency)
        return readTemplate.query(
            "SELECT * FROM order_summaries",
            (rs, rowNum) -> mapSummary(rs)
        );
    }
}
```

---

## 4. Event Sourcing

### 4.1 Event Store

```java
/**
 * Event Sourcing: Armazenar eventos ao inv√©s de estado
 *
 * Estado = Replay de eventos
 *
 * Benef√≠cios:
 * - Auditoria completa (hist√≥rico de mudan√ßas)
 * - Time travel (reconstruir estado em qualquer momento)
 * - Event replay (reprocessar eventos)
 *
 * Trade-offs:
 * - Complexidade maior
 * - Queries exigem proje√ß√µes
 * - Storage maior (todos eventos preservados)
 */

/**
 * Event: Imut√°vel, append-only
 */
@Entity
@Table(name = "order_events")
public class OrderEvent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String aggregateId;  // ID do pedido

    @Column(nullable = false)
    private String eventType;  // "OrderCreated", "ItemAdded", "OrderConfirmed"

    @Column(columnDefinition = "jsonb")
    private String eventData;  // JSON do evento

    @Column(nullable = false)
    private LocalDateTime occurredAt;

    @Column(nullable = false)
    private int version;  // Vers√£o do aggregate (concurrency control)
}

/**
 * Aggregate: Reconstru√≠do a partir de eventos
 */
public class Order {
    private String id;
    private Long customerId;
    private List<OrderItem> items = new ArrayList<>();
    private OrderStatus status;
    private int version;

    /**
     * Reconstruir estado a partir de eventos
     */
    public static Order fromEvents(List<OrderEvent> events) {
        var order = new Order();

        for (var event : events) {
            order.apply(event);
        }

        return order;
    }

    /**
     * Aplicar evento (muda estado)
     */
    private void apply(OrderEvent event) {
        switch (event.getEventType()) {
            case "OrderCreated" -> {
                var data = parseJson(event.getEventData(), OrderCreatedData.class);
                this.id = event.getAggregateId();
                this.customerId = data.customerId();
                this.status = OrderStatus.DRAFT;
            }

            case "ItemAdded" -> {
                var data = parseJson(event.getEventData(), ItemAddedData.class);
                items.add(new OrderItem(data.productId(), data.quantity()));
            }

            case "OrderConfirmed" -> {
                this.status = OrderStatus.CONFIRMED;
            }
        }

        this.version = event.getVersion();
    }

    /**
     * Command: Gerar novos eventos
     */
    public List<OrderEvent> addItem(Long productId, int quantity) {
        if (status != OrderStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify confirmed order");
        }

        var eventData = new ItemAddedData(productId, quantity);
        var event = new OrderEvent(
            id,
            "ItemAdded",
            toJson(eventData),
            LocalDateTime.now(),
            version + 1
        );

        return List.of(event);
    }
}

/**
 * Repository: Salvar e carregar eventos
 */
@Repository
public class OrderEventStore {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * Salvar eventos (transacional)
     */
    @Transactional
    public void saveEvents(String aggregateId, List<OrderEvent> events, int expectedVersion) {
        // Optimistic locking: Verificar vers√£o
        var currentVersion = jdbcTemplate.queryForObject(
            "SELECT COALESCE(MAX(version), 0) FROM order_events WHERE aggregate_id = ?",
            Integer.class,
            aggregateId
        );

        if (currentVersion != expectedVersion) {
            throw new ConcurrencyException("Version mismatch");
        }

        // Inserir eventos
        for (var event : events) {
            jdbcTemplate.update("""
                INSERT INTO order_events (aggregate_id, event_type, event_data, occurred_at, version)
                VALUES (?, ?, ?::jsonb, ?, ?)
                """,
                event.getAggregateId(),
                event.getEventType(),
                event.getEventData(),
                event.getOccurredAt(),
                event.getVersion()
            );
        }
    }

    /**
     * Carregar eventos (reconstruir aggregate)
     */
    public List<OrderEvent> loadEvents(String aggregateId) {
        return jdbcTemplate.query(
            "SELECT * FROM order_events WHERE aggregate_id = ? ORDER BY version",
            (rs, rowNum) -> mapEvent(rs),
            aggregateId
        );
    }
}
```

---

### 4.2 Snapshot Pattern

```java
/**
 * PROBLEMA: Muitos eventos ‚Üí Replay lento
 *
 * SOLU√á√ÉO: Snapshots peri√≥dicos do estado
 */

@Entity
@Table(name = "order_snapshots")
public class OrderSnapshot {
    @Id
    private String aggregateId;

    @Column(columnDefinition = "jsonb")
    private String stateData;  // Estado completo do aggregate

    private int version;  // √öltima vers√£o inclu√≠da

    private LocalDateTime createdAt;
}

/**
 * Load com snapshot
 */
public Order loadOrder(String orderId) {
    // 1. Carregar snapshot (se existir)
    var snapshot = snapshotRepository.findById(orderId).orElse(null);

    Order order;
    int fromVersion;

    if (snapshot != null) {
        order = deserialize(snapshot.getStateData());
        fromVersion = snapshot.getVersion() + 1;
    } else {
        order = new Order();
        fromVersion = 0;
    }

    // 2. Carregar eventos ap√≥s snapshot
    var events = eventStore.loadEventsAfterVersion(orderId, fromVersion);

    // 3. Aplicar eventos
    for (var event : events) {
        order.apply(event);
    }

    return order;
}

/**
 * Criar snapshot a cada 100 eventos
 */
@Scheduled(fixedRate = 60000)
public void createSnapshots() {
    var aggregates = eventStore.findAggregatesWithoutRecentSnapshot();

    for (var aggregateId : aggregates) {
        var order = loadOrder(aggregateId);

        var snapshot = new OrderSnapshot(
            aggregateId,
            serialize(order),
            order.getVersion(),
            LocalDateTime.now()
        );

        snapshotRepository.save(snapshot);
    }
}
```

---

## 5. Domain Modeling

### 5.1 DDD Entities vs Value Objects

```java
/**
 * ENTITY: Identidade importa (ID √∫nico)
 */
@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // ‚Üê Identidade

    private String name;

    @Embedded
    private Address address;  // Value Object

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Customer c)) return false;
        return Objects.equals(id, c.id);  // ‚Üê Igualdade por ID
    }
}

/**
 * VALUE OBJECT: Sem identidade, imut√°vel
 */
@Embeddable
public record Address(
    String street,
    String city,
    String state,
    String zipCode
) {
    // Imut√°vel: Sem setters
    // Igualdade: Por valor (todos campos)
}

/**
 * Uso
 */
var addr1 = new Address("123 Main St", "Springfield", "IL", "62701");
var addr2 = new Address("123 Main St", "Springfield", "IL", "62701");

addr1.equals(addr2);  // true (mesmo valor)

var customer1 = new Customer(1L, "John", addr1);
var customer2 = new Customer(2L, "John", addr1);

customer1.equals(customer2);  // false (IDs diferentes)
```

---

### 5.2 Aggregates

```java
/**
 * AGGREGATE: Cluster de entidades/VOs tratados como unidade
 *
 * Regras:
 * - Aggregate Root: √önica entrada (Order)
 * - Invariantes: Mantidas pelo Root
 * - Transa√ß√µes: Uma transa√ß√£o = Um aggregate
 */

@Entity
@Table(name = "orders")
public class Order {  // Aggregate Root
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private Long customerId;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> items = new ArrayList<>();  // Entidades do aggregate

    private OrderStatus status;

    /**
     * ‚úÖ Adicionar item via Root (mant√©m invariantes)
     */
    public void addItem(Product product, int quantity) {
        if (status != OrderStatus.DRAFT) {
            throw new IllegalStateException("Cannot modify confirmed order");
        }

        // Invariante: Max 10 items por pedido
        if (items.size() >= 10) {
            throw new IllegalStateException("Max 10 items per order");
        }

        var item = new OrderItem(this, product, quantity);
        items.add(item);
    }

    /**
     * ‚úÖ Confirmar pedido (validar invariantes)
     */
    public void confirm() {
        if (items.isEmpty()) {
            throw new IllegalStateException("Cannot confirm empty order");
        }

        if (calculateTotal().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalStateException("Order total must be positive");
        }

        this.status = OrderStatus.CONFIRMED;
    }

    private BigDecimal calculateTotal() {
        return items.stream()
                    .map(item -> item.getUnitPrice().multiply(new BigDecimal(item.getQuantity())))
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

@Entity
@Table(name = "order_items")
public class OrderItem {  // N√£o √© root (n√£o tem repository pr√≥prio)
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(optional = false)
    @JoinColumn(name = "order_id")
    private Order order;  // Sempre vinculado ao aggregate

    private Long productId;
    private int quantity;
    private BigDecimal unitPrice;

    // ‚ùå N√£o tem setters p√∫blicos (modifica√ß√µes via Order)
}

/**
 * Repository: S√≥ para Aggregate Root
 */
public interface OrderRepository extends JpaRepository<Order, Long> {
    // ‚úÖ Opera√ß√µes no aggregate completo
}

// ‚ùå N√£o existe OrderItemRepository
```

---

## üìä Checklist de Qualidade

- [ ] Schema normalizado (pelo menos 3NF) antes de desnormalizar
- [ ] Desnormaliza√ß√£o justificada (performance, n√£o "comodidade")
- [ ] Materialized views para queries complexas (vs desnormaliza√ß√£o)
- [ ] CQRS apenas se read/write t√™m requisitos muito diferentes
- [ ] Event Sourcing apenas se auditoria/replay √© requisito cr√≠tico
- [ ] Aggregates mant√™m invariantes de neg√≥cio
- [ ] Transa√ß√µes respeitam boundaries de aggregates
- [ ] Value objects imut√°veis (records)
- [ ] Entities comparadas por ID (n√£o por campos)
- [ ] Migrations testadas (rollback e rollforward)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Normalizar schema at√© 3NF
2. **Intermedi√°rio**: CQRS com proje√ß√µes (query model)
3. **Avan√ßado**: Event Sourcing com snapshots

---

## üìö Refer√™ncias

- [Database Normalization](https://en.wikipedia.org/wiki/Database_normalization)
- [CQRS Pattern](https://martinfowler.com/bliki/CQRS.html)
- [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)
- [Domain-Driven Design (DDD)](https://www.domainlanguage.com/ddd/)

---

**Anterior:** [12.9 - Multi-Tenancy](12.9-multi-tenancy.md)  
**Pr√≥ximo:** Fase 13 ou revis√£o
