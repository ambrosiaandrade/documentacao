# üî¥ M√≥dulo 12.5: Redis - Cache & Messaging

> **Objetivo:** Dominar Redis para caching, Pub/Sub e estruturas de dados avan√ßadas, com foco em performance e observabilidade.

---

## üìë √çndice

1. [Cache Strategies](#1-cache-strategies)
2. [Spring Cache Abstraction](#2-spring-cache-abstraction)
3. [Redis Data Structures](#3-redis-data-structures)
4. [TTL e Eviction](#4-ttl-e-eviction)
5. [Pub/Sub Messaging](#5-pubsub-messaging)
6. [Testing](#6-testing)
7. [Monitoring](#7-monitoring)

---

## 1. Cache Strategies

### 1.1 Compara√ß√£o de Estrat√©gias

| Estrat√©gia        | Leitura                                  | Escrita                                           | Consist√™ncia | Complexidade |
| ----------------- | ---------------------------------------- | ------------------------------------------------- | ------------ | ------------ |
| **Cache-Aside**   | App l√™ cache ‚Üí miss ‚Üí BD ‚Üí escreve cache | App escreve BD ‚Üí invalida cache                   | Eventual     | Baixa        |
| **Read-Through**  | Cache l√™ BD automaticamente              | App escreve BD                                    | Eventual     | M√©dia        |
| **Write-Through** | App l√™ cache                             | App escreve cache ‚Üí cache escreve BD (s√≠ncrono)   | Forte        | Alta         |
| **Write-Behind**  | App l√™ cache                             | App escreve cache ‚Üí cache escreve BD (ass√≠ncrono) | Eventual     | Alta         |

---

### 1.2 Cache-Aside (Lazy Loading)

```java
/**
 * CACHE-ASIDE: Padr√£o mais comum
 *
 * ‚úÖ VANTAGENS:
 * - Simples de implementar
 * - Cache populado sob demanda (n√£o desperdi√ßa mem√≥ria)
 * - Falha do cache n√£o quebra aplica√ß√£o
 *
 * ‚ö†Ô∏è DESVANTAGENS:
 * - Cache miss inicial (cold start)
 * - Poss√≠vel inconsist√™ncia (cache stale)
 */
@Service
public class ProductCacheAsideService {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private RedisTemplate<String, Product> redisTemplate;

    private static final String CACHE_PREFIX = "product:";
    private static final Duration TTL = Duration.ofMinutes(10);

    /**
     * Leitura com Cache-Aside
     */
    public Product findById(Long id) {
        var cacheKey = CACHE_PREFIX + id;

        // 1. Tentar ler do cache
        var cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;  // Cache HIT
        }

        // 2. Cache MISS ‚Üí Buscar no banco
        var product = productRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Product not found"));

        // 3. Escrever no cache
        redisTemplate.opsForValue().set(cacheKey, product, TTL);

        return product;
    }

    /**
     * Escrita com Cache-Aside
     */
    public Product update(Product product) {
        // 1. Atualizar banco
        var updated = productRepository.save(product);

        // 2. Invalidar cache (ou atualizar)
        var cacheKey = CACHE_PREFIX + product.getId();

        // Op√ß√£o A: Invalidar (lazy reload)
        redisTemplate.delete(cacheKey);

        // Op√ß√£o B: Atualizar (eager)
        // redisTemplate.opsForValue().set(cacheKey, updated, TTL);

        return updated;
    }
}
```

---

### 1.3 Write-Through

```java
/**
 * WRITE-THROUGH: Escrita s√≠ncrona (cache + BD)
 *
 * ‚úÖ VANTAGENS:
 * - Consist√™ncia forte (cache sempre atualizado)
 * - Leitura sempre r√°pida (cache quente)
 *
 * ‚ö†Ô∏è DESVANTAGENS:
 * - Lat√™ncia de escrita maior (2 opera√ß√µes s√≠ncronas)
 * - Cache pode ficar polu√≠do (dados raramente lidos)
 */
@Service
public class ProductWriteThroughService {

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private RedisTemplate<String, Product> redisTemplate;

    /**
     * Escrita s√≠ncrona: cache + BD
     */
    @Transactional
    public Product save(Product product) {
        // 1. Salvar no banco
        var saved = productRepository.save(product);

        // 2. Salvar no cache (s√≠ncrono)
        var cacheKey = "product:" + saved.getId();
        redisTemplate.opsForValue().set(cacheKey, saved, Duration.ofMinutes(30));

        return saved;
    }
}
```

---

## 2. Spring Cache Abstraction

### 2.1 Configura√ß√£o

```yaml
# application.yml
spring:
  cache:
    type: redis
  data:
    redis:
      host: localhost
      port: 6379
      password: secret
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 2
```

```java
/**
 * Configura√ß√£o Spring Cache
 */
@Configuration
@EnableCaching  // Habilita @Cacheable, @CacheEvict, etc.
public class CacheConfig {

    /**
     * RedisCacheManager customizado
     */
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        var config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))                    // TTL padr√£o
            .disableCachingNullValues()                          // N√£o cachear null
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))    // Chaves como String
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));  // Valores como JSON

        // Configura√ß√µes espec√≠ficas por cache
        var cacheConfigurations = Map.of(
            "products", config.entryTtl(Duration.ofHours(1)),
            "users", config.entryTtl(Duration.ofMinutes(5))
        );

        return RedisCacheManager.builder(connectionFactory)
                                .cacheDefaults(config)
                                .withInitialCacheConfigurations(cacheConfigurations)
                                .build();
    }

    /**
     * RedisTemplate customizado (para uso program√°tico)
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        var template = new RedisTemplate<String, Object>();
        template.setConnectionFactory(connectionFactory);

        // Serializers
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());

        return template;
    }
}
```

---

### 2.2 @Cacheable

```java
/**
 * @Cacheable: Cache autom√°tico de leitura
 */
@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    /**
     * @Cacheable: Resultado cacheado automaticamente
     *
     * - Primeira chamada: executa m√©todo, cachea resultado
     * - Chamadas subsequentes: retorna do cache (m√©todo n√£o executado)
     *
     * Chave gerada: products::1 (cacheName::keyExpression)
     */
    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        System.out.println("Cache MISS - querying database for id: " + id);
        return productRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Product not found"));
    }

    /**
     * @Cacheable com chave composta
     */
    @Cacheable(value = "products", key = "#category + ':' + #priceRange")
    public List<Product> findByCategoryAndPrice(String category, String priceRange) {
        return productRepository.findByCategoryAndPriceRange(category, priceRange);
    }

    /**
     * @Cacheable com condi√ß√£o
     *
     * Cache apenas se resultado n√£o for null
     */
    @Cacheable(value = "products", key = "#id", unless = "#result == null")
    public Product findByIdConditional(Long id) {
        return productRepository.findById(id).orElse(null);
    }

    /**
     * @Cacheable com SpEL avan√ßado
     */
    @Cacheable(value = "products",
               key = "#root.methodName + ':' + #id",
               condition = "#id > 0")
    public Product findByIdSpel(Long id) {
        return productRepository.findById(id).orElseThrow();
    }
}
```

---

### 2.3 @CacheEvict e @CachePut

```java
@Service
public class ProductService {

    /**
     * @CacheEvict: Invalidar cache
     *
     * Executado AP√ìS m√©todo (default)
     */
    @CacheEvict(value = "products", key = "#product.id")
    public Product update(Product product) {
        return productRepository.save(product);
    }

    /**
     * @CacheEvict com beforeInvocation
     *
     * Executado ANTES do m√©todo (√∫til se m√©todo pode lan√ßar exce√ß√£o)
     */
    @CacheEvict(value = "products", key = "#id", beforeInvocation = true)
    public void delete(Long id) {
        productRepository.deleteById(id);
    }

    /**
     * @CacheEvict: Limpar cache inteiro
     */
    @CacheEvict(value = "products", allEntries = true)
    public void clearCache() {
        System.out.println("All products cache cleared");
    }

    /**
     * @CachePut: Atualiza cache (sempre executa m√©todo)
     *
     * Diferen√ßa de @Cacheable:
     * - @Cacheable: Pula m√©todo se cache HIT
     * - @CachePut: Sempre executa, atualiza cache
     */
    @CachePut(value = "products", key = "#product.id")
    public Product save(Product product) {
        return productRepository.save(product);
    }

    /**
     * @Caching: M√∫ltiplas opera√ß√µes de cache
     */
    @Caching(
        evict = {
            @CacheEvict(value = "products", key = "#product.id"),
            @CacheEvict(value = "productsByCategory", key = "#product.category")
        }
    )
    public Product updateAndEvictMultiple(Product product) {
        return productRepository.save(product);
    }
}
```

---

## 3. Redis Data Structures

### 3.1 String (Value)

```java
/**
 * String: Estrutura mais simples (chave-valor)
 */
@Service
public class StringOperationsService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void stringOperations() {
        var ops = redisTemplate.opsForValue();

        // SET
        ops.set("user:1:name", "Jo√£o Silva");

        // GET
        var name = ops.get("user:1:name");  // "Jo√£o Silva"

        // SET com TTL
        ops.set("session:abc123", "user_data", Duration.ofMinutes(30));

        // INCR (contador at√¥mico)
        ops.increment("page:views");  // 1
        ops.increment("page:views");  // 2
        ops.increment("page:views", 5);  // 7

        // DECR
        ops.decrement("stock:product:1");

        // GETSET (retorna valor antigo e define novo)
        var oldValue = ops.getAndSet("user:1:name", "Jo√£o Pedro");

        // MGET (m√∫ltiplas chaves em 1 opera√ß√£o)
        var values = ops.multiGet(List.of("user:1:name", "user:2:name"));
    }
}
```

---

### 3.2 Hash (Map)

```java
/**
 * Hash: Mapeia m√∫ltiplos campos em 1 chave (similar HashMap)
 *
 * üí° USO: Objetos com m√∫ltiplos campos
 */
@Service
public class HashOperationsService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    public void hashOperations() {
        var ops = redisTemplate.opsForHash();

        // HSET (definir campo)
        ops.put("user:1", "name", "Jo√£o");
        ops.put("user:1", "email", "joao@email.com");
        ops.put("user:1", "age", "30");

        // HGET (obter campo)
        var name = ops.get("user:1", "name");  // "Jo√£o"

        // HGETALL (obter todos campos)
        var user = ops.entries("user:1");
        // {name=Jo√£o, email=joao@email.com, age=30}

        // HMSET (set m√∫ltiplos campos)
        var fields = Map.of(
            "name", "Maria",
            "email", "maria@email.com",
            "age", "25"
        );
        ops.putAll("user:2", fields);

        // HINCRBY (incrementar campo num√©rico)
        ops.increment("user:1", "loginCount", 1);

        // HEXISTS (campo existe?)
        var exists = ops.hasKey("user:1", "name");  // true

        // HDEL (deletar campo)
        ops.delete("user:1", "age");
    }

    /**
     * Exemplo pr√°tico: Cachear objeto como Hash
     */
    public void cacheUserAsHash(User user) {
        var ops = redisTemplate.opsForHash();
        var key = "user:" + user.getId();

        ops.putAll(key, Map.of(
            "name", user.getName(),
            "email", user.getEmail(),
            "role", user.getRole()
        ));

        // TTL no hash inteiro
        redisTemplate.expire(key, Duration.ofMinutes(15));
    }
}
```

---

### 3.3 List (Queue/Stack)

```java
/**
 * List: Lista ordenada (suporta duplicatas)
 *
 * üí° USO: Filas, logs, feeds
 */
@Service
public class ListOperationsService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void listOperations() {
        var ops = redisTemplate.opsForList();

        // LPUSH (inserir √† esquerda - in√≠cio)
        ops.leftPush("queue:tasks", "task1");
        ops.leftPush("queue:tasks", "task2");
        // Lista: [task2, task1]

        // RPUSH (inserir √† direita - fim)
        ops.rightPush("queue:tasks", "task3");
        // Lista: [task2, task1, task3]

        // LPOP (remover e retornar primeiro)
        var first = ops.leftPop("queue:tasks");  // "task2"

        // RPOP (remover e retornar √∫ltimo)
        var last = ops.rightPop("queue:tasks");  // "task3"

        // LRANGE (obter intervalo)
        var all = ops.range("queue:tasks", 0, -1);  // Todos elementos

        // LLEN (tamanho)
        var size = ops.size("queue:tasks");

        // LTRIM (manter apenas intervalo)
        ops.trim("logs:recent", 0, 99);  // Mant√©m √∫ltimos 100
    }

    /**
     * Exemplo: Fila de processamento (FIFO)
     */
    public void enqueuTask(String task) {
        redisTemplate.opsForList().rightPush("queue:tasks", task);
    }

    public String dequeueTask() {
        return redisTemplate.opsForList().leftPop("queue:tasks");
    }
}
```

---

### 3.4 Set (Conjunto)

```java
/**
 * Set: Conjunto n√£o-ordenado (sem duplicatas)
 *
 * üí° USO: Tags, likes, followers
 */
@Service
public class SetOperationsService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void setOperations() {
        var ops = redisTemplate.opsForSet();

        // SADD (adicionar membros)
        ops.add("post:1:likes", "user:1", "user:2", "user:3");

        // SISMEMBER (membro existe?)
        var liked = ops.isMember("post:1:likes", "user:1");  // true

        // SMEMBERS (todos membros)
        var likes = ops.members("post:1:likes");  // [user:1, user:2, user:3]

        // SCARD (cardinalidade - tamanho)
        var count = ops.size("post:1:likes");  // 3

        // SREM (remover membro)
        ops.remove("post:1:likes", "user:2");

        // SINTER (interse√ß√£o - seguidores em comum)
        ops.add("user:1:following", "user:3", "user:4", "user:5");
        ops.add("user:2:following", "user:3", "user:5", "user:6");

        var commonFollowing = ops.intersect("user:1:following", "user:2:following");
        // [user:3, user:5]

        // SUNION (uni√£o)
        var allFollowing = ops.union("user:1:following", "user:2:following");

        // SDIFF (diferen√ßa)
        var uniqueToUser1 = ops.difference("user:1:following", "user:2:following");
    }
}
```

---

### 3.5 Sorted Set (Ranking)

```java
/**
 * Sorted Set: Conjunto ordenado por score
 *
 * üí° USO: Rankings, leaderboards, time-series
 */
@Service
public class SortedSetOperationsService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void sortedSetOperations() {
        var ops = redisTemplate.opsForZSet();

        // ZADD (adicionar com score)
        ops.add("leaderboard:game1", "player1", 100);
        ops.add("leaderboard:game1", "player2", 250);
        ops.add("leaderboard:game1", "player3", 180);

        // ZRANGE (obter por posi√ß√£o - ordem crescente)
        var top3 = ops.range("leaderboard:game1", 0, 2);
        // [player1, player3, player2]

        // ZREVRANGE (ordem decrescente)
        var top3Desc = ops.reverseRange("leaderboard:game1", 0, 2);
        // [player2, player3, player1]

        // ZRANK (posi√ß√£o do membro - 0-indexed)
        var rank = ops.rank("leaderboard:game1", "player2");  // 2 (√∫ltimo)

        // ZREVRANK (posi√ß√£o inversa)
        var revRank = ops.reverseRank("leaderboard:game1", "player2");  // 0 (primeiro)

        // ZSCORE (obter score)
        var score = ops.score("leaderboard:game1", "player2");  // 250.0

        // ZINCRBY (incrementar score)
        ops.incrementScore("leaderboard:game1", "player1", 50);  // 150

        // ZCOUNT (contar por intervalo de score)
        var count = ops.count("leaderboard:game1", 100, 200);  // 2

        // ZRANGEBYSCORE (obter por score)
        var midRange = ops.rangeByScore("leaderboard:game1", 100, 200);
    }

    /**
     * Exemplo: Top 10 leaderboard com scores
     */
    public List<LeaderboardEntry> getTop10() {
        var ops = redisTemplate.opsForZSet();

        var entries = ops.reverseRangeWithScores("leaderboard:game1", 0, 9);

        return entries.stream()
                      .map(entry -> new LeaderboardEntry(
                          entry.getValue(),
                          entry.getScore().intValue()
                      ))
                      .toList();
    }
}

record LeaderboardEntry(String player, int score) {}
```

---

## 4. TTL e Eviction

### 4.1 Time-To-Live

```java
/**
 * TTL: Expira√ß√£o autom√°tica de chaves
 */
@Service
public class TTLService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void ttlOperations() {
        // SET com TTL (expira em 10 minutos)
        redisTemplate.opsForValue().set("session:abc", "data", Duration.ofMinutes(10));

        // SET sem TTL, depois EXPIRE
        redisTemplate.opsForValue().set("user:1:token", "xyz789");
        redisTemplate.expire("user:1:token", Duration.ofHours(1));

        // TTL (tempo restante em segundos)
        var ttl = redisTemplate.getExpire("user:1:token", TimeUnit.SECONDS);
        // Retorna: tempo restante ou -1 (sem expira√ß√£o) ou -2 (chave n√£o existe)

        // PERSIST (remover expira√ß√£o)
        redisTemplate.persist("user:1:token");

        // EXPIREAT (expirar em timestamp espec√≠fico)
        var expireAt = Instant.now().plus(Duration.ofDays(7));
        redisTemplate.expireAt("promocode:ABC", Date.from(expireAt));
    }
}
```

---

### 4.2 Eviction Policies

```yaml
# redis.conf (configura√ß√£o Redis server)
maxmemory: 512mb
maxmemory-policy: allkeys-lru
# Pol√≠ticas dispon√≠veis:
# - noeviction: Retorna erro quando mem√≥ria cheia (padr√£o)
# - allkeys-lru: Remove chaves menos recentemente usadas (LRU)
# - volatile-lru: LRU apenas em chaves com TTL
# - allkeys-lfu: Remove chaves menos frequentemente usadas (LFU)
# - volatile-lfu: LFU apenas em chaves com TTL
# - allkeys-random: Remove chaves aleatoriamente
# - volatile-random: Random apenas em chaves com TTL
# - volatile-ttl: Remove chaves com menor TTL primeiro
```

---

## 5. Pub/Sub Messaging

### 5.1 Publisher

```java
/**
 * Redis Pub/Sub: Messaging simples (n√£o persiste mensagens)
 *
 * ‚ö†Ô∏è LIMITA√á√ïES:
 * - Mensagens n√£o persistidas (fire-and-forget)
 * - Subscriber deve estar online (n√£o h√° fila)
 *
 * üí° ALTERNATIVAS: RabbitMQ, Kafka para messaging robusto
 */
@Service
public class NotificationPublisher {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * Publicar mensagem em canal
     */
    public void publishNotification(String userId, String message) {
        var channel = "notifications:user:" + userId;

        var notification = new Notification(userId, message, Instant.now());

        redisTemplate.convertAndSend(channel, notification);
    }

    /**
     * Broadcast para todos
     */
    public void broadcastAnnouncement(String message) {
        redisTemplate.convertAndSend("announcements", message);
    }
}

record Notification(String userId, String message, Instant timestamp) {}
```

---

### 5.2 Subscriber

```java
/**
 * Redis Message Listener
 */
@Configuration
public class RedisSubscriberConfig {

    @Bean
    public RedisMessageListenerContainer messageListenerContainer(
            RedisConnectionFactory connectionFactory,
            MessageListenerAdapter listenerAdapter) {

        var container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);

        // Subscrever em canal espec√≠fico
        container.addMessageListener(listenerAdapter,
            new PatternTopic("notifications:user:*"));

        return container;
    }

    @Bean
    public MessageListenerAdapter listenerAdapter(NotificationSubscriber subscriber) {
        return new MessageListenerAdapter(subscriber, "onMessage");
    }
}

@Component
public class NotificationSubscriber {

    /**
     * M√©todo chamado ao receber mensagem
     */
    public void onMessage(Notification notification) {
        System.out.printf("Received notification for user %s: %s%n",
            notification.userId(), notification.message());

        // Processar notifica√ß√£o (enviar email, push, etc.)
    }
}
```

---

## 6. Testing

### 6.1 TestContainers Redis

```java
/**
 * Teste com Redis real (TestContainers)
 */
@SpringBootTest
@Testcontainers
class RedisCacheTest {

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
        .withExposedPorts(6379);

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", redis::getFirstMappedPort);
    }

    @Autowired
    private ProductService productService;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @BeforeEach
    void setUp() {
        redisTemplate.getConnectionFactory().getConnection().flushAll();
    }

    @Test
    void shouldCacheProduct() {
        // Primeira chamada: cache MISS
        var product1 = productService.findById(1L);

        // Segunda chamada: cache HIT (n√£o acessa BD)
        var product2 = productService.findById(1L);

        assertThat(product1).isSameAs(product2);

        // Verificar chave no Redis
        var exists = redisTemplate.hasKey("products::1");
        assertThat(exists).isTrue();
    }

    @Test
    void shouldEvictCacheOnUpdate() {
        // Cachear produto
        productService.findById(1L);

        // Atualizar (deve invalidar cache)
        var updated = new Product(1L, "Updated Name", BigDecimal.TEN);
        productService.update(updated);

        // Cache deve estar vazio
        var exists = redisTemplate.hasKey("products::1");
        assertThat(exists).isFalse();
    }
}
```

---

### 6.2 Embedded Redis

```xml
<!-- Alternativa: Embedded Redis (n√£o requer Docker) -->
<dependency>
    <groupId>it.ozimov</groupId>
    <artifactId>embedded-redis</artifactId>
    <version>0.7.3</version>
    <scope>test</scope>
</dependency>
```

```java
/**
 * Configura√ß√£o Embedded Redis
 */
@TestConfiguration
public class EmbeddedRedisConfig {

    private RedisServer redisServer;

    @PostConstruct
    public void startRedis() {
        redisServer = new RedisServer(6370);  // Porta diferente
        redisServer.start();
    }

    @PreDestroy
    public void stopRedis() {
        if (redisServer != null) {
            redisServer.stop();
        }
    }
}
```

---

## 7. Monitoring

### 7.1 Cache Metrics

```java
/**
 * M√©tricas de cache com Micrometer
 */
@Configuration
public class CacheMetricsConfig {

    @Bean
    public CacheMetricsRegistrar cacheMetricsRegistrar(
            MeterRegistry meterRegistry,
            Collection<CacheManager> cacheManagers) {

        var registrar = new CacheMetricsRegistrar(meterRegistry);

        cacheManagers.forEach(cacheManager ->
            cacheManager.getCacheNames().forEach(cacheName -> {
                var cache = cacheManager.getCache(cacheName);
                registrar.bindCacheToRegistry(cache);
            })
        );

        return registrar;
    }
}

/**
 * Endpoint para m√©tricas de cache
 */
@RestController
@RequestMapping("/cache")
public class CacheMetricsController {

    @Autowired
    private CacheManager cacheManager;

    @GetMapping("/stats")
    public Map<String, CacheStats> getCacheStats() {
        return cacheManager.getCacheNames().stream()
            .collect(Collectors.toMap(
                name -> name,
                name -> calculateStats(name)
            ));
    }

    private CacheStats calculateStats(String cacheName) {
        var cache = cacheManager.getCache(cacheName);
        var nativeCache = (org.springframework.data.redis.cache.RedisCache) cache;

        // Obter estat√≠sticas (implementa√ß√£o depende do provider)
        return new CacheStats(
            cacheName,
            nativeCache.size(),
            // hit rate, miss rate, etc. (requer implementa√ß√£o customizada)
        );
    }
}

record CacheStats(String name, long size) {}
```

---

### 7.2 Redis INFO

```java
/**
 * Monitorar Redis com INFO command
 */
@Service
public class RedisMonitoringService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public void printRedisInfo() {
        var info = redisTemplate.execute((RedisCallback<Properties>) connection -> {
            return connection.info();
        });

        System.out.println("=== Redis INFO ===");
        System.out.println("Used Memory: " + info.getProperty("used_memory_human"));
        System.out.println("Connected Clients: " + info.getProperty("connected_clients"));
        System.out.println("Total Commands: " + info.getProperty("total_commands_processed"));
        System.out.println("Keyspace Hits: " + info.getProperty("keyspace_hits"));
        System.out.println("Keyspace Misses: " + info.getProperty("keyspace_misses"));

        // Calcular hit rate
        var hits = Long.parseLong(info.getProperty("keyspace_hits", "0"));
        var misses = Long.parseLong(info.getProperty("keyspace_misses", "0"));
        var hitRate = hits / (double) (hits + misses) * 100;

        System.out.printf("Hit Rate: %.2f%%%n", hitRate);
    }
}
```

---

## üìä Checklist de Qualidade

- [ ] Usar Cache-Aside para dados read-heavy
- [ ] Definir TTL apropriado (evitar cache stale)
- [ ] Configurar eviction policy (allkeys-lru recomendado)
- [ ] Monitorar hit rate (>80% ideal)
- [ ] Invalidar cache em updates/deletes
- [ ] Usar Hash para objetos (mais eficiente que JSON)
- [ ] Evitar Pub/Sub para mensagens cr√≠ticas (usar queue)
- [ ] Testar com TestContainers (ambiente real)
- [ ] Configurar connection pool (Lettuce default)
- [ ] Alertar se hit rate < 50% (cache ineficaz)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Implementar cache com @Cacheable em API REST
2. **Intermedi√°rio**: Criar leaderboard com Sorted Set
3. **Avan√ßado**: Sistema de notifica√ß√µes real-time com Pub/Sub

---

## üìö Refer√™ncias

- [Redis Documentation](https://redis.io/docs/)
- [Spring Data Redis](https://docs.spring.io/spring-data/redis/docs/current/reference/html/)
- [Redis University (Free)](https://university.redis.com/)

---

**Anterior:** [12.4 - MongoDB](12.4-mongodb.md)  
**Pr√≥ximo:** [12.6 - Migrations](12.6-migrations.md)
