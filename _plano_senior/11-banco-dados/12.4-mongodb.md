# üçÉ M√≥dulo 12.4: MongoDB - NoSQL Document Database

> **Objetivo:** Dominar MongoDB para cen√°rios NoSQL, design de documentos, aggregation pipeline, indexes e testes com TestContainers.

---

## üìë √çndice

1. [SQL vs NoSQL](#1-sql-vs-nosql)
2. [Document Design Patterns](#2-document-design-patterns)
3. [Spring Data MongoDB](#3-spring-data-mongodb)
4. [Queries e Aggregation](#4-queries-e-aggregation)
5. [Indexes](#5-indexes)
6. [Transactions](#6-transactions)
7. [Testing](#7-testing)

---

## 1. SQL vs NoSQL

### 1.1 Compara√ß√£o

| Aspecto             | SQL (PostgreSQL)                       | NoSQL (MongoDB)                              |
| ------------------- | -------------------------------------- | -------------------------------------------- |
| **Schema**          | Fixo (DDL)                             | Flex√≠vel (schema-less)                       |
| **Relacionamentos** | JOINs normalizados                     | Embedding ou refer√™ncias                     |
| **Escalabilidade**  | Vertical (mais CPU/RAM)                | Horizontal (sharding)                        |
| **Transa√ß√µes**      | ACID completo                          | ACID desde 4.0 (multi-doc)                   |
| **Consultas**       | SQL declarativo                        | Aggregation pipeline                         |
| **Casos de Uso**    | Dados estruturados, forte consist√™ncia | Dados semi-estruturados, alta escalabilidade |

---

### 1.2 Quando Usar MongoDB

```java
/**
 * ‚úÖ USE MongoDB quando:
 *
 * 1. Schema evolui rapidamente (startups, MVPs)
 * 2. Dados semi-estruturados ou hier√°rquicos (JSON-like)
 * 3. Alta escala horizontal (milh√µes de documentos)
 * 4. Leitura > Escrita (cache, logs, analytics)
 * 5. Geolocaliza√ß√£o (queries geoespaciais)
 * 6. Agrega√ß√µes complexas (analytics, reports)
 *
 * ‚ö†Ô∏è N√ÉO use quando:
 *
 * 1. Transa√ß√µes complexas multi-tabela (banking)
 * 2. Relacionamentos N:N complexos (normaliza√ß√£o cr√≠tica)
 * 3. Queries ad-hoc imprevis√≠veis (SQL √© mais flex√≠vel)
 * 4. Equipe sem experi√™ncia NoSQL (curva aprendizado)
 */
```

---

## 2. Document Design Patterns

### 2.1 Embedding vs Referencing

```java
/**
 * PADR√ÉO 1: EMBEDDING (denormaliza√ß√£o)
 *
 * ‚úÖ USE quando:
 * - Dados sempre acessados juntos
 * - Rela√ß√£o 1:poucos (ex: 1 user ‚Üí 3 addresses)
 * - Sub-documentos n√£o mudam frequentemente
 *
 * ‚ö†Ô∏è LIMITE: Documento MongoDB max 16MB
 */
@Document(collection = "users")
public class User {

    @Id
    private String id;

    private String name;
    private String email;

    /**
     * Embedding: Endere√ßos dentro do documento user
     *
     * ‚úÖ VANTAGEM: 1 query retorna tudo
     * ‚ö†Ô∏è DESVANTAGEM: Duplica√ß√£o se address usado em m√∫ltiplos contextos
     */
    @Field("addresses")
    private List<Address> addresses = new ArrayList<>();

    /**
     * Nested document (n√£o √© entity separada)
     */
    public record Address(
        String street,
        String city,
        String zipCode,
        boolean isPrimary
    ) {}
}

/**
 * PADR√ÉO 2: REFERENCING (normaliza√ß√£o)
 *
 * ‚úÖ USE quando:
 * - Rela√ß√£o 1:muitos (ex: 1 author ‚Üí 1000 books)
 * - Sub-documentos mudam frequentemente
 * - Sub-documentos acessados independentemente
 */
@Document(collection = "authors")
public class Author {

    @Id
    private String id;

    private String name;

    /**
     * Referencing: Apenas IDs dos livros
     *
     * ‚úÖ VANTAGEM: N√£o duplica dados, documento menor
     * ‚ö†Ô∏è DESVANTAGEM: Requer m√∫ltiplas queries ou $lookup (JOIN)
     */
    @DBRef
    private List<Book> books = new ArrayList<>();

    // Alternativa: Apenas IDs (sem @DBRef)
    // private List<String> bookIds = new ArrayList<>();
}

@Document(collection = "books")
public class Book {

    @Id
    private String id;

    private String title;

    @DBRef
    private Author author;
}
```

---

### 2.2 Padr√µes Avan√ßados

```java
/**
 * PADR√ÉO 3: BUCKET (agrega√ß√£o)
 *
 * üí° USO: Time-series, sensores, logs
 *
 * Agrupa m√∫ltiplos eventos em 1 documento (reduz I/O)
 */
@Document(collection = "temperature_readings")
public class TemperatureBucket {

    @Id
    private String id;

    /**
     * Sensor que gerou leituras
     */
    private String sensorId;

    /**
     * Hora inicial do bucket (ex: 2025-01-01 10:00:00)
     */
    private LocalDateTime bucketStart;

    /**
     * Array de leituras (at√© 1h ou 1000 leituras)
     */
    private List<Reading> readings = new ArrayList<>();

    public record Reading(
        LocalDateTime timestamp,
        Double temperature,
        String unit
    ) {}

    /**
     * Adicionar leitura ao bucket
     */
    public void addReading(Double temperature) {
        readings.add(new Reading(LocalDateTime.now(), temperature, "Celsius"));
    }
}

/**
 * PADR√ÉO 4: SUBSET (campos calculados)
 *
 * üí° USO: Documentos grandes, onde s√≥ parte √© acessada frequentemente
 *
 * Cria c√≥pia com campos essenciais
 */
@Document(collection = "products")
public class Product {

    @Id
    private String id;

    private String name;
    private BigDecimal price;

    /**
     * Reviews completas (pesadas)
     */
    private List<Review> allReviews = new ArrayList<>();

    /**
     * Subset: Apenas √∫ltimas 5 reviews (cache)
     *
     * Atualizado via trigger/application code
     */
    private List<ReviewSummary> recentReviews = new ArrayList<>();

    public record Review(
        String author,
        String text,  // Campo pesado
        Integer rating,
        LocalDateTime createdAt
    ) {}

    public record ReviewSummary(
        String author,
        Integer rating,
        LocalDateTime createdAt
    ) {}
}
```

---

## 3. Spring Data MongoDB

### 3.1 Configura√ß√£o

```yaml
# application.yml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/mydb
      # Ou configura√ß√£o detalhada:
      host: localhost
      port: 27017
      database: mydb
      username: user
      password: pass
      authentication-database: admin
```

```java
/**
 * Configura√ß√£o customizada (opcional)
 */
@Configuration
@EnableMongoRepositories(basePackages = "com.example.repository")
public class MongoConfig {

    /**
     * Custom converter: Enum ‚Üí String
     */
    @Bean
    public MongoCustomConversions mongoCustomConversions() {
        var converters = List.of(
            new EnumToStringConverter(),
            new StringToEnumConverter()
        );
        return new MongoCustomConversions(converters);
    }

    /**
     * Auditing (similar JPA)
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> Optional.of("system");
    }
}

@Configuration
@EnableMongoAuditing
class MongoAuditingConfig {
    // Habilita @CreatedDate, @LastModifiedDate
}
```

---

### 3.2 Document Entity

```java
/**
 * Document: Entity MongoDB
 */
@Document(collection = "orders")  // Nome da collection
public class Order {

    /**
     * @Id: ObjectId gerado automaticamente
     *
     * Tipo String mapeia para ObjectId (12 bytes)
     * Alternativa: usar ObjectId diretamente
     */
    @Id
    private String id;

    /**
     * @Field: Customiza nome do campo no documento
     *
     * √ötil para snake_case vs camelCase
     */
    @Field("order_number")
    private String orderNumber;

    /**
     * @Indexed: Cria √≠ndice simples
     *
     * unique = true: √çndice √∫nico
     */
    @Indexed(unique = true)
    private String trackingCode;

    /**
     * Enum armazenado como String (padr√£o)
     */
    private OrderStatus status;

    /**
     * BigDecimal armazenado como Decimal128
     */
    private BigDecimal totalAmount;

    /**
     * LocalDateTime armazenado como Date (UTC)
     */
    private LocalDateTime createdAt;

    /**
     * Array de sub-documentos (embedding)
     */
    private List<OrderItem> items = new ArrayList<>();

    /**
     * @DBRef: Refer√™ncia a outro documento
     *
     * ‚ö†Ô∏è CUIDADO: Requer query adicional (lazy load)
     */
    @DBRef
    private Customer customer;

    /**
     * @Transient: N√£o persiste no banco
     */
    @Transient
    private String temporaryData;

    /**
     * @Version: Optimistic locking
     */
    @Version
    private Long version;

    /**
     * Auditing autom√°tico
     */
    @CreatedDate
    private Instant createdDate;

    @LastModifiedDate
    private Instant lastModifiedDate;

    /**
     * Sub-documento embutido
     */
    public record OrderItem(
        String productId,
        String productName,
        Integer quantity,
        BigDecimal unitPrice
    ) {
        public BigDecimal getSubtotal() {
            return unitPrice.multiply(BigDecimal.valueOf(quantity));
        }
    }
}

enum OrderStatus {
    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED
}
```

---

### 3.3 Repository

```java
/**
 * MongoRepository: Similar JpaRepository
 */
public interface OrderRepository extends MongoRepository<Order, String> {

    // Query methods (mesma sintaxe JPA)
    List<Order> findByStatus(OrderStatus status);

    List<Order> findByCustomerId(String customerId);

    List<Order> findByCreatedAtBetween(LocalDateTime start, LocalDateTime end);

    /**
     * @Query: Query nativa MongoDB (JSON)
     *
     * Sintaxe: JSON MongoDB
     */
    @Query("{ 'status': ?0, 'totalAmount': { $gte: ?1 } }")
    List<Order> findByStatusAndMinAmount(OrderStatus status, BigDecimal minAmount);

    /**
     * Query com projection (retorna apenas campos espec√≠ficos)
     */
    @Query(value = "{ 'status': ?0 }", fields = "{ 'orderNumber': 1, 'totalAmount': 1 }")
    List<Order> findOrderSummariesByStatus(OrderStatus status);

    /**
     * Aggregation pipeline
     */
    @Aggregation(pipeline = {
        "{ $match: { 'status': ?0 } }",
        "{ $group: { _id: '$customerId', total: { $sum: '$totalAmount' } } }",
        "{ $sort: { total: -1 } }",
        "{ $limit: 10 }"
    })
    List<CustomerSpending> findTopCustomersByStatus(OrderStatus status);
}

/**
 * DTO para aggregation result
 */
record CustomerSpending(
    @Field("_id") String customerId,
    BigDecimal total
) {}
```

---

## 4. Queries e Aggregation

### 4.1 Queries Program√°ticas

```java
/**
 * MongoTemplate: API program√°tica (similar EntityManager)
 */
@Service
public class OrderQueryService {

    @Autowired
    private MongoTemplate mongoTemplate;

    /**
     * Query b√°sica com Criteria
     */
    public List<Order> findOrdersByCriteria(OrderStatus status, BigDecimal minAmount) {
        var query = new Query();
        query.addCriteria(
            Criteria.where("status").is(status)
                    .and("totalAmount").gte(minAmount)
        );

        return mongoTemplate.find(query, Order.class);
    }

    /**
     * Query com sorting e pagina√ß√£o
     */
    public List<Order> findOrdersPaginated(int page, int size) {
        var query = new Query()
            .with(Sort.by(Sort.Direction.DESC, "createdAt"))
            .skip((long) page * size)
            .limit(size);

        return mongoTemplate.find(query, Order.class);
    }

    /**
     * Query complexa (OR, IN, regex)
     */
    public List<Order> findOrdersComplexCriteria(String keyword, List<OrderStatus> statuses) {
        var criteria = new Criteria().orOperator(
            Criteria.where("orderNumber").regex(keyword, "i"),  // Case-insensitive
            Criteria.where("trackingCode").regex(keyword, "i")
        ).and("status").in(statuses);

        return mongoTemplate.find(Query.query(criteria), Order.class);
    }

    /**
     * Update query
     */
    public long updateOrderStatus(String orderId, OrderStatus newStatus) {
        var query = Query.query(Criteria.where("id").is(orderId));
        var update = new Update().set("status", newStatus)
                                 .set("lastModifiedDate", Instant.now());

        var result = mongoTemplate.updateFirst(query, update, Order.class);
        return result.getModifiedCount();
    }

    /**
     * Upsert (update or insert)
     */
    public void upsertOrder(Order order) {
        var query = Query.query(Criteria.where("orderNumber").is(order.getOrderNumber()));
        var update = new Update()
            .set("status", order.getStatus())
            .set("totalAmount", order.getTotalAmount());

        mongoTemplate.upsert(query, update, Order.class);
    }
}
```

---

### 4.2 Aggregation Pipeline

```java
/**
 * Aggregation: Pipeline de transforma√ß√µes (similar SQL GROUP BY + JOINs)
 */
@Service
public class OrderAggregationService {

    @Autowired
    private MongoTemplate mongoTemplate;

    /**
     * Aggregation: Total de vendas por status
     */
    public List<StatusSummary> salesByStatus() {
        var aggregation = Aggregation.newAggregation(
            // Stage 1: Filtrar
            Aggregation.match(Criteria.where("status").in(OrderStatus.DELIVERED, OrderStatus.SHIPPED)),

            // Stage 2: Agrupar
            Aggregation.group("status")
                       .sum("totalAmount").as("totalSales")
                       .count().as("orderCount"),

            // Stage 3: Ordenar
            Aggregation.sort(Sort.Direction.DESC, "totalSales")
        );

        var results = mongoTemplate.aggregate(aggregation, "orders", StatusSummary.class);
        return results.getMappedResults();
    }

    /**
     * Aggregation: Top 10 produtos mais vendidos
     */
    public List<ProductSales> topSellingProducts() {
        var aggregation = Aggregation.newAggregation(
            // Stage 1: Unwind array (1 doc ‚Üí N docs)
            Aggregation.unwind("items"),

            // Stage 2: Agrupar por produto
            Aggregation.group("items.productId")
                       .first("items.productName").as("productName")
                       .sum("items.quantity").as("totalQuantity")
                       .sum(ArithmeticOperators.Multiply.valueOf("items.quantity")
                                                        .multiplyBy("items.unitPrice"))
                           .as("totalRevenue"),

            // Stage 3: Ordenar por quantidade
            Aggregation.sort(Sort.Direction.DESC, "totalQuantity"),

            // Stage 4: Limitar a 10
            Aggregation.limit(10)
        );

        return mongoTemplate.aggregate(aggregation, "orders", ProductSales.class)
                            .getMappedResults();
    }

    /**
     * Aggregation: Lookup ($lookup = JOIN)
     */
    public List<OrderWithCustomer> ordersWithCustomerDetails() {
        var aggregation = Aggregation.newAggregation(
            // Stage 1: Lookup (JOIN)
            Aggregation.lookup(
                "customers",        // Collection a fazer join
                "customerId",       // Campo local
                "_id",              // Campo remoto
                "customerDetails"   // Nome do campo resultado
            ),

            // Stage 2: Unwind resultado (array ‚Üí object)
            Aggregation.unwind("customerDetails"),

            // Stage 3: Project (selecionar campos)
            Aggregation.project()
                       .and("orderNumber").as("orderNumber")
                       .and("totalAmount").as("totalAmount")
                       .and("customerDetails.name").as("customerName")
                       .and("customerDetails.email").as("customerEmail")
        );

        return mongoTemplate.aggregate(aggregation, "orders", OrderWithCustomer.class)
                            .getMappedResults();
    }
}

record StatusSummary(
    @Field("_id") OrderStatus status,
    BigDecimal totalSales,
    Long orderCount
) {}

record ProductSales(
    @Field("_id") String productId,
    String productName,
    Long totalQuantity,
    BigDecimal totalRevenue
) {}

record OrderWithCustomer(
    String orderNumber,
    BigDecimal totalAmount,
    String customerName,
    String customerEmail
) {}
```

---

## 5. Indexes

### 5.1 Tipos de √çndices

```java
/**
 * Indexes melhoram performance de queries
 *
 * ‚ö†Ô∏è TRADE-OFF: Espa√ßo em disco + lentid√£o em writes
 */
@Document(collection = "products")
@CompoundIndex(name = "category_price_idx", def = "{'category': 1, 'price': -1}")
@CompoundIndex(name = "name_text_idx", def = "{'name': 'text', 'description': 'text'}")
public class Product {

    @Id
    private String id;

    /**
     * Single-field index
     */
    @Indexed
    private String sku;

    /**
     * Unique index
     */
    @Indexed(unique = true)
    private String barcode;

    /**
     * Sparse index (apenas docs com campo n√£o-null)
     */
    @Indexed(sparse = true)
    private String externalId;

    /**
     * TTL index (deleta docs ap√≥s N segundos)
     *
     * üí° USO: Cache, sess√µes, logs tempor√°rios
     */
    @Indexed(expireAfterSeconds = 86400)  // 24h
    private LocalDateTime createdAt;

    /**
     * Text index (full-text search)
     * Definido em @CompoundIndex acima
     */
    private String name;
    private String description;

    /**
     * Compound index (m√∫ltiplos campos)
     * Definido em @CompoundIndex acima
     */
    private String category;
    private BigDecimal price;
}
```

---

### 5.2 An√°lise de Performance

```java
/**
 * Analisar uso de √≠ndices
 */
@Service
public class IndexAnalysisService {

    @Autowired
    private MongoTemplate mongoTemplate;

    /**
     * Executar explain() para ver plano de query
     */
    public void analyzeQuery() {
        var query = Query.query(Criteria.where("category").is("Electronics")
                                        .and("price").gte(BigDecimal.valueOf(1000)));

        // Executar explain
        var explain = mongoTemplate.executeCommand("""
            {
                explain: {
                    find: "products",
                    filter: { category: "Electronics", price: { $gte: 1000 } }
                }
            }
            """);

        System.out.println(explain.toJson());

        // Verificar:
        // - "winningPlan" ‚Üí "stage": "IXSCAN" (usa √≠ndice) ou "COLLSCAN" (full scan)
        // - "executionStats" ‚Üí "totalDocsExamined" (menor = melhor)
    }

    /**
     * Listar √≠ndices da collection
     */
    public void listIndexes() {
        var collection = mongoTemplate.getCollection("products");

        for (var index : collection.listIndexes()) {
            System.out.println(index.toJson());
        }
    }
}
```

---

## 6. Transactions

### 6.1 Multi-Document Transactions

```java
/**
 * Transactions: ACID desde MongoDB 4.0
 *
 * ‚ö†Ô∏è REQUISITOS:
 * - Replica set ou sharded cluster (N√ÉO standalone)
 * - MongoDB 4.0+
 */
@Service
public class OrderTransactionService {

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private InventoryRepository inventoryRepository;

    /**
     * Transa√ß√£o com @Transactional (Spring)
     */
    @Transactional
    public void createOrderWithInventoryUpdate(Order order) {
        // Salvar order
        orderRepository.save(order);

        // Atualizar estoque
        for (var item : order.getItems()) {
            inventoryRepository.decrementStock(item.productId(), item.quantity());
        }

        // Se exce√ß√£o ocorrer: rollback autom√°tico
        if (order.getTotalAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
            // Rollback: order n√£o salvo, estoque n√£o atualizado
        }
    }

    /**
     * Transa√ß√£o program√°tica (mais controle)
     */
    public void createOrderProgrammaticTransaction(Order order) {
        var session = mongoTemplate.getMongoDatabase()
                                    .getMongo()
                                    .startSession();

        try {
            session.startTransaction();

            // Opera√ß√µes dentro da transa√ß√£o
            mongoTemplate.save(order);

            for (var item : order.getItems()) {
                var query = Query.query(Criteria.where("productId").is(item.productId()));
                var update = new Update().inc("stock", -item.quantity());
                mongoTemplate.updateFirst(query, update, "inventory");
            }

            // Commit
            session.commitTransaction();

        } catch (Exception e) {
            // Rollback
            session.abortTransaction();
            throw e;
        } finally {
            session.close();
        }
    }
}
```

---

## 7. Testing

### 7.1 TestContainers MongoDB

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>mongodb</artifactId>
    <version>1.19.3</version>
    <scope>test</scope>
</dependency>
```

```java
/**
 * Teste com TestContainers (MongoDB real em Docker)
 */
@SpringBootTest
@Testcontainers
class OrderRepositoryTest {

    /**
     * Container MongoDB
     */
    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer("mongo:7.0")
        .withExposedPorts(27017);

    /**
     * Configurar connection string dinamicamente
     */
    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongoDBContainer::getReplicaSetUrl);
    }

    @Autowired
    private OrderRepository orderRepository;

    @BeforeEach
    void setUp() {
        orderRepository.deleteAll();
    }

    @Test
    void shouldSaveAndFindOrder() {
        // Arrange
        var order = new Order();
        order.setOrderNumber("ORD-001");
        order.setStatus(OrderStatus.PENDING);
        order.setTotalAmount(BigDecimal.valueOf(150.00));

        // Act
        var saved = orderRepository.save(order);
        var found = orderRepository.findById(saved.getId());

        // Assert
        assertThat(found).isPresent();
        assertThat(found.get().getOrderNumber()).isEqualTo("ORD-001");
    }

    @Test
    void shouldFindOrdersByStatus() {
        // Arrange
        orderRepository.saveAll(List.of(
            createOrder("ORD-001", OrderStatus.PENDING),
            createOrder("ORD-002", OrderStatus.DELIVERED),
            createOrder("ORD-003", OrderStatus.PENDING)
        ));

        // Act
        var pending = orderRepository.findByStatus(OrderStatus.PENDING);

        // Assert
        assertThat(pending).hasSize(2);
    }

    private Order createOrder(String orderNumber, OrderStatus status) {
        var order = new Order();
        order.setOrderNumber(orderNumber);
        order.setStatus(status);
        order.setTotalAmount(BigDecimal.valueOf(100));
        return order;
    }
}
```

---

### 7.2 Embedded MongoDB (Flapdoodle)

```xml
<!-- Alternativa: Embedded MongoDB (n√£o requer Docker) -->
<dependency>
    <groupId>de.flapdoodle.embed</groupId>
    <artifactId>de.flapdoodle.embed.mongo.spring30x</artifactId>
    <version>4.12.2</version>
    <scope>test</scope>
</dependency>
```

```java
/**
 * Teste com Embedded MongoDB (mais r√°pido, mas menos fiel)
 */
@DataMongoTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class OrderRepositoryEmbeddedTest {

    @Autowired
    private OrderRepository orderRepository;

    @Test
    void shouldCountOrdersByStatus() {
        // Arrange
        orderRepository.saveAll(List.of(
            createOrder(OrderStatus.PENDING),
            createOrder(OrderStatus.PENDING),
            createOrder(OrderStatus.DELIVERED)
        ));

        // Act
        var count = orderRepository.countByStatus(OrderStatus.PENDING);

        // Assert
        assertThat(count).isEqualTo(2);
    }
}
```

---

## üìä Checklist de Qualidade

- [ ] Usar embedding para dados 1:poucos acessados juntos
- [ ] Usar referencing para dados 1:muitos ou independentes
- [ ] Criar √≠ndices em campos de query frequentes
- [ ] Evitar @DBRef (lazy load problem√°tico) - preferir IDs
- [ ] Usar aggregation pipeline para reports complexos
- [ ] Limitar tamanho de arrays (max 1000 elementos recomendado)
- [ ] Habilitar transactions apenas quando necess√°rio (overhead)
- [ ] Testar com TestContainers (ambiente real)
- [ ] Monitorar √≠ndices n√£o utilizados (espa√ßo desperdi√ßado)
- [ ] Usar TTL indexes para dados tempor√°rios

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Criar API CRUD com MongoDB
2. **Intermedi√°rio**: Implementar aggregation pipeline para dashboard
3. **Avan√ßado**: Modelar schema para rede social (posts, comments, likes)

---

## üìö Refer√™ncias

- [MongoDB Manual](https://www.mongodb.com/docs/manual/)
- [Spring Data MongoDB](https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/)
- [MongoDB University (Free Courses)](https://university.mongodb.com/)

---

**Anterior:** [12.3 - Spring Data Repositories](12.3-spring-data-repositories.md)  
**Pr√≥ximo:** [12.5 - Redis](12.5-redis.md)
