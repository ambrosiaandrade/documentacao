# üî• M√≥dulo 12.2: JPA & Hibernate Profundo

> **Objetivo:** Dominar ciclo de vida de entidades, @Transactional, otimiza√ß√µes de queries, caching e troubleshooting de problemas comuns (N+1, LazyInitializationException).

---

## üìë √çndice

1. [Entity Lifecycle](#1-entity-lifecycle)
2. [@Transactional Profundo](#2-transactional-profundo)
3. [Resolu√ß√£o do Problema N+1](#3-resolu√ß√£o-do-problema-n1)
4. [EntityGraph e Fetch Plans](#4-entitygraph-e-fetch-plans)
5. [Caching L1 e L2](#5-caching-l1-e-l2)
6. [Batch Operations](#6-batch-operations)
7. [Troubleshooting](#7-troubleshooting)
8. [M√©tricas e Monitoramento](#8-m√©tricas-e-monitoramento)

---

## 1. Entity Lifecycle

### 1.1 Estados de uma Entity

```java
import jakarta.persistence.*;

/**
 * Entity pode estar em 4 estados:
 *
 * 1. TRANSIENT (New): Objeto criado, n√£o gerenciado pelo EntityManager
 * 2. MANAGED (Persistent): Gerenciado pelo EntityManager, mudan√ßas sincronizadas
 * 3. DETACHED: Foi gerenciado, mas EntityManager fechou
 * 4. REMOVED: Marcado para dele√ß√£o
 */
@Service
public class EntityLifecycleDemo {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void demonstrateLifecycle() {
        // ESTADO 1: TRANSIENT
        var user = new User();
        user.setName("Jo√£o");
        // Objeto existe apenas na mem√≥ria, n√£o no banco

        // ESTADO 2: MANAGED (persist)
        em.persist(user);
        // Agora EntityManager rastreia mudan√ßas
        // Ainda N√ÉO executou INSERT (apenas no flush/commit)

        user.setName("Jo√£o Silva");  // Mudan√ßa detectada automaticamente
        // N√£o precisa de save() ou update() - Hibernate detecta dirty checking

        em.flush();  // For√ßa sincroniza√ß√£o com banco (executa INSERT)
        // SELECT * FROM users WHERE id = ?  (verifica se existe)
        // INSERT INTO users (name, ...) VALUES (?, ...)

        // ESTADO 3: DETACHED
        em.detach(user);
        // EntityManager n√£o rastreia mais
        user.setName("Jo√£o Pedro");  // Esta mudan√ßa N√ÉO ser√° persistida

        // Reatachar entity
        user = em.merge(user);  // Volta para MANAGED
        // Se existir no banco: UPDATE
        // Se n√£o existir: INSERT

        // ESTADO 4: REMOVED
        em.remove(user);
        // Marcado para dele√ß√£o (DELETE no flush/commit)

        em.flush();
        // DELETE FROM users WHERE id = ?
    }
}
```

---

### 1.2 Dirty Checking

```java
/**
 * Hibernate detecta automaticamente mudan√ßas em entities MANAGED.
 *
 * Mecanismo: Compara snapshot do estado inicial com estado atual no flush.
 */
@Service
public class DirtyCheckingExample {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void updateUser(Long userId) {
        var user = em.find(User.class, userId);
        // SELECT * FROM users WHERE id = ?
        // Hibernate cria snapshot do estado atual

        user.setName("Novo Nome");
        user.setEmail("novo@email.com");
        // Mudan√ßas detectadas no snapshot

        // N√£o precisa de save() ou update()!
        // No commit da transa√ß√£o, Hibernate executa:
        // UPDATE users SET name = ?, email = ? WHERE id = ?
    }

    @Transactional
    public void noChanges(Long userId) {
        var user = em.find(User.class, userId);

        // N√£o modifica nada

        // No commit: Hibernate compara snapshot, v√™ que nada mudou
        // Nenhum UPDATE executado (otimiza√ß√£o autom√°tica)
    }
}
```

---

### 1.3 Flush Modes

```java
/**
 * FlushMode controla quando Hibernate sincroniza com o banco.
 */
@Service
public class FlushModeExample {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void flushModes() {
        // Modo padr√£o: AUTO
        // Hibernate faz flush ANTES de queries e no commit

        var user = new User();
        user.setName("Maria");
        em.persist(user);

        // Query JPQL for√ßa flush autom√°tico
        var users = em.createQuery("SELECT u FROM User u", User.class)
                      .getResultList();
        // Antes de executar SELECT, Hibernate faz flush (INSERT do user)
        // Garante que query veja dados pendentes

        // Modo COMMIT: Flush apenas no commit
        em.setFlushMode(FlushModeType.COMMIT);

        var product = new Product();
        product.setName("Notebook");
        em.persist(product);

        var products = em.createQuery("SELECT p FROM Product p", Product.class)
                         .getResultList();
        // N√ÉO faz flush antes da query
        // product n√£o aparecer√° nos resultados (ainda n√£o no banco)
    }
}
```

---

## 2. @Transactional Profundo

### 2.1 Propagation Levels

```java
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

/**
 * Propagation define como transa√ß√µes interagem quando m√©todos s√£o aninhados.
 */
@Service
public class TransactionPropagationService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private AuditService auditService;

    /**
     * REQUIRED (padr√£o): Usa transa√ß√£o existente ou cria nova
     *
     * Cen√°rio: M√©todo A chama M√©todo B
     * - Se A tem transa√ß√£o: B usa a mesma
     * - Se A n√£o tem: B cria nova
     */
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(Order order) {
        orderRepository.save(order);
        auditService.log("Order created");  // Usa mesma transa√ß√£o

        // Se auditService.log() lan√ßar exce√ß√£o:
        // - Rollback de TUDO (order + audit)
    }

    /**
     * REQUIRES_NEW: Sempre cria nova transa√ß√£o (suspende existente)
     *
     * üí° USO: Audit logs que devem persistir mesmo se opera√ß√£o principal falhar
     */
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logAudit(String message) {
        // Cria transa√ß√£o INDEPENDENTE
        // Commit imediato ao fim do m√©todo (n√£o espera m√©todo pai)
    }

    @Transactional
    public void processOrderWithAudit(Order order) {
        orderRepository.save(order);

        try {
            // Chama m√©todo com REQUIRES_NEW
            logAudit("Processing order " + order.getId());
            // Log comitado IMEDIATAMENTE (transa√ß√£o separada)
        } catch (Exception e) {
            // Mesmo se processar falhar, log j√° foi persistido
        }

        // Se houver erro aqui, order sofre rollback, mas log permanece
        throw new RuntimeException("Order processing failed");
    }

    /**
     * MANDATORY: Requer transa√ß√£o existente (erro se n√£o houver)
     *
     * üí° USO: M√©todos que NUNCA devem rodar isoladamente
     */
    @Transactional(propagation = Propagation.MANDATORY)
    public void updateInventory(Long productId, int quantity) {
        // Se chamado sem transa√ß√£o: IllegalTransactionStateException
    }

    /**
     * SUPPORTS: Usa transa√ß√£o se existir, n√£o cria nova
     *
     * üí° USO: M√©todos de leitura que funcionam com ou sem transa√ß√£o
     */
    @Transactional(propagation = Propagation.SUPPORTS, readOnly = true)
    public Order findOrder(Long id) {
        return orderRepository.findById(id).orElse(null);
    }

    /**
     * NOT_SUPPORTED: Suspende transa√ß√£o existente
     *
     * üí° USO: Opera√ß√µes que n√£o devem ser transacionais (ex: envio de email)
     */
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void sendEmail(String recipient, String message) {
        // Executa fora de transa√ß√£o
        // Mesmo se transa√ß√£o pai sofrer rollback, email j√° foi enviado
    }

    /**
     * NEVER: Erro se houver transa√ß√£o ativa
     *
     * üí° USO: Garantir que m√©todo NUNCA rode em contexto transacional
     */
    @Transactional(propagation = Propagation.NEVER)
    public void generateReport() {
        // Se chamado dentro de transa√ß√£o: IllegalTransactionStateException
    }

    /**
     * NESTED: Cria savepoint dentro de transa√ß√£o existente
     *
     * ‚ö†Ô∏è ATEN√á√ÉO: Requer suporte do JDBC driver (PostgreSQL suporta)
     */
    @Transactional(propagation = Propagation.NESTED)
    public void nestedOperation() {
        // Cria SAVEPOINT
        // Se falhar: rollback apenas at√© o savepoint (n√£o toda transa√ß√£o)
    }
}
```

---

### 2.2 Isolation Levels

```java
import org.springframework.transaction.annotation.Isolation;

/**
 * Isolation define n√≠vel de isolamento entre transa√ß√µes concorrentes.
 *
 * Trade-off: Consist√™ncia vs Performance
 */
@Service
public class TransactionIsolationService {

    /**
     * READ_UNCOMMITTED: Menor isolamento (Dirty Reads poss√≠veis)
     *
     * ‚ö†Ô∏è PERIGO: L√™ dados n√£o comitados de outras transa√ß√µes
     * üí° USO: Reports aproximados onde precis√£o n√£o √© cr√≠tica
     */
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public long countApproximateOrders() {
        // Pode ler dados de transa√ß√µes ainda n√£o comitadas
        // Performance m√°xima, consist√™ncia m√≠nima
        return orderRepository.count();
    }

    /**
     * READ_COMMITTED (padr√£o PostgreSQL): L√™ apenas dados comitados
     *
     * ‚úÖ Previne: Dirty Reads
     * ‚ö†Ô∏è Permite: Non-Repeatable Reads, Phantom Reads
     */
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public Order processOrder(Long id) {
        var order = orderRepository.findById(id).orElseThrow();
        // SELECT * FROM orders WHERE id = ? FOR UPDATE

        // Outra transa√ß√£o pode modificar order AP√ìS este SELECT
        // Se ler novamente, valores podem ser diferentes (Non-Repeatable Read)

        order.setStatus("PROCESSING");
        return orderRepository.save(order);
    }

    /**
     * REPEATABLE_READ (padr√£o MySQL): Garante leituras consistentes
     *
     * ‚úÖ Previne: Dirty Reads, Non-Repeatable Reads
     * ‚ö†Ô∏è Permite: Phantom Reads (novos registros)
     *
     * PostgreSQL: Usa Snapshot Isolation (mais forte que REPEATABLE_READ)
     */
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void updateOrderItems(Long orderId) {
        var order = orderRepository.findById(orderId).orElseThrow();
        var items = order.getItems();

        // Mesmo se outra transa√ß√£o modificar items,
        // esta transa√ß√£o v√™ snapshot inicial

        // ‚ö†Ô∏è MAS: Outra transa√ß√£o pode INSERIR novo item (Phantom Read)
    }

    /**
     * SERIALIZABLE: M√°ximo isolamento (lock completo)
     *
     * ‚úÖ Previne: Dirty Reads, Non-Repeatable Reads, Phantom Reads
     * ‚ö†Ô∏è CUSTO: Performance degradada, risco de deadlocks
     *
     * üí° USO: Opera√ß√µes cr√≠ticas (transfer√™ncias banc√°rias)
     */
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void transferFunds(Long fromAccount, Long toAccount, BigDecimal amount) {
        var from = accountRepository.findById(fromAccount).orElseThrow();
        var to = accountRepository.findById(toAccount).orElseThrow();

        // Transa√ß√µes concorrentes s√£o BLOQUEADAS (executam em s√©rie)

        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));

        accountRepository.save(from);
        accountRepository.save(to);

        // Garantia de consist√™ncia total
        // Se duas transfer√™ncias rodarem simultaneamente: uma espera a outra
    }
}
```

---

### 2.3 Rollback Rules

```java
/**
 * Por padr√£o, @Transactional faz rollback apenas para RuntimeException.
 *
 * Checked Exceptions N√ÉO causam rollback (comportamento controverso).
 */
@Service
public class RollbackRulesService {

    /**
     * Comportamento padr√£o:
     * - RuntimeException ‚Üí Rollback
     * - Checked Exception ‚Üí Commit (!!)
     */
    @Transactional
    public void defaultBehavior() throws Exception {
        orderRepository.save(new Order());

        throw new RuntimeException("Rollback!");  // ‚úÖ Rollback
        // throw new Exception("Commit?!");       // ‚ùå Commit (inesperado!)
    }

    /**
     * rollbackFor: For√ßar rollback para exce√ß√µes espec√≠ficas
     */
    @Transactional(rollbackFor = Exception.class)
    public void rollbackForChecked() throws Exception {
        orderRepository.save(new Order());

        throw new Exception("Agora faz rollback!");  // ‚úÖ Rollback
    }

    /**
     * noRollbackFor: Prevenir rollback para exce√ß√µes espec√≠ficas
     *
     * üí° USO: Exceptions de neg√≥cio que n√£o devem reverter transa√ß√£o
     */
    @Transactional(noRollbackFor = BusinessException.class)
    public void noRollbackForBusiness() {
        auditRepository.save(new AuditLog());

        throw new BusinessException("Item indispon√≠vel");
        // Exce√ß√£o lan√ßada, mas auditLog foi persistido (sem rollback)
    }

    /**
     * Rollback program√°tico
     */
    @Transactional
    public void programmaticRollback() {
        orderRepository.save(new Order());

        if (someCondition) {
            TransactionAspectSupport.currentTransactionStatus()
                                    .setRollbackOnly();
            // Marca transa√ß√£o para rollback (mesmo sem exception)
        }

        // No commit: rollback √© executado
    }
}
```

---

## 3. Resolu√ß√£o do Problema N+1

### 3.1 Identifica√ß√£o do Problema

```java
/**
 * Problema N+1: 1 query inicial + N queries adicionais
 *
 * Causa: FetchType.LAZY + itera√ß√£o sobre collection sem otimiza√ß√£o
 */
@Service
public class N1ProblemDemo {

    @Autowired
    private AuthorRepository authorRepository;

    /**
     * ‚ùå PROBLEMA: N+1 queries
     */
    public void listAuthorsWithBooks() {
        var authors = authorRepository.findAll();
        // Query 1: SELECT * FROM authors

        for (var author : authors) {
            var bookCount = author.getBooks().size();
            // Query 2: SELECT * FROM books WHERE author_id = 1
            // Query 3: SELECT * FROM books WHERE author_id = 2
            // Query N: SELECT * FROM books WHERE author_id = N

            System.out.printf("%s has %d books%n", author.getName(), bookCount);
        }

        // Total: 1 + N queries (N = n√∫mero de autores)
    }
}
```

---

### 3.2 Solu√ß√£o 1: JOIN FETCH

```java
/**
 * JOIN FETCH: Carrega relacionamento em 1 √∫nica query
 */
public interface AuthorRepository extends JpaRepository<Author, Long> {

    /**
     * ‚úÖ SOLU√á√ÉO: JOIN FETCH
     *
     * Gera INNER JOIN e carrega books junto com authors
     */
    @Query("SELECT a FROM Author a JOIN FETCH a.books")
    List<Author> findAllWithBooks();

    /**
     * LEFT JOIN FETCH: Inclui autores sem livros
     */
    @Query("SELECT a FROM Author a LEFT JOIN FETCH a.books")
    List<Author> findAllWithBooksIncludingEmpty();

    /**
     * ‚ö†Ô∏è CUIDADO: N√£o use JOIN FETCH com pagina√ß√£o
     *
     * Hibernate faz fetch em mem√≥ria (n√£o no banco)
     */
    @Query("SELECT a FROM Author a JOIN FETCH a.books")
    Page<Author> findAllWithBooksPageable(Pageable pageable);
    // ‚ö†Ô∏è WARNING: HHH000104: firstResult/maxResults specified with collection fetch
}

@Service
public class OptimizedService {

    @Autowired
    private AuthorRepository authorRepository;

    public void listAuthorsOptimized() {
        var authors = authorRepository.findAllWithBooks();
        // Query 1: SELECT a.*, b.* FROM authors a INNER JOIN books b ON a.id = b.author_id

        for (var author : authors) {
            var bookCount = author.getBooks().size();
            // Sem queries adicionais! Books j√° carregados
        }

        // Total: 1 query apenas
    }
}
```

---

### 3.3 Solu√ß√£o 2: @EntityGraph

```java
/**
 * @EntityGraph: Alternativa declarativa ao JOIN FETCH
 *
 * Vantagens:
 * - N√£o precisa modificar entity
 * - Reutiliz√°vel em m√∫ltiplos m√©todos
 * - Suporta grafos complexos
 */
@Entity
@Table(name = "authors")
@NamedEntityGraph(
    name = "Author.books",
    attributeNodes = @NamedAttributeNode("books")
)
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)
    private List<Book> books = new ArrayList<>();
}

public interface AuthorRepository extends JpaRepository<Author, Long> {

    /**
     * ‚úÖ SOLU√á√ÉO: @EntityGraph
     *
     * type = FETCH: Carrega apenas attributeNodes especificados (EAGER)
     * type = LOAD: Carrega attributeNodes + campos EAGER da entity
     */
    @EntityGraph(value = "Author.books", type = EntityGraph.EntityGraphType.FETCH)
    List<Author> findAll();

    /**
     * EntityGraph inline (sem @NamedEntityGraph)
     */
    @EntityGraph(attributePaths = {"books"})
    List<Author> findAllWithBooks();

    /**
     * Grafo complexo (m√∫ltiplos n√≠veis)
     */
    @EntityGraph(attributePaths = {"books", "books.publisher", "books.reviews"})
    List<Author> findAllWithBooksAndRelations();
}
```

---

### 3.4 Solu√ß√£o 3: @BatchSize

```java
/**
 * @BatchSize: Carrega collections em batches (reduz queries de N para N/batch_size)
 *
 * √ötil quando JOIN FETCH n√£o √© vi√°vel (m√∫ltiplas collections)
 */
@Entity
@Table(name = "authors")
public class Author {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * @BatchSize: Carrega at√© 10 collections por vez
     *
     * Sem BatchSize:
     *   SELECT * FROM books WHERE author_id = 1
     *   SELECT * FROM books WHERE author_id = 2
     *   ... (N queries)
     *
     * Com BatchSize(10):
     *   SELECT * FROM books WHERE author_id IN (1,2,3,4,5,6,7,8,9,10)
     *   SELECT * FROM books WHERE author_id IN (11,12,13,...)
     *   ... (N/10 queries)
     */
    @OneToMany(mappedBy = "author")
    @BatchSize(size = 10)
    private List<Book> books = new ArrayList<>();
}
```

---

### 3.5 Solu√ß√£o 4: Projection (DTO)

```java
/**
 * Projection: Retornar apenas dados necess√°rios (sem entities)
 *
 * ‚úÖ VANTAGEM: Performance m√°xima (sem Hibernate overhead)
 * ‚ö†Ô∏è DESVANTAGEM: Read-only (n√£o pode modificar)
 */
public interface AuthorProjection {
    Long getId();
    String getName();
    Long getBookCount();  // Agrega√ß√£o
}

public interface AuthorRepository extends JpaRepository<Author, Long> {

    /**
     * ‚úÖ SOLU√á√ÉO: Projection com agrega√ß√£o
     *
     * Query √∫nica com COUNT
     */
    @Query("""
        SELECT a.id AS id,
               a.name AS name,
               COUNT(b.id) AS bookCount
        FROM Author a
        LEFT JOIN a.books b
        GROUP BY a.id, a.name
        """)
    List<AuthorProjection> findAllWithBookCount();
}

@Service
public class ProjectionService {

    public void listAuthorsWithCount() {
        var authors = authorRepository.findAllWithBookCount();
        // Query 1: SELECT a.id, a.name, COUNT(b.id) ... GROUP BY ...

        for (var author : authors) {
            System.out.printf("%s: %d books%n",
                author.getName(), author.getBookCount());
            // Sem queries adicionais, sem objetos pesados
        }
    }
}
```

---

## 4. EntityGraph e Fetch Plans

### 4.1 EntityGraph Din√¢mico

```java
/**
 * EntityGraph program√°tico: Flexibilidade total
 */
@Service
public class DynamicFetchService {

    @PersistenceContext
    private EntityManager em;

    public List<Author> findAuthorsWithCustomGraph(boolean includeBooks,
                                                     boolean includeReviews) {
        // Criar EntityGraph dinamicamente
        var graph = em.createEntityGraph(Author.class);

        if (includeBooks) {
            graph.addAttributeNodes("books");

            if (includeReviews) {
                // Subgraph: Grafo aninhado
                var bookSubgraph = graph.addSubgraph("books", Book.class);
                bookSubgraph.addAttributeNodes("reviews");
            }
        }

        // Aplicar graph √† query
        return em.createQuery("SELECT a FROM Author a", Author.class)
                 .setHint("jakarta.persistence.fetchgraph", graph)
                 .getResultList();
    }
}
```

---

## 5. Caching L1 e L2

### 5.1 Cache de Primeiro N√≠vel (Session Cache)

```java
/**
 * Cache L1: Autom√°tico, escopo de EntityManager/Session
 *
 * Garante que m√∫ltiplas buscas pelo mesmo ID retornem MESMA inst√¢ncia
 */
@Service
public class L1CacheDemo {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void cacheLevel1() {
        // Query 1: SELECT
        var user1 = em.find(User.class, 1L);

        // Query 2: N√ÉO executa (retorna do cache L1)
        var user2 = em.find(User.class, 1L);

        System.out.println(user1 == user2);  // true (MESMA inst√¢ncia)

        // Modificar user1 modifica user2 (refer√™ncia compartilhada)
        user1.setName("Jo√£o");
        System.out.println(user2.getName());  // "Jo√£o"

        // Limpar cache L1
        em.clear();

        // Agora executa SELECT novamente
        var user3 = em.find(User.class, 1L);
        System.out.println(user1 == user3);  // false
    }
}
```

---

### 5.2 Cache de Segundo N√≠vel (Compartilhado)

```java
/**
 * Cache L2: Compartilhado entre sess√µes
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO (application.yml):
 * spring.jpa.properties.hibernate.cache.use_second_level_cache: true
 * spring.jpa.properties.hibernate.cache.region.factory_class: jcache
 * spring.jpa.properties.hibernate.javax.cache.provider: org.ehcache.jsr107.EhcacheCachingProvider
 */
@Entity
@Table(name = "products")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Product {
    // Entity cache√°vel
}

@Service
public class L2CacheDemo {

    @PersistenceContext
    private EntityManager em;

    @Transactional
    public void sessionA() {
        var product = em.find(Product.class, 1L);
        // SELECT executado, colocado no cache L2
    }

    @Transactional
    public void sessionB() {
        var product = em.find(Product.class, 1L);
        // N√ÉO executa SELECT (l√™ do cache L2)
        // Cache sobrevive ao fechamento da sess√£o A
    }

    /**
     * Evict: Remover do cache manualmente
     */
    public void evictCache() {
        var cache = em.getEntityManagerFactory().getCache();

        // Evict entity espec√≠fica
        cache.evict(Product.class, 1L);

        // Evict toda classe
        cache.evict(Product.class);

        // Evict todo cache L2
        cache.evictAll();
    }
}
```

---

### 5.3 Query Cache

```java
/**
 * Query Cache: Cacheia resultados de queries JPQL
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO:
 * spring.jpa.properties.hibernate.cache.use_query_cache: true
 */
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    /**
     * @QueryHints: Habilitar cache para query espec√≠fica
     */
    @QueryHints(@QueryHint(name = "org.hibernate.cacheable", value = "true"))
    @Query("SELECT p FROM Product p WHERE p.category = :category")
    List<Product> findByCategory(String category);
}

@Service
public class QueryCacheDemo {

    public void testQueryCache() {
        // Primeira execu√ß√£o: SELECT + adiciona ao cache
        var products1 = productRepository.findByCategory("Electronics");

        // Segunda execu√ß√£o: L√™ do cache (sem SELECT)
        var products2 = productRepository.findByCategory("Electronics");

        // ‚ö†Ô∏è ATEN√á√ÉO: Cache invalidado automaticamente se tabela mudar
    }
}
```

---

## 6. Batch Operations

### 6.1 Batch Insert

```java
/**
 * Batch Insert: Agrupa m√∫ltiplos INSERTs em um batch
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO:
 * spring.jpa.properties.hibernate.jdbc.batch_size: 50
 * spring.jpa.properties.hibernate.order_inserts: true
 * spring.jpa.properties.hibernate.order_updates: true
 */
@Service
public class BatchInsertService {

    @PersistenceContext
    private EntityManager em;

    /**
     * ‚úÖ CORRETO: Flush e clear periodicamente
     */
    @Transactional
    public void batchInsert(List<Product> products) {
        int batchSize = 50;

        for (int i = 0; i < products.size(); i++) {
            em.persist(products.get(i));

            if (i > 0 && i % batchSize == 0) {
                // Flush: Executa INSERTs pendentes
                em.flush();

                // Clear: Limpa cache L1 (libera mem√≥ria)
                em.clear();
            }
        }

        // Flush final para registros restantes
        em.flush();
        em.clear();
    }

    /**
     * ‚ùå PROBLEMA: Sem flush/clear intermedi√°rio
     *
     * - Consome muita mem√≥ria (entities no cache L1)
     * - OutOfMemoryError para listas grandes
     */
    @Transactional
    public void batchInsertWrong(List<Product> products) {
        products.forEach(em::persist);
        // Flush apenas no commit (todos em mem√≥ria)
    }
}
```

---

### 6.2 Bulk Operations

```java
/**
 * Bulk Update/Delete: Opera diretamente no banco (sem carregar entities)
 *
 * ‚úÖ VANTAGEM: Performance m√°xima
 * ‚ö†Ô∏è CUIDADO: N√£o passa por Hibernate (bypassa cache, callbacks)
 */
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    /**
     * Bulk Update: Atualiza m√∫ltiplos registros em 1 query
     *
     * @Modifying: Indica query DML (UPDATE/DELETE)
     * clearAutomatically = true: Limpa cache L1 ap√≥s execu√ß√£o
     */
    @Modifying(clearAutomatically = true)
    @Query("UPDATE Product p SET p.price = p.price * 1.1 WHERE p.category = :category")
    int increasePricesByCategory(String category);

    /**
     * Bulk Delete
     */
    @Modifying(clearAutomatically = true)
    @Query("DELETE FROM Product p WHERE p.stock = 0")
    int deleteOutOfStock();
}

@Service
public class BulkOperationService {

    @Autowired
    private ProductRepository productRepository;

    @Transactional
    public void applyDiscount() {
        // Executa: UPDATE products SET price = price * 1.1 WHERE category = 'Electronics'
        int updated = productRepository.increasePricesByCategory("Electronics");

        System.out.println(updated + " products updated");

        // ‚ö†Ô∏è IMPORTANTE: Entities no cache L1 N√ÉO foram atualizadas
        // clearAutomatically = true resolve isso
    }
}
```

---

## 7. Troubleshooting

### 7.1 LazyInitializationException

```java
/**
 * Erro mais comum: Acessar relacionamento LAZY fora de transa√ß√£o
 */
@Service
public class LazyInitializationProblem {

    @Autowired
    private UserRepository userRepository;

    /**
     * ‚ùå PROBLEMA: Sem @Transactional
     */
    public void listUsersWithOrders() {
        var users = userRepository.findAll();
        // EntityManager fechado aqui

        for (var user : users) {
            var orderCount = user.getOrders().size();
            // LazyInitializationException: No Session!
        }
    }

    /**
     * ‚úÖ SOLU√á√ÉO 1: @Transactional
     */
    @Transactional(readOnly = true)
    public void listUsersWithOrdersFixed() {
        var users = userRepository.findAll();
        // EntityManager ABERTO durante todo m√©todo

        for (var user : users) {
            var orderCount = user.getOrders().size();
            // OK: Lazy load dentro de transa√ß√£o
        }
    }

    /**
     * ‚úÖ SOLU√á√ÉO 2: JOIN FETCH
     */
    public void listUsersWithOrdersJoinFetch() {
        var users = userRepository.findAllWithOrders();
        // Orders j√° carregados (n√£o lazy)

        for (var user : users) {
            var orderCount = user.getOrders().size();
            // OK: Sem lazy load
        }
    }
}
```

---

### 7.2 MultipleBagFetchException

```java
/**
 * Erro: M√∫ltiplos JOIN FETCH em collections (Bag)
 *
 * Hibernate n√£o consegue distinguir ownership de linhas duplicadas
 */
@Entity
public class Author {

    @OneToMany(mappedBy = "author")
    private List<Book> books = new ArrayList<>();

    @OneToMany(mappedBy = "author")
    private List<Article> articles = new ArrayList<>();
}

public interface AuthorRepository extends JpaRepository<Author, Long> {

    /**
     * ‚ùå ERRO: MultipleBagFetchException
     */
    @Query("SELECT a FROM Author a JOIN FETCH a.books JOIN FETCH a.articles")
    List<Author> findAllWithBooksAndArticles();

    /**
     * ‚úÖ SOLU√á√ÉO 1: Trocar List por Set
     */
    // Em Author: Set<Book> books, Set<Article> articles

    /**
     * ‚úÖ SOLU√á√ÉO 2: M√∫ltiplas queries
     */
    @Query("SELECT a FROM Author a JOIN FETCH a.books")
    List<Author> findAllWithBooks();

    @Query("SELECT a FROM Author a JOIN FETCH a.articles WHERE a IN :authors")
    List<Author> loadArticles(@Param("authors") List<Author> authors);

    /**
     * ‚úÖ SOLU√á√ÉO 3: @EntityGraph
     */
    @EntityGraph(attributePaths = {"books", "articles"})
    List<Author> findAll();
}
```

---

## 8. M√©tricas e Monitoramento

### 8.1 Hibernate Statistics

```java
/**
 * Hibernate Statistics: M√©tricas detalhadas
 *
 * ‚öôÔ∏è CONFIGURA√á√ÉO:
 * spring.jpa.properties.hibernate.generate_statistics: true
 */
@Service
public class HibernateStatisticsService {

    @PersistenceContext
    private EntityManager em;

    public void printStatistics() {
        var sessionFactory = em.getEntityManagerFactory()
                               .unwrap(SessionFactory.class);
        var stats = sessionFactory.getStatistics();

        System.out.println("=== Hibernate Statistics ===");
        System.out.println("Queries: " + stats.getQueryExecutionCount());
        System.out.println("Cache L2 Hits: " + stats.getSecondLevelCacheHitCount());
        System.out.println("Cache L2 Misses: " + stats.getSecondLevelCacheMissCount());
        System.out.println("Query Cache Hits: " + stats.getQueryCacheHitCount());
        System.out.println("Entities Loaded: " + stats.getEntityLoadCount());
        System.out.println("Collections Loaded: " + stats.getCollectionLoadCount());
        System.out.println("Flushes: " + stats.getFlushCount());

        // Queries mais lentas
        var queries = stats.getQueries();
        for (var query : queries) {
            var region = stats.getQueryStatistics(query);
            System.out.printf("Query: %s | Executions: %d | Avg Time: %.2fms%n",
                query, region.getExecutionCount(), region.getExecutionAvgTime());
        }
    }
}
```

---

### 8.2 SQL Logging

```yaml
# application.yml
spring:
  jpa:
    show-sql: true # Mostra SQL no console
    properties:
      hibernate:
        format_sql: true # Formata SQL
        use_sql_comments: true # Adiciona coment√°rios com origem da query

logging:
  level:
    org.hibernate.SQL: DEBUG # SQL statements
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE # Par√¢metros bind
    org.hibernate.stat: DEBUG # Estat√≠sticas
```

---

## üìä Checklist de Performance

- [ ] Sempre usar `FetchType.LAZY` em relacionamentos
- [ ] Resolver N+1 com JOIN FETCH, @EntityGraph ou @BatchSize
- [ ] Habilitar batch insert/update (`jdbc.batch_size`)
- [ ] Usar Projections (DTOs) para leitura simples
- [ ] Habilitar cache L2 para entities read-heavy
- [ ] Usar `@Transactional(readOnly = true)` em queries read-only
- [ ] Evitar m√∫ltiplos JOIN FETCH (usar Set ou m√∫ltiplas queries)
- [ ] Flush e clear periodicamente em batch operations
- [ ] Monitorar queries com Hibernate Statistics
- [ ] Usar bulk operations para updates/deletes em massa

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Identificar e corrigir N+1 em projeto existente
2. **Intermedi√°rio**: Implementar cache L2 com Ehcache
3. **Avan√ßado**: Otimizar batch insert de 100k registros (<10s)

---

## üìö Refer√™ncias

- [Hibernate Performance Tuning](https://docs.jboss.org/hibernate/orm/6.4/userguide/html_single/Hibernate_User_Guide.html#performance)
- [Vlad Mihalcea - High-Performance Java Persistence](https://vladmihalcea.com/)
- [Baeldung - JPA/Hibernate Guides](https://www.baeldung.com/hibernate-5)

---

**Anterior:** [12.2 - Anota√ß√µes JPA Completas](12.2-anotacoes-jpa-completas.md)  
**Pr√≥ximo:** [12.3 - Spring Data Repositories](12.3-spring-data-repositories.md)
