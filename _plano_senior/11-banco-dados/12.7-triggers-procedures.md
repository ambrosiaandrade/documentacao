# âš™ï¸ MÃ³dulo 12.7: Triggers & Stored Procedures

> **Objetivo:** Dominar lÃ³gica no banco (triggers, procedures), entender trade-offs e alternativas modernas (Domain Events).

---

## ğŸ“‘ Ãndice

1. [Quando Usar (e Quando NÃƒO)](#1-quando-usar-e-quando-nÃ£o)
2. [Triggers PostgreSQL](#2-triggers-postgresql)
3. [Stored Procedures](#3-stored-procedures)
4. [Testing](#4-testing)
5. [Domain Events (Alternativa)](#5-domain-events-alternativa)
6. [Trade-offs](#6-trade-offs)

---

## 1. Quando Usar (e Quando NÃƒO)

### 1.1 Matriz de DecisÃ£o

| CenÃ¡rio                              | Trigger/Procedure | App Layer | Justificativa                   |
| ------------------------------------ | ----------------- | --------- | ------------------------------- |
| **Auditoria (createdAt, updatedAt)** | âœ… Trigger        | âš ï¸ App    | Garantia de consistÃªncia        |
| **ValidaÃ§Ã£o de negÃ³cio**             | âŒ                | âœ… App    | Testabilidade, flexibilidade    |
| **CÃ¡lculos simples (subtotal)**      | âš ï¸ Trigger        | âœ… App    | App: mais fÃ¡cil debugar         |
| **ReplicaÃ§Ã£o/sync assÃ­ncrono**       | âœ… Trigger        | âš ï¸        | Trigger: atÃ´mico com transaÃ§Ã£o  |
| **Regras complexas**                 | âŒ                | âœ… App    | App: melhor expressividade      |
| **DenormalizaÃ§Ã£o (cache)**           | âœ… Trigger        | âš ï¸        | Trigger: consistÃªncia garantida |
| **IntegraÃ§Ãµes externas**             | âŒ                | âœ… App    | App: retry, observabilidade     |

---

### 1.2 PrincÃ­pios Guia

```sql
/**
 * âœ… USE Triggers/Procedures quando:
 *
 * 1. LÃ³gica DEVE ser consistente independente da aplicaÃ§Ã£o
 *    (ex: auditoria, integridade referencial complexa)
 *
 * 2. Performance crÃ­tica (evitar roundtrips app â†” DB)
 *    (ex: batch updates, aggregations)
 *
 * 3. MÃºltiplas aplicaÃ§Ãµes acessam mesmo banco
 *    (ex: microservices legacy compartilhando BD)
 *
 * âš ï¸ NÃƒO use quando:
 *
 * 1. LÃ³gica de negÃ³cio complexa (dificulta testes unitÃ¡rios)
 * 2. Requer integraÃ§Ã£o externa (APIs, mensageria)
 * 3. Time nÃ£o tem expertise em PL/pgSQL
 * 4. Dificulta versionamento/rollback (migrations complexas)
 */
```

---

## 2. Triggers PostgreSQL

### 2.1 Trigger BÃ¡sico (Auditoria)

```sql
/**
 * TRIGGER: Auditoria automÃ¡tica de timestamps
 *
 * Executado ANTES de INSERT/UPDATE, define updated_at
 */

-- FunÃ§Ã£o trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar trigger em tabela
CREATE TRIGGER update_users_updated_at
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
```

---

### 2.2 Trigger para ValidaÃ§Ã£o

```sql
/**
 * TRIGGER: Validar regra de negÃ³cio
 *
 * Impede criaÃ§Ã£o de pedido se estoque insuficiente
 */

CREATE OR REPLACE FUNCTION validate_order_stock()
RETURNS TRIGGER AS $$
DECLARE
    available_stock INT;
BEGIN
    -- Buscar estoque disponÃ­vel
    SELECT stock INTO available_stock
    FROM products
    WHERE id = NEW.product_id;

    -- Validar quantidade
    IF available_stock < NEW.quantity THEN
        RAISE EXCEPTION 'Insufficient stock for product %. Available: %, Requested: %',
            NEW.product_id, available_stock, NEW.quantity;
    END IF;

    -- Decrementar estoque
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE id = NEW.product_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_order_stock
BEFORE INSERT ON order_items
FOR EACH ROW
EXECUTE FUNCTION validate_order_stock();
```

---

### 2.3 Trigger para DenormalizaÃ§Ã£o

```sql
/**
 * TRIGGER: Manter campo denormalizado sincronizado
 *
 * Atualiza total do pedido quando item Ã© adicionado/removido
 */

CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    -- Recalcular total do pedido
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(quantity * unit_price), 0)
        FROM order_items
        WHERE order_id = COALESCE(NEW.order_id, OLD.order_id)
    )
    WHERE id = COALESCE(NEW.order_id, OLD.order_id);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Trigger em mÃºltiplos eventos
CREATE TRIGGER update_order_total_on_item_change
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
EXECUTE FUNCTION update_order_total();
```

---

### 2.4 Trigger Condicional

```sql
/**
 * TRIGGER: Executar apenas se condiÃ§Ã£o atendida
 */

CREATE OR REPLACE FUNCTION log_price_increase()
RETURNS TRIGGER AS $$
BEGIN
    -- Apenas registrar se preÃ§o AUMENTOU >10%
    IF NEW.price > OLD.price * 1.1 THEN
        INSERT INTO price_change_log (product_id, old_price, new_price, changed_at)
        VALUES (NEW.id, OLD.price, NEW.price, NOW());
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER log_significant_price_changes
AFTER UPDATE OF price ON products
FOR EACH ROW
WHEN (NEW.price > OLD.price * 1.1)  -- CondiÃ§Ã£o WHEN
EXECUTE FUNCTION log_price_increase();
```

---

### 2.5 Tipos de Triggers

```sql
/**
 * BEFORE vs AFTER:
 *
 * BEFORE:
 * - Pode modificar NEW (valores a serem inseridos/atualizados)
 * - Pode cancelar operaÃ§Ã£o (RETURN NULL)
 * - Uso: ValidaÃ§Ãµes, transformaÃ§Ãµes
 *
 * AFTER:
 * - NÃƒO pode modificar NEW (operaÃ§Ã£o jÃ¡ executada)
 * - Uso: Auditoria, propagaÃ§Ã£o, logs
 *
 * ROW vs STATEMENT:
 *
 * FOR EACH ROW:
 * - Executa para cada linha afetada
 * - Acesso a OLD e NEW
 *
 * FOR EACH STATEMENT:
 * - Executa 1x por comando SQL
 * - SEM acesso a OLD/NEW
 */

-- Exemplo STATEMENT trigger
CREATE OR REPLACE FUNCTION log_bulk_delete()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, executed_at)
    VALUES (TG_TABLE_NAME, TG_OP, NOW());

    RETURN NULL;  -- Valor ignorado em AFTER STATEMENT
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER log_product_deletes
AFTER DELETE ON products
FOR EACH STATEMENT
EXECUTE FUNCTION log_bulk_delete();
```

---

## 3. Stored Procedures

### 3.1 Function (Retorna Valor)

```sql
/**
 * FUNCTION: CÃ¡lculo de desconto progressivo
 *
 * Retorna valor (pode ser usado em SELECT)
 */

CREATE OR REPLACE FUNCTION calculate_discount(
    total_amount DECIMAL,
    customer_tier VARCHAR
)
RETURNS DECIMAL AS $$
DECLARE
    discount_rate DECIMAL;
BEGIN
    -- LÃ³gica de desconto por tier
    CASE customer_tier
        WHEN 'GOLD' THEN discount_rate := 0.15;
        WHEN 'SILVER' THEN discount_rate := 0.10;
        WHEN 'BRONZE' THEN discount_rate := 0.05;
        ELSE discount_rate := 0.0;
    END CASE;

    -- Desconto adicional para compras grandes
    IF total_amount > 1000 THEN
        discount_rate := discount_rate + 0.05;
    END IF;

    RETURN total_amount * discount_rate;
END;
$$ LANGUAGE plpgsql IMMUTABLE;  -- IMMUTABLE: mesma entrada = mesma saÃ­da

-- Uso em query
SELECT
    id,
    total_amount,
    calculate_discount(total_amount, customer_tier) AS discount,
    total_amount - calculate_discount(total_amount, customer_tier) AS final_amount
FROM orders;
```

---

### 3.2 Procedure (AÃ§Ã£o sem Retorno)

```sql
/**
 * PROCEDURE: Processamento batch
 *
 * NÃ£o retorna valor (apenas executa aÃ§Ãµes)
 */

CREATE OR REPLACE PROCEDURE cancel_expired_orders()
LANGUAGE plpgsql AS $$
DECLARE
    cancelled_count INT := 0;
BEGIN
    -- Cancelar pedidos pendentes hÃ¡ mais de 7 dias
    UPDATE orders
    SET status = 'CANCELLED',
        cancelled_at = NOW(),
        cancellation_reason = 'Expired (no payment)'
    WHERE status = 'PENDING'
      AND created_at < NOW() - INTERVAL '7 days';

    GET DIAGNOSTICS cancelled_count = ROW_COUNT;

    -- Log
    INSERT INTO batch_job_log (job_name, affected_rows, executed_at)
    VALUES ('cancel_expired_orders', cancelled_count, NOW());

    RAISE NOTICE 'Cancelled % orders', cancelled_count;
END;
$$;

-- Executar procedure
CALL cancel_expired_orders();
```

---

### 3.3 Function com Table Return

```sql
/**
 * FUNCTION: Retornar mÃºltiplas linhas (table)
 *
 * Uso: Complex queries reusÃ¡veis
 */

CREATE OR REPLACE FUNCTION get_customer_stats(customer_id_param BIGINT)
RETURNS TABLE (
    total_orders INT,
    total_spent DECIMAL,
    avg_order_value DECIMAL,
    last_order_date TIMESTAMP
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::INT AS total_orders,
        COALESCE(SUM(total_amount), 0) AS total_spent,
        COALESCE(AVG(total_amount), 0) AS avg_order_value,
        MAX(created_at) AS last_order_date
    FROM orders
    WHERE user_id = customer_id_param;
END;
$$ LANGUAGE plpgsql STABLE;  -- STABLE: nÃ£o modifica banco, mas resultado pode variar

-- Uso
SELECT * FROM get_customer_stats(123);
```

---

### 3.4 Transaction Control

```sql
/**
 * PROCEDURE: Controle explÃ­cito de transaÃ§Ã£o
 */

CREATE OR REPLACE PROCEDURE transfer_funds(
    from_account_id BIGINT,
    to_account_id BIGINT,
    amount DECIMAL
)
LANGUAGE plpgsql AS $$
DECLARE
    from_balance DECIMAL;
BEGIN
    -- Verificar saldo
    SELECT balance INTO from_balance
    FROM accounts
    WHERE id = from_account_id
    FOR UPDATE;  -- Lock pessimista

    IF from_balance < amount THEN
        RAISE EXCEPTION 'Insufficient funds. Balance: %, Required: %', from_balance, amount;
    END IF;

    -- Debitar
    UPDATE accounts
    SET balance = balance - amount
    WHERE id = from_account_id;

    -- Creditar
    UPDATE accounts
    SET balance = balance + amount
    WHERE id = to_account_id;

    -- Log
    INSERT INTO transaction_log (from_account, to_account, amount, executed_at)
    VALUES (from_account_id, to_account_id, amount, NOW());

    COMMIT;  -- Commit explÃ­cito

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;  -- Rollback em caso de erro
        RAISE NOTICE 'Transfer failed: %', SQLERRM;
        RAISE;
END;
$$;
```

---

## 4. Testing

### 4.1 Test Triggers com JUnit

```java
/**
 * Teste de trigger no banco
 */
@SpringBootTest
@Testcontainers
class TriggerTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @DynamicPropertySource
    static void datasourceProps(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @BeforeEach
    void setUp() {
        // Criar trigger
        jdbcTemplate.execute("""
            CREATE OR REPLACE FUNCTION update_updated_at_column()
            RETURNS TRIGGER AS $$
            BEGIN
                NEW.updated_at = NOW();
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            CREATE TRIGGER update_users_updated_at
            BEFORE UPDATE ON users
            FOR EACH ROW
            EXECUTE FUNCTION update_updated_at_column();
            """);
    }

    @Test
    void triggerUpdatesTimestamp() throws Exception {
        // Insert
        jdbcTemplate.update("INSERT INTO users (email, name) VALUES (?, ?)",
            "test@email.com", "Test User");

        // Aguardar 1s
        Thread.sleep(1000);

        // Update
        jdbcTemplate.update("UPDATE users SET name = ? WHERE email = ?",
            "Updated Name", "test@email.com");

        // Verificar updated_at foi alterado
        var timestamps = jdbcTemplate.queryForMap(
            "SELECT created_at, updated_at FROM users WHERE email = ?",
            "test@email.com"
        );

        var createdAt = (Timestamp) timestamps.get("created_at");
        var updatedAt = (Timestamp) timestamps.get("updated_at");

        assertThat(updatedAt).isAfter(createdAt);
    }

    @Test
    void triggerValidatesStock() {
        // Insert produto com estoque 5
        jdbcTemplate.update("INSERT INTO products (name, stock) VALUES (?, ?)",
            "Product A", 5);

        var productId = jdbcTemplate.queryForObject(
            "SELECT id FROM products WHERE name = ?",
            Long.class, "Product A"
        );

        // Tentar criar order_item com quantidade maior que estoque
        assertThatThrownBy(() ->
            jdbcTemplate.update(
                "INSERT INTO order_items (product_id, quantity) VALUES (?, ?)",
                productId, 10
            )
        ).hasMessageContaining("Insufficient stock");
    }
}
```

---

### 4.2 Test Stored Procedures

```java
@SpringBootTest
class StoredProcedureTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void procedureCancelsExpiredOrders() {
        // Insert ordem expirada
        jdbcTemplate.update("""
            INSERT INTO orders (status, created_at)
            VALUES ('PENDING', NOW() - INTERVAL '10 days')
            """);

        // Executar procedure
        jdbcTemplate.execute("CALL cancel_expired_orders()");

        // Verificar status atualizado
        var status = jdbcTemplate.queryForObject(
            "SELECT status FROM orders LIMIT 1",
            String.class
        );

        assertThat(status).isEqualTo("CANCELLED");
    }

    @Test
    void functionCalculatesDiscount() {
        var discount = jdbcTemplate.queryForObject(
            "SELECT calculate_discount(1500.00, 'GOLD')",
            BigDecimal.class
        );

        // 15% (GOLD) + 5% (>1000) = 20%
        assertThat(discount).isEqualByComparingTo("300.00");
    }
}
```

---

## 5. Domain Events (Alternativa)

### 5.1 Spring Domain Events

```java
/**
 * ALTERNATIVA: LÃ³gica no app com Domain Events
 *
 * âœ… VANTAGENS vs Triggers:
 * - TestÃ¡vel (unit tests)
 * - Type-safe
 * - IntegraÃ§Ãµes externas (APIs, mensageria)
 * - Observabilidade (logs, traces)
 */

/**
 * Domain Event
 */
public record OrderCreatedEvent(Long orderId, BigDecimal totalAmount) {}

/**
 * Entity que publica evento
 */
@Entity
@Table(name = "orders")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private BigDecimal totalAmount;
    private OrderStatus status;

    /**
     * Domain Events (Spring Data)
     */
    @DomainEvents
    public Collection<Object> domainEvents() {
        return List.of(new OrderCreatedEvent(id, totalAmount));
    }

    @AfterDomainEventPublication
    public void clearDomainEvents() {
        // Limpar eventos apÃ³s publicaÃ§Ã£o
    }
}

/**
 * Event Listener (substitui trigger)
 */
@Component
public class OrderEventListener {

    @Autowired
    private InventoryService inventoryService;

    @Autowired
    private NotificationService notificationService;

    /**
     * AÃ§Ã£o executada apÃ³s salvar Order
     *
     * Equivalente a AFTER INSERT trigger
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handleOrderCreated(OrderCreatedEvent event) {
        // Atualizar estoque
        inventoryService.decrementStock(event.orderId());

        // Enviar notificaÃ§Ã£o
        notificationService.sendOrderConfirmation(event.orderId());

        // IntegraÃ§Ã£o externa (impossÃ­vel com trigger)
        externalApi.notifyPartner(event.orderId());
    }
}
```

---

### 5.2 ComparaÃ§Ã£o: Trigger vs Domain Events

| Aspecto           | Trigger               | Domain Events            |
| ----------------- | --------------------- | ------------------------ |
| **Testabilidade** | DifÃ­cil (requer BD)   | FÃ¡cil (unit tests)       |
| **Performance**   | Melhor (no DB)        | Boa (app overhead)       |
| **IntegraÃ§Ãµes**   | ImpossÃ­vel            | FÃ¡cil (HTTP, messaging)  |
| **Debugging**     | DifÃ­cil (logs DB)     | FÃ¡cil (logs app, traces) |
| **ConsistÃªncia**  | Garantida (transaÃ§Ã£o) | Depende (eventual)       |
| **Flexibilidade** | Baixa (SQL)           | Alta (Java OOP)          |
| **Versionamento** | Migrations            | Code changes             |

---

## 6. Trade-offs

### 6.1 Matriz de Complexidade

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Alta Complexidade                          â”‚
â”‚  â†‘                                          â”‚
â”‚  â”‚   âŒ Evitar Triggers                     â”‚
â”‚  â”‚   (LÃ³gica de NegÃ³cio)                   â”‚
â”‚  â”‚                                          â”‚
â”‚  â”‚                    âœ… Domain Events     â”‚
â”‚  â”‚                    (Flexibilidade)       â”‚
â”‚  â”‚                                          â”‚
â”‚  â”‚   âœ… Triggers                            â”‚
â”‚  â”‚   (Auditoria, Cache)                    â”‚
â”‚  â†“                                          â”‚
â”‚  Baixa Complexidade                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   Baixa â†â”€â”€ MudanÃ§a Frequente â”€â”€â†’ Alta
```

---

### 6.2 RecomendaÃ§Ãµes Finais

```sql
/**
 * âœ… USE Triggers para:
 *
 * 1. Auditoria tÃ©cnica (updated_at, created_by)
 * 2. DenormalizaÃ§Ã£o de performance (cache fields)
 * 3. Integridade referencial complexa
 * 4. ReplicaÃ§Ã£o/sincronizaÃ§Ã£o interna
 *
 * âœ… USE Domain Events para:
 *
 * 1. LÃ³gica de negÃ³cio (validaÃ§Ãµes, cÃ¡lculos)
 * 2. IntegraÃ§Ãµes externas (APIs, mensageria)
 * 3. Workflows complexos
 * 4. Anything que requer testes unitÃ¡rios
 *
 * âš ï¸ EVITE Triggers para:
 *
 * 1. LÃ³gica que muda frequentemente
 * 2. OperaÃ§Ãµes lentas (HTTP calls, sleep)
 * 3. Anything que dificulta debugging
 * 4. CÃ³digo que time nÃ£o domina PL/pgSQL
 */
```

---

## ğŸ“Š Checklist de Qualidade

- [ ] Documentar TODOS triggers (quando, por quÃª)
- [ ] Testar triggers com banco real (TestContainers)
- [ ] Usar BEFORE para validaÃ§Ãµes (pode cancelar)
- [ ] Usar AFTER para propagaÃ§Ã£o (nÃ£o modifica dados)
- [ ] Evitar triggers que chamam outros triggers (cascata)
- [ ] Logar execuÃ§Ã£o de procedures (audit trail)
- [ ] Preferir Domain Events para lÃ³gica de negÃ³cio
- [ ] Monitorar performance de triggers (pg_stat_user_functions)
- [ ] Versionar triggers em migrations (Flyway/Liquibase)
- [ ] Considerar deadlocks (triggers concorrentes)

---

## ğŸ¯ ExercÃ­cios PrÃ¡ticos

1. **BÃ¡sico**: Criar trigger para auditoria automÃ¡tica
2. **IntermediÃ¡rio**: Stored procedure para batch processing
3. **AvanÃ§ado**: Comparar trigger vs Domain Events (performance, manutenibilidade)

---

## ğŸ“š ReferÃªncias

- [PostgreSQL Triggers](https://www.postgresql.org/docs/current/triggers.html)
- [PL/pgSQL](https://www.postgresql.org/docs/current/plpgsql.html)
- [Spring Domain Events](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#core.domain-events)

---

**Anterior:** [12.6 - Migrations](12.6-migrations.md)  
**PrÃ³ximo:** [12.8 - Connection Pooling](12.8-connection-pooling.md)
