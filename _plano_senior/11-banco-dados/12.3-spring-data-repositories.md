# üîç M√≥dulo 12.3: Spring Data Repositories

> **Objetivo:** Dominar repository patterns, query methods, Specifications, pagina√ß√£o e projections para construir APIs eficientes e type-safe.

---

## üìë √çndice

1. [Repository Hierarchy](#1-repository-hierarchy)
2. [Query Methods](#2-query-methods)
3. [JPQL e Native Queries](#3-jpql-e-native-queries)
4. [Specifications (Criteria API)](#4-specifications-criteria-api)
5. [Pagina√ß√£o e Sorting](#5-pagina√ß√£o-e-sorting)
6. [Projections](#6-projections)
7. [Custom Repository](#7-custom-repository)
8. [Auditing](#8-auditing)

---

## 1. Repository Hierarchy

### 1.1 Hierarquia de Interfaces

```java
/**
 * Spring Data fornece hierarquia de repositories:
 *
 * Repository<T, ID>
 *   ‚îî‚îÄ CrudRepository<T, ID>
 *        ‚îî‚îÄ PagingAndSortingRepository<T, ID>
 *             ‚îî‚îÄ JpaRepository<T, ID>
 */

// Repository base (marker interface)
public interface Repository<T, ID> {
    // Vazio - apenas marca a interface como repository
}

// CRUD b√°sico
public interface CrudRepository<T, ID> extends Repository<T, ID> {
    <S extends T> S save(S entity);
    <S extends T> Iterable<S> saveAll(Iterable<S> entities);
    Optional<T> findById(ID id);
    boolean existsById(ID id);
    Iterable<T> findAll();
    Iterable<T> findAllById(Iterable<ID> ids);
    long count();
    void deleteById(ID id);
    void delete(T entity);
    void deleteAllById(Iterable<? extends ID> ids);
    void deleteAll(Iterable<? extends T> entities);
    void deleteAll();
}

// Adiciona pagina√ß√£o e sorting
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {
    Iterable<T> findAll(Sort sort);
    Page<T> findAll(Pageable pageable);
}

// JPA-specific (mais utilizado)
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID> {
    void flush();
    <S extends T> S saveAndFlush(S entity);
    <S extends T> List<S> saveAllAndFlush(Iterable<S> entities);
    void deleteAllInBatch(Iterable<T> entities);
    void deleteAllByIdInBatch(Iterable<ID> ids);
    void deleteAllInBatch();
    T getOne(ID id);  // @Deprecated - use getReferenceById
    T getReferenceById(ID id);
    List<T> findAll();
    List<T> findAll(Sort sort);
    List<T> findAllById(Iterable<ID> ids);
    <S extends T> List<S> saveAll(Iterable<S> entities);
}
```

---

### 1.2 Exemplo Pr√°tico

```java
/**
 * Repository padr√£o: Estende JpaRepository
 */
public interface UserRepository extends JpaRepository<User, Long> {
    // Herda automaticamente:
    // - save, findById, findAll, delete, etc.
    // - Pagina√ß√£o e sorting
    // - Batch operations
}

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void demonstrateBasicMethods() {
        // Salvar
        var user = new User("Jo√£o", "joao@email.com");
        userRepository.save(user);

        // Buscar por ID
        var found = userRepository.findById(1L);

        // Verificar exist√™ncia
        boolean exists = userRepository.existsById(1L);

        // Contar registros
        long count = userRepository.count();

        // Listar todos
        var users = userRepository.findAll();

        // Deletar
        userRepository.deleteById(1L);

        // Batch save (otimizado)
        var batch = List.of(
            new User("Ana", "ana@email.com"),
            new User("Pedro", "pedro@email.com")
        );
        userRepository.saveAll(batch);

        // Flush (for√ßar sincroniza√ß√£o)
        userRepository.flush();

        // Save and flush
        userRepository.saveAndFlush(user);
    }
}
```

---

## 2. Query Methods

### 2.1 Conven√ß√µes de Nomea√ß√£o

```java
/**
 * Spring Data deriva queries do nome do m√©todo.
 *
 * Padr√£o: findBy + Propriedade + Operador + And/Or + ...
 */
public interface ProductRepository extends JpaRepository<Product, Long> {

    // Igualdade
    List<Product> findByName(String name);
    // SELECT p FROM Product p WHERE p.name = ?1

    // LIKE (case-sensitive)
    List<Product> findByNameLike(String pattern);
    // WHERE p.name LIKE ?1

    // LIKE com % autom√°tico
    List<Product> findByNameContaining(String keyword);
    // WHERE p.name LIKE %?1%

    List<Product> findByNameStartingWith(String prefix);
    // WHERE p.name LIKE ?1%

    List<Product> findByNameEndingWith(String suffix);
    // WHERE p.name LIKE %?1

    // Case-insensitive
    List<Product> findByNameIgnoreCase(String name);
    // WHERE LOWER(p.name) = LOWER(?1)

    // Compara√ß√µes num√©ricas
    List<Product> findByPriceGreaterThan(BigDecimal price);
    // WHERE p.price > ?1

    List<Product> findByPriceLessThanEqual(BigDecimal price);
    // WHERE p.price <= ?1

    List<Product> findByPriceBetween(BigDecimal min, BigDecimal max);
    // WHERE p.price BETWEEN ?1 AND ?2

    // Data/hora
    List<Product> findByCreatedAtBefore(LocalDateTime date);
    // WHERE p.createdAt < ?1

    List<Product> findByCreatedAtAfter(LocalDateTime date);
    // WHERE p.createdAt > ?1

    // NULL check
    List<Product> findByDescriptionIsNull();
    // WHERE p.description IS NULL

    List<Product> findByDescriptionIsNotNull();
    // WHERE p.description IS NOT NULL

    // Boolean
    List<Product> findByActiveTrue();
    // WHERE p.active = TRUE

    List<Product> findByActiveFalse();
    // WHERE p.active = FALSE

    // IN
    List<Product> findByCategoryIn(List<String> categories);
    // WHERE p.category IN (?1, ?2, ...)

    List<Product> findByCategoryNotIn(List<String> categories);
    // WHERE p.category NOT IN (...)

    // AND/OR
    List<Product> findByNameAndCategory(String name, String category);
    // WHERE p.name = ?1 AND p.category = ?2

    List<Product> findByNameOrDescription(String name, String description);
    // WHERE p.name = ?1 OR p.description = ?2

    // Relacionamentos
    List<Product> findByManufacturerName(String manufacturerName);
    // WHERE p.manufacturer.name = ?1 (JOIN autom√°tico)

    // Distinct
    List<String> findDistinctCategoryBy();
    // SELECT DISTINCT p.category FROM Product p

    // Top/First (limitar resultados)
    Product findFirstByOrderByPriceDesc();
    // ORDER BY p.price DESC LIMIT 1

    List<Product> findTop10ByCategory(String category);
    // WHERE p.category = ?1 LIMIT 10

    // Exists
    boolean existsByName(String name);
    // SELECT COUNT(p) > 0 FROM Product p WHERE p.name = ?1

    // Count
    long countByCategory(String category);
    // SELECT COUNT(p) FROM Product p WHERE p.category = ?1

    // Delete
    long deleteByCategory(String category);
    // DELETE FROM Product p WHERE p.category = ?1

    List<Product> removeByCategory(String category);
    // SELECT + DELETE (retorna entities deletadas)
}
```

---

### 2.2 Tabela de Keywords

| Keyword                | Exemplo                       | JPQL Gerado                      |
| ---------------------- | ----------------------------- | -------------------------------- |
| `And`                  | `findByNameAndPrice`          | `WHERE name = ?1 AND price = ?2` |
| `Or`                   | `findByNameOrPrice`           | `WHERE name = ?1 OR price = ?2`  |
| `Is`, `Equals`         | `findByName`                  | `WHERE name = ?1`                |
| `Between`              | `findByPriceBetween`          | `WHERE price BETWEEN ?1 AND ?2`  |
| `LessThan`             | `findByPriceLessThan`         | `WHERE price < ?1`               |
| `LessThanEqual`        | `findByPriceLessThanEqual`    | `WHERE price <= ?1`              |
| `GreaterThan`          | `findByPriceGreaterThan`      | `WHERE price > ?1`               |
| `GreaterThanEqual`     | `findByPriceGreaterThanEqual` | `WHERE price >= ?1`              |
| `After`                | `findByCreatedAtAfter`        | `WHERE createdAt > ?1`           |
| `Before`               | `findByCreatedAtBefore`       | `WHERE createdAt < ?1`           |
| `IsNull`               | `findByDescriptionIsNull`     | `WHERE description IS NULL`      |
| `IsNotNull`, `NotNull` | `findByDescriptionIsNotNull`  | `WHERE description IS NOT NULL`  |
| `Like`                 | `findByNameLike`              | `WHERE name LIKE ?1`             |
| `NotLike`              | `findByNameNotLike`           | `WHERE name NOT LIKE ?1`         |
| `StartingWith`         | `findByNameStartingWith`      | `WHERE name LIKE ?1%`            |
| `EndingWith`           | `findByNameEndingWith`        | `WHERE name LIKE %?1`            |
| `Containing`           | `findByNameContaining`        | `WHERE name LIKE %?1%`           |
| `OrderBy`              | `findByNameOrderByPriceDesc`  | `ORDER BY price DESC`            |
| `Not`                  | `findByNameNot`               | `WHERE name <> ?1`               |
| `In`                   | `findByCategoryIn`            | `WHERE category IN (?1)`         |
| `NotIn`                | `findByCategoryNotIn`         | `WHERE category NOT IN (?1)`     |
| `True`                 | `findByActiveTrue`            | `WHERE active = TRUE`            |
| `False`                | `findByActiveFalse`           | `WHERE active = FALSE`           |
| `IgnoreCase`           | `findByNameIgnoreCase`        | `WHERE LOWER(name) = LOWER(?1)`  |

---

## 3. JPQL e Native Queries

### 3.1 @Query com JPQL

```java
/**
 * @Query: Queries customizadas quando query methods n√£o s√£o suficientes
 */
public interface OrderRepository extends JpaRepository<Order, Long> {

    /**
     * JPQL b√°sico (entity-based, n√£o SQL)
     */
    @Query("SELECT o FROM Order o WHERE o.status = :status")
    List<Order> findByStatus(@Param("status") String status);

    /**
     * JOIN com relacionamento
     */
    @Query("SELECT o FROM Order o JOIN o.customer c WHERE c.email = :email")
    List<Order> findByCustomerEmail(@Param("email") String email);

    /**
     * JOIN FETCH (resolver N+1)
     */
    @Query("SELECT o FROM Order o JOIN FETCH o.items WHERE o.id = :id")
    Optional<Order> findByIdWithItems(@Param("id") Long id);

    /**
     * Agrega√ß√£o
     */
    @Query("SELECT COUNT(o) FROM Order o WHERE o.status = :status")
    long countByStatus(@Param("status") String status);

    @Query("SELECT SUM(o.totalAmount) FROM Order o WHERE o.status = 'COMPLETED'")
    BigDecimal calculateTotalRevenue();

    /**
     * GROUP BY
     */
    @Query("""
        SELECT o.status, COUNT(o)
        FROM Order o
        GROUP BY o.status
        """)
    List<Object[]> countByStatusGrouped();

    /**
     * HAVING
     */
    @Query("""
        SELECT c.id, COUNT(o)
        FROM Order o
        JOIN o.customer c
        GROUP BY c.id
        HAVING COUNT(o) > :minOrders
        """)
    List<Object[]> findCustomersWithMinOrders(@Param("minOrders") long min);

    /**
     * UPDATE query
     */
    @Modifying
    @Query("UPDATE Order o SET o.status = :newStatus WHERE o.status = :oldStatus")
    int updateStatus(@Param("oldStatus") String oldStatus,
                     @Param("newStatus") String newStatus);

    /**
     * DELETE query
     */
    @Modifying
    @Query("DELETE FROM Order o WHERE o.createdAt < :date")
    int deleteOldOrders(@Param("date") LocalDateTime date);
}
```

---

### 3.2 Native SQL

```java
/**
 * Native queries: SQL puro (espec√≠fico do banco)
 *
 * üí° USO: Quando JPQL n√£o suporta (window functions, CTEs, etc.)
 */
public interface OrderRepository extends JpaRepository<Order, Long> {

    /**
     * Native query simples
     */
    @Query(value = "SELECT * FROM orders WHERE status = :status", nativeQuery = true)
    List<Order> findByStatusNative(@Param("status") String status);

    /**
     * Window function (n√£o suportado em JPQL)
     */
    @Query(value = """
        SELECT o.*,
               ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY created_at DESC) as row_num
        FROM orders o
        WHERE customer_id = :customerId
        """, nativeQuery = true)
    List<Order> findOrdersWithRowNumber(@Param("customerId") Long customerId);

    /**
     * CTE recursiva (PostgreSQL)
     */
    @Query(value = """
        WITH RECURSIVE category_tree AS (
            SELECT id, name, parent_id, 0 as level
            FROM categories
            WHERE parent_id IS NULL
            UNION ALL
            SELECT c.id, c.name, c.parent_id, ct.level + 1
            FROM categories c
            JOIN category_tree ct ON c.parent_id = ct.id
        )
        SELECT * FROM category_tree
        """, nativeQuery = true)
    List<Object[]> findCategoryHierarchy();

    /**
     * Native query com Projection
     */
    @Query(value = """
        SELECT c.id, c.name, COUNT(o.id) as orderCount
        FROM customers c
        LEFT JOIN orders o ON c.id = o.customer_id
        GROUP BY c.id, c.name
        """, nativeQuery = true)
    List<CustomerOrderCount> findCustomerOrderCounts();

    /**
     * Native UPDATE
     */
    @Modifying
    @Query(value = "UPDATE orders SET status = 'CANCELLED' WHERE created_at < NOW() - INTERVAL '30 days'",
           nativeQuery = true)
    int cancelOldOrders();
}

/**
 * Projection interface para native query
 */
interface CustomerOrderCount {
    Long getId();
    String getName();
    Long getOrderCount();
}
```

---

## 4. Specifications (Criteria API)

### 4.1 Introdu√ß√£o a Specifications

```java
/**
 * Specifications: Queries type-safe e composable
 *
 * ‚úÖ VANTAGENS:
 * - Type-safe (compile-time checking)
 * - Composable (AND, OR, NOT)
 * - Reutiliz√°vel
 * - Ideal para filtros din√¢micos
 */
public interface ProductRepository extends JpaRepository<Product, Long>,
                                           JpaSpecificationExecutor<Product> {
    // JpaSpecificationExecutor adiciona m√©todos findAll(Specification)
}

/**
 * Specifications como m√©todos est√°ticos
 */
public class ProductSpecifications {

    /**
     * Specification simples: nome cont√©m keyword
     */
    public static Specification<Product> nameContains(String keyword) {
        return (root, query, cb) -> {
            if (keyword == null || keyword.isEmpty()) {
                return cb.conjunction();  // WHERE 1=1 (true)
            }
            return cb.like(cb.lower(root.get("name")),
                          "%" + keyword.toLowerCase() + "%");
        };
    }

    /**
     * Specification: pre√ßo entre min e max
     */
    public static Specification<Product> priceBetween(BigDecimal min, BigDecimal max) {
        return (root, query, cb) -> {
            if (min == null && max == null) {
                return cb.conjunction();
            }
            if (min == null) {
                return cb.lessThanOrEqualTo(root.get("price"), max);
            }
            if (max == null) {
                return cb.greaterThanOrEqualTo(root.get("price"), min);
            }
            return cb.between(root.get("price"), min, max);
        };
    }

    /**
     * Specification: categoria IN
     */
    public static Specification<Product> categoryIn(List<String> categories) {
        return (root, query, cb) -> {
            if (categories == null || categories.isEmpty()) {
                return cb.conjunction();
            }
            return root.get("category").in(categories);
        };
    }

    /**
     * Specification: ativo
     */
    public static Specification<Product> isActive() {
        return (root, query, cb) -> cb.isTrue(root.get("active"));
    }

    /**
     * Specification com JOIN
     */
    public static Specification<Product> manufacturerNameEquals(String name) {
        return (root, query, cb) -> {
            if (name == null) {
                return cb.conjunction();
            }
            // JOIN autom√°tico
            return cb.equal(root.get("manufacturer").get("name"), name);
        };
    }
}
```

---

### 4.2 Composi√ß√£o de Specifications

```java
@Service
public class ProductSearchService {

    @Autowired
    private ProductRepository productRepository;

    /**
     * Busca com filtros din√¢micos (composi√ß√£o)
     */
    public List<Product> search(ProductSearchCriteria criteria) {
        // Composi√ß√£o: AND de m√∫ltiplas specs
        var spec = Specification.where(ProductSpecifications.nameContains(criteria.getKeyword()))
                                .and(ProductSpecifications.priceBetween(criteria.getMinPrice(),
                                                                        criteria.getMaxPrice()))
                                .and(ProductSpecifications.categoryIn(criteria.getCategories()))
                                .and(ProductSpecifications.isActive());

        return productRepository.findAll(spec);
    }

    /**
     * Busca com OR
     */
    public List<Product> searchNameOrDescription(String keyword) {
        var nameSpec = ProductSpecifications.nameContains(keyword);
        var descSpec = ProductSpecifications.descriptionContains(keyword);

        var spec = Specification.where(nameSpec).or(descSpec);

        return productRepository.findAll(spec);
    }

    /**
     * Nega√ß√£o (NOT)
     */
    public List<Product> findInactiveProducts() {
        var spec = Specification.not(ProductSpecifications.isActive());
        return productRepository.findAll(spec);
    }

    /**
     * Composi√ß√£o complexa: (A OR B) AND C
     */
    public List<Product> complexSearch(String keyword, BigDecimal maxPrice) {
        var nameOrDesc = Specification.where(ProductSpecifications.nameContains(keyword))
                                      .or(ProductSpecifications.descriptionContains(keyword));

        var priceFilter = ProductSpecifications.priceBetween(null, maxPrice);

        var finalSpec = nameOrDesc.and(priceFilter);

        return productRepository.findAll(finalSpec);
    }
}

/**
 * DTO para crit√©rios de busca
 */
record ProductSearchCriteria(
    String keyword,
    BigDecimal minPrice,
    BigDecimal maxPrice,
    List<String> categories
) {}
```

---

## 5. Pagina√ß√£o e Sorting

### 5.1 Pagina√ß√£o B√°sica

```java
@RestController
@RequestMapping("/products")
public class ProductController {

    @Autowired
    private ProductRepository productRepository;

    /**
     * Endpoint com pagina√ß√£o
     *
     * GET /products?page=0&size=20&sort=name,asc
     */
    @GetMapping
    public Page<Product> listProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "id,asc") String[] sort) {

        // Criar Pageable
        var pageable = PageRequest.of(page, size, Sort.by(parseSort(sort)));

        return productRepository.findAll(pageable);
    }

    /**
     * Parse sort: "name,asc" ‚Üí Sort.Order
     */
    private Sort.Order[] parseSort(String[] sort) {
        return Arrays.stream(sort)
                     .map(s -> {
                         var parts = s.split(",");
                         var property = parts[0];
                         var direction = parts.length > 1 && "desc".equalsIgnoreCase(parts[1])
                                       ? Sort.Direction.DESC
                                       : Sort.Direction.ASC;
                         return new Sort.Order(direction, property);
                     })
                     .toArray(Sort.Order[]::new);
    }
}
```

---

### 5.2 Pagina√ß√£o com Specifications

```java
@RestController
@RequestMapping("/products")
public class ProductController {

    @Autowired
    private ProductRepository productRepository;

    /**
     * Busca paginada com filtros
     *
     * GET /products?keyword=notebook&minPrice=1000&page=0&size=10
     */
    @GetMapping("/search")
    public Page<Product> search(
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "name,asc") String[] sort) {

        // Specifications
        var spec = Specification.where(ProductSpecifications.nameContains(keyword))
                                .and(ProductSpecifications.priceBetween(minPrice, maxPrice));

        // Pageable
        var pageable = PageRequest.of(page, size, Sort.by(parseSort(sort)));

        // Busca paginada com filtros
        return productRepository.findAll(spec, pageable);
    }
}
```

---

### 5.3 Sorting Avan√ßado

```java
/**
 * Sorting complexo
 */
@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public List<Product> findProductsSorted() {
        // Sort simples
        var sort = Sort.by("name").ascending();
        return productRepository.findAll(sort);

        // M√∫ltiplos campos
        var multiSort = Sort.by("category").ascending()
                            .and(Sort.by("price").descending());
        return productRepository.findAll(multiSort);

        // Null handling
        var nullSort = Sort.by(Sort.Order.asc("name").nullsLast());
        return productRepository.findAll(nullSort);

        // Case-insensitive
        var caseSort = Sort.by(Sort.Order.asc("name").ignoreCase());
        return productRepository.findAll(nullSort);
    }
}
```

---

### 5.4 Slice (Alternativa a Page)

```java
/**
 * Slice: Pagina√ß√£o sem count total
 *
 * ‚úÖ VANTAGEM: Performance (n√£o executa COUNT)
 * ‚ö†Ô∏è DESVANTAGEM: N√£o sabe total de p√°ginas
 *
 * üí° USO: Infinite scroll, "Load More"
 */
public interface ProductRepository extends JpaRepository<Product, Long> {

    Slice<Product> findByCategory(String category, Pageable pageable);
}

@Service
public class ProductService {

    public Slice<Product> loadMore(String category, int page) {
        var pageable = PageRequest.of(page, 20);
        var slice = productRepository.findByCategory(category, pageable);

        // M√©todos dispon√≠veis
        var content = slice.getContent();         // List<Product>
        var hasNext = slice.hasNext();            // boolean
        var isFirst = slice.isFirst();            // boolean
        var isLast = slice.isLast();              // boolean
        var number = slice.getNumber();           // P√°gina atual
        var size = slice.getSize();               // Tamanho p√°gina

        // N√ÉO dispon√≠vel: getTotalPages(), getTotalElements()

        return slice;
    }
}
```

---

## 6. Projections

### 6.1 Interface-Based Projections

```java
/**
 * Projection: Retornar apenas campos necess√°rios (n√£o entity completa)
 *
 * ‚úÖ VANTAGENS:
 * - Performance (menos dados trafegados)
 * - Type-safe
 * - Read-only (imut√°vel)
 */

/**
 * Closed Projection: Todos m√©todos mapeiam para propriedades
 */
public interface ProductSummary {
    Long getId();
    String getName();
    BigDecimal getPrice();
}

public interface ProductRepository extends JpaRepository<Product, Long> {

    /**
     * Query method com Projection
     */
    List<ProductSummary> findByCategory(String category);
    // SELECT p.id, p.name, p.price FROM Product p WHERE p.category = ?1

    /**
     * @Query com Projection
     */
    @Query("SELECT p.id AS id, p.name AS name, p.price AS price FROM Product p")
    List<ProductSummary> findAllSummaries();
}
```

---

### 6.2 Open Projections (SpEL)

```java
/**
 * Open Projection: Computa√ß√£o customizada com SpEL
 */
public interface ProductDetails {

    @Value("#{target.name}")
    String getName();

    @Value("#{target.price}")
    BigDecimal getPrice();

    /**
     * Computa√ß√£o: Pre√ßo com desconto
     */
    @Value("#{target.price * 0.9}")
    BigDecimal getDiscountedPrice();

    /**
     * Concatena√ß√£o
     */
    @Value("#{target.name + ' - ' + target.category}")
    String getFullDescription();

    /**
     * Relacionamento
     */
    @Value("#{target.manufacturer.name}")
    String getManufacturerName();
}
```

---

### 6.3 Class-Based Projections (DTO)

```java
/**
 * DTO: Classe concreta para projection
 *
 * ‚úÖ VANTAGENS:
 * - Type-safe
 * - Imut√°vel (records Java 17+)
 * - Suporta l√≥gica customizada
 */
public record ProductDTO(
    Long id,
    String name,
    BigDecimal price,
    String category
) {
    /**
     * M√©todo customizado
     */
    public String getFormattedPrice() {
        return "R$ " + price.setScale(2, RoundingMode.HALF_UP);
    }
}

public interface ProductRepository extends JpaRepository<Product, Long> {

    /**
     * @Query com constructor expression
     */
    @Query("SELECT new com.example.ProductDTO(p.id, p.name, p.price, p.category) FROM Product p")
    List<ProductDTO> findAllDTOs();

    /**
     * Query method com DTO (requer constructor)
     */
    @Query("SELECT new com.example.ProductDTO(p.id, p.name, p.price, p.category) " +
           "FROM Product p WHERE p.category = :category")
    List<ProductDTO> findByCategoryDTO(@Param("category") String category);
}
```

---

### 6.4 Dynamic Projections

```java
/**
 * Dynamic Projection: Escolher tipo em runtime
 */
public interface ProductRepository extends JpaRepository<Product, Long> {

    /**
     * M√©todo gen√©rico: Aceita qualquer tipo de projection
     */
    <T> List<T> findByCategory(String category, Class<T> type);
}

@Service
public class ProductService {

    @Autowired
    private ProductRepository productRepository;

    public void demonstrateDynamicProjections() {
        // Entity completa
        var products = productRepository.findByCategory("Electronics", Product.class);

        // Projection (summary)
        var summaries = productRepository.findByCategory("Electronics", ProductSummary.class);

        // DTO
        var dtos = productRepository.findByCategory("Electronics", ProductDTO.class);
    }
}
```

---

## 7. Custom Repository

### 7.1 Implementa√ß√£o Customizada

```java
/**
 * Custom Repository: L√≥gica n√£o suportada por query methods/Specifications
 */

/**
 * Interface customizada
 */
public interface ProductRepositoryCustom {
    List<Product> findProductsWithComplexLogic(String criteria);
    void batchUpdatePrices(Map<Long, BigDecimal> updates);
}

/**
 * Implementa√ß√£o (sufixo "Impl" obrigat√≥rio)
 */
@Repository
public class ProductRepositoryImpl implements ProductRepositoryCustom {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List<Product> findProductsWithComplexLogic(String criteria) {
        var cb = em.getCriteriaBuilder();
        var query = cb.createQuery(Product.class);
        var root = query.from(Product.class);

        // L√≥gica complexa com Criteria API
        var predicates = new ArrayList<Predicate>();

        if (criteria.contains("premium")) {
            predicates.add(cb.greaterThan(root.get("price"), BigDecimal.valueOf(1000)));
        }

        if (criteria.contains("popular")) {
            predicates.add(cb.greaterThan(root.get("salesCount"), 100L));
        }

        query.where(cb.and(predicates.toArray(new Predicate[0])));

        return em.createQuery(query).getResultList();
    }

    @Override
    @Transactional
    public void batchUpdatePrices(Map<Long, BigDecimal> updates) {
        int batchSize = 50;
        int count = 0;

        for (var entry : updates.entrySet()) {
            var product = em.find(Product.class, entry.getKey());
            if (product != null) {
                product.setPrice(entry.getValue());

                if (++count % batchSize == 0) {
                    em.flush();
                    em.clear();
                }
            }
        }

        em.flush();
        em.clear();
    }
}

/**
 * Repository principal: Estende ambos
 */
public interface ProductRepository extends JpaRepository<Product, Long>,
                                           ProductRepositoryCustom {
    // M√©todos padr√£o + customizados
}
```

---

## 8. Auditing

### 8.1 Configura√ß√£o de Auditing

```java
/**
 * Habilitar auditing
 */
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class JpaConfig {

    /**
     * AuditorAware: Prov√™ usu√°rio atual
     */
    @Bean
    public AuditorAware<String> auditorProvider() {
        return () -> {
            // Em produ√ß√£o: obter de SecurityContext
            // return Optional.of(SecurityContextHolder.getContext()
            //                                         .getAuthentication()
            //                                         .getName());

            // Exemplo simplificado
            return Optional.of("system");
        };
    }
}
```

---

### 8.2 Entity com Auditing

```java
/**
 * Base entity com auditing
 */
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class AuditableEntity {

    @CreatedDate
    @Column(nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(nullable = false)
    private Instant updatedAt;

    @CreatedBy
    @Column(nullable = false, updatable = false)
    private String createdBy;

    @LastModifiedBy
    @Column(nullable = false)
    private String lastModifiedBy;

    // Getters
}

/**
 * Entity que herda auditing
 */
@Entity
@Table(name = "products")
public class Product extends AuditableEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    // Campos de auditoria herdados automaticamente
}
```

---

## üìä Checklist de Qualidade

- [ ] Usar `JpaRepository` ao inv√©s de `CrudRepository`
- [ ] Evitar query methods muito longos (preferir Specifications)
- [ ] Usar Projections para leitura simples (performance)
- [ ] Implementar pagina√ß√£o em endpoints que listam dados
- [ ] Usar `@Transactional(readOnly = true)` em queries de leitura
- [ ] Preferir Specifications para filtros din√¢micos
- [ ] Usar `Slice` ao inv√©s de `Page` para infinite scroll
- [ ] Implementar auditing em entities cr√≠ticas
- [ ] Custom repositories apenas quando necess√°rio
- [ ] Testar queries complexas com `@DataJpaTest`

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Criar API REST com pagina√ß√£o e sorting
2. **Intermedi√°rio**: Implementar busca avan√ßada com Specifications
3. **Avan√ßado**: Custom repository com batch update otimizado

---

## üìö Refer√™ncias

- [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
- [Baeldung - Spring Data JPA](https://www.baeldung.com/spring-data-jpa-query)
- [Vlad Mihalcea - JPA Queries](https://vladmihalcea.com/)

---

**Anterior:** [12.2 - JPA & Hibernate Profundo](12.2-jpa-hibernate-profundo.md)  
**Pr√≥ximo:** [12.4 - MongoDB](12.4-mongodb.md)
