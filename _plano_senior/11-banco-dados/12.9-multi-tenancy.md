# üè¢ M√≥dulo 12.9: Multi-Tenancy

> **Objetivo:** Implementar estrat√©gias multi-tenant com isolamento, seguran√ßa e performance.

---

## üìë √çndice

1. [Fundamentos](#1-fundamentos)
2. [Database Per Tenant](#2-database-per-tenant)
3. [Schema Per Tenant](#3-schema-per-tenant)
4. [Shared Database](#4-shared-database)
5. [Testing](#5-testing)

---

## 1. Fundamentos

### 1.1 O Que √â Multi-Tenancy?

```java
/**
 * Multi-Tenancy: Arquitetura onde uma √∫nica inst√¢ncia do app
 * serve m√∫ltiplos clientes (tenants) com isolamento de dados.
 *
 * Exemplos:
 * - SaaS: Cada empresa tem seus dados isolados
 * - White-label: Mesma plataforma, branding diferente
 * - Marketplace: Cada vendedor tem seus produtos
 *
 * Desafios:
 * - Isolamento de dados (seguran√ßa)
 * - Performance (queries n√£o podem cruzar tenants)
 * - Escalabilidade (tenants diferentes crescem diferente)
 * - Migrations (schema changes afetam todos)
 */

/**
 * Tenant Context: Identificar qual tenant √© o atual
 */
public record TenantContext(String tenantId) {

    // Tenant identificado por:
    // - Subdomain: customer1.app.com, customer2.app.com
    // - Header: X-Tenant-ID: customer1
    // - JWT claim: { "tenant": "customer1" }
    // - Path param: /api/customer1/orders
}
```

---

### 1.2 Estrat√©gias Comparadas

| Estrat√©gia                      | Isolamento | Performance | Custo      | Escalabilidade | Complexidade |
| ------------------------------- | ---------- | ----------- | ---------- | -------------- | ------------ |
| **Database Per Tenant**         | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê      | ‚≠ê‚≠ê       | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê     | ‚≠ê‚≠ê‚≠ê‚≠ê     |
| **Schema Per Tenant**           | ‚≠ê‚≠ê‚≠ê‚≠ê   | ‚≠ê‚≠ê‚≠ê‚≠ê    | ‚≠ê‚≠ê‚≠ê     | ‚≠ê‚≠ê‚≠ê‚≠ê       | ‚≠ê‚≠ê‚≠ê       |
| **Shared Database (Row-Level)** | ‚≠ê‚≠ê‚≠ê     | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê         | ‚≠ê‚≠ê         |

**Escolha baseada em:**

- **Isolamento cr√≠tico** ‚Üí Database Per Tenant
- **Muitos tenants** ‚Üí Shared Database
- **Meio termo** ‚Üí Schema Per Tenant

---

## 2. Database Per Tenant

### 2.1 Implementa√ß√£o

```java
/**
 * Cada tenant tem seu pr√≥prio banco de dados
 *
 * tenant1 ‚Üí database: tenant1_db
 * tenant2 ‚Üí database: tenant2_db
 * tenant3 ‚Üí database: tenant3_db
 */

/**
 * Tenant Resolver: Extrai tenant do request
 */
@Component
public class TenantResolver {

    /**
     * Extrai tenant do header X-Tenant-ID
     */
    public String resolveTenantId(HttpServletRequest request) {
        var tenantId = request.getHeader("X-Tenant-ID");

        if (tenantId == null || tenantId.isBlank()) {
            throw new IllegalArgumentException("X-Tenant-ID header required");
        }

        return tenantId;
    }

    /**
     * Extrai tenant do subdomain
     */
    public String resolveTenantFromSubdomain(HttpServletRequest request) {
        var host = request.getServerName();  // customer1.app.com
        var parts = host.split("\\.");

        if (parts.length < 3) {
            throw new IllegalArgumentException("Invalid subdomain");
        }

        return parts[0];  // customer1
    }
}

/**
 * Tenant Context Holder: ThreadLocal para tenant atual
 */
public class TenantContextHolder {

    private static final ThreadLocal<String> CONTEXT = new ThreadLocal<>();

    public static void setTenantId(String tenantId) {
        CONTEXT.set(tenantId);
    }

    public static String getTenantId() {
        return CONTEXT.get();
    }

    public static void clear() {
        CONTEXT.remove();
    }
}

/**
 * Interceptor: Captura tenant e armazena no context
 */
@Component
public class TenantInterceptor implements HandlerInterceptor {

    @Autowired
    private TenantResolver tenantResolver;

    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) {
        var tenantId = tenantResolver.resolveTenantId(request);
        TenantContextHolder.setTenantId(tenantId);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                               HttpServletResponse response,
                               Object handler,
                               Exception ex) {
        TenantContextHolder.clear();
    }
}

/**
 * Dynamic DataSource: Roteia para database correto
 */
@Configuration
public class MultiTenantDataSourceConfig {

    @Bean
    public DataSource dataSource() {
        return new TenantRoutingDataSource();
    }
}

/**
 * Routing DataSource: Escolhe database baseado no tenant
 */
public class TenantRoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        return TenantContextHolder.getTenantId();
    }

    @Override
    public void afterPropertiesSet() {
        // Configurar datasources por tenant
        var dataSources = Map.<Object, Object>of(
            "tenant1", createDataSource("jdbc:postgresql://localhost/tenant1_db"),
            "tenant2", createDataSource("jdbc:postgresql://localhost/tenant2_db"),
            "tenant3", createDataSource("jdbc:postgresql://localhost/tenant3_db")
        );

        setTargetDataSources(dataSources);
        setDefaultTargetDataSource(dataSources.get("tenant1"));
        super.afterPropertiesSet();
    }

    private DataSource createDataSource(String url) {
        var config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setUsername("user");
        config.setPassword("pass");
        config.setMaximumPoolSize(10);
        return new HikariDataSource(config);
    }
}
```

---

### 2.2 Dynamic Tenant Registration

```java
/**
 * Cadastrar novo tenant em runtime (sem restart)
 */
@Service
public class TenantProvisioningService {

    @Autowired
    private TenantRoutingDataSource routingDataSource;

    @Autowired
    private JdbcTemplate masterJdbcTemplate;  // Database master

    /**
     * Criar novo tenant
     */
    @Transactional
    public void provisionTenant(String tenantId) {
        // 1. Criar database
        masterJdbcTemplate.execute("CREATE DATABASE " + tenantId + "_db");

        // 2. Criar schema (Flyway)
        var dataSource = createDataSource("jdbc:postgresql://localhost/" + tenantId + "_db");
        var flyway = Flyway.configure()
                           .dataSource(dataSource)
                           .load();
        flyway.migrate();

        // 3. Registrar datasource no routing
        routingDataSource.addDataSource(tenantId, dataSource);

        // 4. Salvar metadata do tenant
        masterJdbcTemplate.update(
            "INSERT INTO tenants (tenant_id, database_name, created_at) VALUES (?, ?, ?)",
            tenantId,
            tenantId + "_db",
            LocalDateTime.now()
        );
    }
}

/**
 * Routing DataSource com registro din√¢mico
 */
public class TenantRoutingDataSource extends AbstractRoutingDataSource {

    private final Map<Object, Object> dataSources = new ConcurrentHashMap<>();

    public void addDataSource(String tenantId, DataSource dataSource) {
        dataSources.put(tenantId, dataSource);
        setTargetDataSources(dataSources);
        afterPropertiesSet();  // Recarregar datasources
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return TenantContextHolder.getTenantId();
    }
}
```

---

## 3. Schema Per Tenant

### 3.1 Implementa√ß√£o

```java
/**
 * Todos tenants no mesmo database, schemas diferentes
 *
 * database: myapp_db
 * ‚îú‚îÄ‚îÄ schema: tenant1
 * ‚îú‚îÄ‚îÄ schema: tenant2
 * ‚îî‚îÄ‚îÄ schema: tenant3
 */

/**
 * Schema Resolver: Define search_path correto
 */
@Component
@Aspect
public class TenantSchemaAspect {

    @Autowired
    private DataSource dataSource;

    /**
     * Antes de cada query, define schema
     */
    @Before("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void setSchema() throws SQLException {
        var tenantId = TenantContextHolder.getTenantId();

        if (tenantId != null) {
            try (var conn = dataSource.getConnection();
                 var stmt = conn.createStatement()) {

                // PostgreSQL: Define search_path
                stmt.execute("SET search_path TO " + tenantId);
            }
        }
    }
}

/**
 * ALTERNATIVA: Connection customizer (Hibernate)
 */
@Configuration
public class HibernateConfig {

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
            DataSource dataSource) {

        var em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);

        var properties = new HashMap<String, Object>();

        // Hibernate interceptor para schema
        properties.put("hibernate.session_factory.interceptor",
                      new TenantSchemaInterceptor());

        em.setJpaPropertyMap(properties);
        return em;
    }
}

/**
 * Hibernate Interceptor
 */
public class TenantSchemaInterceptor extends EmptyInterceptor {

    @Override
    public String onPrepareStatement(String sql) {
        var tenantId = TenantContextHolder.getTenantId();

        if (tenantId != null) {
            // Prefixa tabelas com schema
            return sql.replaceAll("FROM (\\w+)", "FROM " + tenantId + ".$1")
                      .replaceAll("JOIN (\\w+)", "JOIN " + tenantId + ".$1");
        }

        return sql;
    }
}
```

---

### 3.2 Schema Migration

```java
/**
 * Flyway: Migrar todos os schemas
 */
@Service
public class TenantMigrationService {

    @Autowired
    private DataSource dataSource;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * Aplicar migration em todos os tenants
     */
    public void migrateAllTenants() {
        var tenantIds = jdbcTemplate.queryForList(
            "SELECT tenant_id FROM tenants",
            String.class
        );

        for (var tenantId : tenantIds) {
            migrateSchema(tenantId);
        }
    }

    private void migrateSchema(String tenantId) {
        var flyway = Flyway.configure()
                           .dataSource(dataSource)
                           .schemas(tenantId)  // Schema espec√≠fico
                           .load();

        flyway.migrate();
    }
}
```

---

## 4. Shared Database

### 4.1 Row-Level Filtering

```java
/**
 * Todos tenants compartilham tabelas (coluna tenant_id)
 *
 * CREATE TABLE orders (
 *   id BIGSERIAL PRIMARY KEY,
 *   tenant_id VARCHAR(50) NOT NULL,  ‚Üê Identificador do tenant
 *   customer_id BIGINT,
 *   total NUMERIC(10,2),
 *   created_at TIMESTAMP
 * );
 *
 * CREATE INDEX idx_orders_tenant ON orders(tenant_id);
 */

/**
 * JPA: Filter por tenant automaticamente
 */
@Entity
@Table(name = "orders")
@FilterDef(name = "tenantFilter",
           parameters = @ParamDef(name = "tenantId", type = String.class))
@Filter(name = "tenantFilter",
        condition = "tenant_id = :tenantId")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "tenant_id", nullable = false, updatable = false)
    private String tenantId;

    private Long customerId;
    private BigDecimal total;
    private LocalDateTime createdAt;
}

/**
 * Ativar filtro automaticamente
 */
@Component
@Aspect
public class TenantFilterAspect {

    @PersistenceContext
    private EntityManager entityManager;

    @Before("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void enableTenantFilter() {
        var tenantId = TenantContextHolder.getTenantId();

        if (tenantId != null) {
            var session = entityManager.unwrap(Session.class);
            session.enableFilter("tenantFilter")
                   .setParameter("tenantId", tenantId);
        }
    }
}

/**
 * Pre-persist: Definir tenant_id automaticamente
 */
@Component
public class TenantEntityListener {

    @PrePersist
    @PreUpdate
    public void setTenantId(Object entity) {
        if (entity instanceof TenantAware tenantAware) {
            var tenantId = TenantContextHolder.getTenantId();
            tenantAware.setTenantId(tenantId);
        }
    }
}

/**
 * Interface marker
 */
public interface TenantAware {
    String getTenantId();
    void setTenantId(String tenantId);
}

/**
 * Entity implementa TenantAware
 */
@Entity
@EntityListeners(TenantEntityListener.class)
public class Order implements TenantAware {

    @Column(name = "tenant_id")
    private String tenantId;

    @Override
    public String getTenantId() {
        return tenantId;
    }

    @Override
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
}
```

---

### 4.2 PostgreSQL Row-Level Security

```sql
/**
 * RLS: Banco de dados garante isolamento
 */

-- Habilitar RLS
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- Pol√≠tica: Usu√°rio s√≥ v√™ seu tenant
CREATE POLICY tenant_isolation ON orders
  USING (tenant_id = current_setting('app.tenant_id')::TEXT);

-- Definir tenant no connection
SET app.tenant_id = 'tenant1';

-- Queries automaticamente filtradas
SELECT * FROM orders;  -- S√≥ retorna tenant1
```

```java
/**
 * Spring: Definir tenant no connection
 */
@Component
@Aspect
public class RowLevelSecurityAspect {

    @Autowired
    private DataSource dataSource;

    @Before("@annotation(org.springframework.transaction.annotation.Transactional)")
    public void setTenantVariable() throws SQLException {
        var tenantId = TenantContextHolder.getTenantId();

        if (tenantId != null) {
            try (var conn = dataSource.getConnection();
                 var stmt = conn.createStatement()) {

                stmt.execute("SET app.tenant_id = '" + tenantId + "'");
            }
        }
    }
}
```

---

## 5. Testing

### 5.1 Test com M√∫ltiplos Tenants

```java
/**
 * Base test: Setup multi-tenancy
 */
@SpringBootTest
@Testcontainers
public abstract class MultiTenantTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureDataSource(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    protected JdbcTemplate jdbcTemplate;

    @BeforeEach
    void setupTenants() {
        // Criar schemas para tenants
        jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS tenant1");
        jdbcTemplate.execute("CREATE SCHEMA IF NOT EXISTS tenant2");

        // Criar tabelas
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS tenant1.orders (
                id BIGSERIAL PRIMARY KEY,
                customer_id BIGINT,
                total NUMERIC(10,2)
            )
            """);

        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS tenant2.orders (
                id BIGSERIAL PRIMARY KEY,
                customer_id BIGINT,
                total NUMERIC(10,2)
            )
            """);
    }

    /**
     * Helper: Executar c√≥digo como tenant espec√≠fico
     */
    protected <T> T asTenant(String tenantId, Supplier<T> action) {
        try {
            TenantContextHolder.setTenantId(tenantId);
            return action.get();
        } finally {
            TenantContextHolder.clear();
        }
    }
}

/**
 * Test: Isolamento entre tenants
 */
@SpringBootTest
class OrderServiceTest extends MultiTenantTest {

    @Autowired
    private OrderService orderService;

    @Test
    void testTenantIsolation() {
        // Tenant 1: Criar pedido
        var order1 = asTenant("tenant1", () ->
            orderService.createOrder(new Order(null, 100L, new BigDecimal("99.90")))
        );

        // Tenant 2: Criar pedido
        var order2 = asTenant("tenant2", () ->
            orderService.createOrder(new Order(null, 200L, new BigDecimal("199.90")))
        );

        // Tenant 1: S√≥ v√™ seu pedido
        var tenant1Orders = asTenant("tenant1", () ->
            orderService.findAll()
        );
        assertThat(tenant1Orders).hasSize(1);
        assertThat(tenant1Orders.get(0).id()).isEqualTo(order1.id());

        // Tenant 2: S√≥ v√™ seu pedido
        var tenant2Orders = asTenant("tenant2", () ->
            orderService.findAll()
        );
        assertThat(tenant2Orders).hasSize(1);
        assertThat(tenant2Orders.get(0).id()).isEqualTo(order2.id());
    }

    @Test
    void testCrosstenantAccessBlocked() {
        var order1 = asTenant("tenant1", () ->
            orderService.createOrder(new Order(null, 100L, new BigDecimal("99.90")))
        );

        // Tenant 2 n√£o pode acessar pedido do tenant 1
        assertThatThrownBy(() ->
            asTenant("tenant2", () -> orderService.findById(order1.id()))
        ).isInstanceOf(EntityNotFoundException.class);
    }
}
```

---

## üìä Checklist de Qualidade

- [ ] Estrat√©gia escolhida baseada em requisitos (isolamento vs custo)
- [ ] Tenant context capturado no interceptor (header/subdomain/JWT)
- [ ] ThreadLocal limpo ap√≥s request (memory leak)
- [ ] Tenant ID validado (whitelist, n√£o aceitar qualquer valor)
- [ ] Queries filtradas automaticamente (@Filter ou RLS)
- [ ] Migrations aplicadas em todos os tenants
- [ ] Tests validam isolamento entre tenants
- [ ] M√©tricas por tenant (Micrometer tags)
- [ ] Logs incluem tenant_id (MDC)
- [ ] Connection pool dimensionado (tenants \* connections)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Implementar schema per tenant com interceptor
2. **Intermedi√°rio**: Row-level security com PostgreSQL RLS
3. **Avan√ßado**: Dynamic tenant provisioning (criar tenant em runtime)

---

## üìö Refer√™ncias

- [Multi-Tenancy Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/multi-tenancy)
- [Hibernate Multi-Tenancy](https://docs.jboss.org/hibernate/orm/6.2/userguide/html_single/Hibernate_User_Guide.html#multitenacy)
- [PostgreSQL Row-Level Security](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)

---

**Anterior:** [12.8 - Connection Pooling](12.8-connection-pooling.md)  
**Pr√≥ximo:** [12.10 - Database Design](12.10-database-design-modeling.md)
