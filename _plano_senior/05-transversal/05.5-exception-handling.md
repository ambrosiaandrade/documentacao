# 05.5 Exception Handling [INTERMEDI√ÅRIO] ‚ö†Ô∏è

## üéØ Objetivo

Implementar tratamento de exce√ß√µes **global e espec√≠fico** para REST, **async**, **mensageria**, **scheduled tasks**, **WebSocket** e **GraphQL**, garantindo respostas consistentes e observabilidade.

---

## üìö O Que √â?

**Exception Handling** √© o padr√£o para capturar, tratar e responder a exce√ß√µes de forma consistente em diferentes contextos da aplica√ß√£o (sync, async, messaging, etc.).

### Analogia

Como **departamento de atendimento ao cliente**:

- **Sem Exception Handling**: Cliente recebe erro cru "NullPointerException"
- **Com Exception Handling**: Cliente recebe mensagem amig√°vel "Produto n√£o encontrado"
- **Vantagem**: Experi√™ncia consistente e profissional

---

## ‚ùå Problema que Resolve

### Antes (Sem Tratamento Global)

```java
// ‚ùå PROBLEMA: Tratamento inconsistente de erros

@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @GetMapping("/{id}")
    ResponseEntity<ProdutoDTO> buscar(@PathVariable Long id) {
        try {
            Produto produto = service.buscar(id);
            return ResponseEntity.ok(new ProdutoDTO(produto));

        } catch (ProdutoNaoEncontradoException e) {
            // Tratamento manual ‚ùå
            return ResponseEntity.status(404).body(null);

        } catch (Exception e) {
            // Log manual ‚ùå
            log.error("Erro ao buscar produto", e);
            return ResponseEntity.status(500).body(null);
        }
    }

    @PostMapping
    ResponseEntity<ProdutoDTO> criar(@RequestBody CriarProdutoRequest request) {
        try {
            // Valida√ß√£o manual ‚ùå
            if (request.getNome() == null) {
                return ResponseEntity.badRequest().body(null);
            }

            Produto produto = service.criar(request);
            return ResponseEntity.status(201).body(new ProdutoDTO(produto));

        } catch (Exception e) {
            return ResponseEntity.status(500).body(null);
        }
    }
}

// Async sem tratamento ‚ùå
@Async
public void processarPedidoAsync(Long pedidoId) {
    // Se der erro, exce√ß√£o √© perdida ‚ùå
    Pedido pedido = service.buscar(pedidoId);
    pedido.processar();
}

// Mensageria sem tratamento ‚ùå
@RabbitListener(queues = "pedidos")
public void processarMensagem(PedidoMessage message) {
    // Se der erro, mensagem √© perdida ou reprocessada infinitamente ‚ùå
    service.processar(message);
}

// Problemas:
// - Tratamento duplicado em cada endpoint ‚ùå
// - Respostas inconsistentes ‚ùå
// - Sem logs padronizados ‚ùå
// - Async/mensageria sem tratamento ‚ùå
// - Stack trace exposto ao cliente ‚ùå
```

**Problemas**:

- üîÑ C√≥digo duplicado em todo controller
- üìù Respostas de erro inconsistentes
- üö® Exce√ß√µes async perdidas
- üêõ Debugging dif√≠cil

### Depois (Exception Handling Global)

```java
// ‚úÖ SOLU√á√ÉO: Exception Handling global e espec√≠fico

// 1. REST - Global Exception Handler
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    // Recurso n√£o encontrado
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
        ResourceNotFoundException ex,
        WebRequest request
    ) {
        log.warn("Recurso n√£o encontrado: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.NOT_FOUND.value())
            .error("Not Found")
            .message(ex.getMessage())
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .build();

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // Valida√ß√£o de dados
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
        MethodArgumentNotValidException ex,
        WebRequest request
    ) {
        log.warn("Erro de valida√ß√£o: {}", ex.getMessage());

        Map<String, String> violations = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            violations.put(error.getField(), error.getDefaultMessage())
        );

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Validation Failed")
            .message("Dados inv√°lidos")
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .violations(violations)
            .build();

        return ResponseEntity.badRequest().body(error);
    }

    // Regra de neg√≥cio
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusiness(
        BusinessException ex,
        WebRequest request
    ) {
        log.warn("Erro de neg√≥cio: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.UNPROCESSABLE_ENTITY.value())
            .error("Business Rule Violation")
            .message(ex.getMessage())
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .errorCode(ex.getErrorCode())
            .build();

        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    // Erro gen√©rico
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(
        Exception ex,
        WebRequest request
    ) {
        log.error("Erro inesperado: ", ex);

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("Internal Server Error")
            .message("Erro interno do servidor")
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}

// 2. ASYNC - Exception Handler
@Configuration
@EnableAsync
public class AsyncExceptionConfig implements AsyncConfigurer {

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new CustomAsyncExceptionHandler();
    }
}

@Slf4j
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        log.error("‚ùå Erro em m√©todo async: {}.{}",
            method.getDeclaringClass().getSimpleName(),
            method.getName(),
            ex
        );

        // Publicar evento de erro para monitoramento
        publishErrorEvent(ex, method, params);

        // Enviar alerta se cr√≠tico
        if (isCritical(ex)) {
            sendAlert(ex, method);
        }
    }

    private void publishErrorEvent(Throwable ex, Method method, Object... params) {
        // Implementar notifica√ß√£o
    }

    private boolean isCritical(Throwable ex) {
        return ex instanceof DataIntegrityViolationException ||
               ex instanceof OutOfMemoryError;
    }

    private void sendAlert(Throwable ex, Method method) {
        // Enviar para Slack, email, etc.
    }
}

// 3. MENSAGERIA - Exception Handler
@Configuration
public class RabbitMQErrorConfig {

    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory,
        ErrorHandler errorHandler
    ) {
        SimpleRabbitListenerContainerFactory factory =
            new SimpleRabbitListenerContainerFactory();

        factory.setConnectionFactory(connectionFactory);
        factory.setErrorHandler(errorHandler);
        factory.setDefaultRequeueRejected(false); // N√£o reprocessar infinitamente

        return factory;
    }

    @Bean
    public ErrorHandler errorHandler(RabbitTemplate rabbitTemplate) {
        return new ConditionalRejectingErrorHandler(
            new CustomFatalExceptionStrategy(rabbitTemplate)
        );
    }
}

@Slf4j
public class CustomFatalExceptionStrategy implements FatalExceptionStrategy {

    private final RabbitTemplate rabbitTemplate;

    public CustomFatalExceptionStrategy(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    @Override
    public boolean isFatal(Throwable t) {
        // Definir quais erros s√£o fatais (n√£o devem reprocessar)
        boolean isFatal = t instanceof ValidationException ||
                         t instanceof IllegalArgumentException ||
                         t instanceof JsonProcessingException;

        if (isFatal) {
            log.error("‚ùå Erro fatal na mensageria: {}", t.getMessage(), t);

            // Enviar para DLQ
            sendToDLQ(t);
        }

        return isFatal;
    }

    private void sendToDLQ(Throwable t) {
        // Implementar envio para Dead Letter Queue
        log.info("üìÆ Enviando mensagem para DLQ");
    }
}

// 4. SCHEDULED - Exception Handler
@Aspect
@Component
@Slf4j
public class ScheduledExceptionAspect {

    @Around("@annotation(org.springframework.scheduling.annotation.Scheduled)")
    public Object handleScheduledException(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();

        try {
            log.debug("‚è∞ Executando task agendado: {}", methodName);
            return joinPoint.proceed();

        } catch (Exception e) {
            log.error("‚ùå Erro em task agendado: {}", methodName, e);

            // Publicar m√©trica de falha
            publishScheduledTaskError(methodName, e);

            // N√£o propagar exce√ß√£o (task continua agendado)
            return null;
        }
    }

    private void publishScheduledTaskError(String methodName, Exception e) {
        // Enviar para sistema de monitoramento
    }
}

// 5. WEBSOCKET - Exception Handler
@Component
@Slf4j
public class WebSocketExceptionHandler {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public WebSocketExceptionHandler(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    @MessageExceptionHandler
    public void handleException(Exception ex, Message<?> message) {
        log.error("‚ùå Erro no WebSocket: ", ex);

        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        String sessionId = accessor.getSessionId();

        // Enviar erro para o cliente espec√≠fico
        ErrorMessage errorMessage = new ErrorMessage(
            "Erro ao processar mensagem: " + ex.getMessage(),
            LocalDateTime.now()
        );

        messagingTemplate.convertAndSend(
            "/queue/errors-" + sessionId,
            errorMessage
        );
    }
}

// 6. GRAPHQL - Exception Handler
@Component
public class GraphQLExceptionHandler implements DataFetcherExceptionHandler {

    @Override
    public DataFetcherExceptionHandlerResult onException(
        DataFetcherExceptionHandlerParameters params
    ) {
        Throwable exception = params.getException();

        GraphQLError error;

        if (exception instanceof ResourceNotFoundException) {
            error = GraphqlErrorBuilder.newError()
                .message(exception.getMessage())
                .errorType(ErrorType.NOT_FOUND)
                .path(params.getPath())
                .build();

        } else if (exception instanceof ValidationException) {
            error = GraphqlErrorBuilder.newError()
                .message(exception.getMessage())
                .errorType(ErrorType.ValidationError)
                .path(params.getPath())
                .build();

        } else {
            error = GraphqlErrorBuilder.newError()
                .message("Erro interno")
                .errorType(ErrorType.INTERNAL_ERROR)
                .path(params.getPath())
                .build();
        }

        return DataFetcherExceptionHandlerResult.newResult()
            .error(error)
            .build();
    }
}

// Controller limpo ‚úÖ
@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @GetMapping("/{id}")
    ProdutoDTO buscar(@PathVariable Long id) {
        // Exce√ß√£o tratada globalmente ‚úÖ
        return service.buscar(id);
    }

    @PostMapping
    ProdutoDTO criar(@Valid @RequestBody CriarProdutoRequest request) {
        // Valida√ß√£o tratada globalmente ‚úÖ
        return service.criar(request);
    }
}

// ‚úÖ Vantagens:
// - Tratamento global consistente ‚úÖ
// - Controllers limpos ‚úÖ
// - Logs padronizados ‚úÖ
// - Async/mensageria tratados ‚úÖ
// - Sem stack trace exposto ‚úÖ
// - Observabilidade ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Exce√ß√µes Customizadas

```java
// Exce√ß√£o base

@Getter
public abstract class BaseException extends RuntimeException {

    private final String errorCode;
    private final Map<String, Object> details;

    protected BaseException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
        this.details = new HashMap<>();
    }

    protected BaseException(String message, String errorCode, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.details = new HashMap<>();
    }

    public BaseException addDetail(String key, Object value) {
        this.details.put(key, value);
        return this;
    }
}

// Recurso n√£o encontrado
public class ResourceNotFoundException extends BaseException {

    public ResourceNotFoundException(String resourceName, Object id) {
        super(
            String.format("%s n√£o encontrado com id: %s", resourceName, id),
            "RESOURCE_NOT_FOUND"
        );
        addDetail("resourceName", resourceName);
        addDetail("id", id);
    }
}

// Regra de neg√≥cio
public class BusinessException extends BaseException {

    public BusinessException(String message, String errorCode) {
        super(message, errorCode);
    }

    public BusinessException(String message, String errorCode, Throwable cause) {
        super(message, errorCode, cause);
    }
}

// Valida√ß√£o
public class ValidationException extends BaseException {

    private final Map<String, String> violations;

    public ValidationException(String message) {
        super(message, "VALIDATION_ERROR");
        this.violations = new HashMap<>();
    }

    public ValidationException addViolation(String field, String message) {
        this.violations.put(field, message);
        return this;
    }

    public Map<String, String> getViolations() {
        return violations;
    }
}

// Conflito (duplicata, constraint)
public class ConflictException extends BaseException {

    public ConflictException(String message) {
        super(message, "CONFLICT");
    }
}

// N√£o autorizado
public class UnauthorizedException extends BaseException {

    public UnauthorizedException(String message) {
        super(message, "UNAUTHORIZED");
    }
}

// Proibido
public class ForbiddenException extends BaseException {

    public ForbiddenException(String message) {
        super(message, "FORBIDDEN");
    }
}
```

### 2. Response Padronizado

```java
// Resposta de erro

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {

    private LocalDateTime timestamp;
    private int status;
    private String error;
    private String message;
    private String path;
    private String errorCode;
    private Map<String, String> violations;
    private Map<String, Object> details;
    private String traceId; // Para rastreamento

    // Factory methods
    public static ErrorResponse from(Exception ex, HttpStatus status, String path) {
        ErrorResponseBuilder builder = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(status.value())
            .error(status.getReasonPhrase())
            .message(ex.getMessage())
            .path(path)
            .traceId(MDC.get("traceId"));

        if (ex instanceof BaseException) {
            BaseException baseEx = (BaseException) ex;
            builder.errorCode(baseEx.getErrorCode());
            builder.details(baseEx.getDetails());
        }

        if (ex instanceof ValidationException) {
            ValidationException validationEx = (ValidationException) ex;
            builder.violations(validationEx.getViolations());
        }

        return builder.build();
    }
}
```

### 3. REST - Global Exception Handler Completo

```java
@RestControllerAdvice
@Slf4j
@Order(Ordered.HIGHEST_PRECEDENCE)
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    // Resource not found
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(
        ResourceNotFoundException ex,
        HttpServletRequest request
    ) {
        log.warn("Recurso n√£o encontrado: {} - {}", ex.getErrorCode(), ex.getMessage());

        ErrorResponse error = ErrorResponse.from(ex, HttpStatus.NOT_FOUND, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    // Business exception
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusiness(
        BusinessException ex,
        HttpServletRequest request
    ) {
        log.warn("Erro de neg√≥cio: {} - {}", ex.getErrorCode(), ex.getMessage());

        ErrorResponse error = ErrorResponse.from(
            ex,
            HttpStatus.UNPROCESSABLE_ENTITY,
            request.getRequestURI()
        );
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).body(error);
    }

    // Validation exception
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(
        ValidationException ex,
        HttpServletRequest request
    ) {
        log.warn("Erro de valida√ß√£o: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.from(ex, HttpStatus.BAD_REQUEST, request.getRequestURI());
        return ResponseEntity.badRequest().body(error);
    }

    // Conflict
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ErrorResponse> handleConflict(
        ConflictException ex,
        HttpServletRequest request
    ) {
        log.warn("Conflito: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.from(ex, HttpStatus.CONFLICT, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // Unauthorized
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ErrorResponse> handleUnauthorized(
        UnauthorizedException ex,
        HttpServletRequest request
    ) {
        log.warn("N√£o autorizado: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.from(ex, HttpStatus.UNAUTHORIZED, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(error);
    }

    // Forbidden
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ErrorResponse> handleForbidden(
        ForbiddenException ex,
        HttpServletRequest request
    ) {
        log.warn("Proibido: {}", ex.getMessage());

        ErrorResponse error = ErrorResponse.from(ex, HttpStatus.FORBIDDEN, request.getRequestURI());
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(error);
    }

    // Bean Validation (@Valid)
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
        MethodArgumentNotValidException ex,
        HttpHeaders headers,
        HttpStatusCode status,
        WebRequest request
    ) {
        log.warn("Erro de valida√ß√£o: {}", ex.getMessage());

        Map<String, String> violations = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            violations.put(error.getField(), error.getDefaultMessage())
        );

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Validation Failed")
            .message("Dados inv√°lidos")
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .violations(violations)
            .traceId(MDC.get("traceId"))
            .build();

        return ResponseEntity.badRequest().body(error);
    }

    // Missing request parameter
    @Override
    protected ResponseEntity<Object> handleMissingServletRequestParameter(
        MissingServletRequestParameterException ex,
        HttpHeaders headers,
        HttpStatusCode status,
        WebRequest request
    ) {
        log.warn("Par√¢metro ausente: {}", ex.getParameterName());

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("Missing Parameter")
            .message("Par√¢metro obrigat√≥rio ausente: " + ex.getParameterName())
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .traceId(MDC.get("traceId"))
            .build();

        return ResponseEntity.badRequest().body(error);
    }

    // HTTP method not supported
    @Override
    protected ResponseEntity<Object> handleHttpRequestMethodNotSupported(
        HttpRequestMethodNotSupportedException ex,
        HttpHeaders headers,
        HttpStatusCode status,
        WebRequest request
    ) {
        log.warn("M√©todo n√£o suportado: {}", ex.getMethod());

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.METHOD_NOT_ALLOWED.value())
            .error("Method Not Allowed")
            .message("M√©todo " + ex.getMethod() + " n√£o suportado para este endpoint")
            .path(((ServletWebRequest) request).getRequest().getRequestURI())
            .traceId(MDC.get("traceId"))
            .build();

        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(error);
    }

    // Data integrity violation (constraint, unique)
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrityViolation(
        DataIntegrityViolationException ex,
        HttpServletRequest request
    ) {
        log.error("Viola√ß√£o de integridade de dados", ex);

        String message = "Viola√ß√£o de integridade de dados";
        if (ex.getCause() instanceof ConstraintViolationException) {
            message = "Viola√ß√£o de constraint do banco de dados";
        }

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.CONFLICT.value())
            .error("Data Integrity Violation")
            .message(message)
            .path(request.getRequestURI())
            .errorCode("DATA_INTEGRITY_VIOLATION")
            .traceId(MDC.get("traceId"))
            .build();

        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    // Generic exception
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(
        Exception ex,
        HttpServletRequest request
    ) {
        log.error("Erro inesperado: ", ex);

        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("Internal Server Error")
            .message("Erro interno do servidor")
            .path(request.getRequestURI())
            .errorCode("INTERNAL_ERROR")
            .traceId(MDC.get("traceId"))
            .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

### 4. Async Exception Handler

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");
        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncExceptionHandler();
    }
}

@Slf4j
public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        String methodName = method.getDeclaringClass().getSimpleName() + "." + method.getName();

        log.error("‚ùå [ASYNC] Erro n√£o tratado em m√©todo async: {}", methodName, ex);
        log.error("‚ùå [ASYNC] Par√¢metros: {}", Arrays.toString(params));

        // Enviar notifica√ß√£o cr√≠tica
        if (isCriticalError(ex)) {
            sendCriticalAlert(ex, methodName, params);
        }

        // Publicar evento de erro
        publishAsyncErrorEvent(ex, method, params);

        // Incrementar m√©trica de erro
        incrementErrorMetric(methodName, ex.getClass().getSimpleName());
    }

    private boolean isCriticalError(Throwable ex) {
        return ex instanceof DataIntegrityViolationException ||
               ex instanceof OutOfMemoryError ||
               ex instanceof StackOverflowError;
    }

    private void sendCriticalAlert(Throwable ex, String methodName, Object... params) {
        log.error("üö® [ASYNC] ERRO CR√çTICO em {}: {}", methodName, ex.getMessage());
        // Implementar integra√ß√£o com Slack, PagerDuty, etc.
    }

    private void publishAsyncErrorEvent(Throwable ex, Method method, Object... params) {
        // Implementar publica√ß√£o de evento para sistema de monitoramento
    }

    private void incrementErrorMetric(String methodName, String exceptionType) {
        // Implementar incremento de m√©trica (Micrometer, Prometheus)
    }
}
```

### 5. Mensageria Exception Handler

```java
// RabbitMQ Error Handling

@Configuration
public class RabbitMQErrorHandlingConfig {

    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
        ConnectionFactory connectionFactory,
        MessageConverter messageConverter
    ) {
        SimpleRabbitListenerContainerFactory factory =
            new SimpleRabbitListenerContainerFactory();

        factory.setConnectionFactory(connectionFactory);
        factory.setMessageConverter(messageConverter);
        factory.setErrorHandler(new ConditionalRejectingErrorHandler(
            new CustomFatalExceptionStrategy()
        ));
        factory.setDefaultRequeueRejected(false);

        return factory;
    }

    @Bean
    public Queue deadLetterQueue() {
        return QueueBuilder.durable("pedidos.dlq")
            .withArgument("x-message-ttl", 86400000) // 24h
            .build();
    }
}

@Slf4j
public class CustomFatalExceptionStrategy extends ConditionalRejectingErrorHandler.DefaultExceptionStrategy {

    @Override
    public boolean isFatal(Throwable t) {
        // Erros que n√£o devem ser reprocessados
        if (t instanceof ValidationException ||
            t instanceof IllegalArgumentException ||
            t instanceof JsonProcessingException ||
            t instanceof MessageConversionException) {

            log.error("‚ùå [RABBITMQ] Erro fatal detectado: {}", t.getClass().getSimpleName(), t);
            return true;
        }

        // Erros transientes (devem ser reprocessados)
        if (t instanceof AmqpRejectAndDontRequeueException) {
            return true;
        }

        // Por padr√£o, reprocessar
        log.warn("‚ö†Ô∏è [RABBITMQ] Erro transiente, mensagem ser√° reprocessada: {}",
            t.getClass().getSimpleName());
        return false;
    }
}

// Listener com tratamento

@Component
@Slf4j
public class PedidoMessageListener {

    private final PedidoService pedidoService;

    @Autowired
    public PedidoMessageListener(PedidoService pedidoService) {
        this.pedidoService = pedidoService;
    }

    @RabbitListener(queues = "pedidos")
    public void processar(PedidoMessage message, @Header(AmqpHeaders.DELIVERY_TAG) long tag) {
        log.info("üì® [RABBITMQ] Processando mensagem: {}", message.getPedidoId());

        try {
            pedidoService.processar(message);
            log.info("‚úÖ [RABBITMQ] Mensagem processada com sucesso");

        } catch (ValidationException e) {
            // Erro de valida√ß√£o - n√£o reprocessar
            log.error("‚ùå [RABBITMQ] Erro de valida√ß√£o - enviando para DLQ: {}", e.getMessage());
            throw new AmqpRejectAndDontRequeueException("Valida√ß√£o falhou", e);

        } catch (BusinessException e) {
            // Erro de neg√≥cio - n√£o reprocessar
            log.error("‚ùå [RABBITMQ] Erro de neg√≥cio - enviando para DLQ: {}", e.getMessage());
            throw new AmqpRejectAndDontRequeueException("Regra de neg√≥cio violada", e);

        } catch (Exception e) {
            // Erro gen√©rico - tentar reprocessar
            log.error("‚ùå [RABBITMQ] Erro ao processar mensagem - ser√° reprocessada", e);
            throw e;
        }
    }
}
```

### 6. Scheduled Tasks Exception Handler

```java
@Aspect
@Component
@Slf4j
public class ScheduledTaskExceptionHandler {

    @Around("@annotation(org.springframework.scheduling.annotation.Scheduled)")
    public Object handleScheduledException(ProceedingJoinPoint joinPoint) throws Throwable {
        String taskName = joinPoint.getSignature().toShortString();

        try {
            log.debug("‚è∞ [SCHEDULED] Iniciando task: {}", taskName);

            long startTime = System.currentTimeMillis();
            Object result = joinPoint.proceed();
            long duration = System.currentTimeMillis() - startTime;

            log.info("‚úÖ [SCHEDULED] Task conclu√≠do em {}ms: {}", duration, taskName);

            return result;

        } catch (Exception e) {
            log.error("‚ùå [SCHEDULED] Erro em task agendado: {}", taskName, e);

            // Publicar m√©trica de falha
            publishTaskFailureMetric(taskName, e);

            // Enviar alerta se cr√≠tico
            if (isCriticalTask(taskName)) {
                sendTaskFailureAlert(taskName, e);
            }

            // N√£o propagar exce√ß√£o para n√£o desagendar a task
            return null;
        }
    }

    private void publishTaskFailureMetric(String taskName, Exception e) {
        // Implementar publica√ß√£o de m√©trica
    }

    private boolean isCriticalTask(String taskName) {
        return taskName.contains("pagamento") || taskName.contains("faturamento");
    }

    private void sendTaskFailureAlert(String taskName, Exception e) {
        log.error("üö® [SCHEDULED] TAREFA CR√çTICA FALHOU: {}", taskName);
        // Implementar alerta
    }
}
```

---

## üß™ Como Testar

### 1. Teste REST Exception Handler

```java
@SpringBootTest
@AutoConfigureMockMvc
class GlobalExceptionHandlerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProdutoService produtoService;

    @Test
    void deveRetornar404QuandoRecursoNaoEncontrado() throws Exception {
        // Arrange
        when(produtoService.buscar(999L))
            .thenThrow(new ResourceNotFoundException("Produto", 999L));

        // Act & Assert
        mockMvc.perform(get("/api/produtos/999"))
            .andExpect(status().isNotFound())
            .andExpect(jsonPath("$.status").value(404))
            .andExpect(jsonPath("$.error").value("Not Found"))
            .andExpect(jsonPath("$.message").value("Produto n√£o encontrado com id: 999"))
            .andExpect(jsonPath("$.errorCode").value("RESOURCE_NOT_FOUND"));
    }

    @Test
    void deveRetornar400QuandoValidacaoFalha() throws Exception {
        // Arrange
        String jsonInvalido = "{\"nome\":\"\",\"preco\":-10}";

        // Act & Assert
        mockMvc.perform(post("/api/produtos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(jsonInvalido))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.status").value(400))
            .andExpect(jsonPath("$.error").value("Validation Failed"))
            .andExpect(jsonPath("$.violations.nome").exists())
            .andExpect(jsonPath("$.violations.preco").exists());
    }

    @Test
    void deveRetornar422QuandoRegraDeNegocioViolada() throws Exception {
        // Arrange
        when(produtoService.criar(any()))
            .thenThrow(new BusinessException("Estoque insuficiente", "ESTOQUE_INSUFICIENTE"));

        // Act & Assert
        mockMvc.perform(post("/api/produtos")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"nome\":\"Produto\",\"preco\":100}"))
            .andExpect(status().isUnprocessableEntity())
            .andExpect(jsonPath("$.status").value(422))
            .andExpect(jsonPath("$.errorCode").value("ESTOQUE_INSUFICIENTE"));
    }
}
```

### 2. Teste Async Exception Handler

```java
@SpringBootTest
class AsyncExceptionHandlerTest {

    @Autowired
    private AsyncService asyncService;

    @Test
    void deveCapturarExcecaoEmMetodoAsync() throws Exception {
        // Arrange & Act
        asyncService.metodoQueGeraErro();

        // Assert - aguardar async
        Thread.sleep(1000);

        // Verificar logs ou m√©tricas
        // (em ambiente real, verificar sistema de monitoramento)
    }
}

@Service
class AsyncService {

    @Async
    public void metodoQueGeraErro() {
        throw new RuntimeException("Erro proposital para teste");
    }
}
```

### 3. Teste Mensageria Exception Handler

```java
@SpringBootTest
class RabbitMQExceptionHandlerTest {

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private PedidoService pedidoService;

    @Test
    void deveEnviarParaDLQQuandoErroFatal() {
        // Arrange
        when(pedidoService.processar(any()))
            .thenThrow(new ValidationException("Dados inv√°lidos"));

        PedidoMessage message = new PedidoMessage();
        message.setPedidoId(123L);

        // Act
        rabbitTemplate.convertAndSend("pedidos", message);

        // Assert - aguardar processamento
        // Verificar que mensagem foi para DLQ
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Nunca expor stack trace** ao cliente
- ‚úÖ **Logar com n√≠vel adequado** (WARN para esperado, ERROR para inesperado)
- ‚úÖ **Usar c√≥digos de erro** consistentes
- ‚úÖ **Incluir traceId** para rastreamento
- ‚úÖ **DLQ para mensageria** (Dead Letter Queue)
- ‚úÖ **N√£o desagendar scheduled tasks** por erro
- ‚úÖ **Alertas para erros cr√≠ticos**
- ‚úÖ **M√©tricas de erro** (Prometheus, Micrometer)

---

## üîó Compara√ß√£o de Tratamento

| Contexto       | Estrat√©gia                    | Propaga√ß√£o              | Retry                  |
| -------------- | ----------------------------- | ----------------------- | ---------------------- |
| **REST**       | @RestControllerAdvice         | Para cliente            | N√£o                    |
| **Async**      | AsyncUncaughtExceptionHandler | Logged, n√£o propagado   | N√£o                    |
| **Mensageria** | ErrorHandler + DLQ            | Requeue ou DLQ          | Sim (autom√°tico)       |
| **Scheduled**  | @Aspect                       | Logged, n√£o propagado   | Sim (pr√≥xima execu√ß√£o) |
| **WebSocket**  | @MessageExceptionHandler      | Para cliente espec√≠fico | N√£o                    |
| **GraphQL**    | DataFetcherExceptionHandler   | GraphQL error           | N√£o                    |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens           | ‚ö†Ô∏è Desvantagens                        |
| ---------------------- | -------------------------------------- |
| Tratamento consistente | Configura√ß√£o complexa                  |
| Controllers limpos     | M√∫ltiplos handlers                     |
| Logs padronizados      | Overhead m√≠nimo                        |
| Observabilidade        | Pode esconder erros se mal configurado |
| Respostas amig√°veis    | Requer testes abrangentes              |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Exception Handling quando:

- Aplica√ß√£o em produ√ß√£o
- API p√∫blica
- M√∫ltiplos contextos (REST, async, messaging)
- Observabilidade necess√°ria
- Experi√™ncia do usu√°rio importante

### ‚ùå Evite over-engineering quando:

- Aplica√ß√£o simples/prot√≥tipo
- Apenas um contexto
- Erros sempre s√£o fatais

---

**Exception Handling garante tratamento consistente de erros em todos os contextos da aplica√ß√£o!** ‚ö†Ô∏è‚ú®
