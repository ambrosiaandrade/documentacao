# 5.3 Anti-Patterns de Testes [TODOS OS N√çVEIS]

üéØ **Objetivo:** Identificar e evitar armadilhas comuns que comprometem efic√°cia, manutenibilidade e confiabilidade dos testes.

---

## ‚ö† O Que S√£o Anti-Patterns?

Anti-patterns s√£o solu√ß√µes aparentemente funcionais, mas que trazem problemas a longo prazo:

- üî¥ **Fragilidade** - Testes quebram por raz√µes erradas
- üî¥ **Lentid√£o** - Execu√ß√£o demorada desestimula TDD
- üî¥ **Falsas Garantias** - Testes passam mas bugs existem
- üî¥ **Manuten√ß√£o Cara** - Dif√≠ceis de entender e modificar

---

## üö´ Anti-Pattern #1: Testes Fr√°geis (Brittle Tests)

### Sintoma

Testes quebram por mudan√ßas irrelevantes na implementa√ß√£o, mesmo sem mudan√ßa de comportamento.

### Causa Raiz

**Over-specification** - Testar detalhes internos em vez de comportamento p√∫blico.

### Exemplo Ruim

```java
// ‚ùå Teste acoplado √† implementa√ß√£o
@Test
void buscarUsuario() {
    service.buscar(1L);

    // Verificando ordem de chamadas internas
    InOrder inOrder = inOrder(cache, database, logger);
    inOrder.verify(cache).get("user:1");
    inOrder.verify(database).findById(1L);
    inOrder.verify(logger).info("Usu√°rio encontrado");

    // Se refatorar ordem das opera√ß√µes, teste quebra!
}
```

### Solu√ß√£o

```java
// ‚úÖ Teste focado em comportamento
@Test
void buscarUsuarioDeveRetornarDados() {
    Usuario resultado = service.buscar(1L);

    assertNotNull(resultado);
    assertEquals("Admin", resultado.getNome());
    // N√£o importa como service.buscar() faz internamente
}
```

---

## üö´ Anti-Pattern #2: Testes Interdependentes

### Sintoma

Testes falham dependendo da ordem de execu√ß√£o ou compartilham estado mut√°vel.

### Exemplo Ruim

```java
// ‚ùå Estado compartilhado entre testes
class CarrinhoTest {
    static Carrinho carrinho = new Carrinho(); // ‚ö†Ô∏è PERIGO

    @Test
    void teste1_adicionarProduto() {
        carrinho.adicionar(new Produto("A"));
        assertEquals(1, carrinho.quantidade());
    }

    @Test
    void teste2_calcularTotal() {
        // Depende de teste1 ter rodado antes!
        assertEquals(10.0, carrinho.total());
    }
}
```

### Solu√ß√£o

```java
// ‚úÖ Cada teste tem estado isolado
class CarrinhoTest {
    Carrinho carrinho; // Inst√¢ncia

    @BeforeEach
    void setup() {
        carrinho = new Carrinho(); // Reset autom√°tico
    }

    @Test
    void adicionarProdutoDeveIncrementarQuantidade() {
        carrinho.adicionar(new Produto("A"));
        assertEquals(1, carrinho.quantidade());
    }

    @Test
    void calcularTotalComUmProduto() {
        carrinho.adicionar(new Produto("A", 10.0));
        assertEquals(10.0, carrinho.total());
    }
}
```

---

## üö´ Anti-Pattern #3: Testes Silenciosos (Silent Catcher)

### Sintoma

Teste engole exce√ß√µes ou falha de forma n√£o √≥bvia.

### Exemplo Ruim

```java
// ‚ùå Exce√ß√£o ignorada, teste passa sempre
@Test
void processarDados() {
    try {
        service.processar(null); // Deve lan√ßar exce√ß√£o
    } catch (Exception e) {
        // Silenciosamente ignorado ‚ö†Ô∏è
    }
    // Teste passa mesmo se n√£o deveria!
}
```

### Solu√ß√£o

```java
// ‚úÖ Exce√ß√£o explicitamente verificada
@Test
void processarNuloDeveLancarExcecao() {
    assertThrows(IllegalArgumentException.class,
        () -> service.processar(null));
}

// ‚úÖ Ou falhar explicitamente se exce√ß√£o n√£o ocorrer
@Test
void processarNuloDeveLancarExcecao() {
    try {
        service.processar(null);
        fail("Deveria ter lan√ßado IllegalArgumentException");
    } catch (IllegalArgumentException e) {
        assertTrue(e.getMessage().contains("n√£o pode ser nulo"));
    }
}
```

---

## üö´ Anti-Pattern #4: Test Fixture Gigante

### Sintoma

Setup complexo e enorme compartilhado por todos os testes.

### Exemplo Ruim

```java
// ‚ùå Setup excessivo
class UsuarioServiceTest {
    Usuario admin, user1, user2, user3;
    Grupo grupoA, grupoB, grupoC;
    Permissao p1, p2, p3, p4, p5;
    Database db;
    Cache cache;
    EmailService email;

    @BeforeEach
    void setup() {
        // 100 linhas criando objetos que a maioria dos testes n√£o usa
        admin = new Usuario("admin");
        user1 = new Usuario("user1");
        // ... 50 mais objetos ...
    }

    @Test
    void buscarPorId() {
        // Usa apenas 'admin', mas setup cria tudo
    }
}
```

### Solu√ß√£o

```java
// ‚úÖ Setup m√≠nimo + m√©todos auxiliares
class UsuarioServiceTest {
    UsuarioService service;

    @BeforeEach
    void setup() {
        service = new UsuarioService();
    }

    @Test
    void buscarPorIdDeveRetornarUsuario() {
        Usuario admin = criarUsuarioAdmin(); // Apenas o necess√°rio
        when(repo.findById(1L)).thenReturn(Optional.of(admin));

        Usuario resultado = service.buscar(1L);
        assertEquals("Admin", resultado.getNome());
    }

    private Usuario criarUsuarioAdmin() {
        return new Usuario("Admin", "admin@test.com");
    }
}
```

---

## üö´ Anti-Pattern #5: N√∫meros M√°gicos

### Sintoma

Valores literais sem contexto ou significado claro.

### Exemplo Ruim

```java
// ‚ùå O que significam esses n√∫meros?
@Test
void calcularDesconto() {
    Pedido p = new Pedido(100.0);
    assertEquals(90.0, p.aplicarDesconto(10), 0.01);
}

@Test
void validarIdade() {
    Usuario u = new Usuario();
    u.setIdadeAnos(17);
    assertFalse(u.podeVotar()); // Por qu√™ 17?
}
```

### Solu√ß√£o

```java
// ‚úÖ Constantes com nomes significativos
@Test
void calcularDescontoDeveReduzirValor() {
    final double VALOR_PEDIDO = 100.0;
    final double PERCENTUAL_DESCONTO = 10.0;
    final double VALOR_ESPERADO = 90.0;

    Pedido p = new Pedido(VALOR_PEDIDO);
    assertEquals(VALOR_ESPERADO, p.aplicarDesconto(PERCENTUAL_DESCONTO), 0.01);
}

@Test
void usuarioMenorDeIdadeNaoPodeVotar() {
    final int IDADE_MENOR = 17;
    Usuario u = new Usuario();
    u.setIdadeAnos(IDADE_MENOR);
    assertFalse(u.podeVotar());
}
```

---

## üö´ Anti-Pattern #6: Sleeps em Testes Ass√≠ncronos

### Sintoma

Uso de `Thread.sleep()` para aguardar opera√ß√µes ass√≠ncronas.

### Problema

- üî¥ Fr√°gil (pode ser insuficiente em m√°quinas lentas)
- üî¥ Lento (espera fixa mesmo se completar antes)
- üî¥ N√£o determin√≠stico (pode falhar esporadicamente)

### Exemplo Ruim

```java
// ‚ùå Sleep fixo √© fr√°gil
@Test
void aguardarProcessamento() throws InterruptedException {
    service.processarAsync();
    Thread.sleep(2000); // E se levar 2001ms?
    assertTrue(service.concluido());
}
```

### Solu√ß√£o

```java
// ‚úÖ Usar Awaitility ou CountDownLatch
@Test
void aguardarProcessamento() {
    service.processarAsync();

    await()
        .atMost(5, SECONDS)
        .pollInterval(100, MILLISECONDS)
        .until(() -> service.concluido());
}

// ‚úÖ Ou CountDownLatch para sincroniza√ß√£o
@Test
void aguardarCallback() throws InterruptedException {
    CountDownLatch latch = new CountDownLatch(1);

    service.processarAsync(() -> latch.countDown());

    assertTrue(latch.await(5, SECONDS),
        "Callback n√£o executou em 5 segundos");
}
```

---

## üö´ Anti-Pattern #7: Ignorar Exce√ß√µes Esperadas

### Sintoma

Teste n√£o valida propriedades da exce√ß√£o lan√ßada.

### Exemplo Ruim

```java
// ‚ùå Valida apenas que exce√ß√£o foi lan√ßada
@Test
void validarCpfInvalido() {
    assertThrows(Exception.class, // Muito gen√©rico!
        () -> validator.validar("000.000.000-00"));
}
```

### Solu√ß√£o

```java
// ‚úÖ Valida tipo espec√≠fico e mensagem
@Test
void validarCpfInvalidoDeveLancarExcecaoEspecifica() {
    CpfInvalidoException ex = assertThrows(
        CpfInvalidoException.class,
        () -> validator.validar("000.000.000-00")
    );

    assertTrue(ex.getMessage().contains("CPF inv√°lido"));
    assertEquals("000.000.000-00", ex.getCpfFornecido());
}
```

---

## üö´ Anti-Pattern #8: Testes que Testam o Framework

### Sintoma

Testar funcionalidades que o framework/JDK j√° garante.

### Exemplo Ruim

```java
// ‚ùå Testando getter/setter sem l√≥gica
@Test
void setNomeDeveDefinirNome() {
    Usuario u = new Usuario();
    u.setNome("Admin");
    assertEquals("Admin", u.getNome());
}

// ‚ùå Testando comportamento do pr√≥prio List
@Test
void listaDeveConterElementoAdicionado() {
    List<String> lista = new ArrayList<>();
    lista.add("A");
    assertTrue(lista.contains("A"));
}
```

### Quando Testar Getters/Setters

```java
// ‚úÖ Testar quando h√° L√ìGICA
@Test
void setIdadeDeveNormalizarValorNegativo() {
    Usuario u = new Usuario();
    u.setIdade(-5); // L√≥gica: normaliza para 0
    assertEquals(0, u.getIdade());
}

@Test
void getNomeCompletoDeveConcatenarNomeSobrenome() {
    Usuario u = new Usuario("Jo√£o", "Silva");
    assertEquals("Jo√£o Silva", u.getNomeCompleto());
}
```

---

## üö´ Anti-Pattern #9: Assertions Gen√©ricas Demais

### Sintoma

Valida√ß√µes que n√£o garantem o comportamento esperado.

### Exemplo Ruim

```java
// ‚ùå N√£o valida nada relevante
@Test
void buscarUsuarios() {
    List<Usuario> usuarios = service.buscarTodos();
    assertNotNull(usuarios); // Pode ser lista vazia
}

// ‚ùå Gen√©rico demais
@Test
void processar() {
    Object resultado = service.processar();
    assertTrue(resultado instanceof Resultado); // E da√≠?
}
```

### Solu√ß√£o

```java
// ‚úÖ Assertions espec√≠ficas
@Test
void buscarUsuariosDeveRetornarLista() {
    List<Usuario> usuarios = service.buscarTodos();

    assertNotNull(usuarios);
    assertFalse(usuarios.isEmpty(), "Lista n√£o deve estar vazia");
    assertTrue(usuarios.size() >= 2, "Deve ter pelo menos 2 usu√°rios");
    assertEquals("Admin", usuarios.get(0).getNome());
}

// ‚úÖ Valida estado completo
@Test
void processarDeveRetornarResultadoComStatusOk() {
    Resultado resultado = service.processar();

    assertEquals(Status.OK, resultado.getStatus());
    assertNotNull(resultado.getData());
    assertTrue(resultado.getErros().isEmpty());
}
```

---

## üö´ Anti-Pattern #10: Test Code Duplication

### Sintoma

Copiar e colar setup/teardown/dados entre testes.

### Exemplo Ruim

```java
// ‚ùå Setup duplicado
@Test
void teste1() {
    Usuario u = new Usuario("Admin", "admin@test.com");
    u.setAtivo(true);
    u.setRole(Role.ADMIN);
    // Teste...
}

@Test
void teste2() {
    Usuario u = new Usuario("Admin", "admin@test.com");
    u.setAtivo(true);
    u.setRole(Role.ADMIN);
    // Teste...
}
```

### Solu√ß√£o

```java
// ‚úÖ Object Mother / Test Data Builder
class UsuarioBuilder {
    private String nome = "User";
    private String email = "user@test.com";
    private boolean ativo = true;
    private Role role = Role.USER;

    UsuarioBuilder admin() {
        this.nome = "Admin";
        this.email = "admin@test.com";
        this.role = Role.ADMIN;
        return this;
    }

    Usuario build() {
        Usuario u = new Usuario(nome, email);
        u.setAtivo(ativo);
        u.setRole(role);
        return u;
    }
}

class UsuarioTest {
    @Test
    void teste1() {
        Usuario admin = new UsuarioBuilder().admin().build();
        // Teste...
    }

    @Test
    void teste2() {
        Usuario admin = new UsuarioBuilder().admin().build();
        // Teste...
    }
}
```

---

## üö´ Anti-Pattern #11: Testes Condicionais (Logic in Tests)

### Sintoma

Uso de `if`, `for`, `while` dentro de testes.

### Problema

- üî¥ Testes devem ser declarativos, n√£o imperativos
- üî¥ L√≥gica pode ter bugs (quem testa os testes?)
- üî¥ Dificulta entendimento

### Exemplo Ruim

```java
// ‚ùå L√≥gica condicional no teste
@Test
void validarUsuarios() {
    List<Usuario> usuarios = service.buscarTodos();

    for (Usuario u : usuarios) {
        if (u.getRole() == Role.ADMIN) {
            assertTrue(u.isAtivo());
        } else {
            // Pode estar ativo ou n√£o
        }
    }
}
```

### Solu√ß√£o

```java
// ‚úÖ Teste parametrizado declarativo
@ParameterizedTest
@MethodSource("adminUsuarios")
void todosAdminsDevemEstarAtivos(Usuario admin) {
    assertTrue(admin.isAtivo());
}

static Stream<Usuario> adminUsuarios() {
    return service.buscarTodos().stream()
        .filter(u -> u.getRole() == Role.ADMIN);
}
```

---

## üö´ Anti-Pattern #12: Catching Exceptions Wrong

### Sintoma

Estruturas try-catch desnecess√°rias ou incorretas.

### Exemplo Ruim

```java
// ‚ùå Padr√£o obsoleto (JUnit 4)
@Test
void deveLancarExcecao() {
    try {
        service.processar(null);
        fail("Deveria ter lan√ßado exce√ß√£o");
    } catch (IllegalArgumentException e) {
        // Esperado
    }
}
```

### Solu√ß√£o

```java
// ‚úÖ JUnit 5: assertThrows
@Test
void deveLancarExcecao() {
    assertThrows(IllegalArgumentException.class,
        () -> service.processar(null));
}
```

---

## ‚úÖ Checklist de Preven√ß√£o

- [ ] Testes focam em **comportamento p√∫blico**, n√£o implementa√ß√£o?
- [ ] **Nenhum estado compartilhado** entre testes?
- [ ] Exce√ß√µes s√£o **verificadas explicitamente** com assertThrows?
- [ ] Setup √© **m√≠nimo e espec√≠fico** para cada teste?
- [ ] **Nenhum n√∫mero m√°gico** sem constante nomeada?
- [ ] Testes ass√≠ncronos usam **await/latch**, n√£o sleep?
- [ ] Exce√ß√µes validam **tipo espec√≠fico e mensagem**?
- [ ] N√£o h√° testes de **getters/setters triviais**?
- [ ] Assertions s√£o **espec√≠ficas**, n√£o gen√©ricas (assertNotNull)?
- [ ] Evitado **code duplication** com builders/factories?
- [ ] **Sem l√≥gica condicional** (if/for) dentro de testes?
- [ ] Uso de **assertThrows** em vez de try-catch?

---

## üß† Perguntas Reflexivas

1. Como identificar se um teste est√° "testando demais"?
2. Qual o custo de manuten√ß√£o de testes fr√°geis vs robustos?
3. Quando duplica√ß√£o de setup √© aceit√°vel vs quando usar builder?
4. Por que testes com l√≥gica condicional s√£o problem√°ticos?
5. Como balancear cobertura vs fragilidade?

---

## üìö Refer√™ncias

- **Livros:**

  - "xUnit Test Patterns: Refactoring Test Code" (Gerard Meszaros)
  - "Growing Object-Oriented Software, Guided by Tests" (Freeman & Pryce)

- **Artigos:**
  - [Test Smells](http://xunitpatterns.com/Test%20Smells.html) - Gerard Meszaros
  - [Anti-patterns](https://blog.codepipes.com/testing/software-testing-antipatterns.html)

---

## üìö Pr√≥ximos Passos

- [5.1 Princ√≠pios Fundamentais](05.1-principios-testes.md) - Base te√≥rica
- [5.2 Boas Pr√°ticas](05.2-boas-praticas.md) - Padr√µes recomendados
- [5.4 Gloss√°rio](05.4-glossario.md) - Termos t√©cnicos
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [TODOS OS N√çVEIS]  
**Tempo Estimado:** 1,5 horas
