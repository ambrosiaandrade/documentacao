# 05.6 Bean Validation (Jakarta/Javax) [TRANSVERSAL] ‚úÖ

## üéØ Objetivo

Dominar **Bean Validation** (Jakarta Validation / Javax Validation) para **valida√ß√£o declarativa** de dados com **anota√ß√µes**, **validators customizados**, **grupos de valida√ß√£o** e **integra√ß√£o com Spring**.

---

## üìö O que √© Bean Validation?

**Bean Validation** √© uma especifica√ß√£o Java que permite **validar objetos** de forma **declarativa** usando **anota√ß√µes**.

**Implementa√ß√£o padr√£o:** **Hibernate Validator**

---

## üèóÔ∏è Configura√ß√£o

### pom.xml

```xml
<dependencies>
    <!-- Bean Validation API -->
    <dependency>
        <groupId>jakarta.validation</groupId>
        <artifactId>jakarta.validation-api</artifactId>
        <version>3.0.2</version>
    </dependency>

    <!-- Hibernate Validator (implementa√ß√£o) -->
    <dependency>
        <groupId>org.hibernate.validator</groupId>
        <artifactId>hibernate-validator</artifactId>
        <version>8.0.1.Final</version>
    </dependency>

    <!-- Spring Boot Starter (j√° inclui validation) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
</dependencies>
```

---

## üìù Anota√ß√µes Padr√£o

### Valida√ß√£o de Strings

```java
public class UserDTO {

    @NotNull(message = "Nome n√£o pode ser nulo")
    @NotBlank(message = "Nome n√£o pode estar em branco")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    private String nome;

    @NotEmpty(message = "Email n√£o pode estar vazio")
    @Email(message = "Email inv√°lido")
    private String email;

    @Pattern(
        regexp = "^\\d{11}$",
        message = "CPF deve conter 11 d√≠gitos"
    )
    private String cpf;

    @Size(min = 8, message = "Senha deve ter no m√≠nimo 8 caracteres")
    @Pattern(
        regexp = "^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d).*$",
        message = "Senha deve conter letras mai√∫sculas, min√∫sculas e n√∫meros"
    )
    private String senha;
}
```

### Valida√ß√£o Num√©rica

```java
public class ProductDTO {

    @NotNull
    @Positive(message = "Pre√ßo deve ser positivo")
    @DecimalMin(value = "0.01", message = "Pre√ßo m√≠nimo √© 0.01")
    @DecimalMax(value = "99999.99", message = "Pre√ßo m√°ximo √© 99999.99")
    @Digits(integer = 5, fraction = 2, message = "Pre√ßo deve ter no m√°ximo 5 d√≠gitos inteiros e 2 decimais")
    private BigDecimal preco;

    @Min(value = 0, message = "Estoque n√£o pode ser negativo")
    @Max(value = 10000, message = "Estoque m√°ximo √© 10000")
    private Integer estoque;

    @PositiveOrZero(message = "Desconto deve ser zero ou positivo")
    @Max(value = 100, message = "Desconto m√°ximo √© 100%")
    private Integer descontoPercentual;
}
```

### Valida√ß√£o de Datas

```java
public class EventDTO {

    @NotNull
    @Future(message = "Data do evento deve ser futura")
    private LocalDate dataEvento;

    @PastOrPresent(message = "Data de cadastro deve ser passada ou presente")
    private LocalDateTime dataCadastro;

    @NotNull
    private LocalDate dataInicio;

    @NotNull
    private LocalDate dataFim;
}
```

### Valida√ß√£o de Cole√ß√µes

```java
public class OrderDTO {

    @NotNull
    @NotEmpty(message = "Pedido deve ter pelo menos um item")
    @Size(min = 1, max = 50, message = "Pedido deve ter entre 1 e 50 items")
    @Valid  // Valida cada item da lista
    private List<OrderItemDTO> items;

    @NotNull
    @Valid
    private AddressDTO endereco;
}
```

### Valida√ß√£o Booleana

```java
public class TermsDTO {

    @NotNull
    @AssertTrue(message = "Voc√™ deve aceitar os termos de uso")
    private Boolean aceitouTermos;

    @AssertFalse(message = "Usu√°rio n√£o deve estar bloqueado")
    private Boolean bloqueado;
}
```

---

## üß™ Usando @Valid em Controllers

### Controller com Valida√ß√£o

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @PostMapping
    public ResponseEntity<UserDTO> createUser(@Valid @RequestBody UserDTO userDTO) {
        // Se valida√ß√£o falhar, Spring retorna 400 Bad Request automaticamente
        User user = userService.create(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(
        @PathVariable Long id,
        @Valid @RequestBody UserDTO userDTO
    ) {
        User user = userService.update(id, userDTO);
        return ResponseEntity.ok(user);
    }
}
```

### Exception Handler para Valida√ß√£o

```java
@RestControllerAdvice
public class ValidationExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleValidationException(MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getFieldErrors().forEach(error -> {
            errors.put(error.getField(), error.getDefaultMessage());
        });

        return ErrorResponse.builder()
            .message("Erro de valida√ß√£o")
            .timestamp(LocalDateTime.now())
            .errors(errors)
            .build();
    }

    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponse handleConstraintViolation(ConstraintViolationException ex) {

        Map<String, String> errors = new HashMap<>();

        ex.getConstraintViolations().forEach(violation -> {
            String propertyPath = violation.getPropertyPath().toString();
            errors.put(propertyPath, violation.getMessage());
        });

        return ErrorResponse.builder()
            .message("Erro de valida√ß√£o")
            .timestamp(LocalDateTime.now())
            .errors(errors)
            .build();
    }
}
```

---

## üé® Validators Customizados

### Annotation Customizada: @CPF

```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CpfValidator.class)
@Documented
public @interface CPF {

    String message() default "CPF inv√°lido";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

### Validator Implementation

```java
public class CpfValidator implements ConstraintValidator<CPF, String> {

    @Override
    public void initialize(CPF constraintAnnotation) {
        // Inicializa√ß√£o (opcional)
    }

    @Override
    public boolean isValid(String cpf, ConstraintValidatorContext context) {
        if (cpf == null || cpf.isBlank()) {
            return true;  // @NotNull/@NotBlank vai validar isso
        }

        // Remove formata√ß√£o
        cpf = cpf.replaceAll("[^\\d]", "");

        // Valida tamanho
        if (cpf.length() != 11) {
            return false;
        }

        // Valida se todos os d√≠gitos s√£o iguais (00000000000, 11111111111, etc)
        if (cpf.matches("(\\d)\\1{10}")) {
            return false;
        }

        // Calcula d√≠gitos verificadores
        try {
            int sum1 = 0;
            for (int i = 0; i < 9; i++) {
                sum1 += Character.getNumericValue(cpf.charAt(i)) * (10 - i);
            }
            int digit1 = 11 - (sum1 % 11);
            digit1 = (digit1 > 9) ? 0 : digit1;

            int sum2 = 0;
            for (int i = 0; i < 10; i++) {
                sum2 += Character.getNumericValue(cpf.charAt(i)) * (11 - i);
            }
            int digit2 = 11 - (sum2 % 11);
            digit2 = (digit2 > 9) ? 0 : digit2;

            return Character.getNumericValue(cpf.charAt(9)) == digit1 &&
                   Character.getNumericValue(cpf.charAt(10)) == digit2;

        } catch (Exception e) {
            return false;
        }
    }
}
```

### Usando Validator Customizado

```java
public class UserDTO {

    @NotBlank
    @CPF(message = "CPF inv√°lido")
    private String cpf;
}
```

---

## üîÑ Valida√ß√£o Cross-Field

### Annotation: @PasswordMatches

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
@Documented
public @interface PasswordMatches {

    String message() default "Senha e confirma√ß√£o n√£o coincidem";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

### Validator Implementation

```java
public class PasswordMatchesValidator implements ConstraintValidator<PasswordMatches, Object> {

    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        if (obj == null) {
            return true;
        }

        try {
            Field passwordField = obj.getClass().getDeclaredField("senha");
            Field confirmPasswordField = obj.getClass().getDeclaredField("confirmacaoSenha");

            passwordField.setAccessible(true);
            confirmPasswordField.setAccessible(true);

            String password = (String) passwordField.get(obj);
            String confirmPassword = (String) confirmPasswordField.get(obj);

            return password != null && password.equals(confirmPassword);

        } catch (Exception e) {
            return false;
        }
    }
}
```

### DTO com Valida√ß√£o Cross-Field

```java
@PasswordMatches
public class RegistrationDTO {

    @NotBlank
    @Size(min = 8)
    private String senha;

    @NotBlank
    private String confirmacaoSenha;
}
```

---

## üë• Grupos de Valida√ß√£o

### Definir Grupos

```java
public interface OnCreate {}
public interface OnUpdate {}
```

### DTO com Grupos

```java
public class UserDTO {

    @Null(groups = OnCreate.class, message = "ID deve ser nulo na cria√ß√£o")
    @NotNull(groups = OnUpdate.class, message = "ID √© obrigat√≥rio na atualiza√ß√£o")
    private Long id;

    @NotBlank(groups = {OnCreate.class, OnUpdate.class})
    @Size(min = 3, max = 100)
    private String nome;

    @NotBlank(groups = OnCreate.class, message = "Email √© obrigat√≥rio")
    @Email(groups = {OnCreate.class, OnUpdate.class})
    private String email;

    @NotBlank(groups = OnCreate.class, message = "Senha √© obrigat√≥ria na cria√ß√£o")
    @Size(min = 8, groups = {OnCreate.class, OnUpdate.class})
    private String senha;
}
```

### Controller com Grupos

```java
@RestController
@RequestMapping("/api/users")
@Validated  // Habilita valida√ß√£o de grupos
public class UserController {

    @PostMapping
    public ResponseEntity<UserDTO> createUser(
        @Validated(OnCreate.class) @RequestBody UserDTO userDTO
    ) {
        // Valida com grupo OnCreate
        User user = userService.create(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }

    @PutMapping("/{id}")
    public ResponseEntity<UserDTO> updateUser(
        @PathVariable Long id,
        @Validated(OnUpdate.class) @RequestBody UserDTO userDTO
    ) {
        // Valida com grupo OnUpdate
        User user = userService.update(id, userDTO);
        return ResponseEntity.ok(user);
    }
}
```

---

## üß™ Valida√ß√£o Program√°tica

### Validator Program√°tico

```java
@Service
public class UserValidationService {

    private final Validator validator;

    public UserValidationService(Validator validator) {
        this.validator = validator;
    }

    public void validateUser(UserDTO userDTO) {
        Set<ConstraintViolation<UserDTO>> violations = validator.validate(userDTO);

        if (!violations.isEmpty()) {
            StringBuilder sb = new StringBuilder();
            for (ConstraintViolation<UserDTO> violation : violations) {
                sb.append(violation.getPropertyPath())
                  .append(": ")
                  .append(violation.getMessage())
                  .append("\n");
            }
            throw new ValidationException(sb.toString());
        }
    }

    public void validateUserForGroup(UserDTO userDTO, Class<?> group) {
        Set<ConstraintViolation<UserDTO>> violations = validator.validate(userDTO, group);

        if (!violations.isEmpty()) {
            throw new ValidationException("Validation failed for group: " + group.getSimpleName());
        }
    }
}
```

---

## üìã Anota√ß√µes de Valida√ß√£o - Refer√™ncia Completa

| Anota√ß√£o           | Descri√ß√£o                                      | Exemplo                                 |
| ------------------ | ---------------------------------------------- | --------------------------------------- |
| `@NotNull`         | N√£o pode ser null                              | `@NotNull private String nome;`         |
| `@NotBlank`        | N√£o pode ser null, vazio ou apenas espa√ßos     | `@NotBlank private String email;`       |
| `@NotEmpty`        | N√£o pode ser null ou vazio (String/Collection) | `@NotEmpty private List<Item> items;`   |
| `@Size`            | Tamanho entre min e max                        | `@Size(min=3, max=100)`                 |
| `@Min`             | Valor m√≠nimo                                   | `@Min(18) private Integer idade;`       |
| `@Max`             | Valor m√°ximo                                   | `@Max(100) private Integer percent;`    |
| `@DecimalMin`      | Valor decimal m√≠nimo                           | `@DecimalMin("0.01")`                   |
| `@DecimalMax`      | Valor decimal m√°ximo                           | `@DecimalMax("999.99")`                 |
| `@Positive`        | Deve ser positivo (> 0)                        | `@Positive private BigDecimal preco;`   |
| `@PositiveOrZero`  | Deve ser >= 0                                  | `@PositiveOrZero private Integer qty;`  |
| `@Negative`        | Deve ser negativo (< 0)                        | `@Negative private BigDecimal debt;`    |
| `@NegativeOrZero`  | Deve ser <= 0                                  | `@NegativeOrZero`                       |
| `@Past`            | Data no passado                                | `@Past private LocalDate birthDate;`    |
| `@PastOrPresent`   | Data passada ou presente                       | `@PastOrPresent`                        |
| `@Future`          | Data futura                                    | `@Future private LocalDate event;`      |
| `@FutureOrPresent` | Data futura ou presente                        | `@FutureOrPresent`                      |
| `@Email`           | Email v√°lido                                   | `@Email private String email;`          |
| `@Pattern`         | Regex pattern                                  | `@Pattern(regexp="\\d{11}")`            |
| `@Digits`          | D√≠gitos inteiros e fracion√°rios                | `@Digits(integer=5, fraction=2)`        |
| `@AssertTrue`      | Deve ser true                                  | `@AssertTrue private Boolean terms;`    |
| `@AssertFalse`     | Deve ser false                                 | `@AssertFalse private Boolean blocked;` |
| `@Valid`           | Valida objeto nested                           | `@Valid private Address address;`       |

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Sempre use mensagens descritivas
@NotBlank(message = "Nome √© obrigat√≥rio")

// ‚úÖ Combine valida√ß√µes quando necess√°rio
@NotBlank
@Size(min = 3, max = 100)
@Pattern(regexp = "[A-Za-z ]+")
private String nome;

// ‚úÖ Use @Valid para objetos nested
@Valid
private Address endereco;

// ‚úÖ Use grupos para cen√°rios diferentes
@Validated(OnCreate.class)

// ‚úÖ Crie validators customizados para regras complexas
@CPF
@CNPJ
@PhoneNumber

// ‚úÖ Exception handlers centralizados
@RestControllerAdvice

// ‚úÖ Valida√ß√£o program√°tica quando necess√°rio
validator.validate(object);
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Mensagens gen√©ricas
@NotBlank(message = "Invalid")  // ‚ùå

// ‚úÖ Mensagens espec√≠ficas
@NotBlank(message = "Nome √© obrigat√≥rio")

// ‚ùå Valida√ß√£o manual no controller
if (dto.getNome() == null) {  // ‚ùå
    throw new Exception("Nome obrigat√≥rio");
}

// ‚úÖ Use Bean Validation
@Valid @RequestBody UserDTO dto

// ‚ùå Ignorar valida√ß√£o de nested objects
private Address endereco;  // ‚ùå N√£o valida campos de Address

// ‚úÖ Use @Valid
@Valid
private Address endereco;

// ‚ùå Valida√ß√£o duplicada (controller + service)
// Valida√ß√£o j√° est√° no DTO

// ‚úÖ Validar uma vez (no controller com @Valid)

// ‚ùå Regex complexos inline
@Pattern(regexp = "^(?=.*[A-Z])(?=.*[a-z])...")  // ‚ùå Dif√≠cil ler

// ‚úÖ Validator customizado
@StrongPassword
```

---

## üéØ Quando Usar Bean Validation?

### ‚úÖ Use quando:

- Validar **dados de entrada** (DTOs, formul√°rios)
- Regras de valida√ß√£o **declarativas** e **reutiliz√°veis**
- Valida√ß√£o em **m√∫ltiplas camadas** (REST, service)
- **Feedback autom√°tico** ao cliente (400 Bad Request)

### ‚ùå N√£o use quando:

- Valida√ß√µes que requerem **acesso a banco de dados**
- **L√≥gica de neg√≥cio complexa** (usar service layer)
- Valida√ß√µes **ass√≠ncronas**
- **Performance cr√≠tica** (valida√ß√£o tem overhead)

---

## üìù Resumo

**Bean Validation** fornece:

- ‚úÖ **Valida√ß√£o declarativa**: Anota√ß√µes no DTO
- ‚úÖ **Padroniza√ß√£o**: Jakarta/Javax Validation spec
- ‚úÖ **Integra√ß√£o Spring**: @Valid, @Validated
- ‚úÖ **Validators customizados**: @CPF, @CNPJ, etc
- ‚úÖ **Grupos de valida√ß√£o**: OnCreate, OnUpdate
- ‚úÖ **Cross-field validation**: @PasswordMatches
- ‚úÖ **Exception handling**: @RestControllerAdvice
- ‚úÖ **Valida√ß√£o program√°tica**: Validator.validate()

**Regra de ouro:** Use Bean Validation para **valida√ß√µes simples e declarativas** nos DTOs, e delegue **l√≥gica de neg√≥cio complexa** para a camada de servi√ßo.

---

**√öltima Atualiza√ß√£o:** 2025-11-15  
**N√≠vel:** TRANSVERSAL  
**Tempo Estimado:** 40 minutos
