# 05.9 Princ√≠pios de Desenvolvimento [INTERMEDI√ÅRIO] üìê

## üéØ Objetivo

Aplicar **princ√≠pios fundamentais de desenvolvimento** (SOLID, DRY, KISS, YAGNI) para criar c√≥digo **manuten√≠vel**, **test√°vel** e **escal√°vel** em Java/Spring Boot.

---

## üìö O Que S√£o?

**Princ√≠pios de desenvolvimento** s√£o **diretrizes universais** que guiam decis√µes de design, promovendo c√≥digo de alta qualidade independente da tecnologia ou framework.

### Analogia

Como **leis da f√≠sica** para engenharia:

- **Sem Princ√≠pios**: Constru√ß√£o inst√°vel que desmorona
- **Com Princ√≠pios**: Estrutura s√≥lida que resiste ao tempo
- **Vantagem**: C√≥digo que evolui sem quebrar

---

## üèõÔ∏è SOLID

### S - Single Responsibility Principle (SRP)

**"Uma classe deve ter uma, e apenas uma, raz√£o para mudar"**

#### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Classe com m√∫ltiplas responsabilidades

@Service
public class PedidoService {

    // Responsabilidade 1: L√≥gica de neg√≥cio
    public Pedido criar(PedidoRequest request) {
        Pedido pedido = new Pedido();
        pedido.setClienteId(request.getClienteId());
        pedido.setTotal(calcularTotal(request.getItens()));

        // Responsabilidade 2: Persist√™ncia
        entityManager.persist(pedido);

        // Responsabilidade 3: Notifica√ß√£o
        String emailBody = """
            Pedido #%s criado com sucesso!
            Total: R$ %.2f
            """.formatted(pedido.getId(), pedido.getTotal());

        try {
            MimeMessage message = mailSender.createMimeMessage();
            message.setRecipient(Message.RecipientType.TO, new InternetAddress(cliente.getEmail()));
            message.setSubject("Pedido Criado");
            message.setText(emailBody);
            mailSender.send(message);
        } catch (Exception e) {
            log.error("Erro ao enviar email", e);
        }

        // Responsabilidade 4: Logging
        log.info("Pedido {} criado para cliente {}", pedido.getId(), pedido.getClienteId());

        return pedido;
    }
}
```

**Problemas:**

- ‚ùå Mudan√ßas em email quebram l√≥gica de pedido
- ‚ùå Imposs√≠vel testar l√≥gica isoladamente
- ‚ùå Dif√≠cil reutilizar componentes
- ‚ùå Viola Open/Closed Principle

#### ‚úÖ Aplicando SRP

```java
// ‚úÖ SOLU√á√ÉO: Uma responsabilidade por classe

// 1Ô∏è‚É£ L√≥gica de Neg√≥cio
@Service
@RequiredArgsConstructor
public class PedidoService {

    private final PedidoRepository repository;
    private final PedidoNotificationService notificationService;

    public Pedido criar(PedidoRequest request) {
        Pedido pedido = new Pedido();
        pedido.setClienteId(request.getClienteId());
        pedido.setTotal(calcularTotal(request.getItens()));

        pedido = repository.save(pedido);

        notificationService.notificarPedidoCriado(pedido);

        return pedido;
    }

    private BigDecimal calcularTotal(List<ItemPedido> itens) {
        return itens.stream()
                .map(ItemPedido::getSubtotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// 2Ô∏è‚É£ Persist√™ncia (Spring Data j√° implementa)
@Repository
public interface PedidoRepository extends JpaRepository<Pedido, Long> {
}

// 3Ô∏è‚É£ Notifica√ß√£o
@Service
@RequiredArgsConstructor
public class PedidoNotificationService {

    private final EmailService emailService;
    private final ClienteRepository clienteRepository;

    public void notificarPedidoCriado(Pedido pedido) {
        Cliente cliente = clienteRepository.findById(pedido.getClienteId())
                .orElseThrow();

        EmailMessage email = EmailMessage.builder()
                .to(cliente.getEmail())
                .subject("Pedido Criado")
                .body("Pedido #" + pedido.getId() + " criado com sucesso!")
                .build();

        emailService.enviar(email);
    }
}

// 4Ô∏è‚É£ Envio de Email
@Service
@RequiredArgsConstructor
public class EmailService {

    private final JavaMailSender mailSender;

    public void enviar(EmailMessage message) {
        try {
            MimeMessage mimeMessage = mailSender.createMimeMessage();
            mimeMessage.setRecipient(Message.RecipientType.TO,
                    new InternetAddress(message.getTo()));
            mimeMessage.setSubject(message.getSubject());
            mimeMessage.setText(message.getBody());
            mailSender.send(mimeMessage);
        } catch (Exception e) {
            throw new EmailException("Falha ao enviar email", e);
        }
    }
}
```

**Benef√≠cios:**

- ‚úÖ Cada classe tem uma raz√£o para mudar
- ‚úÖ F√°cil testar isoladamente
- ‚úÖ Reutiliz√°vel em outros contextos
- ‚úÖ Facilita manuten√ß√£o

---

### O - Open/Closed Principle (OCP)

**"Entidades devem estar abertas para extens√£o, mas fechadas para modifica√ß√£o"**

#### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Modifica√ß√£o para adicionar novos tipos

public class DescontoService {

    public BigDecimal calcular(Pedido pedido, String tipoCliente) {
        if (tipoCliente.equals("VIP")) {
            return pedido.getTotal().multiply(BigDecimal.valueOf(0.20)); // 20%
        } else if (tipoCliente.equals("GOLD")) {
            return pedido.getTotal().multiply(BigDecimal.valueOf(0.15)); // 15%
        } else if (tipoCliente.equals("SILVER")) {
            return pedido.getTotal().multiply(BigDecimal.valueOf(0.10)); // 10%
        } else {
            return BigDecimal.ZERO;
        }
    }
}
```

**Problemas:**

- ‚ùå Adicionar novo tipo exige modificar m√©todo
- ‚ùå Quebra testes existentes
- ‚ùå L√≥gica n√£o reutiliz√°vel

#### ‚úÖ Aplicando OCP (Strategy Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Extens√≠vel via polimorfismo

// Interface
public interface DescontoStrategy {
    BigDecimal calcular(Pedido pedido);
    boolean aplicavelPara(TipoCliente tipo);
}

// Implementa√ß√µes
@Component
public class DescontoVipStrategy implements DescontoStrategy {

    @Override
    public BigDecimal calcular(Pedido pedido) {
        return pedido.getTotal().multiply(BigDecimal.valueOf(0.20));
    }

    @Override
    public boolean aplicavelPara(TipoCliente tipo) {
        return tipo == TipoCliente.VIP;
    }
}

@Component
public class DescontoGoldStrategy implements DescontoStrategy {

    @Override
    public BigDecimal calcular(Pedido pedido) {
        return pedido.getTotal().multiply(BigDecimal.valueOf(0.15));
    }

    @Override
    public boolean aplicavelPara(TipoCliente tipo) {
        return tipo == TipoCliente.GOLD;
    }
}

// Service (fechado para modifica√ß√£o)
@Service
@RequiredArgsConstructor
public class DescontoService {

    private final List<DescontoStrategy> strategies;

    public BigDecimal calcular(Pedido pedido, TipoCliente tipoCliente) {
        return strategies.stream()
                .filter(strategy -> strategy.aplicavelPara(tipoCliente))
                .findFirst()
                .map(strategy -> strategy.calcular(pedido))
                .orElse(BigDecimal.ZERO);
    }
}

// ‚úÖ Adicionar novo desconto SEM modificar c√≥digo existente
@Component
public class DescontoPlatinumStrategy implements DescontoStrategy {

    @Override
    public BigDecimal calcular(Pedido pedido) {
        return pedido.getTotal().multiply(BigDecimal.valueOf(0.25)); // 25%
    }

    @Override
    public boolean aplicavelPara(TipoCliente tipo) {
        return tipo == TipoCliente.PLATINUM;
    }
}
```

**Benef√≠cios:**

- ‚úÖ Novos descontos n√£o modificam c√≥digo existente
- ‚úÖ Testes antigos continuam v√°lidos
- ‚úÖ Cada estrat√©gia test√°vel isoladamente

---

### L - Liskov Substitution Principle (LSP)

**"Subtipos devem ser substitu√≠veis por seus tipos base"**

#### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Subtipo quebra contrato da superclasse

public class Retangulo {
    protected int largura;
    protected int altura;

    public void setLargura(int largura) {
        this.largura = largura;
    }

    public void setAltura(int altura) {
        this.altura = altura;
    }

    public int calcularArea() {
        return largura * altura;
    }
}

public class Quadrado extends Retangulo {

    @Override
    public void setLargura(int largura) {
        this.largura = largura;
        this.altura = largura; // ‚ùå Viola LSP: altera comportamento inesperado
    }

    @Override
    public void setAltura(int altura) {
        this.largura = altura;
        this.altura = altura; // ‚ùå Viola LSP
    }
}

// Teste que quebra
void testeRetangulo(Retangulo retangulo) {
    retangulo.setLargura(5);
    retangulo.setAltura(4);

    assertEquals(20, retangulo.calcularArea()); // ‚úÖ Retangulo: OK
                                                 // ‚ùå Quadrado: Falha (16 != 20)
}
```

#### ‚úÖ Aplicando LSP

```java
// ‚úÖ SOLU√á√ÉO: Composi√ß√£o ao inv√©s de heran√ßa

public interface Forma {
    int calcularArea();
}

public class Retangulo implements Forma {
    private final int largura;
    private final int altura;

    public Retangulo(int largura, int altura) {
        this.largura = largura;
        this.altura = altura;
    }

    @Override
    public int calcularArea() {
        return largura * altura;
    }
}

public class Quadrado implements Forma {
    private final int lado;

    public Quadrado(int lado) {
        this.lado = lado;
    }

    @Override
    public int calcularArea() {
        return lado * lado;
    }
}

// Uso consistente
void testeForma(Forma forma) {
    int area = forma.calcularArea(); // ‚úÖ Funciona para qualquer Forma
    assertTrue(area > 0);
}
```

**Exemplo Real - Spring Boot:**

```java
// ‚úÖ LSP respeitado: qualquer Repository √© substitu√≠vel

public interface ClienteRepository extends JpaRepository<Cliente, Long> {
    List<Cliente> findByNome(String nome);
}

public interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByClienteId(Long clienteId);
}

// Service gen√©rico funciona com qualquer repository
public <T, ID> void auditarEntidade(JpaRepository<T, ID> repository, ID id) {
    repository.findById(id).ifPresent(entity -> {
        log.info("Auditando: {}", entity);
    });
}
```

---

### I - Interface Segregation Principle (ISP)

**"Clientes n√£o devem depender de interfaces que n√£o usam"**

#### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Interface "fat" com m√©todos desnecess√°rios

public interface PagamentoService {
    void processarCartaoCredito(CartaoCredito cartao);
    void processarBoleto(Boleto boleto);
    void processarPix(Pix pix);
    void processarPayPal(PayPal paypal);
    void reembolsarCartao(String transacaoId);
    void cancelarBoleto(String boletoId);
}

// Implementa√ß√£o for√ßada a implementar m√©todos n√£o suportados
public class BoletoPagamentoService implements PagamentoService {

    @Override
    public void processarBoleto(Boleto boleto) {
        // Implementa√ß√£o real
    }

    @Override
    public void cancelarBoleto(String boletoId) {
        // Implementa√ß√£o real
    }

    @Override
    public void processarCartaoCredito(CartaoCredito cartao) {
        throw new UnsupportedOperationException("N√£o suportado"); // ‚ùå
    }

    @Override
    public void processarPix(Pix pix) {
        throw new UnsupportedOperationException("N√£o suportado"); // ‚ùå
    }

    @Override
    public void processarPayPal(PayPal paypal) {
        throw new UnsupportedOperationException("N√£o suportado"); // ‚ùå
    }

    @Override
    public void reembolsarCartao(String transacaoId) {
        throw new UnsupportedOperationException("N√£o suportado"); // ‚ùå
    }
}
```

#### ‚úÖ Aplicando ISP

```java
// ‚úÖ SOLU√á√ÉO: Interfaces segregadas

// Interface base
public interface PagamentoProcessor<T> {
    void processar(T pagamento);
}

// Interfaces espec√≠ficas
public interface CartaoCreditoProcessor extends PagamentoProcessor<CartaoCredito> {
    void reembolsar(String transacaoId);
}

public interface BoletoProcessor extends PagamentoProcessor<Boleto> {
    void cancelar(String boletoId);
}

public interface PixProcessor extends PagamentoProcessor<Pix> {
    // Pix n√£o tem m√©todos adicionais
}

// Implementa√ß√µes focadas
@Service
public class CartaoCreditoService implements CartaoCreditoProcessor {

    @Override
    public void processar(CartaoCredito cartao) {
        // Implementa√ß√£o
    }

    @Override
    public void reembolsar(String transacaoId) {
        // Implementa√ß√£o
    }
}

@Service
public class BoletoService implements BoletoProcessor {

    @Override
    public void processar(Boleto boleto) {
        // Implementa√ß√£o
    }

    @Override
    public void cancelar(String boletoId) {
        // Implementa√ß√£o
    }
}
```

**Benef√≠cios:**

- ‚úÖ Classes implementam apenas o necess√°rio
- ‚úÖ Sem m√©todos "vazios" ou UnsupportedOperationException
- ‚úÖ Facilita testes e manuten√ß√£o

---

### D - Dependency Inversion Principle (DIP)

**"Dependa de abstra√ß√µes, n√£o de implementa√ß√µes concretas"**

#### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Depend√™ncia direta de implementa√ß√µes

@Service
public class PedidoService {

    // ‚ùå Depend√™ncia de classe concreta
    private final MySqlPedidoRepository repository;
    private final SmtpEmailService emailService;

    public PedidoService() {
        this.repository = new MySqlPedidoRepository(); // ‚ùå new direto
        this.emailService = new SmtpEmailService();   // ‚ùå new direto
    }

    public void criar(Pedido pedido) {
        repository.save(pedido);
        emailService.enviar(pedido.getClienteEmail(), "Pedido criado");
    }
}
```

**Problemas:**

- ‚ùå Imposs√≠vel trocar banco de dados
- ‚ùå Imposs√≠vel mockar para testes
- ‚ùå Alto acoplamento

#### ‚úÖ Aplicando DIP

```java
// ‚úÖ SOLU√á√ÉO: Depend√™ncia de abstra√ß√µes

// Abstra√ß√µes (interfaces)
public interface PedidoRepository extends JpaRepository<Pedido, Long> {
}

public interface EmailService {
    void enviar(String destinatario, String mensagem);
}

// Service depende de abstra√ß√µes
@Service
@RequiredArgsConstructor // Inje√ß√£o via construtor
public class PedidoService {

    // ‚úÖ Depend√™ncia de interfaces
    private final PedidoRepository repository;
    private final EmailService emailService;

    public void criar(Pedido pedido) {
        repository.save(pedido);
        emailService.enviar(pedido.getClienteEmail(), "Pedido criado");
    }
}

// Implementa√ß√µes concretas (invers√£o completa)
@Repository
public class MySqlPedidoRepositoryImpl implements PedidoRepository {
    // Implementa√ß√£o MySQL
}

@Service
@Primary
public class SmtpEmailServiceImpl implements EmailService {

    @Override
    public void enviar(String destinatario, String mensagem) {
        // Implementa√ß√£o SMTP
    }
}

// ‚úÖ F√°cil trocar implementa√ß√£o
@Service
@Profile("dev")
public class ConsoleEmailServiceImpl implements EmailService {

    @Override
    public void enviar(String destinatario, String mensagem) {
        System.out.println("Email para " + destinatario + ": " + mensagem);
    }
}
```

**Benef√≠cios:**

- ‚úÖ F√°cil substituir implementa√ß√µes
- ‚úÖ Test√°vel com mocks
- ‚úÖ Baixo acoplamento

---

## üîÅ DRY - Don't Repeat Yourself

**"Cada peda√ßo de conhecimento deve ter uma representa√ß√£o √∫nica, inequ√≠voca e autoritativa"**

### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: C√≥digo duplicado

@RestController
@RequestMapping("/api/clientes")
public class ClienteController {

    @PostMapping
    public ResponseEntity<ClienteDTO> criar(@RequestBody ClienteRequest request) {
        // Valida√ß√£o duplicada
        if (request.getCpf() == null || !validarCpf(request.getCpf())) {
            return ResponseEntity.badRequest().build();
        }
        if (request.getEmail() == null || !validarEmail(request.getEmail())) {
            return ResponseEntity.badRequest().build();
        }
        // ...
    }

    @PutMapping("/{id}")
    public ResponseEntity<ClienteDTO> atualizar(@PathVariable Long id, @RequestBody ClienteRequest request) {
        // ‚ùå Mesma valida√ß√£o duplicada
        if (request.getCpf() == null || !validarCpf(request.getCpf())) {
            return ResponseEntity.badRequest().build();
        }
        if (request.getEmail() == null || !validarEmail(request.getEmail())) {
            return ResponseEntity.badRequest().build();
        }
        // ...
    }
}

@RestController
@RequestMapping("/api/fornecedores")
public class FornecedorController {

    @PostMapping
    public ResponseEntity<FornecedorDTO> criar(@RequestBody FornecedorRequest request) {
        // ‚ùå Valida√ß√£o duplicada novamente
        if (request.getCnpj() == null || !validarCnpj(request.getCnpj())) {
            return ResponseEntity.badRequest().build();
        }
        if (request.getEmail() == null || !validarEmail(request.getEmail())) {
            return ResponseEntity.badRequest().build();
        }
        // ...
    }
}
```

### ‚úÖ Aplicando DRY

```java
// ‚úÖ SOLU√á√ÉO: Bean Validation (centralizado)

@Data
public class ClienteRequest {

    @NotBlank(message = "CPF √© obrigat√≥rio")
    @ValidCpf // Custom validator
    private String cpf;

    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email
    private String email;
}

@Data
public class FornecedorRequest {

    @NotBlank(message = "CNPJ √© obrigat√≥rio")
    @ValidCnpj // Custom validator
    private String cnpj;

    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email
    private String email;
}

// Controllers sem c√≥digo duplicado
@RestController
@RequestMapping("/api/clientes")
public class ClienteController {

    @PostMapping
    public ResponseEntity<ClienteDTO> criar(@Valid @RequestBody ClienteRequest request) {
        // ‚úÖ Valida√ß√£o autom√°tica via @Valid
        return ResponseEntity.ok(service.criar(request));
    }
}
```

**Outro Exemplo - Queries Duplicadas:**

```java
// ‚ùå PROBLEMA: Queries duplicadas

public class ClienteService {
    void metodo1() {
        List<Cliente> clientes = entityManager.createQuery(
            "SELECT c FROM Cliente c WHERE c.ativo = true AND c.tipo = :tipo", Cliente.class)
            .setParameter("tipo", TipoCliente.VIP)
            .getResultList();
    }

    void metodo2() {
        // ‚ùå Query duplicada
        List<Cliente> clientes = entityManager.createQuery(
            "SELECT c FROM Cliente c WHERE c.ativo = true AND c.tipo = :tipo", Cliente.class)
            .setParameter("tipo", TipoCliente.GOLD)
            .getResultList();
    }
}

// ‚úÖ SOLU√á√ÉO: Repository method

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long> {

    @Query("SELECT c FROM Cliente c WHERE c.ativo = true AND c.tipo = :tipo")
    List<Cliente> findAtivosByTipo(@Param("tipo") TipoCliente tipo);
}

public class ClienteService {
    void metodo1() {
        List<Cliente> clientes = repository.findAtivosByTipo(TipoCliente.VIP);
    }

    void metodo2() {
        List<Cliente> clientes = repository.findAtivosByTipo(TipoCliente.GOLD);
    }
}
```

---

## üíã KISS - Keep It Simple, Stupid

**"A simplicidade deve ser um objetivo chave do design"**

### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Over-engineering

public class PedidoValidator {

    public ValidationResult validar(Pedido pedido) {
        ValidationResult result = new ValidationResult();

        // ‚ùå Complexidade desnecess√°ria
        Optional.ofNullable(pedido)
                .map(Pedido::getItens)
                .filter(itens -> !itens.isEmpty())
                .orElseThrow(() -> new ValidationException("Pedido sem itens"));

        Optional.ofNullable(pedido)
                .map(Pedido::getClienteId)
                .filter(id -> id > 0)
                .orElseThrow(() -> new ValidationException("Cliente inv√°lido"));

        return result;
    }
}
```

### ‚úÖ Aplicando KISS

```java
// ‚úÖ SOLU√á√ÉO: Simples e direto

public class PedidoValidator {

    public void validar(Pedido pedido) {
        if (pedido.getItens().isEmpty()) {
            throw new ValidationException("Pedido sem itens");
        }

        if (pedido.getClienteId() == null || pedido.getClienteId() <= 0) {
            throw new ValidationException("Cliente inv√°lido");
        }
    }
}
```

**Outro Exemplo:**

```java
// ‚ùå PROBLEMA: Abstra√ß√£o prematura

public interface PagamentoStrategy {
    PagamentoResult processar(PagamentoContext context);
}

public class PagamentoContext {
    private Map<String, Object> attributes;
    private PagamentoMetadata metadata;
    // 20+ campos
}

public class PagamentoFactory {
    public PagamentoStrategy create(PagamentoType type) {
        // Factory complexa
    }
}

// ‚úÖ SOLU√á√ÉO: Come√ßar simples

public interface PagamentoService {
    void processar(Pagamento pagamento);
}

@Service
public class CartaoCreditoService implements PagamentoService {

    @Override
    public void processar(Pagamento pagamento) {
        // Implementa√ß√£o direta
    }
}
```

---

## üö´ YAGNI - You Aren't Gonna Need It

**"N√£o adicione funcionalidade at√© que seja necess√°rio"**

### ‚ùå Viola√ß√£o

```java
// ‚ùå PROBLEMA: Funcionalidade especulativa

@Entity
public class Cliente {

    private Long id;
    private String nome;
    private String email;

    // ‚ùå Campos que "podem" ser √∫teis no futuro
    private String telefoneReserva;
    private String enderecoAlternativo;
    private String contatoEmergencia;
    private LocalDateTime ultimaCompraFutura; // ???
    private BigDecimal limiteCredito; // N√£o implementado ainda
    private String[] preferencias; // N√£o usado
}

@Service
public class PedidoService {

    // ‚ùå M√©todos que "podem" ser √∫teis
    public void agendarPedidoFuturo(Pedido pedido, LocalDateTime data) {
        throw new UnsupportedOperationException("N√£o implementado");
    }

    public void calcularPrevisaoEntrega(Pedido pedido) {
        throw new UnsupportedOperationException("N√£o implementado");
    }
}
```

### ‚úÖ Aplicando YAGNI

```java
// ‚úÖ SOLU√á√ÉO: Apenas o necess√°rio agora

@Entity
public class Cliente {

    private Long id;
    private String nome;
    private String email;

    // ‚úÖ Apenas campos atualmente usados
}

@Service
public class PedidoService {

    // ‚úÖ Apenas m√©todos implementados e usados
    public Pedido criar(PedidoRequest request) {
        // Implementa√ß√£o real
    }

    public Pedido buscar(Long id) {
        // Implementa√ß√£o real
    }
}

// ‚úÖ Adicionar campos/m√©todos quando necess√°rio (incremental)
```

---

## üß™ Testes dos Princ√≠pios

### Testando SRP

```java
@Test
void pedidoService_deveria_apenas_gerenciar_logica_negocio() {
    // Arrange
    PedidoService service = new PedidoService(repository, notificationService);

    // Act
    Pedido pedido = service.criar(request);

    // Assert
    verify(repository).save(any(Pedido.class)); // ‚úÖ Delega persist√™ncia
    verify(notificationService).notificarPedidoCriado(any()); // ‚úÖ Delega notifica√ß√£o
}
```

### Testando OCP

```java
@Test
void descontoService_deveria_suportar_novas_estrategias_sem_modificacao() {
    // Arrange
    List<DescontoStrategy> strategies = List.of(
            new DescontoVipStrategy(),
            new DescontoGoldStrategy(),
            new DescontoPlatinumStrategy() // ‚úÖ Nova estrat√©gia sem modificar service
    );

    DescontoService service = new DescontoService(strategies);

    // Act & Assert
    assertThat(service.calcular(pedido, TipoCliente.PLATINUM))
            .isEqualByComparingTo(new BigDecimal("25.00"));
}
```

### Testando DIP

```java
@Test
void pedidoService_deveria_funcionar_com_qualquer_implementacao() {
    // Arrange - Mock (invers√£o de depend√™ncia)
    PedidoRepository mockRepository = mock(PedidoRepository.class);
    EmailService mockEmailService = mock(EmailService.class);

    PedidoService service = new PedidoService(mockRepository, mockEmailService);

    // Act
    service.criar(pedido);

    // Assert - ‚úÖ Funciona com mocks (qualquer implementa√ß√£o)
    verify(mockRepository).save(any());
    verify(mockEmailService).enviar(anyString(), anyString());
}
```

---

## üìã Checklist de Princ√≠pios

### SOLID

- [ ] **SRP**: Cada classe tem uma √∫nica responsabilidade?
- [ ] **OCP**: C√≥digo extens√≠vel sem modifica√ß√£o?
- [ ] **LSP**: Subtipos substitu√≠veis pelos tipos base?
- [ ] **ISP**: Interfaces focadas e segregadas?
- [ ] **DIP**: Depend√™ncias em abstra√ß√µes, n√£o implementa√ß√µes?

### DRY

- [ ] L√≥gica duplicada foi extra√≠da?
- [ ] Valida√ß√µes centralizadas (Bean Validation)?
- [ ] Queries reutiliz√°veis (repository methods)?

### KISS

- [ ] Solu√ß√£o mais simples poss√≠vel?
- [ ] Abstra√ß√µes apenas quando necess√°rio?
- [ ] C√≥digo auto-explicativo?

### YAGNI

- [ ] Funcionalidades especulativas removidas?
- [ ] Apenas c√≥digo atualmente usado?
- [ ] Design incremental (n√£o big-bang)?

---

## üéØ Quando Aplicar?

| Princ√≠pio | Sempre | √Äs Vezes | Raramente |
| --------- | ------ | -------- | --------- |
| SRP       | ‚úÖ     |          |           |
| OCP       | ‚úÖ     |          |           |
| LSP       | ‚úÖ     |          |           |
| ISP       |        | ‚úÖ       |           |
| DIP       | ‚úÖ     |          |           |
| DRY       | ‚úÖ     |          |           |
| KISS      | ‚úÖ     |          |           |
| YAGNI     | ‚úÖ     |          |           |

**Nota:** ISP nem sempre √© necess√°rio em projetos pequenos com interfaces simples.

---

## üîó Recursos

- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [Clean Code (Robert C. Martin)](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [The Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/)

---

## üìù Resumo

**Princ√≠pios de Desenvolvimento** garantem:

- ‚úÖ **SOLID**: C√≥digo manuten√≠vel e extens√≠vel
- ‚úÖ **DRY**: Sem duplica√ß√£o de l√≥gica
- ‚úÖ **KISS**: Simplicidade acima de tudo
- ‚úÖ **YAGNI**: Apenas o necess√°rio

**Regra de ouro:** Princ√≠pios s√£o **diretrizes**, n√£o leis absolutas. Use bom senso e contexto.
