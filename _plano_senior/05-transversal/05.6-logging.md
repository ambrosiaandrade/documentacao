# 05.6 Logging [INTERMEDI√ÅRIO] üìä

## üéØ Objetivo

Implementar **logging estruturado** e **contextual** com rastreamento de requisi√ß√µes (trace IDs), integra√ß√£o com **ELK Stack/Splunk**, e estrat√©gias para **REST**, **async**, **mensageria** e **scheduled tasks**.

---

## üìö O Que √â?

**Logging** √© a pr√°tica de registrar eventos da aplica√ß√£o de forma estruturada, permitindo **debugging**, **auditoria**, **monitoramento** e **an√°lise de comportamento**.

### Analogia

Como **caixa preta de avi√£o**:

- **Sem Logging**: Acidente sem evid√™ncias
- **Com Logging**: Registros detalhados de todos os eventos
- **Vantagem**: Investiga√ß√£o e preven√ß√£o de problemas

---

## ‚ùå Problema que Resolve

### Antes (Sem Logging Estruturado)

```java
// ‚ùå PROBLEMA: Logs n√£o estruturados e sem contexto

@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    @PostMapping
    ResponseEntity<PedidoDTO> criar(@RequestBody PedidoRequest request) {
        System.out.println("Criando pedido"); // ‚ùå Sistema standard output

        Pedido pedido = service.criar(request);

        System.out.println("Pedido criado: " + pedido.getId()); // ‚ùå Sem estrutura

        return ResponseEntity.ok(new PedidoDTO(pedido));
    }
}

@Service
class PedidoService {

    void criar(PedidoRequest request) {
        log.info("Criando pedido para cliente: " + request.getClienteId()); // ‚ùå Sem trace ID

        // Processamento...

        log.info("Pedido criado com sucesso"); // ‚ùå Sem contexto
    }
}
```

**Problemas:**

- ‚ùå Logs n√£o estruturados (dif√≠cil de parsear)
- ‚ùå Sem correla√ß√£o entre requisi√ß√µes (trace ID)
- ‚ùå Informa√ß√µes sens√≠veis expostas
- ‚ùå Dif√≠cil buscar logs espec√≠ficos
- ‚ùå Sem contexto em logs ass√≠ncronos

---

## ‚úÖ Solu√ß√£o: Logging Estruturado + MDC

### 1Ô∏è‚É£ Configura√ß√£o Logback (logback-spring.xml)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Console Appender (Development) -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyNames>traceId,userId,clientId</includeMdcKeyNames>
            <customFields>{"application":"pedidos-api","environment":"${ENVIRONMENT:-dev}"}</customFields>
        </encoder>
    </appender>

    <!-- File Appender (JSON Structured) -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application-%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <includeMdcKeyNames>traceId,userId,clientId,method,uri,status</includeMdcKeyNames>
        </encoder>
    </appender>

    <!-- Async Appender (Performance) -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <queueSize>512</queueSize>
        <discardingThreshold>0</discardingThreshold>
        <appender-ref ref="FILE" />
    </appender>

    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="ASYNC" />
    </root>

    <!-- Custom Logger Levels -->
    <logger name="com.empresa" level="DEBUG" />
    <logger name="org.springframework.web" level="INFO" />
    <logger name="org.hibernate.SQL" level="DEBUG" />
</configuration>
```

---

### 2Ô∏è‚É£ MDC Filter (Trace ID + Context)

```java
// üèóÔ∏è INFRASTRUCTURE
package com.empresa.pedidos.infrastructure.logging;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.UUID;

@Slf4j
@Component
@Order(1) // Primeiro filtro
public class MdcFilter implements Filter {

    private static final String TRACE_ID = "traceId";
    private static final String USER_ID = "userId";
    private static final String METHOD = "method";
    private static final String URI = "uri";
    private static final String X_TRACE_ID = "X-Trace-Id";

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;

        try {
            // 1. Gera ou extrai trace ID
            String traceId = httpRequest.getHeader(X_TRACE_ID);
            if (traceId == null || traceId.isBlank()) {
                traceId = UUID.randomUUID().toString();
            }

            // 2. Popula MDC
            MDC.put(TRACE_ID, traceId);
            MDC.put(METHOD, httpRequest.getMethod());
            MDC.put(URI, httpRequest.getRequestURI());

            // 3. Extrai userId do contexto de seguran√ßa (se autenticado)
            String userId = extractUserIdFromSecurityContext();
            if (userId != null) {
                MDC.put(USER_ID, userId);
            }

            log.info("Request received: {} {}", httpRequest.getMethod(), httpRequest.getRequestURI());

            // 4. Continua cadeia de filtros
            chain.doFilter(request, response);

            log.info("Request completed: {} {}", httpRequest.getMethod(), httpRequest.getRequestURI());

        } finally {
            // 5. Limpa MDC (CR√çTICO para evitar memory leak)
            MDC.clear();
        }
    }

    private String extractUserIdFromSecurityContext() {
        try {
            var authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated()) {
                return authentication.getName();
            }
        } catch (Exception e) {
            log.warn("Falha ao extrair userId", e);
        }
        return null;
    }
}
```

---

### 3Ô∏è‚É£ REST Controller com Logging

```java
// üéÆ CONTROLLER
package com.empresa.pedidos.controller;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@Slf4j
@RestController
@RequestMapping("/api/pedidos")
@RequiredArgsConstructor
public class PedidoController {

    private final PedidoService service;

    @PostMapping
    public ResponseEntity<PedidoDTO> criar(@RequestBody PedidoRequest request) {
        // ‚úÖ Trace ID automaticamente no MDC via MdcFilter
        log.info("Criando pedido: {}", request); // JSON estruturado

        PedidoDTO pedido = service.criar(request);

        log.info("Pedido criado com sucesso: id={}", pedido.getId());

        return ResponseEntity.ok(pedido);
    }

    @GetMapping("/{id}")
    public ResponseEntity<PedidoDTO> buscar(@PathVariable Long id) {
        log.debug("Buscando pedido: id={}", id);

        PedidoDTO pedido = service.buscar(id);

        log.debug("Pedido encontrado: id={}", id);

        return ResponseEntity.ok(pedido);
    }

    @PutMapping("/{id}")
    public ResponseEntity<PedidoDTO> atualizar(@PathVariable Long id, @RequestBody PedidoRequest request) {
        log.info("Atualizando pedido: id={}, request={}", id, request);

        PedidoDTO pedido = service.atualizar(id, request);

        log.info("Pedido atualizado: id={}", id);

        return ResponseEntity.ok(pedido);
    }
}
```

**Sa√≠da JSON Estruturada:**

```json
{
  "timestamp": "2024-01-15T10:30:00.123Z",
  "level": "INFO",
  "logger": "com.empresa.pedidos.controller.PedidoController",
  "message": "Criando pedido: PedidoRequest(clienteId=123, produtos=[...])",
  "traceId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "userId": "user@example.com",
  "method": "POST",
  "uri": "/api/pedidos",
  "application": "pedidos-api",
  "environment": "prod"
}
```

---

### 4Ô∏è‚É£ Logging Ass√≠ncrono (@Async)

```java
// üîÑ ASYNC SERVICE
package com.empresa.pedidos.service;

import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
public class NotificacaoService {

    @Async
    public CompletableFuture<Void> enviarEmail(Long pedidoId, String destinatario) {
        // ‚úÖ Propaga MDC para thread ass√≠ncrona
        Map<String, String> mdcContext = MDC.getCopyOfContextMap();

        try {
            // Restaura MDC na thread ass√≠ncrona
            if (mdcContext != null) {
                MDC.setContextMap(mdcContext);
            }

            log.info("Enviando email: pedidoId={}, destinatario={}", pedidoId, destinatario);

            // Simula envio de email
            Thread.sleep(2000);

            log.info("Email enviado com sucesso: pedidoId={}", pedidoId);

            return CompletableFuture.completedFuture(null);

        } catch (Exception e) {
            log.error("Erro ao enviar email: pedidoId={}", pedidoId, e);
            throw new RuntimeException(e);

        } finally {
            // Limpa MDC
            MDC.clear();
        }
    }
}
```

**Configura√ß√£o Executor com MDC:**

```java
// ‚öôÔ∏è CONFIGURATION
package com.empresa.pedidos.config;

import org.slf4j.MDC;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.TaskDecorator;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.Map;
import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("async-");

        // ‚úÖ Propaga MDC automaticamente
        executor.setTaskDecorator(new MdcTaskDecorator());

        executor.initialize();
        return executor;
    }

    // Decorador que propaga MDC
    static class MdcTaskDecorator implements TaskDecorator {

        @Override
        public Runnable decorate(Runnable runnable) {
            Map<String, String> contextMap = MDC.getCopyOfContextMap();

            return () -> {
                try {
                    if (contextMap != null) {
                        MDC.setContextMap(contextMap);
                    }
                    runnable.run();
                } finally {
                    MDC.clear();
                }
            };
        }
    }
}
```

---

### 5Ô∏è‚É£ Logging em Mensageria (RabbitMQ)

```java
// üì¨ MESSAGING LISTENER
package com.empresa.pedidos.messaging;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class PedidoListener {

    private final PedidoService service;

    @RabbitListener(queues = "${rabbitmq.queue.pedidos}")
    public void processar(Message message, PedidoCriadoEvent event) {
        String traceId = extractTraceId(message);

        try {
            // ‚úÖ Configura MDC para mensageria
            MDC.put("traceId", traceId);
            MDC.put("messageId", message.getMessageProperties().getMessageId());
            MDC.put("queue", "pedidos.criado");

            log.info("Mensagem recebida: event={}", event);

            service.processar(event);

            log.info("Mensagem processada com sucesso: pedidoId={}", event.getPedidoId());

        } catch (Exception e) {
            log.error("Erro ao processar mensagem: event={}", event, e);
            throw e;

        } finally {
            MDC.clear();
        }
    }

    private String extractTraceId(Message message) {
        Object traceId = message.getMessageProperties().getHeader("traceId");
        return traceId != null ? traceId.toString() : UUID.randomUUID().toString();
    }
}
```

**Publisher com Trace ID:**

```java
// üì§ MESSAGING PUBLISHER
package com.empresa.pedidos.messaging;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@RequiredArgsConstructor
public class PedidoPublisher {

    private final RabbitTemplate rabbitTemplate;

    public void publicar(PedidoCriadoEvent event) {
        String traceId = MDC.get("traceId");

        log.info("Publicando evento: event={}, traceId={}", event, traceId);

        rabbitTemplate.convertAndSend("pedidos.exchange", "pedidos.criado", event, message -> {
            // ‚úÖ Propaga trace ID via header
            message.getMessageProperties().setHeader("traceId", traceId);
            return message;
        });

        log.debug("Evento publicado: event={}", event);
    }
}
```

---

### 6Ô∏è‚É£ Logging em Scheduled Tasks

```java
// ‚è∞ SCHEDULED TASK
package com.empresa.pedidos.scheduling;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class PedidoScheduler {

    private final PedidoService service;

    @Scheduled(cron = "0 0 2 * * *") // 02:00 AM todos os dias
    public void processarPendentes() {
        String traceId = UUID.randomUUID().toString();

        try {
            // ‚úÖ Configura MDC para scheduled task
            MDC.put("traceId", traceId);
            MDC.put("task", "processar-pendentes");

            log.info("Iniciando processamento de pedidos pendentes");

            int processados = service.processarPendentes();

            log.info("Processamento conclu√≠do: processados={}", processados);

        } catch (Exception e) {
            log.error("Erro ao processar pedidos pendentes", e);

        } finally {
            MDC.clear();
        }
    }

    @Scheduled(fixedDelay = 300000) // 5 minutos
    public void limparExpirados() {
        String traceId = UUID.randomUUID().toString();

        try {
            MDC.put("traceId", traceId);
            MDC.put("task", "limpar-expirados");

            log.info("Iniciando limpeza de pedidos expirados");

            int removidos = service.limparExpirados();

            log.info("Limpeza conclu√≠da: removidos={}", removidos);

        } catch (Exception e) {
            log.error("Erro ao limpar pedidos expirados", e);

        } finally {
            MDC.clear();
        }
    }
}
```

---

### 7Ô∏è‚É£ Mascaramento de Dados Sens√≠veis

```java
// üîí MASKING UTILITY
package com.empresa.pedidos.util;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

import java.io.IOException;

// Anota√ß√£o customizada
@JsonSerialize(using = SensitiveDataSerializer.class)
public @interface SensitiveData {}

// Serializador que mascara dados
class SensitiveDataSerializer extends JsonSerializer<String> {

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
        if (value == null || value.length() < 4) {
            gen.writeString("***");
            return;
        }

        // Mant√©m √∫ltimos 4 caracteres
        String masked = "*".repeat(value.length() - 4) + value.substring(value.length() - 4);
        gen.writeString(masked);
    }
}

// DTO com dados sens√≠veis
@Data
public class ClienteDTO {
    private Long id;
    private String nome;

    @SensitiveData
    private String cpf; // 123.456.789-01 ‚Üí *********89-01

    @SensitiveData
    private String email; // user@example.com ‚Üí ************.com

    @SensitiveData
    private String telefone; // (11) 98765-4321 ‚Üí **************4321
}
```

**Configura√ß√£o ToString Masking:**

```java
// üì¶ DOMAIN ENTITY
package com.empresa.pedidos.domain;

import lombok.Data;
import lombok.ToString;

@Data
public class Cartao {
    private Long id;

    @ToString.Exclude // ‚ùå N√£o exibe no toString()
    private String numero;

    @ToString.Exclude
    private String cvv;

    private String bandeira;
}
```

---

### 8Ô∏è‚É£ Aspect para Logging de M√©todos

```java
// üéØ ASPECT
package com.empresa.pedidos.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Slf4j
@Aspect
@Component
public class LoggingAspect {

    @Around("@annotation(Loggable)")
    public Object logExecution(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().toShortString();

        log.debug("Iniciando execu√ß√£o: method={}", methodName);

        long startTime = System.currentTimeMillis();

        try {
            Object result = joinPoint.proceed();

            long executionTime = System.currentTimeMillis() - startTime;

            log.debug("Execu√ß√£o conclu√≠da: method={}, duration={}ms", methodName, executionTime);

            return result;

        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;

            log.error("Execu√ß√£o falhou: method={}, duration={}ms", methodName, executionTime, e);

            throw e;
        }
    }
}

// Anota√ß√£o customizada
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {}

// Uso
@Service
class PedidoService {

    @Loggable
    public PedidoDTO criar(PedidoRequest request) {
        // M√©todo ser√° automaticamente logado
    }
}
```

---

## üß™ Testes de Logging

### 1Ô∏è‚É£ Capturando Logs em Testes

```java
// üß™ TEST
package com.empresa.pedidos.controller;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.read.ListAppender;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.slf4j.LoggerFactory;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class PedidoControllerLoggingTest {

    private ListAppender<ILoggingEvent> logAppender;
    private Logger logger;

    @BeforeEach
    void setup() {
        logger = (Logger) LoggerFactory.getLogger(PedidoController.class);
        logAppender = new ListAppender<>();
        logAppender.start();
        logger.addAppender(logAppender);
    }

    @Test
    void deveria_logar_criacao_pedido() {
        // Arrange
        PedidoRequest request = new PedidoRequest(123L, List.of());

        // Act
        controller.criar(request);

        // Assert
        List<ILoggingEvent> logs = logAppender.list;

        assertThat(logs).hasSize(2);
        assertThat(logs.get(0).getMessage()).contains("Criando pedido");
        assertThat(logs.get(0).getLevel()).isEqualTo(Level.INFO);

        assertThat(logs.get(1).getMessage()).contains("Pedido criado com sucesso");
    }
}
```

---

### 2Ô∏è‚É£ Testando MDC Propagation

```java
// üß™ TEST
package com.empresa.pedidos.infrastructure.logging;

import org.junit.jupiter.api.Test;
import org.slf4j.MDC;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;

import jakarta.servlet.FilterChain;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

class MdcFilterTest {

    private final MdcFilter filter = new MdcFilter();

    @Test
    void deveria_propagar_trace_id_do_header() throws Exception {
        // Arrange
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.addHeader("X-Trace-Id", "abc-123");
        request.setMethod("POST");
        request.setRequestURI("/api/pedidos");

        MockHttpServletResponse response = new MockHttpServletResponse();
        FilterChain chain = mock(FilterChain.class);

        // Act
        doAnswer(invocation -> {
            // Verifica MDC durante execu√ß√£o da chain
            assertThat(MDC.get("traceId")).isEqualTo("abc-123");
            assertThat(MDC.get("method")).isEqualTo("POST");
            assertThat(MDC.get("uri")).isEqualTo("/api/pedidos");
            return null;
        }).when(chain).doFilter(request, response);

        filter.doFilter(request, response, chain);

        // Assert
        verify(chain).doFilter(request, response);
        assertThat(MDC.getCopyOfContextMap()).isNull(); // Limpou ap√≥s request
    }

    @Test
    void deveria_gerar_trace_id_quando_ausente() throws Exception {
        // Arrange
        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();
        FilterChain chain = mock(FilterChain.class);

        // Act
        doAnswer(invocation -> {
            assertThat(MDC.get("traceId")).isNotNull();
            assertThat(MDC.get("traceId")).hasSize(36); // UUID format
            return null;
        }).when(chain).doFilter(request, response);

        filter.doFilter(request, response, chain);

        // Assert
        verify(chain).doFilter(request, response);
    }
}
```

---

## üìä Integra√ß√£o com ELK Stack

### Filebeat Configuration

```yaml
# filebeat.yml
filebeat.inputs:
  - type: log
    enabled: true
    paths:
      - /app/logs/*.log
    json.keys_under_root: true
    json.add_error_key: true

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "pedidos-api-%{+yyyy.MM.dd}"

setup.kibana:
  host: "kibana:5601"
```

### Logstash Pipeline

```conf
input {
  beats {
    port => 5044
  }
}

filter {
  if [application] == "pedidos-api" {
    json {
      source => "message"
    }

    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "pedidos-api-%{+YYYY.MM.dd}"
  }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use n√≠veis apropriados
log.trace("Entrando no m√©todo com params: {}", params); // Detalhes minuciosos
log.debug("Calculando total: items={}", items); // Debugging
log.info("Pedido criado: id={}", id); // Eventos importantes
log.warn("Cache miss: key={}", key); // Situa√ß√µes anormais
log.error("Falha ao processar pedido", exception); // Erros graves

// ‚úÖ Use placeholders (evita concatena√ß√£o desnecess√°ria)
log.info("Cliente {} criou pedido {}", clienteId, pedidoId); // ‚úÖ
log.info("Cliente " + clienteId + " criou pedido " + pedidoId); // ‚ùå

// ‚úÖ Log exceptions com contexto
try {
    service.processar(pedido);
} catch (Exception e) {
    log.error("Erro ao processar pedido: pedidoId={}", pedido.getId(), e); // ‚úÖ
    log.error("Erro", e); // ‚ùå Sem contexto
}

// ‚úÖ Evite logs em loops
List<Pedido> pedidos = repository.findAll();
log.info("Processando {} pedidos", pedidos.size()); // ‚úÖ
pedidos.forEach(pedido -> {
    // log.info("Processando pedido: {}", pedido); // ‚ùå Polui√ß√£o
    service.processar(pedido);
});
log.info("Processamento conclu√≠do");

// ‚úÖ Dados sens√≠veis mascarados
log.info("Cliente criado: cpf={}", maskCpf(cpf)); // ‚úÖ
log.info("Cliente criado: cpf={}", cpf); // ‚ùå LGPD violation
```

---

### ‚ùå Anti-Patterns

```java
// ‚ùå System.out.println
System.out.println("Pedido criado"); // N√£o vai para log aggregator

// ‚ùå Logs excessivos
log.debug("Linha 1");
log.debug("Linha 2");
log.debug("Linha 3"); // Polui√ß√£o

// ‚ùå Logs sem contexto
log.error("Erro ao salvar"); // Qual entidade? Qual ID?

// ‚ùå Log de stack trace manual
log.error(e.getMessage()); // ‚ùå Perde stack trace
log.error("Erro", e); // ‚úÖ

// ‚ùå Concatena√ß√£o antes de verificar n√≠vel
log.debug("Dados: " + expensiveOperation()); // ‚ùå Executa sempre
if (log.isDebugEnabled()) {
    log.debug("Dados: {}", expensiveOperation()); // ‚úÖ
}
```

---

## üîç Compara√ß√£o de N√≠veis

| N√≠vel | Quando Usar                       | Exemplo                           |
| ----- | --------------------------------- | --------------------------------- |
| TRACE | Detalhes extremos (raramente)     | Entrada/sa√≠da de cada m√©todo      |
| DEBUG | Informa√ß√µes de debugging          | Valores de vari√°veis, queries SQL |
| INFO  | Eventos importantes do neg√≥cio    | Pedido criado, pagamento aprovado |
| WARN  | Situa√ß√µes anormais (n√£o cr√≠ticas) | Cache miss, retry tentado         |
| ERROR | Erros graves (requer a√ß√£o)        | Falha ao conectar DB, exception   |

---

## ‚öñÔ∏è Vantagens e Desvantagens

### ‚úÖ Vantagens

- **Rastreabilidade**: Trace ID conecta logs de toda requisi√ß√£o
- **Observabilidade**: Integra√ß√£o com ELK/Splunk para an√°lise
- **Performance**: Async logging n√£o bloqueia aplica√ß√£o
- **Debugging**: Logs estruturados facilitam troubleshooting
- **Auditoria**: Registro completo de eventos cr√≠ticos

### ‚ö†Ô∏è Desvantagens

- **Overhead**: Logs excessivos impactam performance
- **Armazenamento**: Logs consomem espa√ßo em disco
- **Complexidade**: Configura√ß√£o de MDC e propaga√ß√£o
- **Seguran√ßa**: Risco de expor dados sens√≠veis

---

## üéØ Quando Usar?

| Cen√°rio                  | Usar Logging?         |
| ------------------------ | --------------------- |
| API REST                 | ‚úÖ Sempre (com MDC)   |
| Processamento ass√≠ncrono | ‚úÖ Com propaga√ß√£o MDC |
| Mensageria               | ‚úÖ Com trace ID       |
| Scheduled tasks          | ‚úÖ Com contexto       |
| M√©todos privados         | ‚ö†Ô∏è Evitar polui√ß√£o    |
| Loops intensivos         | ‚ùå Apenas sum√°rio     |

---

## üîó Recursos

- [SLF4J Documentation](https://www.slf4j.org/)
- [Logback Manual](https://logback.qos.ch/manual/)
- [Logstash Logback Encoder](https://github.com/logfellow/logstash-logback-encoder)
- [ELK Stack](https://www.elastic.co/elastic-stack)
- [Spring Boot Logging](https://docs.spring.io/spring-boot/reference/features/logging.html)

---

## üìù Resumo

**Logging estruturado** com **MDC** e **trace IDs** garante:

- ‚úÖ Rastreabilidade completa de requisi√ß√µes
- ‚úÖ Integra√ß√£o com ferramentas de an√°lise (ELK/Splunk)
- ‚úÖ Contexto preservado em async e messaging
- ‚úÖ Mascaramento de dados sens√≠veis
- ‚úÖ Performance via async appenders

**Regra de ouro:** Log o suficiente para debugging, mas evite polui√ß√£o e exposi√ß√£o de dados sens√≠veis.
