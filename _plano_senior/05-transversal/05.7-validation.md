# 05.7 Validation [INTERMEDI√ÅRIO] ‚úîÔ∏è

## üéØ Objetivo

Implementar **valida√ß√£o robusta** usando **Bean Validation (JSR-380)**, validadores customizados, grupos de valida√ß√£o, e integra√ß√£o com **REST**, **service layer**, e **database constraints**.

---

## üìö O Que √â?

**Validation** √© o processo de garantir que dados atendam regras de neg√≥cio antes de serem processados ou persistidos, usando anota√ß√µes declarativas e validadores customizados.

### Analogia

Como **controle de qualidade em f√°brica**:

- **Sem Valida√ß√£o**: Produtos defeituosos chegam ao cliente
- **Com Valida√ß√£o**: Inspe√ß√£o em m√∫ltiplas etapas (entrada ‚Üí processamento ‚Üí sa√≠da)
- **Vantagem**: Preven√ß√£o de erros e dados inconsistentes

---

## ‚ùå Problema que Resolve

### Antes (Valida√ß√£o Manual)

```java
// ‚ùå PROBLEMA: Valida√ß√£o manual e duplicada

@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @PostMapping
    ResponseEntity<ProdutoDTO> criar(@RequestBody ProdutoRequest request) {
        // ‚ùå Valida√ß√£o manual no controller
        if (request.getNome() == null || request.getNome().isBlank()) {
            throw new IllegalArgumentException("Nome √© obrigat√≥rio");
        }

        if (request.getPreco() == null || request.getPreco().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Pre√ßo deve ser maior que zero");
        }

        if (request.getCategoria() == null) {
            throw new IllegalArgumentException("Categoria √© obrigat√≥ria");
        }

        // ... mais valida√ß√µes ...

        return ResponseEntity.ok(service.criar(request));
    }
}

@Service
class ProdutoService {

    void criar(ProdutoRequest request) {
        // ‚ùå Valida√ß√£o duplicada no service
        if (request.getNome().length() > 100) {
            throw new IllegalArgumentException("Nome muito longo");
        }

        // ... mais valida√ß√µes duplicadas ...
    }
}
```

**Problemas:**

- ‚ùå C√≥digo verboso e repetitivo
- ‚ùå Valida√ß√£o duplicada em m√∫ltiplas camadas
- ‚ùå Dif√≠cil manuten√ß√£o
- ‚ùå Mensagens de erro inconsistentes
- ‚ùå L√≥gica de valida√ß√£o espalhada

---

## ‚úÖ Solu√ß√£o: Bean Validation + Custom Validators

### 1Ô∏è‚É£ Depend√™ncias

```xml
<!-- pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

---

### 2Ô∏è‚É£ DTO com Valida√ß√µes B√°sicas

```java
// üì¶ REQUEST DTO
package com.empresa.produtos.dto;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
public class ProdutoRequest {

    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    private String nome;

    @NotBlank(message = "Descri√ß√£o √© obrigat√≥ria")
    @Size(max = 500, message = "Descri√ß√£o n√£o pode exceder 500 caracteres")
    private String descricao;

    @NotNull(message = "Pre√ßo √© obrigat√≥rio")
    @DecimalMin(value = "0.01", message = "Pre√ßo deve ser maior que zero")
    @DecimalMax(value = "999999.99", message = "Pre√ßo n√£o pode exceder 999999.99")
    @Digits(integer = 6, fraction = 2, message = "Pre√ßo deve ter no m√°ximo 6 d√≠gitos inteiros e 2 decimais")
    private BigDecimal preco;

    @NotNull(message = "Quantidade √© obrigat√≥ria")
    @Min(value = 0, message = "Quantidade n√£o pode ser negativa")
    @Max(value = 9999, message = "Quantidade n√£o pode exceder 9999")
    private Integer quantidade;

    @NotNull(message = "Categoria √© obrigat√≥ria")
    @Pattern(regexp = "ELETRONICOS|ROUPAS|ALIMENTOS|LIVROS", message = "Categoria inv√°lida")
    private String categoria;

    @Email(message = "Email do fornecedor inv√°lido")
    private String fornecedorEmail;

    @Past(message = "Data de fabrica√ß√£o deve ser no passado")
    private LocalDate dataFabricacao;

    @Future(message = "Data de validade deve ser no futuro")
    private LocalDate dataValidade;

    @NotEmpty(message = "Lista de tags n√£o pode ser vazia")
    @Size(max = 10, message = "M√°ximo de 10 tags")
    private List<@NotBlank(message = "Tag n√£o pode ser vazia") String> tags;
}
```

---

### 3Ô∏è‚É£ Controller com @Valid

```java
// üéÆ CONTROLLER
package com.empresa.produtos.controller;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/produtos")
@RequiredArgsConstructor
@Validated // Necess√°rio para @PathVariable/@RequestParam validations
public class ProdutoController {

    private final ProdutoService service;

    @PostMapping
    public ResponseEntity<ProdutoDTO> criar(@Valid @RequestBody ProdutoRequest request) {
        // ‚úÖ Valida√ß√£o autom√°tica via @Valid
        // Se falhar, lan√ßa MethodArgumentNotValidException

        ProdutoDTO produto = service.criar(request);

        return ResponseEntity.ok(produto);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ProdutoDTO> atualizar(
            @PathVariable @Min(1) Long id, // ‚úÖ Valida path variable
            @Valid @RequestBody ProdutoRequest request) {

        ProdutoDTO produto = service.atualizar(id, request);

        return ResponseEntity.ok(produto);
    }

    @GetMapping
    public ResponseEntity<List<ProdutoDTO>> listar(
            @RequestParam(required = false) @Size(max = 50) String nome, // ‚úÖ Valida query param
            @RequestParam(required = false) @Min(0) @Max(9999) Integer quantidadeMin) {

        List<ProdutoDTO> produtos = service.listar(nome, quantidadeMin);

        return ResponseEntity.ok(produtos);
    }
}
```

---

### 4Ô∏è‚É£ Exception Handler para Valida√ß√µes

```java
// üö® EXCEPTION HANDLER
package com.empresa.produtos.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class ValidationExceptionHandler {

    // Trata valida√ß√µes de @RequestBody
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();

        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });

        ValidationErrorResponse response = ValidationErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Validation Failed")
                .message("Erro de valida√ß√£o nos campos fornecidos")
                .violations(errors)
                .build();

        log.warn("Valida√ß√£o falhou: {}", errors);

        return ResponseEntity.badRequest().body(response);
    }

    // Trata valida√ß√µes de @PathVariable e @RequestParam
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ValidationErrorResponse> handleConstraintViolation(ConstraintViolationException ex) {
        Map<String, String> errors = new HashMap<>();

        for (ConstraintViolation<?> violation : ex.getConstraintViolations()) {
            String propertyPath = violation.getPropertyPath().toString();
            String message = violation.getMessage();
            errors.put(propertyPath, message);
        }

        ValidationErrorResponse response = ValidationErrorResponse.builder()
                .timestamp(LocalDateTime.now())
                .status(HttpStatus.BAD_REQUEST.value())
                .error("Constraint Violation")
                .message("Erro de valida√ß√£o nos par√¢metros fornecidos")
                .violations(errors)
                .build();

        log.warn("Constraint violation: {}", errors);

        return ResponseEntity.badRequest().body(response);
    }
}

// üìÑ RESPONSE
@Data
@Builder
class ValidationErrorResponse {
    private LocalDateTime timestamp;
    private Integer status;
    private String error;
    private String message;
    private Map<String, String> violations;
}
```

**Exemplo de Resposta:**

```json
{
  "timestamp": "2024-01-15T10:30:00",
  "status": 400,
  "error": "Validation Failed",
  "message": "Erro de valida√ß√£o nos campos fornecidos",
  "violations": {
    "nome": "Nome √© obrigat√≥rio",
    "preco": "Pre√ßo deve ser maior que zero",
    "categoria": "Categoria inv√°lida"
  }
}
```

---

### 5Ô∏è‚É£ Validadores Customizados

#### CPF Validator

```java
// üîß CUSTOM VALIDATOR
package com.empresa.produtos.validation;

import jakarta.validation.Constraint;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.Payload;

import java.lang.annotation.*;

// Anota√ß√£o
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = CpfValidator.class)
@Documented
public @interface ValidCpf {
    String message() default "CPF inv√°lido";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Implementa√ß√£o
class CpfValidator implements ConstraintValidator<ValidCpf, String> {

    @Override
    public boolean isValid(String cpf, ConstraintValidatorContext context) {
        if (cpf == null || cpf.isBlank()) {
            return true; // Use @NotBlank para obrigat√≥rio
        }

        // Remove caracteres n√£o num√©ricos
        cpf = cpf.replaceAll("\\D", "");

        // Verifica tamanho
        if (cpf.length() != 11) {
            return false;
        }

        // Verifica sequ√™ncias inv√°lidas (111.111.111-11, etc.)
        if (cpf.matches("(\\d)\\1{10}")) {
            return false;
        }

        // Calcula d√≠gitos verificadores
        try {
            int[] digits = cpf.chars().map(c -> c - '0').toArray();

            // Primeiro d√≠gito verificador
            int sum = 0;
            for (int i = 0; i < 9; i++) {
                sum += digits[i] * (10 - i);
            }
            int firstDigit = 11 - (sum % 11);
            if (firstDigit >= 10) firstDigit = 0;

            if (digits[9] != firstDigit) {
                return false;
            }

            // Segundo d√≠gito verificador
            sum = 0;
            for (int i = 0; i < 10; i++) {
                sum += digits[i] * (11 - i);
            }
            int secondDigit = 11 - (sum % 11);
            if (secondDigit >= 10) secondDigit = 0;

            return digits[10] == secondDigit;

        } catch (Exception e) {
            return false;
        }
    }
}

// Uso
@Data
class ClienteRequest {

    @NotBlank
    @ValidCpf // ‚úÖ Valida CPF
    private String cpf;
}
```

---

#### Enum Validator

```java
// üîß ENUM VALIDATOR
package com.empresa.produtos.validation;

import jakarta.validation.Constraint;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.Payload;

import java.lang.annotation.*;
import java.util.Arrays;

// Anota√ß√£o
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = EnumValidator.class)
@Documented
public @interface ValidEnum {
    String message() default "Valor inv√°lido";
    Class<? extends Enum<?>> enumClass();
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Implementa√ß√£o
class EnumValidator implements ConstraintValidator<ValidEnum, String> {

    private Enum<?>[] enumValues;

    @Override
    public void initialize(ValidEnum annotation) {
        enumValues = annotation.enumClass().getEnumConstants();
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }

        return Arrays.stream(enumValues)
                .anyMatch(e -> e.name().equals(value));
    }
}

// Uso
enum StatusPedido {
    PENDENTE, PROCESSANDO, CONCLUIDO, CANCELADO
}

@Data
class PedidoRequest {

    @NotNull
    @ValidEnum(enumClass = StatusPedido.class, message = "Status inv√°lido. Valores permitidos: PENDENTE, PROCESSANDO, CONCLUIDO, CANCELADO")
    private String status;
}
```

---

#### Date Range Validator

```java
// üîß DATE RANGE VALIDATOR
package com.empresa.produtos.validation;

import jakarta.validation.Constraint;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.Payload;

import java.lang.annotation.*;
import java.time.LocalDate;

// Anota√ß√£o
@Target(ElementType.TYPE) // Valida a classe inteira
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = DateRangeValidator.class)
@Documented
public @interface ValidDateRange {
    String message() default "Data final deve ser posterior √† data inicial";
    String startField();
    String endField();
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Implementa√ß√£o
class DateRangeValidator implements ConstraintValidator<ValidDateRange, Object> {

    private String startField;
    private String endField;

    @Override
    public void initialize(ValidDateRange annotation) {
        this.startField = annotation.startField();
        this.endField = annotation.endField();
    }

    @Override
    public boolean isValid(Object value, ConstraintValidatorContext context) {
        try {
            var startDate = (LocalDate) value.getClass()
                    .getDeclaredField(startField)
                    .get(value);

            var endDate = (LocalDate) value.getClass()
                    .getDeclaredField(endField)
                    .get(value);

            if (startDate == null || endDate == null) {
                return true;
            }

            return !endDate.isBefore(startDate);

        } catch (Exception e) {
            return false;
        }
    }
}

// Uso
@Data
@ValidDateRange(startField = "dataInicio", endField = "dataFim") // ‚úÖ Valida consist√™ncia entre campos
class RelatorioRequest {

    @NotNull
    private LocalDate dataInicio;

    @NotNull
    private LocalDate dataFim;
}
```

---

### 6Ô∏è‚É£ Grupos de Valida√ß√£o

```java
// üì¶ VALIDATION GROUPS
package com.empresa.produtos.validation;

public interface ValidationGroups {
    interface Create {}
    interface Update {}
}

// DTO com grupos
@Data
class ProdutoRequest {

    @Null(groups = Create.class, message = "ID deve ser nulo na cria√ß√£o")
    @NotNull(groups = Update.class, message = "ID √© obrigat√≥rio na atualiza√ß√£o")
    private Long id;

    @NotBlank(groups = {Create.class, Update.class}, message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, groups = {Create.class, Update.class})
    private String nome;

    @NotNull(groups = Create.class, message = "Pre√ßo √© obrigat√≥rio na cria√ß√£o")
    @DecimalMin(value = "0.01", groups = {Create.class, Update.class})
    private BigDecimal preco;
}

// Controller usando grupos
@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @PostMapping
    public ResponseEntity<ProdutoDTO> criar(
            @Validated(Create.class) @RequestBody ProdutoRequest request) {
        // ‚úÖ Valida apenas anota√ß√µes do grupo Create
        return ResponseEntity.ok(service.criar(request));
    }

    @PutMapping("/{id}")
    public ResponseEntity<ProdutoDTO> atualizar(
            @PathVariable Long id,
            @Validated(Update.class) @RequestBody ProdutoRequest request) {
        // ‚úÖ Valida apenas anota√ß√µes do grupo Update
        return ResponseEntity.ok(service.atualizar(id, request));
    }
}
```

---

### 7Ô∏è‚É£ Valida√ß√£o na Service Layer

```java
// üíº SERVICE
package com.empresa.produtos.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;

@Service
@Validated // ‚úÖ Habilita valida√ß√£o no service
@RequiredArgsConstructor
public class ProdutoService {

    private final ProdutoRepository repository;

    public ProdutoDTO criar(@Valid ProdutoRequest request) {
        // ‚úÖ Valida√ß√£o autom√°tica mesmo sem @RestController

        // Valida√ß√£o customizada de neg√≥cio
        if (repository.existsByNome(request.getNome())) {
            throw new BusinessException("J√° existe produto com este nome");
        }

        Produto produto = new Produto(request);
        produto = repository.save(produto);

        return new ProdutoDTO(produto);
    }

    public ProdutoDTO buscar(@NotNull(message = "ID √© obrigat√≥rio") Long id) {
        // ‚úÖ Valida par√¢metro

        return repository.findById(id)
                .map(ProdutoDTO::new)
                .orElseThrow(() -> new ResourceNotFoundException("Produto n√£o encontrado"));
    }
}
```

---

### 8Ô∏è‚É£ Valida√ß√£o em Entidades JPA

```java
// üì¶ ENTITY
package com.empresa.produtos.domain;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;

@Data
@Entity
@Table(name = "produtos")
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(min = 3, max = 100)
    @Column(nullable = false, length = 100, unique = true)
    private String nome;

    @NotBlank
    @Size(max = 500)
    @Column(nullable = false, length = 500)
    private String descricao;

    @NotNull
    @DecimalMin("0.01")
    @Digits(integer = 6, fraction = 2)
    @Column(nullable = false, precision = 8, scale = 2)
    private BigDecimal preco;

    @Min(0)
    @Column(nullable = false)
    private Integer quantidade = 0;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private Categoria categoria;
}

// Configura√ß√£o para validar antes de persistir
@Configuration
class JpaValidationConfig {

    @Bean
    public LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }

    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}
```

---

### 9Ô∏è‚É£ Internacionaliza√ß√£o (i18n)

```properties
# src/main/resources/ValidationMessages.properties

# Bean Validation padr√£o
jakarta.validation.constraints.NotBlank.message=Campo obrigat√≥rio
jakarta.validation.constraints.NotNull.message=Campo obrigat√≥rio
jakarta.validation.constraints.Size.message=Tamanho deve estar entre {min} e {max}
jakarta.validation.constraints.Min.message=Valor m√≠nimo √© {value}
jakarta.validation.constraints.Max.message=Valor m√°ximo √© {value}
jakarta.validation.constraints.Email.message=Email inv√°lido
jakarta.validation.constraints.Past.message=Data deve ser no passado
jakarta.validation.constraints.Future.message=Data deve ser no futuro

# Valida√ß√µes customizadas
produto.nome.obrigatorio=Nome do produto √© obrigat√≥rio
produto.preco.invalido=Pre√ßo deve ser maior que zero
produto.categoria.invalida=Categoria inv√°lida
```

```properties
# ValidationMessages_pt_BR.properties
produto.nome.obrigatorio=Nome do produto √© obrigat√≥rio
produto.preco.invalido=Pre√ßo deve ser maior que zero

# ValidationMessages_en_US.properties
produto.nome.obrigatorio=Product name is required
produto.preco.invalido=Price must be greater than zero
```

```java
// Uso no DTO
@Data
class ProdutoRequest {

    @NotBlank(message = "{produto.nome.obrigatorio}") // ‚úÖ Usa mensagem internacionalizada
    private String nome;

    @DecimalMin(value = "0.01", message = "{produto.preco.invalido}")
    private BigDecimal preco;
}
```

---

## üß™ Testes de Valida√ß√£o

### 1Ô∏è‚É£ Testes Unit√°rios de Validadores

```java
// üß™ TEST
package com.empresa.produtos.validation;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

class ProdutoRequestValidationTest {

    private Validator validator;

    @BeforeEach
    void setup() {
        validator = Validation.buildDefaultValidatorFactory().getValidator();
    }

    @Test
    void deveria_falhar_quando_nome_nulo() {
        // Arrange
        ProdutoRequest request = new ProdutoRequest();
        request.setNome(null);
        request.setPreco(BigDecimal.TEN);
        request.setCategoria("ELETRONICOS");

        // Act
        Set<ConstraintViolation<ProdutoRequest>> violations = validator.validate(request);

        // Assert
        assertThat(violations).hasSize(1);
        assertThat(violations).extracting("message").contains("Nome √© obrigat√≥rio");
    }

    @Test
    void deveria_falhar_quando_preco_negativo() {
        // Arrange
        ProdutoRequest request = new ProdutoRequest();
        request.setNome("Produto Teste");
        request.setPreco(BigDecimal.valueOf(-10));
        request.setCategoria("ELETRONICOS");

        // Act
        Set<ConstraintViolation<ProdutoRequest>> violations = validator.validate(request);

        // Assert
        assertThat(violations).hasSize(1);
        assertThat(violations).extracting("message").contains("Pre√ßo deve ser maior que zero");
    }

    @Test
    void deveria_passar_quando_dados_validos() {
        // Arrange
        ProdutoRequest request = new ProdutoRequest();
        request.setNome("Notebook Dell");
        request.setDescricao("Notebook Dell Inspiron 15");
        request.setPreco(BigDecimal.valueOf(3500.00));
        request.setQuantidade(10);
        request.setCategoria("ELETRONICOS");

        // Act
        Set<ConstraintViolation<ProdutoRequest>> violations = validator.validate(request);

        // Assert
        assertThat(violations).isEmpty();
    }
}
```

---

### 2Ô∏è‚É£ Testes de Validadores Customizados

```java
// üß™ TEST
package com.empresa.produtos.validation;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import static org.assertj.core.api.Assertions.assertThat;

class CpfValidatorTest {

    private final CpfValidator validator = new CpfValidator();

    @ParameterizedTest
    @ValueSource(strings = {
            "123.456.789-09",
            "12345678909",
            "111.444.777-35"
    })
    void deveria_aceitar_cpf_valido(String cpf) {
        assertThat(validator.isValid(cpf, null)).isTrue();
    }

    @ParameterizedTest
    @ValueSource(strings = {
            "123.456.789-00",
            "111.111.111-11",
            "000.000.000-00",
            "12345678900",
            "123"
    })
    void deveria_rejeitar_cpf_invalido(String cpf) {
        assertThat(validator.isValid(cpf, null)).isFalse();
    }

    @Test
    void deveria_aceitar_cpf_nulo() {
        assertThat(validator.isValid(null, null)).isTrue();
    }
}
```

---

### 3Ô∏è‚É£ Testes de Integra√ß√£o (Controller)

```java
// üß™ INTEGRATION TEST
package com.empresa.produtos.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(ProdutoController.class)
class ProdutoControllerValidationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void deveria_retornar_400_quando_request_invalido() throws Exception {
        // Arrange
        ProdutoRequest request = new ProdutoRequest();
        request.setNome(""); // Inv√°lido
        request.setPreco(BigDecimal.valueOf(-10)); // Inv√°lido

        // Act & Assert
        mockMvc.perform(post("/api/produtos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.status").value(400))
                .andExpect(jsonPath("$.violations.nome").exists())
                .andExpect(jsonPath("$.violations.preco").exists());
    }

    @Test
    void deveria_retornar_200_quando_request_valido() throws Exception {
        // Arrange
        ProdutoRequest request = new ProdutoRequest();
        request.setNome("Notebook Dell");
        request.setDescricao("Notebook Dell Inspiron");
        request.setPreco(BigDecimal.valueOf(3500.00));
        request.setQuantidade(10);
        request.setCategoria("ELETRONICOS");

        // Act & Assert
        mockMvc.perform(post("/api/produtos")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk());
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use grupos de valida√ß√£o para cen√°rios diferentes
@Validated(Create.class) // Cria√ß√£o
@Validated(Update.class) // Atualiza√ß√£o

// ‚úÖ Valide cole√ß√µes e elementos internos
@NotEmpty
private List<@Valid ItemPedidoDTO> itens;

// ‚úÖ Use validadores customizados para regras complexas
@ValidCpf
@ValidEnum(enumClass = StatusPedido.class)

// ‚úÖ Mensagens de erro claras e internacionalizadas
@NotBlank(message = "{produto.nome.obrigatorio}")

// ‚úÖ Valide na camada de servi√ßo tamb√©m (defesa em profundidade)
@Service
@Validated
class ProdutoService {
    void criar(@Valid ProdutoRequest request) { }
}

// ‚úÖ Combine valida√ß√µes de Bean Validation com valida√ß√µes de neg√≥cio
if (repository.existsByNome(request.getNome())) {
    throw new BusinessException("Nome duplicado");
}
```

---

### ‚ùå Anti-Patterns

```java
// ‚ùå Valida√ß√£o manual quando Bean Validation resolve
if (request.getNome() == null) { } // Use @NotNull

// ‚ùå Mensagens hardcoded
@NotBlank(message = "Nome obrigat√≥rio") // Use i18n

// ‚ùå Ignorar valida√ß√£o em camadas internas
service.criar(request); // Validar tamb√©m no service

// ‚ùå Valida√ß√£o duplicada
// Controller valida E service valida manualmente (use @Valid)

// ‚ùå Exce√ß√µes gen√©ricas
throw new RuntimeException("Erro"); // Use ValidationException
```

---

## üîç Anota√ß√µes Mais Comuns

| Anota√ß√£o        | Uso                            | Exemplo                             |
| --------------- | ------------------------------ | ----------------------------------- |
| @NotNull        | Campo n√£o pode ser null        | `@NotNull Long id`                  |
| @NotBlank       | String n√£o pode ser null/vazia | `@NotBlank String nome`             |
| @NotEmpty       | Collection n√£o pode ser vazia  | `@NotEmpty List<String> tags`       |
| @Size           | Tamanho de String/Collection   | `@Size(min=3, max=100) String nome` |
| @Min / @Max     | Valor num√©rico m√≠nimo/m√°ximo   | `@Min(0) @Max(999) Integer qtd`     |
| @DecimalMin/Max | BigDecimal m√≠nimo/m√°ximo       | `@DecimalMin("0.01") BigDecimal`    |
| @Email          | Valida formato de email        | `@Email String email`               |
| @Pattern        | Regex customizado              | `@Pattern(regexp="\\d{5}-\\d{3}")`  |
| @Past / @Future | Data no passado/futuro         | `@Past LocalDate nascimento`        |
| @Valid          | Valida objeto aninhado         | `@Valid EnderecoDTO endereco`       |

---

## ‚öñÔ∏è Vantagens e Desvantagens

### ‚úÖ Vantagens

- **Declarativo**: Valida√ß√£o via anota√ß√µes (menos c√≥digo)
- **Reutiliz√°vel**: Validadores customizados compartilhados
- **Padronizado**: JSR-380 (Bean Validation 2.0)
- **Internacionalizado**: Mensagens traduz√≠veis
- **Test√°vel**: F√°cil testar validadores isoladamente

### ‚ö†Ô∏è Desvantagens

- **Complexidade**: Valida√ß√µes complexas podem ser verbosas
- **Performance**: Reflex√£o tem overhead (m√≠nimo)
- **Limita√ß√µes**: Valida√ß√µes ass√≠ncronas ou com IO dif√≠ceis

---

## üéØ Quando Usar?

| Cen√°rio                       | Bean Validation?        |
| ----------------------------- | ----------------------- |
| Validar entrada de API        | ‚úÖ Sempre               |
| Validar par√¢metros de m√©todos | ‚úÖ Com @Validated       |
| Regras de neg√≥cio simples     | ‚úÖ Validadores custom   |
| Regras complexas com banco    | ‚ö†Ô∏è Combinar com service |
| Valida√ß√£o ass√≠ncrona          | ‚ùå Implementar manual   |

---

## üîó Recursos

- [Bean Validation 2.0 (JSR-380)](https://beanvalidation.org/)
- [Hibernate Validator](https://hibernate.org/validator/)
- [Spring Validation](https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html)

---

## üìù Resumo

**Bean Validation** com validadores customizados garante:

- ‚úÖ Valida√ß√£o declarativa e reutiliz√°vel
- ‚úÖ Mensagens de erro consistentes e internacionalizadas
- ‚úÖ Valida√ß√£o em m√∫ltiplas camadas (controller, service, entity)
- ‚úÖ Validadores customizados para regras de neg√≥cio
- ‚úÖ Grupos de valida√ß√£o para cen√°rios diferentes

**Regra de ouro:** Valide dados na entrada (controller) e em pontos cr√≠ticos (service), combinando Bean Validation com valida√ß√µes de neg√≥cio.
