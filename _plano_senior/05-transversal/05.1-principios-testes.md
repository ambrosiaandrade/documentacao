# 5.1 Princ√≠pios Fundamentais de Testes [TODOS OS N√çVEIS]

üéØ **Objetivo:** Dominar os princ√≠pios universais que guiam a cria√ß√£o de testes eficazes, independente da tecnologia ou framework.

---

## Por Que Princ√≠pios Importam?

Princ√≠pios fornecem a base conceitual para decis√µes t√©cnicas. Ao entender **por que** testamos de certas formas, voc√™ pode:

‚úÖ Tomar decis√µes conscientes sobre trade-offs  
‚úÖ Adaptar pr√°ticas a diferentes contextos  
‚úÖ Evitar seguir "receitas" sem entendimento  
‚úÖ Criar testes manuten√≠veis em longo prazo

---

## üéØ FIRST Principles

Acr√¥nimo que define caracter√≠sticas de bons testes unit√°rios:

### **F - Fast (R√°pido)**

Testes devem executar em **milissegundos**.

**Por qu√™?**

- Feedback imediato durante desenvolvimento
- Viabiliza execu√ß√£o frequente (TDD, CI/CD)
- Mant√©m produtividade alta

**Como alcan√ßar:**

```java
// ‚ùå LENTO - Acessa banco real
@Test
void buscarUsuario() {
    Usuario u = repositorio.findById(1L); // 200ms
    assertNotNull(u);
}

// ‚úÖ R√ÅPIDO - Mock ou in-memory
@Test
void buscarUsuario() {
    Usuario mock = new Usuario(1L, "Admin");
    when(repo.findById(1L)).thenReturn(Optional.of(mock));
    Usuario u = service.buscar(1L); // <1ms
    assertNotNull(u);
}
```

**Exce√ß√µes leg√≠timas:**

- Testes de integra√ß√£o (segundos aceit√°veis)
- Testes E2E (minutos toler√°veis)
- Performance/carga (horas quando necess√°rio)

---

### **I - Independent (Independente)**

Cada teste deve executar **isoladamente**, sem depender da ordem ou estado de outros.

**Por qu√™?**

- Evita falhas em cascata
- Permite execu√ß√£o paralela
- Facilita debugging (1 falha = 1 problema)

**Viola√ß√£o comum:**

```java
class EstadoCompartilhadoTest {
    static List<String> cache = new ArrayList<>(); // ‚ö†Ô∏è PERIGO

    @Test
    void test1() {
        cache.add("A");
        assertEquals(1, cache.size()); // Passa se executar primeiro
    }

    @Test
    void test2() {
        assertEquals(0, cache.size()); // Falha se test1 rodou antes
    }
}
```

**Solu√ß√£o:**

```java
class IsoladoTest {
    private List<String> cache; // Inst√¢ncia

    @BeforeEach
    void setup() {
        cache = new ArrayList<>(); // Reset autom√°tico
    }

    @Test void test1() { cache.add("A"); assertEquals(1, cache.size()); }
    @Test void test2() { assertEquals(0, cache.size()); }
}
```

---

### **R - Repeatable (Repet√≠vel)**

Executar 100x deve produzir **mesmo resultado** sempre.

**Por qu√™?**

- Confiabilidade do CI/CD
- Debugging eficiente
- Evita "funciona na minha m√°quina"

**Viola√ß√µes t√≠picas:**

#### 1. Depend√™ncia de Data/Hora Atual

```java
// ‚ùå FLAKY - Falha se rodado ap√≥s meia-noite
@Test
void validarIdade() {
    LocalDate nascimento = LocalDate.of(2000, 1, 1);
    int idade = Period.between(nascimento, LocalDate.now()).getYears();
    assertTrue(idade > 18);
}

// ‚úÖ REPET√çVEL - Injeta clock
@Test
void validarIdade() {
    Clock fixo = Clock.fixed(Instant.parse("2025-01-01T00:00:00Z"), ZoneId.of("UTC"));
    LocalDate hoje = LocalDate.now(fixo);
    LocalDate nascimento = LocalDate.of(2000, 1, 1);
    assertEquals(25, Period.between(nascimento, hoje).getYears());
}
```

#### 2. Concorr√™ncia Sem Sincroniza√ß√£o

```java
// ‚ùå FLAKY - Race condition
@Test
void incrementoParalelo() {
    int[] contador = {0};
    IntStream.range(0, 1000).parallel()
        .forEach(i -> contador[0]++); // N√ÉO thread-safe
    assertEquals(1000, contador[0]); // √Äs vezes 998, 999...
}

// ‚úÖ REPET√çVEL - AtomicInteger
@Test
void incrementoParalelo() {
    AtomicInteger contador = new AtomicInteger();
    IntStream.range(0, 1000).parallel()
        .forEach(i -> contador.incrementAndGet());
    assertEquals(1000, contador.get());
}
```

#### 3. Ordem de Cole√ß√µes N√£o Determin√≠stica

```java
// ‚ùå FLAKY - HashSet n√£o garante ordem
@Test
void listarUsuarios() {
    Set<String> users = new HashSet<>(Arrays.asList("Ana", "Bob"));
    assertEquals("[Ana, Bob]", users.toString()); // Pode ser [Bob, Ana]
}

// ‚úÖ REPET√çVEL - LinkedHashSet ou assertThat
@Test
void listarUsuarios() {
    Set<String> users = new LinkedHashSet<>(Arrays.asList("Ana", "Bob"));
    assertThat(users).containsExactly("Ana", "Bob"); // Ordem expl√≠cita
}
```

---

### **S - Self-Validating (Auto-validante)**

Teste deve ter resultado **bin√°rio**: passa ou falha. Sem interpreta√ß√£o manual.

**Por qu√™?**

- Automa√ß√£o completa
- CI/CD confi√°vel
- Remove ambiguidade

**Errado:**

```java
// ‚ùå Requer inspe√ß√£o manual do log
@Test
void validarAPI() {
    String resp = api.buscar();
    System.out.println(resp); // ‚ö†Ô∏è Humano precisa verificar
}
```

**Correto:**

```java
// ‚úÖ Assert expl√≠cito
@Test
void validarAPI() {
    String resp = api.buscar();
    assertTrue(resp.contains("\"status\":\"ok\""));
    assertFalse(resp.contains("error"));
}
```

---

### **T - Timely (Oportuno)**

Testes devem ser escritos **antes ou junto** com o c√≥digo de produ√ß√£o.

**Por qu√™?**

- TDD: design emerge dos requisitos
- Evita c√≥digo "n√£o test√°vel"
- Documenta√ß√£o viva desde o in√≠cio

**Fluxo TDD:**

```
1. üî¥ Red   ‚Üí Escrever teste que falha
2. üü¢ Green ‚Üí Implementar m√≠nimo para passar
3. üîµ Blue  ‚Üí Refatorar com seguran√ßa
```

**Exemplo:**

```java
// 1. RED - Teste antes da implementa√ß√£o
@Test
void calcularDesconto() {
    Pedido p = new Pedido(100.0);
    assertEquals(90.0, p.aplicarDesconto(10), 0.01);
}

// 2. GREEN - Implementa√ß√£o m√≠nima
class Pedido {
    private double valor;
    double aplicarDesconto(double percentual) {
        return valor * (1 - percentual/100);
    }
}

// 3. BLUE - Refatorar
class Pedido {
    double aplicarDesconto(double percentual) {
        validarPercentual(percentual);
        return valor * (1 - percentual/100);
    }
    private void validarPercentual(double p) {
        if (p < 0 || p > 100) throw new IllegalArgumentException();
    }
}
```

---

## üß™ AAA Pattern (Arrange-Act-Assert)

Estrutura universal para organizar testes.

### Anatomia

```java
@Test
void exemploAAA() {
    // üîß ARRANGE (Given) - Preparar cen√°rio
    Calculadora calc = new Calculadora();
    int a = 5, b = 3;

    // ‚ö° ACT (When) - Executar a√ß√£o
    int resultado = calc.somar(a, b);

    // ‚úÖ ASSERT (Then) - Verificar resultado
    assertEquals(8, resultado);
}
```

### Benef√≠cios

‚úÖ **Legibilidade** - Estrutura √≥bvia  
‚úÖ **Manuten√ß√£o** - F√°cil localizar se√ß√µes  
‚úÖ **Documenta√ß√£o** - Intent claro

### Varia√ß√µes

#### BDD: Given-When-Then

```java
@Test
void validarLogin() {
    // Given um usu√°rio cadastrado
    Usuario user = new Usuario("admin", "123");
    when(repo.findByUsername("admin")).thenReturn(Optional.of(user));

    // When tenta fazer login
    boolean sucesso = service.autenticar("admin", "123");

    // Then deve autenticar com sucesso
    assertTrue(sucesso);
}
```

#### Testes complexos: m√∫ltiplos acts/asserts

```java
@Test
void fluxoCarrinho() {
    // Arrange
    Carrinho c = new Carrinho();
    Produto p1 = new Produto("Livro", 50.0);
    Produto p2 = new Produto("Caneta", 2.0);

    // Act 1 + Assert 1
    c.adicionar(p1);
    assertEquals(1, c.quantidade());

    // Act 2 + Assert 2
    c.adicionar(p2);
    assertEquals(2, c.quantidade());
    assertEquals(52.0, c.total(), 0.01);
}
```

---

## üîç Testes de Unidade vs Integra√ß√£o vs E2E

### Pir√¢mide de Testes

```
           /\
          /  \  E2E (poucos)
         /----\
        / INTG \ Integra√ß√£o (m√©dio)
       /--------\
      /  UNIT   \ Unidade (muitos)
     /____________\
```

### Caracter√≠sticas

| Aspecto            | Unidade         | Integra√ß√£o         | E2E                |
| ------------------ | --------------- | ------------------ | ------------------ |
| **Escopo**         | 1 classe/m√©todo | 2+ componentes     | Sistema completo   |
| **Velocidade**     | <10ms           | 100-500ms          | 1-10s              |
| **Isolamento**     | Alto (mocks)    | M√©dio (containers) | Baixo (real)       |
| **Confiabilidade** | Alta (sem I/O)  | M√©dia (rede/DB)    | Baixa (UI/browser) |
| **Quantidade**     | 70-80%          | 15-20%             | 5-10%              |

### Quando usar cada tipo

#### Unidade: L√≥gica de Neg√≥cio

```java
@Test
void calcularJurosCompostos() {
    double montante = Financeiro.calcularJuros(1000, 0.05, 2);
    assertEquals(1102.50, montante, 0.01);
}
```

#### Integra√ß√£o: Componentes Reais

```java
@SpringBootTest
@Testcontainers
class RepositorioIntegracaoTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @Test
    void salvarEBuscar() {
        Usuario u = repo.save(new Usuario("admin"));
        Optional<Usuario> encontrado = repo.findById(u.getId());
        assertTrue(encontrado.isPresent());
    }
}
```

#### E2E: Fluxo do Usu√°rio

```java
@Test
void fluxoCompra() {
    navegador.acessar("/produtos");
    navegador.clicar("#produto-1 .adicionar");
    navegador.clicar("#carrinho");
    navegador.preencher("#cpf", "12345678901");
    navegador.clicar("#finalizar");
    assertTrue(navegador.textoPresente("Pedido confirmado"));
}
```

---

## üéØ Princ√≠pios para Testes Concorrentes

Testes de c√≥digo ass√≠ncrono/paralelo exigem aten√ß√£o especial:

### 1. Determinismo Relativo

```java
// ‚ùå Sleep fixo √© fr√°gil
@Test
void aguardarProcessamento() throws InterruptedException {
    service.processar();
    Thread.sleep(2000); // Pode ser insuficiente em m√°quina lenta
    assertTrue(service.concluido());
}

// ‚úÖ Await com condi√ß√£o
@Test
void aguardarProcessamento() {
    service.processar();
    await().atMost(5, SECONDS).until(() -> service.concluido());
}
```

### 2. Sincroniza√ß√£o Expl√≠cita

```java
@Test
void iniciarSimultaneo() throws InterruptedException {
    int threads = 10;
    CountDownLatch start = new CountDownLatch(1);
    CountDownLatch fim = new CountDownLatch(threads);

    for (int i = 0; i < threads; i++) {
        new Thread(() -> {
            start.await(); // Todos aguardam sinal
            // Executar a√ß√£o
            fim.countDown();
        }).start();
    }

    start.countDown(); // Libera todos simultaneamente
    assertTrue(fim.await(5, SECONDS));
}
```

### 3. Usar Estruturas Thread-Safe

```java
// ‚úÖ AtomicInteger garante opera√ß√£o at√¥mica
AtomicInteger contador = new AtomicInteger();
IntStream.range(0, 1000).parallel()
    .forEach(i -> contador.incrementAndGet());
assertEquals(1000, contador.get());
```

---

## ‚ö† Anti-Princ√≠pios: O Que Evitar

### 1. Testes que Testam o Framework

```java
// ‚ùå Testando getter/setter (sem l√≥gica)
@Test
void setNomeDeveDefinirNome() {
    Usuario u = new Usuario();
    u.setNome("Admin");
    assertEquals("Admin", u.getNome());
}
```

### 2. Testes Acoplados √† Implementa√ß√£o

```java
// ‚ùå Verificando detalhes internos
@Test
void buscarUsuario() {
    service.buscar(1L);
    verify(cache, times(1)).get("user:1"); // ‚ö†Ô∏è Detalhe interno
    verify(db, never()).query(any()); // ‚ö†Ô∏è Fr√°gil
}

// ‚úÖ Testar comportamento p√∫blico
@Test
void buscarUsuario() {
    Usuario u = service.buscar(1L);
    assertNotNull(u);
    assertEquals("Admin", u.getNome());
}
```

### 3. Testes Gen√©ricos Demais

```java
// ‚ùå N√£o valida comportamento espec√≠fico
@Test
void testarServico() {
    assertNotNull(service.processar());
}

// ‚úÖ Assert espec√≠fico
@Test
void processarDeveRetornarStatusOk() {
    Resultado r = service.processar();
    assertEquals(Status.OK, r.getStatus());
    assertFalse(r.getErros().isEmpty());
}
```

---

## ‚úÖ Checklist de Princ√≠pios

- [ ] Meus testes seguem **FIRST** (Fast, Independent, Repeatable, Self-Validating, Timely)?
- [ ] Uso **AAA** para estruturar testes claramente?
- [ ] Balanceio correto entre testes de **unidade/integra√ß√£o/E2E**?
- [ ] Evito **sleep** em testes ass√≠ncronos (uso await/latch)?
- [ ] Testes s√£o **independentes** (sem estado compartilhado)?
- [ ] Testes validam **comportamento**, n√£o implementa√ß√£o?
- [ ] Uso **Clock/Instant fixo** para datas em vez de `now()`?
- [ ] Testes concorrentes usam estruturas **thread-safe**?

---

## üß† Perguntas Reflexivas

1. Por que a pir√¢mide recomenda mais testes de unidade que E2E?
2. Qual o trade-off entre velocidade e confiabilidade em testes?
3. Como TDD influencia o design do c√≥digo de produ√ß√£o?
4. Quando √© aceit√°vel um teste levar segundos para executar?
5. Como garantir que testes continuem relevantes ap√≥s refatora√ß√µes?

---

## üìö Refer√™ncias e Leitura Adicional

- **Livros:**

  - "Growing Object-Oriented Software, Guided by Tests" (Freeman & Pryce)
  - "Test Driven Development: By Example" (Kent Beck)
  - "Working Effectively with Legacy Code" (Michael Feathers)

- **Artigos:**
  - [Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html) - Martin Fowler
  - [FIRST Principles](https://github.com/ghsukumar/SFDC_Best_Practices/wiki/F.I.R.S.T-Principles-of-Unit-Testing)

---

## üìö Pr√≥ximos Passos

- [5.2 Boas Pr√°ticas de Testes](05.2-boas-praticas.md) - Conven√ß√µes e padr√µes
- [5.3 Anti-Patterns](05.3-anti-patterns.md) - Erros comuns a evitar
- [5.4 Gloss√°rio de Testes](05.4-glossario.md) - Termos t√©cnicos
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [TODOS OS N√çVEIS]  
**Tempo Estimado:** 2 horas
