# 05.7 Annotations em Java e Spring [TRANSVERSAL] ‚úÖ

## üéØ Objetivo

Dominar **annotations** em Java e Spring: desde **built-in annotations** at√© **custom annotations**, **meta-annotations**, **retention policies**, **annotation processors** e o **ecossistema Spring annotations**.

---

## üìö O que s√£o Annotations?

**Annotations** (anota√ß√µes) s√£o **metadados** adicionados ao c√≥digo que fornecem **informa√ß√µes** ao compilador, ferramentas de build ou frameworks em **runtime**.

**Sintaxe:**

```java
@AnnotationName
@AnnotationName(value = "something")
@AnnotationName(param1 = "value1", param2 = 123)
```

---

## üèóÔ∏è Built-in Java Annotations

### @Override

Indica que um m√©todo **sobrescreve** um m√©todo da superclasse.

```java
public class Animal {
    public void makeSound() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {

    @Override  // Compilador verifica se m√©todo existe na superclasse
    public void makeSound() {
        System.out.println("Woof!");
    }

    // @Override
    // public void makeSond() {  // ‚ùå ERRO: Typo detectado pelo compilador
    //     System.out.println("Woof!");
    // }
}
```

### @Deprecated

Marca c√≥digo como **obsoleto** (n√£o deve ser usado).

```java
public class Calculator {

    /**
     * @deprecated Use {@link #add(int, int)} instead
     */
    @Deprecated(since = "2.0", forRemoval = true)
    public int sum(int a, int b) {
        return a + b;
    }

    public int add(int a, int b) {
        return a + b;
    }
}

// Uso:
Calculator calc = new Calculator();
calc.sum(5, 3);  // ‚ö†Ô∏è Warning: 'sum(int, int)' is deprecated
```

### @SuppressWarnings

Suprime **warnings** do compilador.

```java
public class Example {

    @SuppressWarnings("unused")
    private String unusedField;  // Sem warning

    @SuppressWarnings("unchecked")
    public void unsafeOperation() {
        List list = new ArrayList();  // Sem warning de tipo n√£o parametrizado
        list.add("String");
    }

    @SuppressWarnings({"unused", "deprecation"})
    public void multipleWarnings() {
        Calculator calc = new Calculator();
        calc.sum(1, 2);  // Sem warning de deprecation
    }
}
```

### @FunctionalInterface

Marca interface como **funcional** (exatamente 1 m√©todo abstrato).

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);

    // M√©todos default/static s√£o permitidos
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }

    static void info() {
        System.out.println("Calculator interface");
    }
}

// Uso com Lambda:
Calculator sum = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;
```

### @SafeVarargs

Suprime warnings em m√©todos **varargs** com **generics**.

```java
public class VarargsExample {

    @SafeVarargs
    @SuppressWarnings("varargs")
    public final <T> void printAll(T... items) {
        for (T item : items) {
            System.out.println(item);
        }
    }

    // Uso:
    public static void main(String[] args) {
        VarargsExample example = new VarargsExample();
        example.printAll("A", "B", "C");
        example.printAll(1, 2, 3);
    }
}
```

---

## üé® Meta-Annotations

**Meta-annotations** s√£o anota√ß√µes aplicadas a **outras anota√ß√µes**.

### @Target

Define **onde** a annotation pode ser aplicada.

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

// Apenas em campos
@Target(ElementType.FIELD)
public @interface Column {
    String name();
}

// Em m√∫ltiplos lugares
@Target({ElementType.METHOD, ElementType.TYPE})
public @interface Transactional {
}

// Em qualquer lugar
@Target({
    ElementType.TYPE,           // Classes, interfaces, enums
    ElementType.FIELD,          // Campos
    ElementType.METHOD,         // M√©todos
    ElementType.PARAMETER,      // Par√¢metros de m√©todos
    ElementType.CONSTRUCTOR,    // Construtores
    ElementType.LOCAL_VARIABLE, // Vari√°veis locais
    ElementType.ANNOTATION_TYPE,// Outras annotations
    ElementType.PACKAGE,        // Pacotes
    ElementType.TYPE_PARAMETER, // Par√¢metros de tipo gen√©rico
    ElementType.TYPE_USE        // Uso de tipo
})
public @interface MyAnnotation {
}
```

### @Retention

Define **quando** a annotation est√° dispon√≠vel.

```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

// SOURCE: Descartada pelo compilador (para ferramentas)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}

// CLASS: Gravada no .class, mas n√£o dispon√≠vel em runtime (padr√£o)
@Retention(RetentionPolicy.CLASS)
public @interface Generated {
}

// RUNTIME: Dispon√≠vel em runtime via Reflection
@Retention(RetentionPolicy.RUNTIME)
public @interface Entity {
}
```

**Compara√ß√£o:**

| Retention | .java | .class | Runtime | Uso                             |
| --------- | ----- | ------ | ------- | ------------------------------- |
| SOURCE    | ‚úÖ    | ‚ùå     | ‚ùå      | Ferramentas, valida√ß√µes compile |
| CLASS     | ‚úÖ    | ‚úÖ     | ‚ùå      | Bytecode analysis, APT          |
| RUNTIME   | ‚úÖ    | ‚úÖ     | ‚úÖ      | Reflection, frameworks (Spring) |

### @Documented

Inclui annotation na **JavaDoc**.

```java
import java.lang.annotation.Documented;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Author {
    String name();
    String date();
}

// Aparece na JavaDoc:
/**
 * User entity
 */
@Author(name = "John Doe", date = "2025-11-15")
public class User {
}
```

### @Inherited

Permite que **subclasses** herdem a annotation.

```java
import java.lang.annotation.Inherited;

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Auditable {
}

@Auditable
public class BaseEntity {
}

// SubEntity tamb√©m ter√° @Auditable
public class User extends BaseEntity {
}
```

### @Repeatable

Permite aplicar a **mesma annotation m√∫ltiplas vezes**.

```java
import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedule {
    String day();
    String time();
}

// Container annotation
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedules {
    Schedule[] value();
}

// Uso:
@Schedule(day = "Monday", time = "10:00")
@Schedule(day = "Friday", time = "14:00")
public void meeting() {
}
```

---

## üõ†Ô∏è Custom Annotations

### Annotation Simples

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Entity {
    // Sem elementos
}

// Uso:
@Entity
public class User {
}
```

### Annotation com Elementos

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Table {

    String name();                    // Obrigat√≥rio
    String schema() default "public"; // Opcional com default
    String catalog() default "";
}

// Uso:
@Table(name = "users", schema = "app")
public class User {
}

@Table(name = "orders")  // schema = "public" (default)
public class Order {
}
```

### Annotation com Arrays

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Authors {
    String[] names();
    int[] years() default {};
}

// Uso:
@Authors(names = {"John", "Jane"}, years = {2023, 2024})
public class Book {
}
```

### Annotation com Enum

```java
public enum AccessLevel {
    READ, WRITE, ADMIN
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Secured {
    AccessLevel level() default AccessLevel.READ;
}

// Uso:
@Secured(level = AccessLevel.ADMIN)
public void deleteUser() {
}
```

### Annotation com Class

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Mapper {
    Class<?> target();
}

// Uso:
@Mapper(target = UserDTO.class)
public class UserMapper {
}
```

---

## üîç Lendo Annotations via Reflection

### Verificar se Annotation Existe

```java
public class AnnotationReader {

    public static void main(String[] args) {
        Class<User> clazz = User.class;

        // Verificar se tem annotation
        if (clazz.isAnnotationPresent(Entity.class)) {
            System.out.println("User √© uma entidade");
        }

        // Obter annotation
        Entity entity = clazz.getAnnotation(Entity.class);
        if (entity != null) {
            System.out.println("Entity encontrada");
        }
    }
}
```

### Ler Elementos da Annotation

```java
@Table(name = "users", schema = "app")
public class User {
}

public class TableReader {

    public static void main(String[] args) {
        Class<User> clazz = User.class;

        if (clazz.isAnnotationPresent(Table.class)) {
            Table table = clazz.getAnnotation(Table.class);

            System.out.println("Table name: " + table.name());    // users
            System.out.println("Schema: " + table.schema());      // app
            System.out.println("Catalog: " + table.catalog());    // (empty)
        }
    }
}
```

### Ler Annotations de M√©todos

```java
public class User {

    @Secured(level = AccessLevel.ADMIN)
    public void deleteUser() {
    }

    @Secured(level = AccessLevel.WRITE)
    public void updateUser() {
    }
}

public class MethodAnnotationReader {

    public static void main(String[] args) throws Exception {
        Class<User> clazz = User.class;

        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Secured.class)) {
                Secured secured = method.getAnnotation(Secured.class);

                System.out.printf(
                    "Method: %s, Access Level: %s%n",
                    method.getName(),
                    secured.level()
                );
            }
        }
    }
}

// Output:
// Method: deleteUser, Access Level: ADMIN
// Method: updateUser, Access Level: WRITE
```

### Ler Annotations de Campos

```java
public class User {

    @Column(name = "user_id")
    private Long id;

    @Column(name = "email_address")
    private String email;
}

public class FieldAnnotationReader {

    public static void main(String[] args) {
        Class<User> clazz = User.class;

        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);

                System.out.printf(
                    "Field: %s -> Column: %s%n",
                    field.getName(),
                    column.name()
                );
            }
        }
    }
}

// Output:
// Field: id -> Column: user_id
// Field: email -> Column: email_address
```

---

## üå± Spring Annotations - Ecossistema Completo

### Core Annotations

```java
// Component Scanning
@Component        // Componente gen√©rico
@Service          // L√≥gica de neg√≥cio
@Repository       // Acesso a dados
@Controller       // MVC Controller
@RestController   // REST API Controller (@Controller + @ResponseBody)
@Configuration    // Classe de configura√ß√£o
@Bean             // Define bean no contexto Spring

// Dependency Injection
@Autowired        // Inje√ß√£o autom√°tica
@Qualifier        // Desambigua√ß√£o
@Primary          // Bean preferencial
@Lazy             // Lazy initialization
@Value            // Injetar propriedades

// Scopes
@Scope("singleton")    // Padr√£o
@Scope("prototype")    // Nova inst√¢ncia a cada inje√ß√£o
@Scope("request")      // Por request HTTP
@Scope("session")      // Por sess√£o HTTP
@RequestScope          // Shortcut para request scope
@SessionScope          // Shortcut para session scope

// Lifecycle
@PostConstruct    // Executado ap√≥s constru√ß√£o
@PreDestroy       // Executado antes de destruir
```

### Web MVC Annotations

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    // HTTP Methods
    @GetMapping("/{id}")           // GET /api/users/1
    @PostMapping                   // POST /api/users
    @PutMapping("/{id}")           // PUT /api/users/1
    @PatchMapping("/{id}")         // PATCH /api/users/1
    @DeleteMapping("/{id}")        // DELETE /api/users/1

    // Path Variables
    public User getUser(@PathVariable Long id) { }

    // Query Parameters
    public List<User> search(@RequestParam String name) { }

    // Request Body
    public User create(@RequestBody UserDTO dto) { }

    // Headers
    public void method(@RequestHeader("X-API-Key") String apiKey) { }

    // Cookies
    public void method(@CookieValue("sessionId") String sessionId) { }
}
```

### Validation Annotations

```java
public class UserDTO {

    @NotNull
    @NotBlank
    @NotEmpty
    @Size(min = 3, max = 100)
    @Email
    @Pattern(regexp = "\\d{11}")
    @Min(18)
    @Max(100)
    @Positive
    @PositiveOrZero
    @Negative
    @NegativeOrZero
    @DecimalMin("0.01")
    @DecimalMax("999.99")
    @Digits(integer = 5, fraction = 2)
    @Past
    @PastOrPresent
    @Future
    @FutureOrPresent
    @AssertTrue
    @AssertFalse
    @Valid  // Valida nested objects
}
```

### Data JPA Annotations

```java
@Entity
@Table(name = "users", schema = "app")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "email_address", nullable = false, unique = true)
    private String email;

    @Temporal(TemporalType.TIMESTAMP)
    private Date createdAt;

    @Enumerated(EnumType.STRING)
    private UserStatus status;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Order> orders;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "company_id")
    private Company company;

    @ManyToMany
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;

    @Transient  // N√£o persiste no banco
    private String tempField;

    @Version  // Optimistic locking
    private Long version;
}
```

### Transaction Annotations

```java
@Service
public class UserService {

    @Transactional  // Transa√ß√£o com defaults
    public void createUser(User user) { }

    @Transactional(
        readOnly = true,
        isolation = Isolation.READ_COMMITTED,
        propagation = Propagation.REQUIRED,
        timeout = 30,
        rollbackFor = Exception.class,
        noRollbackFor = IllegalArgumentException.class
    )
    public User getUser(Long id) { }
}
```

### Caching Annotations

```java
@Service
@CacheConfig(cacheNames = "users")
public class UserService {

    @Cacheable(key = "#id")
    public User findById(Long id) { }

    @CachePut(key = "#user.id")
    public User update(User user) { }

    @CacheEvict(key = "#id")
    public void delete(Long id) { }

    @CacheEvict(allEntries = true)
    public void deleteAll() { }

    @Caching(
        cacheable = {@Cacheable("users")},
        evict = {@CacheEvict("orders")}
    )
    public User complexOperation() { }
}
```

### Security Annotations

```java
@RestController
public class AdminController {

    @PreAuthorize("hasRole('ADMIN')")
    public void adminOnly() { }

    @PreAuthorize("hasAnyRole('ADMIN', 'MANAGER')")
    public void managerOrAdmin() { }

    @PreAuthorize("hasAuthority('DELETE_USER')")
    public void deleteUser() { }

    @PreAuthorize("#username == authentication.principal.username")
    public void ownProfileOnly(@PathVariable String username) { }

    @PostAuthorize("returnObject.owner == authentication.principal.username")
    public Order getOrder(Long orderId) { }

    @Secured("ROLE_ADMIN")
    public void securedMethod() { }
}
```

### Testing Annotations

```java
// Unit Tests
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository repository;

    @InjectMocks
    private UserService service;

    @Test
    @DisplayName("Should create user successfully")
    void testCreateUser() { }
}

// Integration Tests
@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService service;

    @Test
    void testGetUser() throws Exception { }
}

// Data JPA Tests
@DataJpaTest
class UserRepositoryTest {

    @Autowired
    private UserRepository repository;

    @Autowired
    private TestEntityManager entityManager;

    @Test
    void testFindByEmail() { }
}

// WebMvc Tests
@WebMvcTest(UserController.class)
class UserControllerWebTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService service;
}
```

### Scheduling & Async Annotations

```java
@Service
public class ScheduledTasks {

    @Scheduled(fixedRate = 5000)  // A cada 5 segundos
    public void taskEvery5Seconds() { }

    @Scheduled(fixedDelay = 10000)  // 10s ap√≥s t√©rmino
    public void taskWithDelay() { }

    @Scheduled(cron = "0 0 0 * * ?")  // Meia-noite todo dia
    public void midnightTask() { }

    @Async
    public CompletableFuture<String> asyncTask() {
        // Executa em thread separada
        return CompletableFuture.completedFuture("Result");
    }
}
```

### Conditional Annotations

```java
@Configuration
public class ConditionalConfig {

    @Bean
    @ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
    public FeatureService featureService() { }

    @Bean
    @ConditionalOnMissingBean
    public DefaultService defaultService() { }

    @Bean
    @ConditionalOnClass(name = "com.example.OptionalClass")
    public OptionalFeature optionalFeature() { }

    @Bean
    @Profile("dev")
    public DataSource devDataSource() { }

    @Bean
    @Profile("prod")
    public DataSource prodDataSource() { }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use @Retention(RUNTIME) para annotations lidas em runtime
@Retention(RetentionPolicy.RUNTIME)

// ‚úÖ Use @Target para limitar onde a annotation pode ser aplicada
@Target({ElementType.METHOD, ElementType.TYPE})

// ‚úÖ Use @Documented para incluir na JavaDoc
@Documented

// ‚úÖ Forne√ßa defaults quando apropriado
String schema() default "public";

// ‚úÖ Nomes descritivos
@Transactional  // ‚úÖ
@Tx             // ‚ùå

// ‚úÖ Combine Spring annotations
@RestController  // = @Controller + @ResponseBody
@RequestMapping("/api")

// ‚úÖ Use @Autowired com constructor injection
@Autowired
public UserService(UserRepository repository) {
    this.repository = repository;
}
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Retention SOURCE para annotations usadas em runtime
@Retention(RetentionPolicy.SOURCE)  // ‚ùå
public @interface Entity { }

// ‚úÖ
@Retention(RetentionPolicy.RUNTIME)
public @interface Entity { }

// ‚ùå Sem @Target (pode ser aplicada em qualquer lugar)
public @interface Table { }  // ‚ùå

// ‚úÖ
@Target(ElementType.TYPE)
public @interface Table { }

// ‚ùå Field injection
@Autowired  // ‚ùå Dificulta testes
private UserRepository repository;

// ‚úÖ Constructor injection
private final UserRepository repository;

@Autowired
public UserService(UserRepository repository) {
    this.repository = repository;
}

// ‚ùå Muitas responsabilidades em uma annotation
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ...})
public @interface DoEverything { }  // ‚ùå

// ‚úÖ Annotations espec√≠ficas
@Entity  // Para classes
@Column  // Para campos
@Transactional  // Para m√©todos
```

---

## üéØ Quando Usar Custom Annotations?

### ‚úÖ Use quando:

- **Reduzir duplica√ß√£o**: Combinar m√∫ltiplas annotations
- **Documenta√ß√£o**: Tornar inten√ß√£o expl√≠cita
- **Meta-programming**: AOP, valida√ß√£o, processamento
- **Framework interno**: Conven√ß√µes da equipe

### Exemplo: Annotation Combinada

```java
// Ao inv√©s de repetir:
@RestController
@RequestMapping("/api/users")
@Validated
@Slf4j
public class UserController { }

// Crie:
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@RestController
@RequestMapping
@Validated
@Slf4j
public @interface ApiController {
    String value() default "";
}

// Use:
@ApiController("/api/users")
public class UserController { }
```

---

## üìù Resumo

**Annotations** fornecem:

- ‚úÖ **Metadados**: Informa√ß√µes sobre o c√≥digo
- ‚úÖ **Compile-time checks**: @Override, @FunctionalInterface
- ‚úÖ **Runtime processing**: Reflection, frameworks
- ‚úÖ **Redu√ß√£o de boilerplate**: Spring annotations
- ‚úÖ **Documenta√ß√£o**: @Documented, @Deprecated
- ‚úÖ **Custom annotations**: Meta-programming
- ‚úÖ **Meta-annotations**: @Target, @Retention
- ‚úÖ **Spring ecosystem**: @Component, @Autowired, @Transactional

**Regra de ouro:** Use annotations para **declarar inten√ß√µes** e **reduzir c√≥digo repetitivo**, mas evite **overengineering** com custom annotations desnecess√°rias.

---

**√öltima Atualiza√ß√£o:** 2025-11-15  
**N√≠vel:** TRANSVERSAL  
**Tempo Estimado:** 50 minutos
