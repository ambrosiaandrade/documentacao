# 03.2 Testcontainers [AVAN√áADO] üê≥

## üéØ Objetivo

Usar **Testcontainers** para rodar **containers Docker reais** (PostgreSQL, MongoDB, Redis, RabbitMQ, Kafka) durante testes de integra√ß√£o, garantindo **paridade com produ√ß√£o** sem mocks.

---

## üìö O Que √© Testcontainers?

**Testcontainers** √© uma biblioteca Java que gerencia **containers Docker** automaticamente durante testes, permitindo testar contra **bancos de dados reais**, **message brokers**, **caches** e outros servi√ßos de infraestrutura.

### Por Que Usar Testcontainers?

```java
// ‚ùå SEM Testcontainers - H2 em mem√≥ria
@DataJpaTest
class ClienteRepositoryTest {
    // Usa H2 (diferente do PostgreSQL de produ√ß√£o)
    // Pode ter bugs de SQL espec√≠ficos do PostgreSQL n√£o detectados
}

// ‚úÖ COM Testcontainers - PostgreSQL real
@Testcontainers
@SpringBootTest
class ClienteRepositoryTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    // Usa PostgreSQL real em Docker
    // Detecta problemas espec√≠ficos do PostgreSQL
}
```

**Vantagens:**

- ‚úÖ **Paridade com produ√ß√£o**: Mesmo banco/vers√£o de prod
- ‚úÖ **Detecta bugs reais**: SQL espec√≠fico, tipos de dados, √≠ndices
- ‚úÖ **Isolamento**: Cada teste tem container limpo
- ‚úÖ **Sem instala√ß√£o manual**: Docker gerencia tudo

---

## üèóÔ∏è Configura√ß√£o

### pom.xml

```xml
<dependencies>
    <!-- Testcontainers Core -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>testcontainers</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- JUnit 5 Integration -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- PostgreSQL Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>postgresql</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- MySQL Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>mysql</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- MongoDB Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>mongodb</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- RabbitMQ Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>rabbitmq</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>

    <!-- Kafka Container -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>kafka</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## üóÑÔ∏è PostgreSQL Container

### B√°sico com @Container

```java
@Testcontainers
@SpringBootTest
class ClienteRepositoryPostgresTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @DisplayName("Deve salvar cliente no PostgreSQL real")
    void deveSalvarClienteNoPostgreSQL() {
        // Given
        Cliente cliente = new Cliente("Jo√£o", "joao@mail.com", "12345678901");

        // When
        Cliente salvo = clienteRepository.save(cliente);

        // Then
        assertNotNull(salvo.getId());

        // Valida que realmente foi salvo no banco
        Optional<Cliente> encontrado = clienteRepository.findById(salvo.getId());
        assertTrue(encontrado.isPresent());
        assertEquals("Jo√£o", encontrado.get().getNome());
    }

    @Test
    @DisplayName("Deve validar constraint UNIQUE de email")
    void deveValidarConstraintUniqueEmail() {
        // Given
        clienteRepository.save(new Cliente("Jo√£o", "joao@mail.com", "12345678901"));

        // When & Then - PostgreSQL lan√ßa constraint violation
        assertThrows(DataIntegrityViolationException.class, () -> {
            clienteRepository.save(new Cliente("Maria", "joao@mail.com", "98765432109"));
            clienteRepository.flush();
        });
    }
}
```

### PostgreSQL com Scripts de Inicializa√ß√£o

```java
@Testcontainers
@SpringBootTest
class ClienteRepositoryWithScriptsTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15")
            .withInitScript("init-db.sql");  // Executa script ao iniciar

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
}
```

**init-db.sql:**

```sql
CREATE TABLE IF NOT EXISTS cliente (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL
);

INSERT INTO cliente (nome, email, cpf) VALUES ('Jo√£o', 'joao@mail.com', '12345678901');
INSERT INTO cliente (nome, email, cpf) VALUES ('Maria', 'maria@mail.com', '98765432109');
```

---

## üóÑÔ∏è MySQL Container

```java
@Testcontainers
@SpringBootTest
class ProdutoRepositoryMySQLTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", mysql::getJdbcUrl);
        registry.add("spring.datasource.username", mysql::getUsername);
        registry.add("spring.datasource.password", mysql::getPassword);
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "create-drop");
    }

    @Autowired
    private ProdutoRepository produtoRepository;

    @Test
    @DisplayName("Deve validar JSON column no MySQL")
    void deveValidarJsonColumn() {
        // Given - MySQL 8.0 suporta JSON nativo
        Produto produto = new Produto("PROD-001", "Notebook");
        produto.setEspecificacoes("{\"cpu\":\"i7\",\"ram\":\"16GB\"}");  // JSON

        // When
        Produto salvo = produtoRepository.save(produto);

        // Then
        Optional<Produto> encontrado = produtoRepository.findById(salvo.getId());
        assertTrue(encontrado.isPresent());
        assertTrue(encontrado.get().getEspecificacoes().contains("i7"));
    }
}
```

---

## üçÉ MongoDB Container

```java
@Testcontainers
@SpringBootTest
class PedidoRepositoryMongoTest {

    @Container
    static MongoDBContainer mongodb = new MongoDBContainer("mongo:7.0")
            .withExposedPorts(27017);

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri", mongodb::getReplicaSetUrl);
    }

    @Autowired
    private PedidoMongoRepository pedidoRepository;

    @Test
    @DisplayName("Deve salvar pedido no MongoDB")
    void deveSalvarPedidoNoMongoDB() {
        // Given
        Pedido pedido = new Pedido();
        pedido.setClienteId(1L);
        pedido.setItems(List.of(
            new Item("PROD-001", 2, new BigDecimal("100")),
            new Item("PROD-002", 1, new BigDecimal("50"))
        ));
        pedido.setTotal(new BigDecimal("250"));

        // When
        Pedido salvo = pedidoRepository.save(pedido);

        // Then
        assertNotNull(salvo.getId());

        Optional<Pedido> encontrado = pedidoRepository.findById(salvo.getId());
        assertTrue(encontrado.isPresent());
        assertEquals(2, encontrado.get().getItems().size());
    }

    @Test
    @DisplayName("Deve buscar pedidos por clienteId")
    void deveBuscarPorClienteId() {
        // Given
        pedidoRepository.save(new Pedido(1L, new BigDecimal("100")));
        pedidoRepository.save(new Pedido(1L, new BigDecimal("200")));
        pedidoRepository.save(new Pedido(2L, new BigDecimal("300")));

        // When
        List<Pedido> pedidos = pedidoRepository.findByClienteId(1L);

        // Then
        assertEquals(2, pedidos.size());
        assertTrue(pedidos.stream().allMatch(p -> p.getClienteId() == 1L));
    }
}
```

---

## üóÑÔ∏è Redis Container

```java
@Testcontainers
@SpringBootTest
class CacheRedisTest {

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
            .withExposedPorts(6379);

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", () -> redis.getMappedPort(6379));
    }

    @Autowired
    private ProdutoService produtoService;

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Test
    @DisplayName("Deve cachear produto no Redis")
    void deveCachearProduto() {
        // Given
        Long produtoId = 1L;

        // When - Primeira chamada (n√£o est√° no cache)
        ProdutoDTO produto1 = produtoService.buscar(produtoId);

        // Then - Valida que foi salvo no Redis
        String cacheKey = "produto::" + produtoId;
        assertTrue(redisTemplate.hasKey(cacheKey));

        // When - Segunda chamada (vem do cache)
        ProdutoDTO produto2 = produtoService.buscar(produtoId);

        // Then - Mesmo objeto
        assertEquals(produto1.getId(), produto2.getId());
    }

    @Test
    @DisplayName("Deve invalidar cache ao atualizar produto")
    void deveInvalidarCacheAoAtualizar() {
        // Given
        Long produtoId = 1L;
        produtoService.buscar(produtoId);  // Popula cache

        String cacheKey = "produto::" + produtoId;
        assertTrue(redisTemplate.hasKey(cacheKey));

        // When - Atualiza produto
        ProdutoDTO atualizado = new ProdutoDTO(produtoId, "Produto Atualizado");
        produtoService.atualizar(atualizado);

        // Then - Cache foi invalidado
        assertFalse(redisTemplate.hasKey(cacheKey));
    }
}
```

---

## üê∞ RabbitMQ Container

```java
@Testcontainers
@SpringBootTest
class PedidoMessageIntegrationTest {

    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12-management")
            .withExposedPorts(5672, 15672);

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.rabbitmq.host", rabbitmq::getHost);
        registry.add("spring.rabbitmq.port", rabbitmq::getAmqpPort);
        registry.add("spring.rabbitmq.username", rabbitmq::getAdminUsername);
        registry.add("spring.rabbitmq.password", rabbitmq::getAdminPassword);
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private PedidoProducer pedidoProducer;

    @Test
    @DisplayName("Deve enviar mensagem para RabbitMQ")
    void deveEnviarMensagemParaRabbitMQ() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(1L, new BigDecimal("100"));

        // When
        pedidoProducer.publicar(evento);

        // Then - Consome mensagem diretamente da fila
        Thread.sleep(1000);  // Aguarda processamento ass√≠ncrono

        Object mensagem = rabbitTemplate.receiveAndConvert("pedidos.criados", 5000);
        assertNotNull(mensagem);

        PedidoCriadoEvent eventoRecebido = (PedidoCriadoEvent) mensagem;
        assertEquals(1L, eventoRecebido.getPedidoId());
        assertEquals(new BigDecimal("100"), eventoRecebido.getTotal());
    }
}
```

### RabbitMQ com Consumer

```java
@Component
public class PedidoConsumer {

    @RabbitListener(queues = "pedidos.criados")
    public void processar(PedidoCriadoEvent evento) {
        log.info("Processando pedido: {}", evento.getPedidoId());
        // L√≥gica de processamento
    }
}

@Testcontainers
@SpringBootTest
class PedidoConsumerTest {

    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12-management");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.rabbitmq.host", rabbitmq::getHost);
        registry.add("spring.rabbitmq.port", rabbitmq::getAmqpPort);
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @MockBean
    private PagamentoService pagamentoService;  // Mock do servi√ßo chamado pelo consumer

    @Test
    @DisplayName("Consumer deve processar mensagem do RabbitMQ")
    void consumerDeveProcessarMensagem() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(1L, new BigDecimal("100"));

        // When - Envia mensagem para fila
        rabbitTemplate.convertAndSend("pedidos.criados", evento);

        // Then - Aguarda consumer processar
        Thread.sleep(2000);

        verify(pagamentoService, timeout(5000)).processar(1L);
    }
}
```

---

## üì® Kafka Container

```java
@Testcontainers
@SpringBootTest
class PedidoKafkaIntegrationTest {

    @Container
    static KafkaContainer kafka = new KafkaContainer(
            DockerImageName.parse("confluentinc/cp-kafka:7.5.0")
    );

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.kafka.bootstrap-servers", kafka::getBootstrapServers);
    }

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    @Autowired
    private KafkaConsumer<String, PedidoCriadoEvent> kafkaConsumer;

    @Test
    @DisplayName("Deve enviar e consumir mensagem do Kafka")
    void deveEnviarEConsumirMensagem() throws Exception {
        // Given
        String topic = "pedidos-criados";
        PedidoCriadoEvent evento = new PedidoCriadoEvent(1L, new BigDecimal("100"));

        // When - Produz mensagem
        kafkaTemplate.send(topic, evento).get();  // .get() aguarda confirma√ß√£o

        // Then - Consome mensagem
        kafkaConsumer.subscribe(Collections.singletonList(topic));

        ConsumerRecords<String, PedidoCriadoEvent> records = kafkaConsumer.poll(Duration.ofSeconds(10));

        assertEquals(1, records.count());

        PedidoCriadoEvent eventoRecebido = records.iterator().next().value();
        assertEquals(1L, eventoRecebido.getPedidoId());
    }
}
```

### Kafka com @KafkaListener

```java
@Component
public class PedidoKafkaListener {

    @Autowired
    private PagamentoService pagamentoService;

    @KafkaListener(topics = "pedidos-criados", groupId = "pedidos-group")
    public void processar(PedidoCriadoEvent evento) {
        log.info("Processando pedido Kafka: {}", evento.getPedidoId());
        pagamentoService.processar(evento.getPedidoId());
    }
}

@Testcontainers
@SpringBootTest
@EmbeddedKafka(topics = "pedidos-criados", partitions = 1)
class PedidoKafkaListenerTest {

    @Container
    static KafkaContainer kafka = new KafkaContainer(
            DockerImageName.parse("confluentinc/cp-kafka:7.5.0")
    );

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.kafka.bootstrap-servers", kafka::getBootstrapServers);
        registry.add("spring.kafka.consumer.auto-offset-reset", () -> "earliest");
    }

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    @MockBean
    private PagamentoService pagamentoService;

    @Test
    @DisplayName("Listener deve processar mensagem Kafka")
    void listenerDeveProcessarMensagem() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(1L, new BigDecimal("100"));

        // When
        kafkaTemplate.send("pedidos-criados", evento).get();

        // Then - Aguarda listener processar
        verify(pagamentoService, timeout(10000)).processar(1L);
    }
}
```

---

## üîÑ Docker Compose com Testcontainers

### M√∫ltiplos Containers

```java
@Testcontainers
@SpringBootTest
class FullStackIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:7-alpine")
            .withExposedPorts(6379);

    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12-management");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        // PostgreSQL
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);

        // Redis
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", () -> redis.getMappedPort(6379));

        // RabbitMQ
        registry.add("spring.rabbitmq.host", rabbitmq::getHost);
        registry.add("spring.rabbitmq.port", rabbitmq::getAmqpPort);
    }

    @Autowired
    private PedidoService pedidoService;

    @Autowired
    private PedidoRepository pedidoRepository;

    @Test
    @DisplayName("Deve criar pedido com PostgreSQL, Redis e RabbitMQ")
    void deveCriarPedidoComFullStack() {
        // Given
        PedidoRequest request = new PedidoRequest();
        request.setClienteId(1L);
        request.setItems(List.of(new ItemRequest("PROD-001", 2)));

        // When
        PedidoDTO pedido = pedidoService.criar(request);

        // Then
        assertNotNull(pedido.getId());

        // Valida persist√™ncia no PostgreSQL
        assertTrue(pedidoRepository.existsById(pedido.getId()));

        // Redis e RabbitMQ validados por mocks ou observabilidade
    }
}
```

---

## ‚ö° Container Reuso (Singleton Container)

### Compartilhar Container Entre Testes

```java
public abstract class AbstractPostgresTest {

    static PostgreSQLContainer<?> postgres;

    static {
        postgres = new PostgreSQLContainer<>("postgres:15")
                .withReuse(true);  // Reusa container entre testes
        postgres.start();
    }

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }
}

// Herda configura√ß√£o
@SpringBootTest
class ClienteRepositoryTest extends AbstractPostgresTest {

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    void deveSalvar() {
        Cliente cliente = clienteRepository.save(new Cliente("Jo√£o", "joao@mail.com"));
        assertNotNull(cliente.getId());
    }
}

@SpringBootTest
class PedidoRepositoryTest extends AbstractPostgresTest {

    @Autowired
    private PedidoRepository pedidoRepository;

    @Test
    void deveSalvar() {
        Pedido pedido = pedidoRepository.save(new Pedido(1L, new BigDecimal("100")));
        assertNotNull(pedido.getId());
    }
}
```

**Vantagens:**

- ‚úÖ **Performance**: Container inicia apenas 1 vez
- ‚úÖ **Economia de recursos**: Menos mem√≥ria/CPU

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use mesma vers√£o de produ√ß√£o
new PostgreSQLContainer<>("postgres:15")  // Mesma vers√£o de prod

// ‚úÖ Use @DynamicPropertySource para configurar propriedades
@DynamicPropertySource
static void configureProperties(DynamicPropertyRegistry registry) {
    registry.add("spring.datasource.url", postgres::getJdbcUrl);
}

// ‚úÖ Compartilhe containers entre testes (singleton)
static PostgreSQLContainer<?> postgres;
static {
    postgres = new PostgreSQLContainer<>("postgres:15").withReuse(true);
    postgres.start();
}

// ‚úÖ Limpe dados entre testes
@BeforeEach
void setUp() {
    repository.deleteAll();
}
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Iniciar container em @BeforeEach (muito lento)
@BeforeEach
void setUp() {
    postgres = new PostgreSQLContainer<>("postgres:15");
    postgres.start();  // ‚ùå Lento!
}

// ‚úÖ Use static container (inicia 1 vez)
@Container
static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

// ‚ùå N√£o especificar vers√£o
new PostgreSQLContainer<>("postgres:latest")  // ‚ùå Vers√£o inst√°vel

// ‚úÖ Vers√£o espec√≠fica
new PostgreSQLContainer<>("postgres:15")
```

---

## üìù Resumo

**Testcontainers** oferece:

- ‚úÖ **PostgreSQL/MySQL**: Banco real com SQL espec√≠fico
- ‚úÖ **MongoDB**: NoSQL real para testes
- ‚úÖ **Redis**: Cache real
- ‚úÖ **RabbitMQ**: Message broker real
- ‚úÖ **Kafka**: Event streaming real
- ‚úÖ **Container Reuso**: Performance com singleton container
- ‚úÖ **@DynamicPropertySource**: Configura√ß√£o din√¢mica

**Regra de ouro:** Use **Testcontainers** para testes de integra√ß√£o que precisam **paridade com produ√ß√£o** (bancos, mensageria, cache), mas continue usando **H2/mocks** para testes unit√°rios r√°pidos.
