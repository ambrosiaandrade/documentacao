# 03.5 Testes de Banco de Dados [AVAN√áADO] üóÑÔ∏è

## üéØ Objetivo

Dominar estrat√©gias de **testes de banco de dados** com **@DataJpaTest**, **@Sql**, **DbUnit**, **Flyway**, **Liquibase**, **queries nativas**, **transa√ß√µes** e **migrations** para garantir integridade e performance.

---

## üìö Tipos de Testes de Banco

### 1. Repository Tests (@DataJpaTest)

Testa **camada de persist√™ncia** isoladamente.

### 2. Migration Tests (Flyway/Liquibase)

Testa **scripts de migra√ß√£o** de banco.

### 3. Integration Tests

Testa **fluxo completo** (controller ‚Üí service ‚Üí repository).

### 4. Performance Tests

Testa **N+1 queries**, **√≠ndices**, **otimiza√ß√µes**.

---

## üèóÔ∏è Configura√ß√£o

### pom.xml

```xml
<dependencies>
    <!-- Spring Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- H2 Database (testes) -->
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>test</scope>
    </dependency>

    <!-- PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Flyway -->
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>

    <!-- Liquibase -->
    <dependency>
        <groupId>org.liquibase</groupId>
        <artifactId>liquibase-core</artifactId>
    </dependency>

    <!-- DbUnit -->
    <dependency>
        <groupId>org.dbunit</groupId>
        <artifactId>dbunit</artifactId>
        <version>2.7.3</version>
        <scope>test</scope>
    </dependency>

    <!-- Spring DbUnit -->
    <dependency>
        <groupId>com.github.springtestdbunit</groupId>
        <artifactId>spring-test-dbunit</artifactId>
        <version>1.3.0</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## üß™ @DataJpaTest - Repository Testing

### Teste B√°sico de Repository

```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class ClienteRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @DisplayName("Deve salvar cliente no banco")
    void deveSalvarCliente() {
        // Given
        Cliente cliente = new Cliente("Jo√£o", "joao@mail.com", "12345678901");

        // When
        Cliente salvo = clienteRepository.save(cliente);
        entityManager.flush();

        // Then
        assertNotNull(salvo.getId());

        Cliente encontrado = entityManager.find(Cliente.class, salvo.getId());
        assertEquals("Jo√£o", encontrado.getNome());
    }

    @Test
    @DisplayName("Deve buscar cliente por email")
    void deveBuscarPorEmail() {
        // Given
        Cliente cliente = new Cliente("Maria", "maria@mail.com", "98765432109");
        entityManager.persist(cliente);
        entityManager.flush();

        // When
        Optional<Cliente> encontrado = clienteRepository.findByEmail("maria@mail.com");

        // Then
        assertTrue(encontrado.isPresent());
        assertEquals("Maria", encontrado.get().getNome());
    }

    @Test
    @DisplayName("Deve retornar empty quando cliente n√£o existe")
    void deveRetornarEmptyQuandoNaoExiste() {
        // When
        Optional<Cliente> encontrado = clienteRepository.findByEmail("inexistente@mail.com");

        // Then
        assertFalse(encontrado.isPresent());
    }
}
```

### Testando Queries Customizadas

```java
public interface ClienteRepository extends JpaRepository<Cliente, Long> {

    @Query("SELECT c FROM Cliente c WHERE c.nome LIKE %:nome%")
    List<Cliente> buscarPorNomeContendo(@Param("nome") String nome);

    @Query("SELECT c FROM Cliente c WHERE c.vip = true AND c.ativo = true")
    List<Cliente> buscarClientesVipAtivos();

    @Query(value = "SELECT * FROM cliente WHERE DATE(data_cadastro) = CURRENT_DATE",
           nativeQuery = true)
    List<Cliente> buscarClientesCadastradosHoje();
}
```

```java
@DataJpaTest
class ClienteRepositoryQueryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @DisplayName("Deve buscar clientes por nome contendo texto")
    void deveBuscarPorNomeContendo() {
        // Given
        entityManager.persist(new Cliente("Jo√£o Silva", "joao@mail.com"));
        entityManager.persist(new Cliente("Maria Silva", "maria@mail.com"));
        entityManager.persist(new Cliente("Pedro Costa", "pedro@mail.com"));
        entityManager.flush();

        // When
        List<Cliente> clientes = clienteRepository.buscarPorNomeContendo("Silva");

        // Then
        assertEquals(2, clientes.size());
        assertTrue(clientes.stream()
            .allMatch(c -> c.getNome().contains("Silva")));
    }

    @Test
    @DisplayName("Deve buscar apenas clientes VIP ativos")
    void deveBuscarClientesVipAtivos() {
        // Given
        Cliente vipAtivo = new Cliente("Jo√£o", "joao@mail.com");
        vipAtivo.setVip(true);
        vipAtivo.setAtivo(true);

        Cliente vipInativo = new Cliente("Maria", "maria@mail.com");
        vipInativo.setVip(true);
        vipInativo.setAtivo(false);

        Cliente regularAtivo = new Cliente("Pedro", "pedro@mail.com");
        regularAtivo.setVip(false);
        regularAtivo.setAtivo(true);

        entityManager.persist(vipAtivo);
        entityManager.persist(vipInativo);
        entityManager.persist(regularAtivo);
        entityManager.flush();

        // When
        List<Cliente> clientes = clienteRepository.buscarClientesVipAtivos();

        // Then
        assertEquals(1, clientes.size());
        assertEquals("Jo√£o", clientes.get(0).getNome());
    }

    @Test
    @DisplayName("Deve buscar clientes cadastrados hoje (query nativa)")
    void deveBuscarClientesCadastradosHoje() {
        // Given
        Cliente clienteHoje = new Cliente("Jo√£o", "joao@mail.com");
        clienteHoje.setDataCadastro(LocalDateTime.now());

        Cliente clienteOntem = new Cliente("Maria", "maria@mail.com");
        clienteOntem.setDataCadastro(LocalDateTime.now().minusDays(1));

        entityManager.persist(clienteHoje);
        entityManager.persist(clienteOntem);
        entityManager.flush();

        // When
        List<Cliente> clientes = clienteRepository.buscarClientesCadastradosHoje();

        // Then
        assertEquals(1, clientes.size());
        assertEquals("Jo√£o", clientes.get(0).getNome());
    }
}
```

---

## üìù @Sql - Scripts SQL nos Testes

### Carregar Dados com @Sql

```java
@DataJpaTest
class ClienteRepositoryWithSqlTest {

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @Sql("/test-data/clientes.sql")
    @DisplayName("Deve carregar dados do SQL antes do teste")
    void deveCarregarDadosDoSQL() {
        // Given - Dados carregados por clientes.sql

        // When
        List<Cliente> clientes = clienteRepository.findAll();

        // Then
        assertEquals(5, clientes.size());
    }

    @Test
    @Sql(scripts = {
        "/test-data/schema.sql",
        "/test-data/clientes.sql"
    })
    @DisplayName("Deve executar m√∫ltiplos scripts SQL")
    void deveExecutarMultiplosScripts() {
        List<Cliente> clientes = clienteRepository.findAll();
        assertTrue(clientes.size() > 0);
    }

    @Test
    @Sql(
        scripts = "/test-data/clientes.sql",
        executionPhase = Sql.ExecutionPhase.BEFORE_TEST_METHOD
    )
    @Sql(
        scripts = "/test-data/cleanup.sql",
        executionPhase = Sql.ExecutionPhase.AFTER_TEST_METHOD
    )
    @DisplayName("Deve executar SQL antes e depois do teste")
    void deveExecutarSQLAntesEDepois() {
        // Before: clientes.sql carrega 5 clientes
        assertEquals(5, clienteRepository.count());

        // Test logic

        // After: cleanup.sql limpa tudo
    }
}
```

### Scripts SQL de Teste

**clientes.sql:**

```sql
INSERT INTO cliente (nome, email, cpf, vip, ativo)
VALUES ('Jo√£o Silva', 'joao@mail.com', '12345678901', true, true);

INSERT INTO cliente (nome, email, cpf, vip, ativo)
VALUES ('Maria Santos', 'maria@mail.com', '98765432109', false, true);

INSERT INTO cliente (nome, email, cpf, vip, ativo)
VALUES ('Pedro Costa', 'pedro@mail.com', '11111111111', true, false);

INSERT INTO cliente (nome, email, cpf, vip, ativo)
VALUES ('Ana Lima', 'ana@mail.com', '22222222222', false, true);

INSERT INTO cliente (nome, email, cpf, vip, ativo)
VALUES ('Carlos Mendes', 'carlos@mail.com', '33333333333', true, true);
```

**cleanup.sql:**

```sql
DELETE FROM pedido_item;
DELETE FROM pedido;
DELETE FROM cliente;
```

---

## üîÑ Flyway Migrations

### Estrutura de Migrations

```
src/main/resources/db/migration/
‚îú‚îÄ‚îÄ V1__criar_tabela_cliente.sql
‚îú‚îÄ‚îÄ V2__criar_tabela_produto.sql
‚îú‚îÄ‚îÄ V3__criar_tabela_pedido.sql
‚îú‚îÄ‚îÄ V4__adicionar_coluna_vip_cliente.sql
‚îî‚îÄ‚îÄ V5__criar_indices.sql
```

### Migration SQL

**V1\_\_criar_tabela_cliente.sql:**

```sql
CREATE TABLE cliente (
    id BIGSERIAL PRIMARY KEY,
    nome VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    cpf VARCHAR(11) UNIQUE NOT NULL,
    vip BOOLEAN DEFAULT FALSE,
    ativo BOOLEAN DEFAULT TRUE,
    data_cadastro TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_cliente_email ON cliente(email);
CREATE INDEX idx_cliente_cpf ON cliente(cpf);
```

**V4\_\_adicionar_coluna_vip_cliente.sql:**

```sql
ALTER TABLE cliente ADD COLUMN desconto_percentual INTEGER DEFAULT 0;

UPDATE cliente SET desconto_percentual = 10 WHERE vip = TRUE;
```

### Testando Migrations

```java
@SpringBootTest
@Testcontainers
class FlywayMigrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.flyway.enabled", () -> "true");
    }

    @Autowired
    private Flyway flyway;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    @DisplayName("Deve executar todas as migrations com sucesso")
    void deveExecutarTodasMigrationsComSucesso() {
        // When
        MigrateResult result = flyway.migrate();

        // Then
        assertTrue(result.migrationsExecuted > 0);
        assertTrue(result.success);

        // Valida que tabelas foram criadas
        Integer count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'cliente'",
            Integer.class
        );
        assertEquals(1, count);
    }

    @Test
    @DisplayName("Deve validar vers√£o das migrations")
    void deveValidarVersaoDasMigrations() {
        // Given
        flyway.migrate();

        // When
        var info = flyway.info();
        var current = info.current();

        // Then
        assertNotNull(current);
        assertEquals("5", current.getVersion().getVersion());  // V5 √© a √∫ltima
        assertEquals("criar_indices", current.getDescription());
    }

    @Test
    @DisplayName("Deve fazer rollback de migration (clean + migrate)")
    void deveFazerRollbackDeMigration() {
        // Given - Executa migrations
        flyway.migrate();

        // When - Limpa banco
        flyway.clean();

        // Then - Tabelas n√£o existem mais
        Integer count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'cliente'",
            Integer.class
        );
        assertEquals(0, count);

        // When - Executa migrations novamente
        flyway.migrate();

        // Then - Tabelas recriadas
        count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'cliente'",
            Integer.class
        );
        assertEquals(1, count);
    }
}
```

### Testando Migration Espec√≠fica

```java
@Test
@DisplayName("Deve executar migration V4 que adiciona coluna desconto")
void deveExecutarMigrationV4() {
    // Given - Executa at√© V3
    flyway.migrate();

    // Insere cliente VIP antes da V4
    jdbcTemplate.update(
        "INSERT INTO cliente (nome, email, cpf, vip) VALUES (?, ?, ?, ?)",
        "Jo√£o", "joao@mail.com", "12345678901", true
    );

    // When - Executa V4 (adiciona coluna desconto_percentual)
    flyway.migrate();

    // Then - Coluna existe e cliente VIP tem desconto 10%
    Integer desconto = jdbcTemplate.queryForObject(
        "SELECT desconto_percentual FROM cliente WHERE email = ?",
        Integer.class,
        "joao@mail.com"
    );

    assertEquals(10, desconto);
}
```

---

## üîÑ Liquibase Changesets

### Estrutura de Changesets

```
src/main/resources/db/changelog/
‚îú‚îÄ‚îÄ db.changelog-master.yaml
‚îú‚îÄ‚îÄ changes/
‚îÇ   ‚îú‚îÄ‚îÄ 001-criar-tabela-cliente.yaml
‚îÇ   ‚îú‚îÄ‚îÄ 002-criar-tabela-produto.yaml
‚îÇ   ‚îî‚îÄ‚îÄ 003-adicionar-coluna-vip.yaml
```

### Changeset YAML

**db.changelog-master.yaml:**

```yaml
databaseChangeLog:
  - include:
      file: db/changelog/changes/001-criar-tabela-cliente.yaml
  - include:
      file: db/changelog/changes/002-criar-tabela-produto.yaml
  - include:
      file: db/changelog/changes/003-adicionar-coluna-vip.yaml
```

**001-criar-tabela-cliente.yaml:**

```yaml
databaseChangeLog:
  - changeSet:
      id: 001-criar-tabela-cliente
      author: desenvolvedor
      changes:
        - createTable:
            tableName: cliente
            columns:
              - column:
                  name: id
                  type: BIGINT
                  autoIncrement: true
                  constraints:
                    primaryKey: true
                    nullable: false
              - column:
                  name: nome
                  type: VARCHAR(100)
                  constraints:
                    nullable: false
              - column:
                  name: email
                  type: VARCHAR(100)
                  constraints:
                    nullable: false
                    unique: true
              - column:
                  name: cpf
                  type: VARCHAR(11)
                  constraints:
                    nullable: false
                    unique: true
        - createIndex:
            indexName: idx_cliente_email
            tableName: cliente
            columns:
              - column:
                  name: email
```

### Testando Liquibase

```java
@SpringBootTest
@Testcontainers
class LiquibaseChangesetTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.liquibase.enabled", () -> "true");
    }

    @Autowired
    private SpringLiquibase liquibase;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    @DisplayName("Deve executar todos os changesets com sucesso")
    void deveExecutarTodosChangesetsComSucesso() throws Exception {
        // When
        liquibase.afterPropertiesSet();

        // Then - Valida que tabelas foram criadas
        Integer count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_name = 'cliente'",
            Integer.class
        );
        assertEquals(1, count);
    }

    @Test
    @DisplayName("Deve validar que changesets foram executados")
    void deveValidarChangesetsExecutados() {
        // When
        Integer count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM databasechangelog WHERE id = ?",
            Integer.class,
            "001-criar-tabela-cliente"
        );

        // Then
        assertEquals(1, count);
    }
}
```

---

## üß™ DbUnit - Dataset Testing

### Dataset XML

**clientes-dataset.xml:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataset>
    <cliente id="1" nome="Jo√£o Silva" email="joao@mail.com" cpf="12345678901" vip="true" ativo="true"/>
    <cliente id="2" nome="Maria Santos" email="maria@mail.com" cpf="98765432109" vip="false" ativo="true"/>
    <cliente id="3" nome="Pedro Costa" email="pedro@mail.com" cpf="11111111111" vip="true" ativo="false"/>
</dataset>
```

### Testando com DbUnit

```java
@SpringBootTest
@TestExecutionListeners({
    DependencyInjectionTestExecutionListener.class,
    DbUnitTestExecutionListener.class
})
@DbUnitConfiguration(databaseConnection = "dataSource")
class ClienteRepositoryDbUnitTest {

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @DatabaseSetup("/datasets/clientes-dataset.xml")
    @DisplayName("Deve carregar dataset DbUnit antes do teste")
    void deveCarregarDatasetDbUnit() {
        // Given - Dataset carregado automaticamente

        // When
        List<Cliente> clientes = clienteRepository.findAll();

        // Then
        assertEquals(3, clientes.size());

        Cliente joao = clienteRepository.findByEmail("joao@mail.com").get();
        assertTrue(joao.isVip());
    }

    @Test
    @DatabaseSetup("/datasets/clientes-dataset.xml")
    @ExpectedDatabase(
        value = "/datasets/clientes-expected.xml",
        assertionMode = DatabaseAssertionMode.NON_STRICT
    )
    @DisplayName("Deve validar estado final do banco com dataset esperado")
    void deveValidarEstadoFinalComDatasetEsperado() {
        // Given
        Cliente cliente = clienteRepository.findByEmail("joao@mail.com").get();

        // When - Atualiza cliente
        cliente.setNome("Jo√£o Silva Atualizado");
        clienteRepository.save(cliente);

        // Then - DbUnit valida que banco est√° igual a clientes-expected.xml
    }

    @Test
    @DatabaseSetup("/datasets/clientes-dataset.xml")
    @DatabaseTearDown(
        value = "/datasets/cleanup-dataset.xml",
        type = DatabaseOperation.DELETE_ALL
    )
    @DisplayName("Deve limpar banco ap√≥s teste com TearDown")
    void deveLimparBancoAposTeste() {
        // Test logic

        // TearDown executado automaticamente ap√≥s teste
    }
}
```

**clientes-expected.xml:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataset>
    <cliente id="1" nome="Jo√£o Silva Atualizado" email="joao@mail.com"/>
</dataset>
```

---

## üîç Testando N+1 Queries

### Problema N+1

```java
@Entity
public class Pedido {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Cliente cliente;

    @OneToMany(mappedBy = "pedido", fetch = FetchType.LAZY)
    private List<PedidoItem> items = new ArrayList<>();
}
```

### Detectando N+1

```java
@DataJpaTest
class PedidoRepositoryN1Test {

    @Autowired
    private PedidoRepository pedidoRepository;

    @Autowired
    private TestEntityManager entityManager;

    @Test
    @DisplayName("Deve detectar problema N+1 ao buscar pedidos com items")
    void deveDetectarProblemaN1() {
        // Given - Cria 10 pedidos com items
        for (int i = 0; i < 10; i++) {
            Cliente cliente = new Cliente("Cliente " + i, "cliente" + i + "@mail.com");
            entityManager.persist(cliente);

            Pedido pedido = new Pedido(cliente);
            pedido.addItem(new PedidoItem("PROD-001", 2));
            pedido.addItem(new PedidoItem("PROD-002", 1));
            entityManager.persist(pedido);
        }
        entityManager.flush();
        entityManager.clear();

        // When - Busca pedidos (lazy load)
        List<Pedido> pedidos = pedidoRepository.findAll();

        // Then - Acessa items (dispara N queries adicionais)
        for (Pedido pedido : pedidos) {
            int itemsCount = pedido.getItems().size();  // N+1 query!
            System.out.println("Pedido " + pedido.getId() + " tem " + itemsCount + " items");
        }

        // Problema: 1 query para pedidos + 10 queries para items = 11 queries
    }
}
```

### Resolvendo N+1 com JOIN FETCH

```java
public interface PedidoRepository extends JpaRepository<Pedido, Long> {

    @Query("SELECT p FROM Pedido p JOIN FETCH p.items JOIN FETCH p.cliente")
    List<Pedido> findAllWithItemsAndCliente();

    @EntityGraph(attributePaths = {"items", "cliente"})
    List<Pedido> findAll();
}
```

```java
@Test
@DisplayName("Deve resolver N+1 com JOIN FETCH")
void deveResolverN1ComJoinFetch() {
    // Given - Cria 10 pedidos com items
    for (int i = 0; i < 10; i++) {
        Cliente cliente = new Cliente("Cliente " + i, "cliente" + i + "@mail.com");
        entityManager.persist(cliente);

        Pedido pedido = new Pedido(cliente);
        pedido.addItem(new PedidoItem("PROD-001", 2));
        pedido.addItem(new PedidoItem("PROD-002", 1));
        entityManager.persist(pedido);
    }
    entityManager.flush();
    entityManager.clear();

    // When - Busca com JOIN FETCH (1 query apenas)
    List<Pedido> pedidos = pedidoRepository.findAllWithItemsAndCliente();

    // Then - Acessa items sem queries adicionais
    for (Pedido pedido : pedidos) {
        int itemsCount = pedido.getItems().size();  // Sem query adicional!
        assertNotNull(pedido.getCliente().getNome());  // Sem query adicional!
    }

    // Solu√ß√£o: 1 query apenas!
}
```

---

## ‚ö° Testando Performance de Queries

### Hibernate Statistics

```java
@DataJpaTest
class QueryPerformanceTest {

    @Autowired
    private EntityManager entityManager;

    @Autowired
    private PedidoRepository pedidoRepository;

    @Test
    @DisplayName("Deve medir quantidade de queries executadas")
    void deveMedirQuantidadeDeQueries() {
        // Given - Habilita statistics
        SessionFactory sessionFactory = entityManager.getEntityManagerFactory()
            .unwrap(SessionFactory.class);
        Statistics stats = sessionFactory.getStatistics();
        stats.setStatisticsEnabled(true);
        stats.clear();

        // When
        List<Pedido> pedidos = pedidoRepository.findAllWithItemsAndCliente();

        // Then
        long queryCount = stats.getQueryExecutionCount();
        System.out.println("Queries executadas: " + queryCount);

        assertTrue(queryCount <= 2, "Esperado no m√°ximo 2 queries, mas foram executadas " + queryCount);
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use @DataJpaTest para testes de repository
@DataJpaTest

// ‚úÖ Use TestEntityManager para controle fino
entityManager.persist(cliente);
entityManager.flush();
entityManager.clear();

// ‚úÖ Use @Sql para carregar dados de teste
@Sql("/test-data/clientes.sql")

// ‚úÖ Teste migrations (Flyway/Liquibase)
flyway.migrate();
assertEquals("5", info.current().getVersion().getVersion());

// ‚úÖ Use DbUnit para datasets complexos
@DatabaseSetup("/datasets/clientes-dataset.xml")

// ‚úÖ Detecte e resolva N+1 queries
@Query("SELECT p FROM Pedido p JOIN FETCH p.items")

// ‚úÖ Use @EntityGraph para lazy loading eficiente
@EntityGraph(attributePaths = {"items", "cliente"})

// ‚úÖ Teste constraints do banco
assertThrows(DataIntegrityViolationException.class, ...);

// ‚úÖ Limpe dados entre testes
@BeforeEach
void setUp() {
    repository.deleteAll();
}
```

### ‚ùå Anti-Patterns

```java
// ‚ùå N√£o testar queries customizadas
@Query("SELECT c FROM Cliente c WHERE ...")  // ‚ùå Sem teste

// ‚úÖ Sempre teste queries
@Test
void deveExecutarQueryCustomizada() { ... }

// ‚ùå Ignorar N+1 queries
List<Pedido> pedidos = repository.findAll();
pedidos.forEach(p -> p.getItems().size());  // ‚ùå N+1!

// ‚úÖ Use JOIN FETCH
@Query("SELECT p FROM Pedido p JOIN FETCH p.items")

// ‚ùå N√£o testar migrations
// Migrations quebradas s√≥ descobertas em produ√ß√£o

// ‚úÖ Teste migrations
@Test
void deveMigrarBancoComSucesso() {
    flyway.migrate();
    assertTrue(result.success);
}

// ‚ùå Hard-coded SQL em testes
jdbcTemplate.update("INSERT INTO cliente VALUES (1, 'Jo√£o', ...)")  // ‚ùå

// ‚úÖ Use @Sql ou DbUnit
@Sql("/test-data/clientes.sql")

// ‚ùå N√£o limpar dados entre testes
// Estado de teste anterior interfere

// ‚úÖ Cleanup
@BeforeEach
void setUp() {
    repository.deleteAll();
}
```

---

## üéØ Quando Usar Cada Abordagem?

| Cen√°rio                   | @DataJpaTest | @Sql        | DbUnit      | Flyway/Liquibase |
| ------------------------- | ------------ | ----------- | ----------- | ---------------- |
| Teste unit√°rio repository | ‚úÖ Sim       | ‚ö†Ô∏è Opcional | ‚ö†Ô∏è Opcional | ‚ùå N√£o           |
| Teste de migration        | ‚ùå N√£o       | ‚ùå N√£o      | ‚ùå N√£o      | ‚úÖ Sim           |
| Dataset complexo          | ‚ö†Ô∏è Limitado  | ‚ö†Ô∏è OK       | ‚úÖ Sim      | ‚ùå N√£o           |
| Performance               | ‚úÖ Sim       | ‚ö†Ô∏è Limitado | ‚ö†Ô∏è Limitado | ‚ùå N√£o           |

---

## üìù Resumo

**Testes de Banco de Dados** garantem:

- ‚úÖ **@DataJpaTest**: Testes de repository isolados
- ‚úÖ **TestEntityManager**: Controle fino de persist√™ncia
- ‚úÖ **@Sql**: Carregar dados SQL antes/depois dos testes
- ‚úÖ **Flyway**: Testar migrations versionadas
- ‚úÖ **Liquibase**: Testar changesets YAML/XML
- ‚úÖ **DbUnit**: Datasets XML para testes complexos
- ‚úÖ **N+1 Detection**: Detectar e resolver queries ineficientes
- ‚úÖ **Hibernate Statistics**: Medir performance
- ‚úÖ **Constraints**: Validar UNIQUE, NOT NULL, FK

**Regra de ouro:** Teste **queries customizadas**, **migrations** e **performance** (N+1) para evitar bugs e lentid√£o em produ√ß√£o.
