# 03.7 Testes de XML e JSON [AVAN√áADO] üìÑ

## üéØ Objetivo

Dominar **testes de serializa√ß√£o/desserializa√ß√£o** com **JSONPath**, **Jackson**, **JAXB**, **XML validation**, **JSON Schema validation** e **custom serializers/deserializers**.

---

## üìö Tipos de Testes

### 1. JSON Tests (@JsonTest)

Testa **serializa√ß√£o/desserializa√ß√£o JSON** com Jackson.

### 2. XML Tests

Testa **serializa√ß√£o/desserializa√ß√£o XML** com JAXB.

### 3. Schema Validation

Valida **JSON/XML** contra schemas (JSON Schema, XSD).

### 4. Custom Serializers

Testa **serializers/deserializers customizados**.

---

## üèóÔ∏è Configura√ß√£o

### pom.xml

```xml
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Spring Boot Test -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!-- Jackson (JSON) -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>

    <dependency>
        <groupId>com.fasterxml.jackson.datatype</groupId>
        <artifactId>jackson-datatype-jsr310</artifactId>
    </dependency>

    <!-- JAXB (XML) -->
    <dependency>
        <groupId>javax.xml.bind</groupId>
        <artifactId>jaxb-api</artifactId>
        <version>2.3.1</version>
    </dependency>

    <dependency>
        <groupId>org.glassfish.jaxb</groupId>
        <artifactId>jaxb-runtime</artifactId>
    </dependency>

    <!-- JSON Schema Validator -->
    <dependency>
        <groupId>com.networknt</groupId>
        <artifactId>json-schema-validator</artifactId>
        <version>1.0.87</version>
        <scope>test</scope>
    </dependency>

    <!-- JSONPath -->
    <dependency>
        <groupId>com.jayway.jsonpath</groupId>
        <artifactId>json-path</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## üß™ @JsonTest - Testes de JSON

### DTO B√°sico

```java
public class ClienteDTO {

    @JsonProperty("id")
    private Long id;

    @JsonProperty("nome")
    private String nome;

    @JsonProperty("email")
    private String email;

    @JsonFormat(pattern = "dd/MM/yyyy")
    private LocalDate dataNascimento;

    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String telefone;

    @JsonIgnore
    private String senha;
}
```

### Teste de Serializa√ß√£o (Object ‚Üí JSON)

```java
@JsonTest
class ClienteDTOSerializationTest {

    @Autowired
    private JacksonTester<ClienteDTO> json;

    @Test
    @DisplayName("Deve serializar ClienteDTO para JSON corretamente")
    void deveSerializarClienteDTOParaJson() throws Exception {
        // Given
        ClienteDTO cliente = new ClienteDTO(
            1L,
            "Jo√£o Silva",
            "joao@mail.com",
            LocalDate.of(1990, 5, 15),
            "11987654321",
            "senha123"
        );

        // When
        JsonContent<ClienteDTO> result = json.write(cliente);

        // Then
        assertThat(result).extractingJsonPathNumberValue("$.id").isEqualTo(1);
        assertThat(result).extractingJsonPathStringValue("$.nome").isEqualTo("Jo√£o Silva");
        assertThat(result).extractingJsonPathStringValue("$.email").isEqualTo("joao@mail.com");
        assertThat(result).extractingJsonPathStringValue("$.dataNascimento").isEqualTo("15/05/1990");
        assertThat(result).extractingJsonPathStringValue("$.telefone").isEqualTo("11987654321");

        // Valida que @JsonIgnore funcionou
        assertThat(result).doesNotHaveJsonPath("$.senha");
    }

    @Test
    @DisplayName("Deve serializar com telefone null (JsonInclude.NON_NULL)")
    void deveSerializarComTelefoneNull() throws Exception {
        // Given - Cliente sem telefone
        ClienteDTO cliente = new ClienteDTO(
            1L,
            "Jo√£o Silva",
            "joao@mail.com",
            LocalDate.of(1990, 5, 15),
            null,  // Telefone null
            "senha123"
        );

        // When
        JsonContent<ClienteDTO> result = json.write(cliente);

        // Then - Campo telefone n√£o aparece no JSON
        assertThat(result).doesNotHaveJsonPath("$.telefone");
    }

    @Test
    @DisplayName("Deve serializar para JSON string esperada")
    void deveSerializarParaJsonStringEsperada() throws Exception {
        // Given
        ClienteDTO cliente = new ClienteDTO(
            1L,
            "Jo√£o Silva",
            "joao@mail.com",
            LocalDate.of(1990, 5, 15),
            "11987654321",
            "senha123"
        );

        // When
        JsonContent<ClienteDTO> result = json.write(cliente);

        // Then - Compara com JSON esperado
        assertThat(result).isEqualToJson("""
            {
                "id": 1,
                "nome": "Jo√£o Silva",
                "email": "joao@mail.com",
                "dataNascimento": "15/05/1990",
                "telefone": "11987654321"
            }
            """);
    }
}
```

### Teste de Desserializa√ß√£o (JSON ‚Üí Object)

```java
@JsonTest
class ClienteDTODeserializationTest {

    @Autowired
    private JacksonTester<ClienteDTO> json;

    @Test
    @DisplayName("Deve desserializar JSON para ClienteDTO corretamente")
    void deveDesserializarJsonParaClienteDTO() throws Exception {
        // Given
        String jsonContent = """
            {
                "id": 1,
                "nome": "Jo√£o Silva",
                "email": "joao@mail.com",
                "dataNascimento": "15/05/1990",
                "telefone": "11987654321"
            }
            """;

        // When
        ObjectContent<ClienteDTO> result = json.parse(jsonContent);
        ClienteDTO cliente = result.getObject();

        // Then
        assertEquals(1L, cliente.getId());
        assertEquals("Jo√£o Silva", cliente.getNome());
        assertEquals("joao@mail.com", cliente.getEmail());
        assertEquals(LocalDate.of(1990, 5, 15), cliente.getDataNascimento());
        assertEquals("11987654321", cliente.getTelefone());
    }

    @Test
    @DisplayName("Deve desserializar JSON sem telefone (campo opcional)")
    void deveDesserializarJsonSemTelefone() throws Exception {
        // Given
        String jsonContent = """
            {
                "id": 1,
                "nome": "Jo√£o Silva",
                "email": "joao@mail.com",
                "dataNascimento": "15/05/1990"
            }
            """;

        // When
        ClienteDTO cliente = json.parse(jsonContent).getObject();

        // Then
        assertNull(cliente.getTelefone());
    }

    @Test
    @DisplayName("Deve lan√ßar exce√ß√£o quando data inv√°lida")
    void deveLancarExcecaoQuandoDataInvalida() {
        // Given
        String jsonContent = """
            {
                "id": 1,
                "nome": "Jo√£o Silva",
                "email": "joao@mail.com",
                "dataNascimento": "data-invalida"
            }
            """;

        // When & Then
        assertThrows(Exception.class, () -> json.parse(jsonContent));
    }
}
```

---

## üîç JSONPath Avan√ßado

### Valida√ß√µes Complexas com JSONPath

```java
@Test
@DisplayName("Deve validar JSON complexo com JSONPath")
void deveValidarJsonComplexoComJsonPath() {
    // Given
    String json = """
        {
            "pedido": {
                "id": 1,
                "cliente": {
                    "nome": "Jo√£o Silva",
                    "email": "joao@mail.com"
                },
                "items": [
                    {
                        "codigo": "PROD-001",
                        "nome": "Notebook",
                        "quantidade": 2,
                        "preco": 3000.00
                    },
                    {
                        "codigo": "PROD-002",
                        "nome": "Mouse",
                        "quantidade": 3,
                        "preco": 50.00
                    }
                ],
                "valorTotal": 6150.00,
                "dataPedido": "2024-01-15T10:30:00"
            }
        }
        """;

    // When & Then
    DocumentContext ctx = JsonPath.parse(json);

    // Valida root
    assertEquals(1, (int) ctx.read("$.pedido.id"));
    assertEquals(6150.00, (double) ctx.read("$.pedido.valorTotal"), 0.01);

    // Valida cliente nested
    assertEquals("Jo√£o Silva", ctx.read("$.pedido.cliente.nome"));
    assertEquals("joao@mail.com", ctx.read("$.pedido.cliente.email"));

    // Valida array de items
    List<Map<String, Object>> items = ctx.read("$.pedido.items");
    assertEquals(2, items.size());

    // Valida primeiro item
    assertEquals("PROD-001", ctx.read("$.pedido.items[0].codigo"));
    assertEquals("Notebook", ctx.read("$.pedido.items[0].nome"));
    assertEquals(2, (int) ctx.read("$.pedido.items[0].quantidade"));

    // Valida com filtros
    List<String> nomesCaros = ctx.read("$.pedido.items[?(@.preco > 100)].nome");
    assertEquals(List.of("Notebook"), nomesCaros);

    // Valida soma (aggregation)
    int quantidadeTotal = ctx.read("$.pedido.items[*].quantidade", List.class)
        .stream()
        .mapToInt(q -> (int) q)
        .sum();
    assertEquals(5, quantidadeTotal);
}
```

### JSONPath com Arrays

```java
@Test
@DisplayName("Deve validar arrays com JSONPath")
void deveValidarArraysComJsonPath() {
    // Given
    String json = """
        {
            "clientes": [
                {"id": 1, "nome": "Jo√£o", "idade": 25, "vip": true},
                {"id": 2, "nome": "Maria", "idade": 30, "vip": false},
                {"id": 3, "nome": "Pedro", "idade": 20, "vip": true}
            ]
        }
        """;

    DocumentContext ctx = JsonPath.parse(json);

    // Tamanho do array
    assertEquals(3, ((List<?>) ctx.read("$.clientes")).size());

    // Filtrar por idade > 25
    List<Map<String, Object>> maioresQue25 = ctx.read("$.clientes[?(@.idade > 25)]");
    assertEquals(1, maioresQue25.size());
    assertEquals("Maria", maioresQue25.get(0).get("nome"));

    // Filtrar VIPs
    List<String> nomesVip = ctx.read("$.clientes[?(@.vip == true)].nome");
    assertEquals(List.of("Jo√£o", "Pedro"), nomesVip);

    // Buscar por ID espec√≠fico
    String nomeJoao = ctx.read("$.clientes[?(@.id == 1)].nome", List.class).get(0);
    assertEquals("Jo√£o", nomeJoao);
}
```

---

## üìù XML Tests com JAXB

### DTO com JAXB Annotations

```java
@XmlRootElement(name = "cliente")
@XmlAccessorType(XmlAccessType.FIELD)
public class ClienteXML {

    @XmlElement(name = "id")
    private Long id;

    @XmlElement(name = "nome", required = true)
    private String nome;

    @XmlElement(name = "email", required = true)
    private String email;

    @XmlElement(name = "data-nascimento")
    @XmlJavaTypeAdapter(LocalDateAdapter.class)
    private LocalDate dataNascimento;

    @XmlElementWrapper(name = "enderecos")
    @XmlElement(name = "endereco")
    private List<EnderecoXML> enderecos = new ArrayList<>();

    @XmlTransient
    private String senha;
}
```

### LocalDateAdapter para JAXB

```java
public class LocalDateAdapter extends XmlAdapter<String, LocalDate> {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("dd/MM/yyyy");

    @Override
    public LocalDate unmarshal(String v) {
        return v != null ? LocalDate.parse(v, FORMATTER) : null;
    }

    @Override
    public String marshal(LocalDate v) {
        return v != null ? v.format(FORMATTER) : null;
    }
}
```

### Teste de Serializa√ß√£o XML

```java
class ClienteXMLSerializationTest {

    private JAXBContext jaxbContext;
    private Marshaller marshaller;

    @BeforeEach
    void setUp() throws Exception {
        jaxbContext = JAXBContext.newInstance(ClienteXML.class);
        marshaller = jaxbContext.createMarshaller();
        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
    }

    @Test
    @DisplayName("Deve serializar ClienteXML para XML corretamente")
    void deveSerializarClienteXMLParaXml() throws Exception {
        // Given
        ClienteXML cliente = new ClienteXML(
            1L,
            "Jo√£o Silva",
            "joao@mail.com",
            LocalDate.of(1990, 5, 15)
        );
        cliente.addEndereco(new EnderecoXML("Rua A", "S√£o Paulo", "SP", "01000-000"));
        cliente.addEndereco(new EnderecoXML("Rua B", "Campinas", "SP", "13000-000"));

        // When
        StringWriter writer = new StringWriter();
        marshaller.marshal(cliente, writer);
        String xml = writer.toString();

        // Then
        System.out.println(xml);

        assertTrue(xml.contains("<id>1</id>"));
        assertTrue(xml.contains("<nome>Jo√£o Silva</nome>"));
        assertTrue(xml.contains("<email>joao@mail.com</email>"));
        assertTrue(xml.contains("<data-nascimento>15/05/1990</data-nascimento>"));
        assertTrue(xml.contains("<enderecos>"));
        assertTrue(xml.contains("<endereco>"));

        // Valida que @XmlTransient funcionou
        assertFalse(xml.contains("senha"));
    }

    @Test
    @DisplayName("Deve validar estrutura XML com XPath")
    void deveValidarEstruturaXmlComXPath() throws Exception {
        // Given
        ClienteXML cliente = new ClienteXML(
            1L,
            "Jo√£o Silva",
            "joao@mail.com",
            LocalDate.of(1990, 5, 15)
        );

        // When
        StringWriter writer = new StringWriter();
        marshaller.marshal(cliente, writer);
        String xml = writer.toString();

        // Then - Parse XML e valida com XPath
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document doc = builder.parse(new InputSource(new StringReader(xml)));

        XPath xpath = XPathFactory.newInstance().newXPath();

        assertEquals("1", xpath.evaluate("/cliente/id", doc));
        assertEquals("Jo√£o Silva", xpath.evaluate("/cliente/nome", doc));
        assertEquals("joao@mail.com", xpath.evaluate("/cliente/email", doc));
        assertEquals("15/05/1990", xpath.evaluate("/cliente/data-nascimento", doc));
    }
}
```

### Teste de Desserializa√ß√£o XML

```java
class ClienteXMLDeserializationTest {

    private JAXBContext jaxbContext;
    private Unmarshaller unmarshaller;

    @BeforeEach
    void setUp() throws Exception {
        jaxbContext = JAXBContext.newInstance(ClienteXML.class);
        unmarshaller = jaxbContext.createUnmarshaller();
    }

    @Test
    @DisplayName("Deve desserializar XML para ClienteXML corretamente")
    void deveDesserializarXmlParaClienteXML() throws Exception {
        // Given
        String xml = """
            <?xml version="1.0" encoding="UTF-8"?>
            <cliente>
                <id>1</id>
                <nome>Jo√£o Silva</nome>
                <email>joao@mail.com</email>
                <data-nascimento>15/05/1990</data-nascimento>
                <enderecos>
                    <endereco>
                        <logradouro>Rua A</logradouro>
                        <cidade>S√£o Paulo</cidade>
                        <estado>SP</estado>
                        <cep>01000-000</cep>
                    </endereco>
                </enderecos>
            </cliente>
            """;

        // When
        ClienteXML cliente = (ClienteXML) unmarshaller.unmarshal(new StringReader(xml));

        // Then
        assertEquals(1L, cliente.getId());
        assertEquals("Jo√£o Silva", cliente.getNome());
        assertEquals("joao@mail.com", cliente.getEmail());
        assertEquals(LocalDate.of(1990, 5, 15), cliente.getDataNascimento());
        assertEquals(1, cliente.getEnderecos().size());
        assertEquals("Rua A", cliente.getEnderecos().get(0).getLogradouro());
    }

    @Test
    @DisplayName("Deve lan√ßar exce√ß√£o quando XML inv√°lido")
    void deveLancarExcecaoQuandoXmlInvalido() {
        // Given - XML sem campo obrigat√≥rio (nome)
        String xml = """
            <?xml version="1.0" encoding="UTF-8"?>
            <cliente>
                <id>1</id>
                <email>joao@mail.com</email>
            </cliente>
            """;

        // When & Then
        assertThrows(JAXBException.class, () -> {
            unmarshaller.unmarshal(new StringReader(xml));
        });
    }
}
```

---

## üîí JSON Schema Validation

### JSON Schema

**cliente-schema.json:**

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Cliente",
  "type": "object",
  "required": ["nome", "email"],
  "properties": {
    "id": {
      "type": "integer",
      "minimum": 1
    },
    "nome": {
      "type": "string",
      "minLength": 3,
      "maxLength": 100
    },
    "email": {
      "type": "string",
      "format": "email"
    },
    "dataNascimento": {
      "type": "string",
      "pattern": "^\\d{2}/\\d{2}/\\d{4}$"
    },
    "idade": {
      "type": "integer",
      "minimum": 18,
      "maximum": 120
    }
  }
}
```

### Testando JSON Schema Validation

```java
class JsonSchemaValidationTest {

    private JsonSchema schema;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() throws Exception {
        // Carrega schema
        JsonSchemaFactory factory = JsonSchemaFactory.getInstance(SpecVersion.VersionFlag.V7);
        InputStream schemaStream = getClass().getResourceAsStream("/schemas/cliente-schema.json");
        schema = factory.getSchema(schemaStream);

        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
    }

    @Test
    @DisplayName("Deve validar JSON v√°lido contra schema")
    void deveValidarJsonValidoContraSchema() throws Exception {
        // Given
        String json = """
            {
                "id": 1,
                "nome": "Jo√£o Silva",
                "email": "joao@mail.com",
                "dataNascimento": "15/05/1990",
                "idade": 33
            }
            """;

        // When
        JsonNode jsonNode = objectMapper.readTree(json);
        Set<ValidationMessage> errors = schema.validate(jsonNode);

        // Then
        assertTrue(errors.isEmpty(), "JSON deve ser v√°lido");
    }

    @Test
    @DisplayName("Deve detectar erro quando nome muito curto")
    void deveDetectarErroQuandoNomeMuitoCurto() throws Exception {
        // Given - Nome com 2 caracteres (m√≠nimo √© 3)
        String json = """
            {
                "nome": "Jo",
                "email": "joao@mail.com"
            }
            """;

        // When
        JsonNode jsonNode = objectMapper.readTree(json);
        Set<ValidationMessage> errors = schema.validate(jsonNode);

        // Then
        assertFalse(errors.isEmpty());
        assertTrue(errors.stream()
            .anyMatch(e -> e.getMessage().contains("minLength")));
    }

    @Test
    @DisplayName("Deve detectar erro quando email inv√°lido")
    void deveDetectarErroQuandoEmailInvalido() throws Exception {
        // Given
        String json = """
            {
                "nome": "Jo√£o Silva",
                "email": "email-invalido"
            }
            """;

        // When
        JsonNode jsonNode = objectMapper.readTree(json);
        Set<ValidationMessage> errors = schema.validate(jsonNode);

        // Then
        assertFalse(errors.isEmpty());
        assertTrue(errors.stream()
            .anyMatch(e -> e.getMessage().contains("email")));
    }

    @Test
    @DisplayName("Deve detectar erro quando campo obrigat√≥rio ausente")
    void deveDetectarErroQuandoCampoObrigatorioAusente() throws Exception {
        // Given - Sem email (obrigat√≥rio)
        String json = """
            {
                "nome": "Jo√£o Silva"
            }
            """;

        // When
        JsonNode jsonNode = objectMapper.readTree(json);
        Set<ValidationMessage> errors = schema.validate(jsonNode);

        // Then
        assertFalse(errors.isEmpty());
        assertTrue(errors.stream()
            .anyMatch(e -> e.getMessage().contains("required")));
    }
}
```

---

## üé® Custom Serializers/Deserializers

### Custom Serializer

```java
public class CpfSerializer extends JsonSerializer<String> {

    @Override
    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers)
            throws IOException {
        // Formata CPF: 12345678901 ‚Üí 123.456.789-01
        if (value != null && value.length() == 11) {
            String formatted = String.format("%s.%s.%s-%s",
                value.substring(0, 3),
                value.substring(3, 6),
                value.substring(6, 9),
                value.substring(9, 11)
            );
            gen.writeString(formatted);
        } else {
            gen.writeString(value);
        }
    }
}
```

### Custom Deserializer

```java
public class CpfDeserializer extends JsonDeserializer<String> {

    @Override
    public String deserialize(JsonParser p, DeserializationContext ctxt)
            throws IOException {
        // Remove formata√ß√£o: 123.456.789-01 ‚Üí 12345678901
        String value = p.getText();
        return value != null ? value.replaceAll("[.\\-]", "") : null;
    }
}
```

### DTO com Custom Serializers

```java
public class ClienteDTO {

    private Long id;
    private String nome;

    @JsonSerialize(using = CpfSerializer.class)
    @JsonDeserialize(using = CpfDeserializer.class)
    private String cpf;

    @JsonSerialize(using = MoneySerializer.class)
    @JsonDeserialize(using = MoneyDeserializer.class)
    private BigDecimal saldo;
}
```

### Testando Custom Serializers

```java
@JsonTest
class CustomSerializersTest {

    @Autowired
    private JacksonTester<ClienteDTO> json;

    @Test
    @DisplayName("Deve serializar CPF formatado")
    void deveSerializarCpfFormatado() throws Exception {
        // Given
        ClienteDTO cliente = new ClienteDTO(1L, "Jo√£o", "12345678901", new BigDecimal("1000.00"));

        // When
        JsonContent<ClienteDTO> result = json.write(cliente);

        // Then - CPF deve estar formatado
        assertThat(result).extractingJsonPathStringValue("$.cpf")
            .isEqualTo("123.456.789-01");
    }

    @Test
    @DisplayName("Deve desserializar CPF removendo formata√ß√£o")
    void deveDesserializarCpfRemovendoFormatacao() throws Exception {
        // Given
        String jsonContent = """
            {
                "id": 1,
                "nome": "Jo√£o",
                "cpf": "123.456.789-01",
                "saldo": 1000.00
            }
            """;

        // When
        ClienteDTO cliente = json.parse(jsonContent).getObject();

        // Then - CPF deve estar sem formata√ß√£o
        assertEquals("12345678901", cliente.getCpf());
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use @JsonTest para testes de serializa√ß√£o
@JsonTest

// ‚úÖ Use JacksonTester
@Autowired
private JacksonTester<ClienteDTO> json;

// ‚úÖ Teste @JsonFormat para datas
@JsonFormat(pattern = "dd/MM/yyyy")
private LocalDate dataNascimento;

// ‚úÖ Teste @JsonIgnore para campos sens√≠veis
@JsonIgnore
private String senha;

// ‚úÖ Teste @JsonInclude para campos opcionais
@JsonInclude(JsonInclude.Include.NON_NULL)
private String telefone;

// ‚úÖ Use JSONPath para valida√ß√µes complexas
ctx.read("$.pedido.items[?(@.preco > 100)].nome");

// ‚úÖ Valide JSON contra JSON Schema
Set<ValidationMessage> errors = schema.validate(jsonNode);

// ‚úÖ Teste custom serializers/deserializers
@JsonSerialize(using = CpfSerializer.class)

// ‚úÖ Use JAXB para XML
@XmlRootElement(name = "cliente")

// ‚úÖ Teste XML com XPath
xpath.evaluate("/cliente/nome", doc);
```

### ‚ùå Anti-Patterns

```java
// ‚ùå N√£o testar serializa√ß√£o
// Bugs em produ√ß√£o com JSON inv√°lido

// ‚úÖ Sempre teste
@Test
void deveSerializarCorretamente() { ... }

// ‚ùå N√£o validar JSON Schema
// Contratos de API quebrados

// ‚úÖ Valide contra schema
schema.validate(jsonNode);

// ‚ùå Hard-coded JSON strings
String json = "{\"nome\":\"Jo√£o\"}";  // ‚ùå

// ‚úÖ Use ObjectMapper
objectMapper.writeValueAsString(cliente);

// ‚ùå Ignorar formata√ß√£o de datas
// Datas em formatos diferentes

// ‚úÖ Use @JsonFormat
@JsonFormat(pattern = "dd/MM/yyyy")

// ‚ùå N√£o testar campos null/opcionais
// NullPointerException em produ√ß√£o

// ‚úÖ Teste casos edge
@Test
void deveSerializarComTelefoneNull() { ... }
```

---

## üéØ Quando Usar Cada Abordagem?

| Cen√°rio                | @JsonTest   | JSONPath    | JSON Schema | JAXB   |
| ---------------------- | ----------- | ----------- | ----------- | ------ |
| Teste de serializa√ß√£o  | ‚úÖ Sim      | ‚ö†Ô∏è Limitado | ‚ùå N√£o      | ‚ùå N√£o |
| Valida√ß√£o de contratos | ‚ö†Ô∏è Limitado | ‚ö†Ô∏è Limitado | ‚úÖ Sim      | ‚ö†Ô∏è XSD |
| Testes de XML          | ‚ùå N√£o      | ‚ùå N√£o      | ‚ùå N√£o      | ‚úÖ Sim |
| Custom serializers     | ‚úÖ Sim      | ‚ùå N√£o      | ‚ùå N√£o      | ‚ùå N√£o |

---

## üìù Resumo

**Testes de XML e JSON** garantem:

- ‚úÖ **@JsonTest**: Testes de serializa√ß√£o/desserializa√ß√£o JSON
- ‚úÖ **JacksonTester**: Valida JSON com assertions
- ‚úÖ **JSONPath**: Valida√ß√µes complexas de JSON (arrays, nested objects, filtros)
- ‚úÖ **JSON Schema**: Valida JSON contra schemas (required, types, formats)
- ‚úÖ **JAXB**: Serializa√ß√£o/desserializa√ß√£o de XML
- ‚úÖ **XPath**: Valida√ß√µes de estrutura XML
- ‚úÖ **Custom Serializers**: Testa formata√ß√£o customizada (CPF, dinheiro, datas)
- ‚úÖ **@JsonFormat**: Testa formata√ß√£o de datas/n√∫meros
- ‚úÖ **@JsonIgnore/@JsonInclude**: Testa campos sens√≠veis/opcionais

**Regra de ouro:** Sempre teste **serializa√ß√£o**, **desserializa√ß√£o** e **valida√ß√£o de schemas** para evitar quebras de contrato de API.
