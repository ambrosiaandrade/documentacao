# 03.3 Testes de Mensageria [AVAN√áADO] üì®

## üéØ Objetivo

Testar sistemas de **mensageria ass√≠ncrona** com **RabbitMQ** e **Kafka**, validando **producers**, **consumers**, **dead letter queues**, **retries** e **idempot√™ncia** usando **EmbeddedKafka**, **Testcontainers** e **mocks**.

---

## üìö O Que √© Mensageria?

**Mensageria** √© comunica√ß√£o **ass√≠ncrona** entre servi√ßos via **message brokers** (RabbitMQ, Kafka), permitindo **desacoplamento**, **escalabilidade** e **resili√™ncia**.

### Por Que Testar Mensageria?

```java
// ‚ùå SEM testes de mensageria
// - Producer publica, mas n√£o sabe se funcionou
// - Consumer pode falhar silenciosamente
// - Bugs s√≥ aparecem em produ√ß√£o

// ‚úÖ COM testes de mensageria
// - Valida que mensagem foi publicada
// - Valida que consumer processou corretamente
// - Testa cen√°rios de erro (retry, DLQ)
```

---

## üê∞ RabbitMQ Testing

### Configura√ß√£o

```xml
<dependencies>
    <!-- Spring AMQP -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>

    <!-- Spring AMQP Test -->
    <dependency>
        <groupId>org.springframework.amqp</groupId>
        <artifactId>spring-rabbit-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!-- Testcontainers RabbitMQ -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>rabbitmq</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## üì§ RabbitMQ Producer

### Producer Service

```java
@Service
@RequiredArgsConstructor
public class PedidoProducer {

    private final RabbitTemplate rabbitTemplate;

    public void publicarPedidoCriado(PedidoCriadoEvent evento) {
        log.info("Publicando evento PedidoCriado: pedidoId={}", evento.getPedidoId());

        rabbitTemplate.convertAndSend(
            "pedidos.exchange",
            "pedido.criado",
            evento
        );
    }

    public void publicarPedidoCancelado(Long pedidoId) {
        PedidoCanceladoEvent evento = new PedidoCanceladoEvent(pedidoId, LocalDateTime.now());

        rabbitTemplate.convertAndSend(
            "pedidos.exchange",
            "pedido.cancelado",
            evento
        );
    }
}
```

### Testando Producer com Testcontainers

```java
@Testcontainers
@SpringBootTest
class PedidoProducerIntegrationTest {

    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12-management");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.rabbitmq.host", rabbitmq::getHost);
        registry.add("spring.rabbitmq.port", rabbitmq::getAmqpPort);
        registry.add("spring.rabbitmq.username", rabbitmq::getAdminUsername);
        registry.add("spring.rabbitmq.password", rabbitmq::getAdminPassword);
    }

    @Autowired
    private PedidoProducer pedidoProducer;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    @DisplayName("Deve publicar evento PedidoCriado no RabbitMQ")
    void devePublicarEventoPedidoCriado() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(
            100L,
            1L,
            new BigDecimal("250.00"),
            LocalDateTime.now()
        );

        // When
        pedidoProducer.publicarPedidoCriado(evento);

        // Then - Consome mensagem diretamente da fila
        Thread.sleep(1000);  // Aguarda processamento ass√≠ncrono

        Object mensagem = rabbitTemplate.receiveAndConvert("pedidos.criados", 5000);
        assertNotNull(mensagem, "Mensagem n√£o foi publicada na fila");

        PedidoCriadoEvent eventoRecebido = (PedidoCriadoEvent) mensagem;
        assertEquals(100L, eventoRecebido.getPedidoId());
        assertEquals(1L, eventoRecebido.getClienteId());
        assertEquals(new BigDecimal("250.00"), eventoRecebido.getTotal());
    }

    @Test
    @DisplayName("Deve publicar evento com routing key correta")
    void devePublicarComRoutingKeyCorreta() {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // When
        pedidoProducer.publicarPedidoCriado(evento);

        // Then - Valida na fila correta (binding key = "pedido.criado")
        Object mensagem = rabbitTemplate.receiveAndConvert("pedidos.criados", 5000);
        assertNotNull(mensagem);
    }
}
```

---

## üì• RabbitMQ Consumer

### Consumer Service

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PedidoConsumer {

    private final PagamentoService pagamentoService;
    private final EmailService emailService;

    @RabbitListener(queues = "pedidos.criados")
    public void processarPedidoCriado(PedidoCriadoEvent evento) {
        log.info("Processando PedidoCriado: pedidoId={}", evento.getPedidoId());

        try {
            // Processa pagamento
            pagamentoService.processar(evento.getPedidoId(), evento.getTotal());

            // Envia email de confirma√ß√£o
            emailService.enviarConfirmacao(evento.getClienteId(), evento.getPedidoId());

            log.info("Pedido processado com sucesso: pedidoId={}", evento.getPedidoId());
        } catch (Exception ex) {
            log.error("Erro ao processar pedido: pedidoId={}", evento.getPedidoId(), ex);
            throw new AmqpRejectAndDontRequeueException("Erro no processamento", ex);
        }
    }

    @RabbitListener(queues = "pedidos.cancelados")
    public void processarPedidoCancelado(PedidoCanceladoEvent evento) {
        log.info("Processando PedidoCancelado: pedidoId={}", evento.getPedidoId());

        pagamentoService.estornar(evento.getPedidoId());
        emailService.enviarCancelamento(evento.getPedidoId());
    }
}
```

### Testando Consumer

```java
@Testcontainers
@SpringBootTest
class PedidoConsumerIntegrationTest {

    @Container
    static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12-management");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.rabbitmq.host", rabbitmq::getHost);
        registry.add("spring.rabbitmq.port", rabbitmq::getAmqpPort);
    }

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @MockBean
    private PagamentoService pagamentoService;

    @MockBean
    private EmailService emailService;

    @Test
    @DisplayName("Consumer deve processar evento PedidoCriado")
    void consumerDeveProcessarEventoPedidoCriado() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(
            100L,
            1L,
            new BigDecimal("250.00"),
            LocalDateTime.now()
        );

        // When - Publica mensagem na fila
        rabbitTemplate.convertAndSend("pedidos.criados", evento);

        // Then - Aguarda consumer processar
        Thread.sleep(2000);

        verify(pagamentoService, timeout(5000)).processar(100L, new BigDecimal("250.00"));
        verify(emailService, timeout(5000)).enviarConfirmacao(1L, 100L);
    }

    @Test
    @DisplayName("Consumer deve rejeitar mensagem quando erro no processamento")
    void consumerDeveRejeitarMensagemQuandoErro() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // Mock pagamentoService lan√ßando exce√ß√£o
        doThrow(new PagamentoException("Gateway indispon√≠vel"))
            .when(pagamentoService).processar(anyLong(), any(BigDecimal.class));

        // When
        rabbitTemplate.convertAndSend("pedidos.criados", evento);

        // Then - Aguarda consumer processar e rejeitar
        Thread.sleep(2000);

        verify(pagamentoService, timeout(5000)).processar(100L, new BigDecimal("250"));
        verify(emailService, never()).enviarConfirmacao(anyLong(), anyLong());

        // Mensagem foi para Dead Letter Queue (DLQ)
        Object mensagemDLQ = rabbitTemplate.receiveAndConvert("pedidos.criados.dlq", 5000);
        assertNotNull(mensagemDLQ, "Mensagem deveria estar na DLQ");
    }
}
```

---

## üîÑ RabbitMQ Dead Letter Queue (DLQ)

### Configura√ß√£o DLQ

```java
@Configuration
public class RabbitMQConfig {

    @Bean
    public Queue pedidosCriadosQueue() {
        return QueueBuilder.durable("pedidos.criados")
                .withArgument("x-dead-letter-exchange", "pedidos.dlx")
                .withArgument("x-dead-letter-routing-key", "pedido.criado.dlq")
                .build();
    }

    @Bean
    public Queue pedidosDLQ() {
        return new Queue("pedidos.criados.dlq", true);
    }

    @Bean
    public DirectExchange pedidosExchange() {
        return new DirectExchange("pedidos.exchange");
    }

    @Bean
    public DirectExchange deadLetterExchange() {
        return new DirectExchange("pedidos.dlx");
    }

    @Bean
    public Binding pedidosCriadosBinding() {
        return BindingBuilder.bind(pedidosCriadosQueue())
                .to(pedidosExchange())
                .with("pedido.criado");
    }

    @Bean
    public Binding pedidosDLQBinding() {
        return BindingBuilder.bind(pedidosDLQ())
                .to(deadLetterExchange())
                .with("pedido.criado.dlq");
    }
}
```

### Testando DLQ

```java
@Test
@DisplayName("Deve enviar mensagem para DLQ ap√≥s 3 tentativas falhadas")
void deveEnviarParaDLQApos3Tentativas() throws Exception {
    // Given
    PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

    // Mock sempre falha
    doThrow(new RuntimeException("Erro permanente"))
        .when(pagamentoService).processar(anyLong(), any(BigDecimal.class));

    // When - Publica mensagem
    rabbitTemplate.convertAndSend("pedidos.criados", evento);

    // Then - Aguarda 3 retries + envio para DLQ
    Thread.sleep(10000);  // Aguarda retries

    // Verifica 3 tentativas
    verify(pagamentoService, times(3)).processar(100L, new BigDecimal("250"));

    // Mensagem na DLQ
    Object mensagemDLQ = rabbitTemplate.receiveAndConvert("pedidos.criados.dlq", 5000);
    assertNotNull(mensagemDLQ);
}
```

---

## üì® Kafka Testing

### Configura√ß√£o

```xml
<dependencies>
    <!-- Spring Kafka -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka</artifactId>
    </dependency>

    <!-- Spring Kafka Test -->
    <dependency>
        <groupId>org.springframework.kafka</groupId>
        <artifactId>spring-kafka-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!-- Testcontainers Kafka -->
    <dependency>
        <groupId>org.testcontainers</groupId>
        <artifactId>kafka</artifactId>
        <version>1.19.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

## üì§ Kafka Producer

### Producer Service

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class PedidoKafkaProducer {

    private final KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    public void publicar(PedidoCriadoEvent evento) {
        log.info("Publicando evento Kafka: pedidoId={}", evento.getPedidoId());

        String key = evento.getClienteId().toString();  // Partition key

        kafkaTemplate.send("pedidos-criados", key, evento)
                .thenAccept(result -> {
                    log.info("Evento publicado com sucesso: partition={}, offset={}",
                        result.getRecordMetadata().partition(),
                        result.getRecordMetadata().offset());
                })
                .exceptionally(ex -> {
                    log.error("Erro ao publicar evento Kafka", ex);
                    return null;
                });
    }
}
```

### Testando Producer com EmbeddedKafka

```java
@SpringBootTest
@EmbeddedKafka(
    topics = {"pedidos-criados"},
    partitions = 3,
    brokerProperties = {
        "listeners=PLAINTEXT://localhost:9092",
        "auto.create.topics.enable=true"
    }
)
class PedidoKafkaProducerTest {

    @Autowired
    private PedidoKafkaProducer producer;

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    private KafkaConsumer<String, PedidoCriadoEvent> consumer;

    @BeforeEach
    void setUp() {
        Map<String, Object> configs = new HashMap<>();
        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        configs.put(ConsumerConfig.GROUP_ID_CONFIG, "test-group");
        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        configs.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
        configs.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");

        consumer = new KafkaConsumer<>(configs);
        consumer.subscribe(Collections.singletonList("pedidos-criados"));
    }

    @AfterEach
    void tearDown() {
        consumer.close();
    }

    @Test
    @DisplayName("Deve publicar evento no Kafka")
    void devePublicarEventoNoKafka() {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(
            100L,
            1L,
            new BigDecimal("250.00"),
            LocalDateTime.now()
        );

        // When
        producer.publicar(evento);

        // Then - Consome mensagem
        ConsumerRecords<String, PedidoCriadoEvent> records =
            consumer.poll(Duration.ofSeconds(10));

        assertEquals(1, records.count());

        PedidoCriadoEvent eventoRecebido = records.iterator().next().value();
        assertEquals(100L, eventoRecebido.getPedidoId());
        assertEquals(new BigDecimal("250.00"), eventoRecebido.getTotal());
    }

    @Test
    @DisplayName("Deve usar clienteId como partition key")
    void deveUsarClienteIdComoPartitionKey() {
        // Given
        PedidoCriadoEvent evento1 = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));
        PedidoCriadoEvent evento2 = new PedidoCriadoEvent(101L, 1L, new BigDecimal("300"));

        // When - Mesmo clienteId (mesma partition)
        producer.publicar(evento1);
        producer.publicar(evento2);

        // Then - Ambos na mesma partition
        ConsumerRecords<String, PedidoCriadoEvent> records =
            consumer.poll(Duration.ofSeconds(10));

        assertEquals(2, records.count());

        List<Integer> partitions = new ArrayList<>();
        records.forEach(record -> partitions.add(record.partition()));

        // Mesma partition
        assertEquals(partitions.get(0), partitions.get(1));
    }
}
```

### Testando Producer com Testcontainers

```java
@Testcontainers
@SpringBootTest
class PedidoKafkaProducerIntegrationTest {

    @Container
    static KafkaContainer kafka = new KafkaContainer(
        DockerImageName.parse("confluentinc/cp-kafka:7.5.0")
    );

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.kafka.bootstrap-servers", kafka::getBootstrapServers);
    }

    @Autowired
    private PedidoKafkaProducer producer;

    @Test
    @DisplayName("Deve publicar evento no Kafka real (Testcontainers)")
    void devePublicarEventoNoKafkaReal() {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // When
        producer.publicar(evento);

        // Then - Valida que foi publicado (via KafkaConsumer direto)
        // Similar ao teste anterior, mas usando container real
    }
}
```

---

## üì• Kafka Consumer

### Consumer Service

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PedidoKafkaConsumer {

    private final PagamentoService pagamentoService;
    private final EmailService emailService;

    @KafkaListener(
        topics = "pedidos-criados",
        groupId = "pedidos-group",
        containerFactory = "kafkaListenerContainerFactory"
    )
    public void processar(PedidoCriadoEvent evento,
                         @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
                         @Header(KafkaHeaders.OFFSET) long offset) {
        log.info("Processando evento Kafka: pedidoId={}, partition={}, offset={}",
            evento.getPedidoId(), partition, offset);

        try {
            pagamentoService.processar(evento.getPedidoId(), evento.getTotal());
            emailService.enviarConfirmacao(evento.getClienteId(), evento.getPedidoId());

            log.info("Evento processado com sucesso");
        } catch (Exception ex) {
            log.error("Erro ao processar evento Kafka", ex);
            throw ex;  // Kafka far√° retry conforme configura√ß√£o
        }
    }
}
```

### Testando Consumer

```java
@SpringBootTest
@EmbeddedKafka(topics = {"pedidos-criados"}, partitions = 1)
class PedidoKafkaConsumerTest {

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    @MockBean
    private PagamentoService pagamentoService;

    @MockBean
    private EmailService emailService;

    @Test
    @DisplayName("Consumer deve processar evento Kafka")
    void consumerDeveProcessarEventoKafka() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(
            100L,
            1L,
            new BigDecimal("250.00"),
            LocalDateTime.now()
        );

        // When
        kafkaTemplate.send("pedidos-criados", evento).get();  // .get() aguarda confirma√ß√£o

        // Then - Aguarda consumer processar
        verify(pagamentoService, timeout(10000)).processar(100L, new BigDecimal("250.00"));
        verify(emailService, timeout(10000)).enviarConfirmacao(1L, 100L);
    }

    @Test
    @DisplayName("Consumer deve fazer retry quando erro transit√≥rio")
    void consumerDeveFazerRetryQuandoErroTransitorio() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // Mock: falha 2 vezes, sucesso na 3¬™
        doThrow(new RuntimeException("Erro transit√≥rio"))
            .doThrow(new RuntimeException("Erro transit√≥rio"))
            .doNothing()
            .when(pagamentoService).processar(anyLong(), any(BigDecimal.class));

        // When
        kafkaTemplate.send("pedidos-criados", evento).get();

        // Then - Aguarda 3 tentativas
        verify(pagamentoService, timeout(15000).times(3))
            .processar(100L, new BigDecimal("250"));

        // Email enviado apenas ap√≥s sucesso
        verify(emailService, timeout(5000)).enviarConfirmacao(1L, 100L);
    }
}
```

---

## üîÑ Kafka Retry e DLT (Dead Letter Topic)

### Configura√ß√£o Retry

```java
@Configuration
public class KafkaConsumerConfig {

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, PedidoCriadoEvent> kafkaListenerContainerFactory(
            ConsumerFactory<String, PedidoCriadoEvent> consumerFactory) {

        ConcurrentKafkaListenerContainerFactory<String, PedidoCriadoEvent> factory =
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);

        // Retry configuration
        factory.setCommonErrorHandler(new DefaultErrorHandler(
            new FixedBackOff(1000L, 3L)  // 3 retries com 1s de intervalo
        ));

        return factory;
    }
}
```

### Configura√ß√£o DLT (Dead Letter Topic)

```java
@Configuration
public class KafkaConsumerConfig {

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, PedidoCriadoEvent> kafkaListenerContainerFactory(
            ConsumerFactory<String, PedidoCriadoEvent> consumerFactory,
            KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate) {

        ConcurrentKafkaListenerContainerFactory<String, PedidoCriadoEvent> factory =
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);

        // Dead Letter Publishing Recoverer
        DeadLetterPublishingRecoverer recoverer = new DeadLetterPublishingRecoverer(
            kafkaTemplate,
            (record, ex) -> new TopicPartition("pedidos-criados.dlt", record.partition())
        );

        // Error handler com DLT
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
            recoverer,
            new FixedBackOff(1000L, 3L)
        );

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }
}
```

### Testando DLT

```java
@SpringBootTest
@EmbeddedKafka(topics = {"pedidos-criados", "pedidos-criados.dlt"}, partitions = 1)
class KafkaDLTTest {

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    @MockBean
    private PagamentoService pagamentoService;

    private KafkaConsumer<String, PedidoCriadoEvent> dltConsumer;

    @BeforeEach
    void setUp() {
        Map<String, Object> configs = new HashMap<>();
        configs.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        configs.put(ConsumerConfig.GROUP_ID_CONFIG, "dlt-test-group");
        configs.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configs.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        configs.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
        configs.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");

        dltConsumer = new KafkaConsumer<>(configs);
        dltConsumer.subscribe(Collections.singletonList("pedidos-criados.dlt"));
    }

    @AfterEach
    void tearDown() {
        dltConsumer.close();
    }

    @Test
    @DisplayName("Deve enviar mensagem para DLT ap√≥s 3 tentativas falhadas")
    void deveEnviarParaDLTApos3Tentativas() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // Mock sempre falha
        doThrow(new RuntimeException("Erro permanente"))
            .when(pagamentoService).processar(anyLong(), any(BigDecimal.class));

        // When
        kafkaTemplate.send("pedidos-criados", evento).get();

        // Then - Aguarda 3 retries
        Thread.sleep(10000);

        verify(pagamentoService, times(3)).processar(100L, new BigDecimal("250"));

        // Mensagem no DLT
        ConsumerRecords<String, PedidoCriadoEvent> records =
            dltConsumer.poll(Duration.ofSeconds(10));

        assertEquals(1, records.count());

        PedidoCriadoEvent eventoDLT = records.iterator().next().value();
        assertEquals(100L, eventoDLT.getPedidoId());
    }
}
```

---

## üîç Idempot√™ncia

### Consumer Idempotente

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class PedidoIdempotentConsumer {

    private final PagamentoService pagamentoService;
    private final ProcessadosRepository processadosRepository;

    @KafkaListener(topics = "pedidos-criados", groupId = "pedidos-group")
    public void processar(PedidoCriadoEvent evento,
                         @Header(KafkaHeaders.RECEIVED_PARTITION) int partition,
                         @Header(KafkaHeaders.OFFSET) long offset) {

        String idempotencyKey = String.format("pedido-%d-partition-%d-offset-%d",
            evento.getPedidoId(), partition, offset);

        // Verifica se j√° processou
        if (processadosRepository.existsByKey(idempotencyKey)) {
            log.warn("Evento j√° processado, ignorando: {}", idempotencyKey);
            return;
        }

        try {
            // Processa
            pagamentoService.processar(evento.getPedidoId(), evento.getTotal());

            // Marca como processado
            processadosRepository.save(new Processado(idempotencyKey, LocalDateTime.now()));

            log.info("Evento processado com sucesso");
        } catch (Exception ex) {
            log.error("Erro ao processar evento", ex);
            throw ex;
        }
    }
}
```

### Testando Idempot√™ncia

```java
@SpringBootTest
@EmbeddedKafka(topics = {"pedidos-criados"}, partitions = 1)
class IdempotenciaTest {

    @Autowired
    private KafkaTemplate<String, PedidoCriadoEvent> kafkaTemplate;

    @MockBean
    private PagamentoService pagamentoService;

    @Autowired
    private ProcessadosRepository processadosRepository;

    @BeforeEach
    void setUp() {
        processadosRepository.deleteAll();
    }

    @Test
    @DisplayName("Deve processar mensagem apenas uma vez (idempot√™ncia)")
    void deveProcessarApenasUmaVez() throws Exception {
        // Given
        PedidoCriadoEvent evento = new PedidoCriadoEvent(100L, 1L, new BigDecimal("250"));

        // When - Envia mesma mensagem 3 vezes
        kafkaTemplate.send("pedidos-criados", evento).get();
        kafkaTemplate.send("pedidos-criados", evento).get();
        kafkaTemplate.send("pedidos-criados", evento).get();

        // Then - Aguarda processamento
        Thread.sleep(5000);

        // Processou apenas 1 vez (idempotente)
        verify(pagamentoService, times(1)).processar(100L, new BigDecimal("250"));
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use Testcontainers para testes realistas
@Container
static RabbitMQContainer rabbitmq = new RabbitMQContainer("rabbitmq:3.12");

// ‚úÖ Use EmbeddedKafka para testes r√°pidos
@EmbeddedKafka(topics = {"pedidos"}, partitions = 1)

// ‚úÖ Aguarde processamento ass√≠ncrono
verify(service, timeout(5000)).processar(...);

// ‚úÖ Teste DLQ/DLT
Object mensagemDLQ = rabbitTemplate.receiveAndConvert("queue.dlq", 5000);
assertNotNull(mensagemDLQ);

// ‚úÖ Teste idempot√™ncia
kafkaTemplate.send(topic, evento);  // 1¬™ vez
kafkaTemplate.send(topic, evento);  // 2¬™ vez (deve ignorar)
verify(service, times(1)).processar(...);  // Processou apenas 1 vez

// ‚úÖ Use partition key no Kafka
String key = evento.getClienteId().toString();
kafkaTemplate.send(topic, key, evento);

// ‚úÖ Cleanup entre testes
@BeforeEach
void setUp() {
    processadosRepository.deleteAll();
}
```

### ‚ùå Anti-Patterns

```java
// ‚ùå N√£o aguardar processamento ass√≠ncrono
rabbitTemplate.convertAndSend("queue", evento);
verify(service).processar(...);  // ‚ùå Pode n√£o ter processado ainda

// ‚úÖ Aguarde
verify(service, timeout(5000)).processar(...);

// ‚ùå Testar com Thread.sleep gen√©rico
Thread.sleep(1000);  // ‚ùå Pode ser insuficiente

// ‚úÖ Use timeout() do Mockito
verify(service, timeout(5000)).processar(...);

// ‚ùå N√£o testar cen√°rios de erro
// (apenas happy path)

// ‚úÖ Teste retries, DLQ, DLT

// ‚ùå N√£o limpar estado entre testes
// Mensagens antigas podem interferir

// ‚úÖ Limpe filas/t√≥picos antes de cada teste
```

---

## üéØ Quando Usar Cada Abordagem?

| Cen√°rio                  | EmbeddedKafka/RabbitTest | Testcontainers |
| ------------------------ | ------------------------ | -------------- |
| Teste unit√°rio r√°pido    | ‚úÖ Sim                   | ‚ùå N√£o         |
| Teste de integra√ß√£o real | ‚ö†Ô∏è Limitado              | ‚úÖ Sim         |
| CI/CD                    | ‚úÖ Sim                   | ‚úÖ Sim         |
| Paridade com produ√ß√£o    | ‚ö†Ô∏è Limitado              | ‚úÖ Sim         |
| Performance              | ‚úÖ R√°pido                | ‚ö†Ô∏è Mais lento  |

---

## üìù Resumo

**Testes de Mensageria** garantem:

- ‚úÖ **RabbitMQ**: Producers, consumers, DLQ, routing keys
- ‚úÖ **Kafka**: Producers, consumers, DLT, partition keys
- ‚úÖ **EmbeddedKafka**: Testes r√°pidos em mem√≥ria
- ‚úÖ **Testcontainers**: Brokers reais (RabbitMQ/Kafka)
- ‚úÖ **Retry**: Testes de retentativas autom√°ticas
- ‚úÖ **DLQ/DLT**: Dead letter queues/topics
- ‚úÖ **Idempot√™ncia**: Processar mensagens apenas uma vez
- ‚úÖ **Mocks**: PagamentoService, EmailService (depend√™ncias)

**Regra de ouro:** Use **EmbeddedKafka/RabbitTest** para testes **r√°pidos** e **Testcontainers** para testes de **integra√ß√£o realistas** que garantem **paridade com produ√ß√£o**.
