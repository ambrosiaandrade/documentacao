# 03.8 Testes de Performance e Carga [AVAN√áADO] ‚ö°

## üéØ Objetivo

Dominar **testes de performance** com **JMeter**, **Gatling**, **JMH**, **load testing**, **stress testing**, **spike testing** e **integra√ß√£o com CI/CD** para garantir escalabilidade e confiabilidade.

---

## üìö Tipos de Testes de Performance

### 1. Load Testing

Testa o sistema sob **carga esperada** (ex: 100 usu√°rios simult√¢neos).

### 2. Stress Testing

Testa o sistema sob **carga extrema** at√© encontrar o **ponto de quebra**.

### 3. Spike Testing

Testa o sistema com **picos s√∫bitos** de carga (ex: Black Friday).

### 4. Soak Testing

Testa o sistema sob **carga prolongada** (ex: 24 horas) para detectar **memory leaks**.

### 5. Benchmarking

Testa **performance de m√©todos espec√≠ficos** (microbenchmarks com JMH).

---

## üèóÔ∏è Configura√ß√£o

### pom.xml

```xml
<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- JMH (Java Microbenchmark Harness) -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-core</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>

    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-generator-annprocess</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>

    <!-- Gatling (Scala) -->
    <dependency>
        <groupId>io.gatling.highcharts</groupId>
        <artifactId>gatling-charts-highcharts</artifactId>
        <version>3.10.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <!-- Gatling Maven Plugin -->
        <plugin>
            <groupId>io.gatling</groupId>
            <artifactId>gatling-maven-plugin</artifactId>
            <version>4.7.0</version>
        </plugin>
    </plugins>
</build>
```

---

## üß™ JMeter - Load Testing

### Instala√ß√£o

```bash
# Download JMeter
wget https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.tgz
tar -xzf apache-jmeter-5.6.3.tgz

# Executar JMeter GUI
./apache-jmeter-5.6.3/bin/jmeter.sh
```

### Test Plan B√°sico (JMX)

**cliente-load-test.jmx:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="5.0">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="Cliente API Load Test">
      <stringProp name="TestPlan.comments">Teste de carga para API de Clientes</stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">false</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments">
        <collectionProp name="Arguments.arguments">
          <elementProp name="BASE_URL" elementType="Argument">
            <stringProp name="Argument.name">BASE_URL</stringProp>
            <stringProp name="Argument.value">http://localhost:8080</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
    </TestPlan>

    <hashTree>
      <!-- Thread Group: 100 usu√°rios, ramp-up 10s -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Usuario Thread Group">
        <stringProp name="ThreadGroup.num_threads">100</stringProp>
        <stringProp name="ThreadGroup.ramp_time">10</stringProp>
        <stringProp name="ThreadGroup.duration">60</stringProp>
        <boolProp name="ThreadGroup.scheduler">true</boolProp>
      </ThreadGroup>

      <hashTree>
        <!-- HTTP Request: GET /api/clientes -->
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="GET Clientes">
          <stringProp name="HTTPSampler.domain">${BASE_URL}</stringProp>
          <stringProp name="HTTPSampler.path">/api/clientes</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
        </HTTPSamplerProxy>

        <!-- Assertions -->
        <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="Response Code 200">
          <stringProp name="Assertion.test_field">Assertion.response_code</stringProp>
          <stringProp name="Assertion.test_type">8</stringProp>
          <stringProp name="Assertion.test_strings">200</stringProp>
        </ResponseAssertion>

        <!-- Listeners -->
        <ResultCollector guiclass="SummaryReport" testclass="ResultCollector" testname="Summary Report"/>
        <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="View Results Tree"/>
      </hashTree>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
```

### Executando JMeter via CLI

```bash
# Executa teste em modo CLI (headless)
jmeter -n -t cliente-load-test.jmx -l results.jtl -e -o ./report

# Par√¢metros:
# -n: modo non-GUI
# -t: test plan file
# -l: log de resultados
# -e: gera relat√≥rio HTML
# -o: pasta de sa√≠da do relat√≥rio
```

### Analisando Resultados JMeter

```bash
# Relat√≥rio HTML gerado em ./report/index.html

# M√©tricas principais:
# - Throughput: requisi√ß√µes/segundo
# - Response Time: tempo de resposta (avg, min, max, percentiles)
# - Error Rate: % de erros
# - Active Threads: threads ativas ao longo do tempo
```

---

## üî• Gatling - Scala DSL

### Simula√ß√£o B√°sica

**ClienteLoadSimulation.scala:**

```scala
package simulations

import io.gatling.core.Predef._
import io.gatling.http.Predef._
import scala.concurrent.duration._

class ClienteLoadSimulation extends Simulation {

  // Configura√ß√£o HTTP
  val httpProtocol = http
    .baseUrl("http://localhost:8080")
    .acceptHeader("application/json")
    .contentTypeHeader("application/json")

  // Cen√°rio: Listar clientes
  val listarClientes = scenario("Listar Clientes")
    .exec(
      http("GET /api/clientes")
        .get("/api/clientes")
        .check(status.is(200))
        .check(jsonPath("$[*].nome").findAll.saveAs("nomes"))
    )
    .pause(1)

  // Cen√°rio: Criar cliente
  val criarCliente = scenario("Criar Cliente")
    .exec(
      http("POST /api/clientes")
        .post("/api/clientes")
        .body(StringBody("""{
          "nome": "Jo√£o Silva",
          "email": "joao${__UUID()}@mail.com",
          "cpf": "12345678901"
        }"""))
        .check(status.is(201))
        .check(jsonPath("$.id").saveAs("clienteId"))
    )
    .pause(1)
    .exec(
      http("GET /api/clientes/${clienteId}")
        .get("/api/clientes/${clienteId}")
        .check(status.is(200))
    )

  // Cen√°rio: Buscar cliente espec√≠fico
  val buscarCliente = scenario("Buscar Cliente")
    .exec(
      http("GET /api/clientes/1")
        .get("/api/clientes/1")
        .check(status.is(200))
        .check(jsonPath("$.nome").is("Jo√£o Silva"))
    )

  // Setup: Load Testing (carga constante)
  setUp(
    listarClientes.inject(
      rampUsers(50) during (10.seconds),  // Ramp-up: 50 usu√°rios em 10s
      constantUsersPerSec(10) during (60.seconds)  // Carga: 10 usu√°rios/s por 60s
    ),
    criarCliente.inject(
      rampUsers(20) during (10.seconds),
      constantUsersPerSec(5) during (60.seconds)
    ),
    buscarCliente.inject(
      rampUsers(30) during (10.seconds),
      constantUsersPerSec(8) during (60.seconds)
    )
  ).protocols(httpProtocol)
}
```

### Stress Testing com Gatling

```scala
class ClienteStressSimulation extends Simulation {

  val httpProtocol = http.baseUrl("http://localhost:8080")

  val stress = scenario("Stress Test")
    .exec(http("GET /api/clientes").get("/api/clientes").check(status.is(200)))

  setUp(
    stress.inject(
      rampUsers(10) during (5.seconds),     // Fase 1: 10 users
      constantUsersPerSec(10) during (30.seconds),
      rampUsers(50) during (10.seconds),    // Fase 2: 50 users
      constantUsersPerSec(50) during (30.seconds),
      rampUsers(100) during (10.seconds),   // Fase 3: 100 users (stress)
      constantUsersPerSec(100) during (30.seconds),
      rampUsers(200) during (10.seconds),   // Fase 4: 200 users (breaking point?)
      constantUsersPerSec(200) during (30.seconds)
    )
  ).protocols(httpProtocol)
  .assertions(
    global.responseTime.max.lt(5000),       // Max response time < 5s
    global.successfulRequests.percent.gt(95) // Success rate > 95%
  )
}
```

### Spike Testing com Gatling

```scala
class ClienteSpikeSimulation extends Simulation {

  val httpProtocol = http.baseUrl("http://localhost:8080")

  val spike = scenario("Spike Test")
    .exec(http("GET /api/clientes").get("/api/clientes"))

  setUp(
    spike.inject(
      rampUsers(10) during (10.seconds),    // Carga normal
      constantUsersPerSec(10) during (30.seconds),

      // Spike s√∫bito!
      rampUsers(500) during (5.seconds),    // 500 usu√°rios em 5s
      constantUsersPerSec(500) during (10.seconds),

      // Volta ao normal
      rampUsers(10) during (5.seconds),
      constantUsersPerSec(10) during (30.seconds)
    )
  ).protocols(httpProtocol)
}
```

### Executando Gatling

```bash
# Executa simula√ß√£o via Maven
mvn gatling:test -Dgatling.simulationClass=simulations.ClienteLoadSimulation

# Relat√≥rio gerado em: target/gatling/results/*/index.html
```

### Analisando Resultados Gatling

```bash
# Relat√≥rio HTML interativo com gr√°ficos:
# - Response Time Distribution
# - Response Time Percentiles (50th, 75th, 95th, 99th)
# - Requests per Second
# - Active Users over Time
# - Error Rate

# M√©tricas principais:
# - Mean response time: tempo m√©dio
# - 95th percentile: 95% das requisi√ß√µes abaixo desse tempo
# - Requests/sec: throughput
# - OK/KO: taxa de sucesso/erro
```

---

## üî¨ JMH - Microbenchmarks

### Benchmark de M√©todo

```java
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Benchmark)
@Fork(value = 1, warmups = 1)
@Warmup(iterations = 2, time = 1)
@Measurement(iterations = 5, time = 1)
public class ClienteServiceBenchmark {

    private ClienteService clienteService;
    private List<Cliente> clientes;

    @Setup
    public void setUp() {
        clienteService = new ClienteService();

        // Cria 10.000 clientes para benchmark
        clientes = new ArrayList<>();
        for (int i = 0; i < 10_000; i++) {
            clientes.add(new Cliente((long) i, "Cliente " + i, "cliente" + i + "@mail.com"));
        }
    }

    @Benchmark
    public List<ClienteDTO> testBuscarClientesVip() {
        // Benchmark: filtra clientes VIP
        return clienteService.buscarClientesVip(clientes);
    }

    @Benchmark
    public List<ClienteDTO> testBuscarClientesVipParallel() {
        // Benchmark: filtra clientes VIP (parallel stream)
        return clienteService.buscarClientesVipParallel(clientes);
    }

    @Benchmark
    public Map<String, List<ClienteDTO>> testAgruparClientesPorCidade() {
        // Benchmark: agrupa clientes por cidade
        return clienteService.agruparClientesPorCidade(clientes);
    }

    public static void main(String[] args) throws Exception {
        org.openjdk.jmh.Main.main(args);
    }
}
```

### Comparando Implementa√ß√µes

```java
@State(Scope.Benchmark)
public class StringConcatenationBenchmark {

    private static final int ITERATIONS = 1000;

    @Benchmark
    public String testStringConcat() {
        // Pior: + operator
        String result = "";
        for (int i = 0; i < ITERATIONS; i++) {
            result = result + "item" + i;
        }
        return result;
    }

    @Benchmark
    public String testStringBuilder() {
        // Melhor: StringBuilder
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < ITERATIONS; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }

    @Benchmark
    public String testStringJoiner() {
        // Alternativa: StringJoiner
        StringJoiner joiner = new StringJoiner("");
        for (int i = 0; i < ITERATIONS; i++) {
            joiner.add("item" + i);
        }
        return joiner.toString();
    }
}
```

### Executando JMH

```bash
# Compila benchmarks
mvn clean install

# Executa benchmarks
java -jar target/benchmarks.jar

# Resultados:
# Benchmark                                  Mode  Cnt    Score   Error  Units
# ClienteServiceBenchmark.buscarVip          avgt    5   12.345 ¬± 0.123  us/op
# ClienteServiceBenchmark.buscarVipParallel  avgt    5    6.789 ¬± 0.089  us/op
# StringConcatenationBenchmark.concat        avgt    5  500.123 ¬± 5.678  us/op
# StringConcatenationBenchmark.builder       avgt    5    8.456 ¬± 0.234  us/op
```

---

## üìä Monitoramento e M√©tricas

### Spring Boot Actuator + Micrometer

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

### application.yml

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

### Custom Metrics

```java
@RestController
@RequestMapping("/api/clientes")
public class ClienteController {

    private final ClienteService clienteService;
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer requestTimer;

    public ClienteController(ClienteService clienteService, MeterRegistry meterRegistry) {
        this.clienteService = clienteService;
        this.meterRegistry = meterRegistry;

        // Counter: quantidade de requisi√ß√µes
        this.requestCounter = Counter.builder("clientes.requests")
            .description("Total de requisi√ß√µes para /api/clientes")
            .tag("endpoint", "listar")
            .register(meterRegistry);

        // Timer: tempo de resposta
        this.requestTimer = Timer.builder("clientes.response.time")
            .description("Tempo de resposta de /api/clientes")
            .register(meterRegistry);
    }

    @GetMapping
    public List<ClienteDTO> listar() {
        requestCounter.increment();

        return requestTimer.record(() -> {
            return clienteService.listarTodos();
        });
    }
}
```

### Visualizando M√©tricas com Prometheus/Grafana

```bash
# Prometheus scrape config (prometheus.yml)
scrape_configs:
  - job_name: 'spring-boot-app'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['localhost:8080']

# Acessa m√©tricas:
# http://localhost:8080/actuator/prometheus

# Exemplos de m√©tricas:
# - http_server_requests_seconds_count
# - http_server_requests_seconds_sum
# - jvm_memory_used_bytes
# - clientes_requests_total
# - clientes_response_time_seconds
```

---

## üöÄ Integra√ß√£o com CI/CD

### GitHub Actions - Performance Tests

**.github/workflows/performance-tests.yml:**

```yaml
name: Performance Tests

on:
  pull_request:
    branches: [main]
  schedule:
    - cron: "0 2 * * 1" # Segunda-feira √†s 2h

jobs:
  gatling-tests:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: "17"
          distribution: "temurin"

      - name: Start Application
        run: |
          mvn spring-boot:run &
          sleep 30  # Aguarda aplica√ß√£o subir

      - name: Run Gatling Load Tests
        run: mvn gatling:test -Dgatling.simulationClass=simulations.ClienteLoadSimulation

      - name: Upload Gatling Report
        uses: actions/upload-artifact@v3
        with:
          name: gatling-report
          path: target/gatling/results/

      - name: Check Performance Thresholds
        run: |
          # Extrai m√©tricas do relat√≥rio
          MEAN_RESPONSE_TIME=$(grep -oP 'mean: \K[0-9]+' target/gatling/results/*/index.html | head -1)
          ERROR_RATE=$(grep -oP 'KO: \K[0-9.]+' target/gatling/results/*/index.html | head -1)

          # Valida thresholds
          if [ $MEAN_RESPONSE_TIME -gt 1000 ]; then
            echo "‚ùå Mean response time ($MEAN_RESPONSE_TIME ms) acima do limite (1000 ms)"
            exit 1
          fi

          if [ $(echo "$ERROR_RATE > 5.0" | bc) -eq 1 ]; then
            echo "‚ùå Error rate ($ERROR_RATE%) acima do limite (5%)"
            exit 1
          fi

          echo "‚úÖ Performance tests passed!"
```

### GitLab CI - JMeter Tests

**.gitlab-ci.yml:**

```yaml
stages:
  - build
  - test
  - performance

performance-test:
  stage: performance
  image: maven:3.9-eclipse-temurin-17
  services:
    - postgres:15

  before_script:
    - apt-get update && apt-get install -y wget
    - wget https://dlcdn.apache.org//jmeter/binaries/apache-jmeter-5.6.3.tgz
    - tar -xzf apache-jmeter-5.6.3.tgz

  script:
    # Sobe aplica√ß√£o
    - mvn spring-boot:run &
    - sleep 30

    # Executa JMeter
    - ./apache-jmeter-5.6.3/bin/jmeter.sh -n -t tests/cliente-load-test.jmx -l results.jtl -e -o ./report

    # Analisa resultados
    - |
      ERROR_RATE=$(grep -oP 'errorPct=\K[0-9.]+' results.jtl | awk '{sum+=$1} END {print sum/NR}')
      if [ $(echo "$ERROR_RATE > 5.0" | bc) -eq 1 ]; then
        echo "‚ùå Error rate too high: $ERROR_RATE%"
        exit 1
      fi

  artifacts:
    when: always
    paths:
      - report/
    expire_in: 1 week

  only:
    - main
    - schedules
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Defina objetivos claros
// - Load: 1000 usu√°rios simult√¢neos, <1s response time
// - Stress: Encontrar ponto de quebra
// - Spike: Recupera√ß√£o em <30s

// ‚úÖ Use ramp-up gradual
rampUsers(100) during (30.seconds)  // N√£o 0 ‚Üí 100 instant√¢neo

// ‚úÖ Execute em ambiente isolado
// N√£o em produ√ß√£o, n√£o em m√°quina de dev

// ‚úÖ Monitore recursos do servidor
// CPU, mem√≥ria, conex√µes DB, threads

// ‚úÖ Valide thresholds
.assertions(
  global.responseTime.percentile(95).lt(1000),
  global.successfulRequests.percent.gt(99)
)

// ‚úÖ Use dados realistas
// N√£o fixos: "joao@mail.com"
// Variados: "joao${__UUID()}@mail.com"

// ‚úÖ Teste cen√°rios compostos
scenario("User Journey")
  .exec(login)
  .pause(2)
  .exec(buscarProduto)
  .pause(3)
  .exec(adicionarCarrinho)
  .pause(1)
  .exec(checkout)

// ‚úÖ Execute regularmente
// CI/CD scheduled (semanal)
// Antes de releases

// ‚úÖ Compare resultados hist√≥ricos
// Detectar regress√µes de performance
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Testar em produ√ß√£o
// Pode derrubar o sistema!

// ‚úÖ Use ambiente de staging/homolog

// ‚ùå N√£o usar ramp-up
constantUsersPerSec(1000) during (1.second)  // ‚ùå Spike instant√¢neo

// ‚úÖ Ramp-up gradual
rampUsers(1000) during (60.seconds)

// ‚ùå Ignorar m√©tricas do servidor
// S√≥ olhar response time

// ‚úÖ Monitore CPU, mem√≥ria, DB connections

// ‚ùå Dados irrealistas
// Sempre mesmo cliente, mesmo produto

// ‚úÖ Dados variados com feeders

// ‚ùå N√£o validar thresholds
// Teste passa mesmo com performance ruim

// ‚úÖ Assertions claras
global.responseTime.percentile(95).lt(1000)

// ‚ùå Executar manualmente
// Performance tests esquecidos

// ‚úÖ CI/CD scheduled
# Toda segunda √†s 2h
```

---

## üéØ Quando Usar Cada Ferramenta?

| Ferramenta  | Uso Principal                         | Vantagens                    | Desvantagens               |
| ----------- | ------------------------------------- | ---------------------------- | -------------------------- |
| **JMeter**  | Load/Stress tests HTTP                | GUI, amplamente usado        | XML verboso, lento         |
| **Gatling** | Load/Stress tests avan√ßados           | Scala DSL, relat√≥rios lindos | Curva aprendizado          |
| **JMH**     | Microbenchmarks (m√©todos espec√≠ficos) | Precis√£o cient√≠fica          | Scope limitado             |
| **Locust**  | Load tests Python                     | Simplicidade Python          | Menos recursos que Gatling |

---

## üìù Resumo

**Testes de Performance** garantem:

- ‚úÖ **Load Testing**: Sistema aguenta carga esperada (ex: 1000 usu√°rios)
- ‚úÖ **Stress Testing**: Encontra ponto de quebra (ex: 5000 usu√°rios)
- ‚úÖ **Spike Testing**: Sistema se recupera de picos s√∫bitos (Black Friday)
- ‚úÖ **Soak Testing**: Detecta memory leaks (carga prolongada 24h)
- ‚úÖ **JMeter**: Load tests HTTP com GUI e CLI
- ‚úÖ **Gatling**: Load tests com Scala DSL e relat√≥rios interativos
- ‚úÖ **JMH**: Microbenchmarks para m√©todos espec√≠ficos (String concat, loops)
- ‚úÖ **Micrometer/Prometheus**: M√©tricas em tempo real (response time, throughput)
- ‚úÖ **CI/CD Integration**: Performance tests automatizados (GitHub Actions, GitLab CI)

**Regra de ouro:** Execute testes de performance **regularmente** (CI/CD scheduled) e compare com **baselines hist√≥ricas** para detectar **regress√µes** antes de produ√ß√£o.
