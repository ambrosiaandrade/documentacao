# 03.1 Spring Context Testing [AVAN√áADO] üçÉ

## üéØ Objetivo

Dominar **testes de integra√ß√£o** com Spring Boot usando **@SpringBootTest**, **@WebMvcTest**, **@DataJpaTest**, **test slices**, **TestRestTemplate**, **MockMvc** e **@MockBean** para validar comportamento completo da aplica√ß√£o.

---

## üìö O Que √© Spring Context Testing?

**Spring Context Testing** carrega o **contexto completo do Spring** (ou partes dele) para testar **integra√ß√£o entre componentes** reais, diferente de testes unit√°rios que usam apenas mocks.

### Diferen√ßa: Teste Unit√°rio vs Teste de Integra√ß√£o

```java
// ‚ùå Teste UNIT√ÅRIO - Mocks de tudo
@ExtendWith(MockitoExtension.class)
class ClienteServiceTest {
    @Mock
    private ClienteRepository repository;

    @InjectMocks
    private ClienteService service;

    @Test
    void deveSalvar() {
        when(repository.save(any())).thenReturn(new Cliente(1L, "Jo√£o"));
        Cliente salvo = service.salvar(new Cliente("Jo√£o"));
        assertEquals(1L, salvo.getId());
    }
}

// ‚úÖ Teste de INTEGRA√á√ÉO - Contexto Spring real
@SpringBootTest
class ClienteServiceIntegrationTest {
    @Autowired
    private ClienteService service;  // Bean real

    @Autowired
    private ClienteRepository repository;  // Repository real

    @Test
    void deveSalvarNoBancoReal() {
        Cliente cliente = service.salvar(new Cliente("Jo√£o"));

        // Valida persist√™ncia real
        Optional<Cliente> encontrado = repository.findById(cliente.getId());
        assertTrue(encontrado.isPresent());
    }
}
```

---

## üèóÔ∏è @SpringBootTest - Contexto Completo

### Configura√ß√£o B√°sica

```java
@SpringBootTest
@AutoConfigureMockMvc  // Injeta MockMvc automaticamente
class PedidoIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private PedidoService pedidoService;

    @Autowired
    private PedidoRepository pedidoRepository;

    @Test
    void deveCriarPedidoCompleto() throws Exception {
        // Given
        String requestBody = """
            {
                "clienteId": 1,
                "items": [
                    {"produtoId": 10, "quantidade": 2},
                    {"produtoId": 20, "quantidade": 1}
                ]
            }
            """;

        // When
        MvcResult result = mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").exists())
                .andExpect(jsonPath("$.clienteId").value(1))
                .andExpect(jsonPath("$.items").isArray())
                .andReturn();

        // Then - Valida persist√™ncia no banco
        String responseBody = result.getResponse().getContentAsString();
        Long pedidoId = JsonPath.read(responseBody, "$.id");

        Optional<Pedido> pedido = pedidoRepository.findById(pedidoId);
        assertTrue(pedido.isPresent());
        assertEquals(2, pedido.get().getItems().size());
    }
}
```

### WebEnvironment Modes

```java
// 1. MOCK (padr√£o) - N√£o sobe servidor, usa MockMvc
@SpringBootTest(webEnvironment = WebEnvironment.MOCK)
class MockEnvironmentTest {
    @Autowired
    private MockMvc mockMvc;  // ‚úÖ Dispon√≠vel

    // TestRestTemplate n√£o dispon√≠vel
}

// 2. RANDOM_PORT - Sobe servidor em porta aleat√≥ria
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class RandomPortTest {
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;  // ‚úÖ Dispon√≠vel

    @Test
    void deveAcessarEndpoint() {
        String url = "http://localhost:" + port + "/api/clientes";
        ResponseEntity<List> response = restTemplate.getForEntity(url, List.class);
        assertEquals(HttpStatus.OK, response.getStatusCode());
    }
}

// 3. DEFINED_PORT - Usa porta definida em application.properties
@SpringBootTest(webEnvironment = WebEnvironment.DEFINED_PORT)
class DefinedPortTest {
    // Usa server.port do application.properties
}

// 4. NONE - N√£o sobe servidor web
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
class NoWebTest {
    @Autowired
    private ClienteService clienteService;  // ‚úÖ Testa apenas services

    // Sem MockMvc ou TestRestTemplate
}
```

---

## üß™ TestRestTemplate - Cliente HTTP Real

### GET Request

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ClienteControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private ClienteRepository clienteRepository;

    @BeforeEach
    void setUp() {
        clienteRepository.deleteAll();
        clienteRepository.save(new Cliente(1L, "Jo√£o", "joao@mail.com"));
        clienteRepository.save(new Cliente(2L, "Maria", "maria@mail.com"));
    }

    @Test
    @DisplayName("Deve listar todos os clientes")
    void deveListarTodosClientes() {
        // When
        ResponseEntity<ClienteDTO[]> response = restTemplate.getForEntity(
            "/api/clientes",
            ClienteDTO[].class
        );

        // Then
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals(2, response.getBody().length);
    }

    @Test
    @DisplayName("Deve buscar cliente por ID")
    void deveBuscarClientePorId() {
        // When
        ResponseEntity<ClienteDTO> response = restTemplate.getForEntity(
            "/api/clientes/1",
            ClienteDTO.class
        );

        // Then
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("Jo√£o", response.getBody().getNome());
    }

    @Test
    @DisplayName("Deve retornar 404 quando cliente n√£o existe")
    void deveRetornar404QuandoClienteNaoExiste() {
        // When
        ResponseEntity<ProblemDetail> response = restTemplate.getForEntity(
            "/api/clientes/999",
            ProblemDetail.class
        );

        // Then
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    }
}
```

### POST Request

```java
@Test
@DisplayName("Deve criar cliente com sucesso")
void deveCriarCliente() {
    // Given
    ClienteRequest request = new ClienteRequest(
        "Pedro Silva",
        "pedro@mail.com",
        "12345678901"
    );

    // When
    ResponseEntity<ClienteDTO> response = restTemplate.postForEntity(
        "/api/clientes",
        request,
        ClienteDTO.class
    );

    // Then
    assertEquals(HttpStatus.CREATED, response.getStatusCode());
    assertNotNull(response.getBody());
    assertNotNull(response.getBody().getId());
    assertEquals("Pedro Silva", response.getBody().getNome());

    // Valida header Location
    String location = response.getHeaders().getLocation().toString();
    assertTrue(location.contains("/api/clientes/"));

    // Valida persist√™ncia no banco
    Long clienteId = response.getBody().getId();
    Optional<Cliente> cliente = clienteRepository.findById(clienteId);
    assertTrue(cliente.isPresent());
}

@Test
@DisplayName("Deve retornar 400 quando dados inv√°lidos")
void deveRetornar400QuandoDadosInvalidos() {
    // Given - Email inv√°lido
    ClienteRequest request = new ClienteRequest(
        "Pedro",
        "email-invalido",  // Sem @
        "123"  // CPF inv√°lido
    );

    // When
    ResponseEntity<ProblemDetail> response = restTemplate.postForEntity(
        "/api/clientes",
        request,
        ProblemDetail.class
    );

    // Then
    assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
}
```

### PUT Request

```java
@Test
@DisplayName("Deve atualizar cliente existente")
void deveAtualizarCliente() {
    // Given
    Cliente clienteExistente = clienteRepository.save(
        new Cliente("Jo√£o", "joao@mail.com", "12345678901")
    );

    ClienteRequest updateRequest = new ClienteRequest(
        "Jo√£o Silva",  // Nome atualizado
        "joao.silva@mail.com",  // Email atualizado
        "12345678901"
    );

    // When
    restTemplate.put(
        "/api/clientes/" + clienteExistente.getId(),
        updateRequest
    );

    // Then - Valida no banco
    Cliente atualizado = clienteRepository.findById(clienteExistente.getId()).get();
    assertEquals("Jo√£o Silva", atualizado.getNome());
    assertEquals("joao.silva@mail.com", atualizado.getEmail());
}
```

### DELETE Request

```java
@Test
@DisplayName("Deve deletar cliente existente")
void deveDeletarCliente() {
    // Given
    Cliente cliente = clienteRepository.save(new Cliente("Jo√£o", "joao@mail.com"));

    // When
    restTemplate.delete("/api/clientes/" + cliente.getId());

    // Then
    assertFalse(clienteRepository.existsById(cliente.getId()));
}
```

### Exchange (M√©todos HTTP Avan√ßados)

```java
@Test
@DisplayName("Deve fazer requisi√ß√£o com headers customizados")
void deveUsarHeadersCustomizados() {
    // Given
    HttpHeaders headers = new HttpHeaders();
    headers.set("X-API-Key", "secret-key");
    headers.set("X-Request-ID", UUID.randomUUID().toString());

    HttpEntity<Void> entity = new HttpEntity<>(headers);

    // When
    ResponseEntity<ClienteDTO[]> response = restTemplate.exchange(
        "/api/clientes",
        HttpMethod.GET,
        entity,
        ClienteDTO[].class
    );

    // Then
    assertEquals(HttpStatus.OK, response.getStatusCode());
}

@Test
@DisplayName("Deve fazer PATCH request")
void deveFazerPatchRequest() {
    // Given
    Cliente cliente = clienteRepository.save(new Cliente("Jo√£o", "joao@mail.com"));

    Map<String, Object> updates = Map.of("nome", "Jo√£o Silva");
    HttpEntity<Map<String, Object>> entity = new HttpEntity<>(updates);

    // When
    ResponseEntity<ClienteDTO> response = restTemplate.exchange(
        "/api/clientes/" + cliente.getId(),
        HttpMethod.PATCH,
        entity,
        ClienteDTO.class
    );

    // Then
    assertEquals(HttpStatus.OK, response.getStatusCode());
    assertEquals("Jo√£o Silva", response.getBody().getNome());
}
```

---

## üéØ MockMvc - Testes Sem Servidor HTTP

### B√°sico com MockMvc

```java
@SpringBootTest
@AutoConfigureMockMvc
class ProdutoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ProdutoRepository produtoRepository;

    @Test
    @DisplayName("Deve listar produtos com filtro")
    void deveListarProdutosComFiltro() throws Exception {
        // Given
        produtoRepository.save(new Produto("PROD-001", "Notebook", new BigDecimal("3000")));
        produtoRepository.save(new Produto("PROD-002", "Mouse", new BigDecimal("50")));

        // When & Then
        mockMvc.perform(get("/api/produtos")
                .param("categoria", "ELETRONICOS")
                .param("precoMinimo", "100"))
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))
                .andExpect(jsonPath("$").isArray())
                .andExpect(jsonPath("$[0].codigo").value("PROD-001"))
                .andExpect(jsonPath("$[0].preco").value(3000))
                .andDo(print());  // Imprime request/response no console
    }
}
```

### JSONPath Assertions

```java
@Test
@DisplayName("Deve validar estrutura JSON completa")
void deveValidarEstruturaJSON() throws Exception {
    mockMvc.perform(get("/api/clientes/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.nome").value("Jo√£o"))
            .andExpect(jsonPath("$.email").value("joao@mail.com"))
            .andExpect(jsonPath("$.cpf").value("12345678901"))
            .andExpect(jsonPath("$.vip").value(false))
            .andExpect(jsonPath("$.dataCadastro").isNotEmpty())
            .andExpect(jsonPath("$.endereco").exists())
            .andExpect(jsonPath("$.endereco.cep").value("01310-100"))
            .andExpect(jsonPath("$.pedidos").isArray())
            .andExpect(jsonPath("$.pedidos.length()").value(2));
}
```

### POST com MockMvc

```java
@Test
@DisplayName("Deve criar pedido e retornar 201")
void deveCriarPedido() throws Exception {
    String requestBody = """
        {
            "clienteId": 1,
            "items": [
                {
                    "produtoId": 10,
                    "quantidade": 2
                }
            ],
            "formaPagamento": "CREDITO"
        }
        """;

    mockMvc.perform(post("/api/pedidos")
            .contentType(MediaType.APPLICATION_JSON)
            .content(requestBody))
            .andExpect(status().isCreated())
            .andExpect(header().exists("Location"))
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.status").value("PENDENTE"))
            .andExpect(jsonPath("$.total").isNumber());
}
```

### Capturando Resposta

```java
@Test
@DisplayName("Deve capturar resposta e validar detalhes")
void deveCapturarResposta() throws Exception {
    MvcResult result = mockMvc.perform(post("/api/clientes")
            .contentType(MediaType.APPLICATION_JSON)
            .content("{\"nome\":\"Jo√£o\",\"email\":\"joao@mail.com\"}"))
            .andExpect(status().isCreated())
            .andReturn();

    String responseBody = result.getResponse().getContentAsString();
    ClienteDTO cliente = new ObjectMapper().readValue(responseBody, ClienteDTO.class);

    assertNotNull(cliente.getId());
    assertEquals("Jo√£o", cliente.getNome());
}
```

---

## üî¨ Test Slices - Contexto Parcial

### @WebMvcTest - Apenas Controllers

```java
@WebMvcTest(ClienteController.class)
class ClienteControllerWebTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean  // Mock do service
    private ClienteService clienteService;

    @Test
    @DisplayName("Deve testar controller isoladamente")
    void deveTestarControllerIsolado() throws Exception {
        // Given
        ClienteDTO clienteDTO = new ClienteDTO(1L, "Jo√£o", "joao@mail.com");
        when(clienteService.buscarPorId(1L)).thenReturn(Optional.of(clienteDTO));

        // When & Then
        mockMvc.perform(get("/api/clientes/1"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.nome").value("Jo√£o"));

        verify(clienteService).buscarPorId(1L);
    }
}
```

**Vantagens:**

- ‚úÖ Carrega apenas camada web (r√°pido)
- ‚úÖ Testa valida√ß√µes, serializa√ß√£o JSON, status HTTP
- ‚úÖ N√£o carrega repository, database

### @DataJpaTest - Apenas Persistence

```java
@DataJpaTest
class ClienteRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private ClienteRepository clienteRepository;

    @Test
    @DisplayName("Deve buscar cliente por email")
    void deveBuscarPorEmail() {
        // Given
        Cliente cliente = new Cliente("Jo√£o", "joao@mail.com", "12345678901");
        entityManager.persist(cliente);
        entityManager.flush();

        // When
        Optional<Cliente> encontrado = clienteRepository.findByEmail("joao@mail.com");

        // Then
        assertTrue(encontrado.isPresent());
        assertEquals("Jo√£o", encontrado.get().getNome());
    }

    @Test
    @DisplayName("Deve validar query customizada")
    void deveValidarQueryCustomizada() {
        // Given
        entityManager.persist(new Cliente("Jo√£o", "joao@mail.com"));
        entityManager.persist(new Cliente("Maria", "maria@mail.com"));
        entityManager.flush();

        // When
        List<Cliente> clientes = clienteRepository.findByNomeContaining("a");

        // Then
        assertEquals(2, clientes.size());  // Jo√£o + Maria (ambos t√™m 'a')
    }
}
```

**Vantagens:**

- ‚úÖ Carrega apenas JPA components
- ‚úÖ Usa banco H2 em mem√≥ria (padr√£o)
- ‚úÖ Transa√ß√µes rollback autom√°tico ap√≥s cada teste

### @JsonTest - Serializa√ß√£o/Deserializa√ß√£o

```java
@JsonTest
class ClienteDTOJsonTest {

    @Autowired
    private JacksonTester<ClienteDTO> json;

    @Test
    @DisplayName("Deve serializar ClienteDTO para JSON")
    void deveSerializarParaJSON() throws Exception {
        ClienteDTO cliente = new ClienteDTO(1L, "Jo√£o", "joao@mail.com");

        JsonContent<ClienteDTO> jsonContent = json.write(cliente);

        assertThat(jsonContent).hasJsonPathNumberValue("$.id");
        assertThat(jsonContent).extractingJsonPathNumberValue("$.id").isEqualTo(1);
        assertThat(jsonContent).extractingJsonPathStringValue("$.nome").isEqualTo("Jo√£o");
        assertThat(jsonContent).extractingJsonPathStringValue("$.email").isEqualTo("joao@mail.com");
    }

    @Test
    @DisplayName("Deve deserializar JSON para ClienteDTO")
    void deveDeserializarDeJSON() throws Exception {
        String jsonString = """
            {
                "id": 1,
                "nome": "Jo√£o",
                "email": "joao@mail.com"
            }
            """;

        ClienteDTO cliente = json.parse(jsonString).getObject();

        assertEquals(1L, cliente.getId());
        assertEquals("Jo√£o", cliente.getNome());
        assertEquals("joao@mail.com", cliente.getEmail());
    }
}
```

### @RestClientTest - Testes de RestTemplate/WebClient

```java
@RestClientTest(PagamentoGatewayClient.class)
class PagamentoGatewayClientTest {

    @Autowired
    private PagamentoGatewayClient client;

    @Autowired
    private MockRestServiceServer server;

    @Test
    @DisplayName("Deve chamar API externa de pagamento")
    void deveChamarAPIExterna() throws Exception {
        // Given
        String expectedResponse = """
            {
                "transactionId": "TXN-123",
                "status": "APPROVED"
            }
            """;

        server.expect(requestTo("https://gateway.com/api/payments"))
                .andExpect(method(HttpMethod.POST))
                .andExpect(jsonPath("$.amount").value(100.00))
                .andRespond(withSuccess(expectedResponse, MediaType.APPLICATION_JSON));

        // When
        PagamentoRequest request = new PagamentoRequest(new BigDecimal("100.00"));
        PagamentoResponse response = client.processar(request);

        // Then
        assertEquals("TXN-123", response.getTransactionId());
        assertEquals("APPROVED", response.getStatus());
        server.verify();
    }
}
```

---

## üé≠ @MockBean vs @Mock

### Quando Usar Cada Um

```java
// @Mock - Teste unit√°rio (sem Spring Context)
@ExtendWith(MockitoExtension.class)
class ServiceUnitTest {
    @Mock
    private ClienteRepository repository;  // Mock Mockito puro

    @InjectMocks
    private ClienteService service;  // N√£o √© bean Spring
}

// @MockBean - Teste de integra√ß√£o (com Spring Context)
@SpringBootTest
class ServiceIntegrationTest {
    @MockBean
    private ClienteRepository repository;  // Substitui bean no contexto Spring

    @Autowired
    private ClienteService service;  // Bean Spring real (com repository mockado)
}
```

### Exemplo Real

```java
@SpringBootTest
@AutoConfigureMockMvc
class PedidoFlowIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PagamentoGateway pagamentoGateway;  // Mock API externa

    @MockBean
    private EmailService emailService;  // Mock envio de email

    @Autowired
    private PedidoRepository pedidoRepository;  // Repository REAL

    @Autowired
    private ClienteRepository clienteRepository;  // Repository REAL

    @Test
    @DisplayName("Deve criar pedido completo com pagamento e email")
    void deveCriarPedidoCompleto() throws Exception {
        // Given - Cria cliente real no banco
        Cliente cliente = clienteRepository.save(new Cliente("Jo√£o", "joao@mail.com"));

        // Mock gateway de pagamento
        when(pagamentoGateway.processar(any()))
                .thenReturn(new PagamentoResponse("TXN-123", "APPROVED"));

        // Mock envio de email
        doNothing().when(emailService).enviar(anyString(), anyString());

        String requestBody = String.format("""
            {
                "clienteId": %d,
                "items": [{"produtoId": 10, "quantidade": 2}]
            }
            """, cliente.getId());

        // When
        MvcResult result = mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestBody))
                .andExpect(status().isCreated())
                .andReturn();

        // Then
        Long pedidoId = JsonPath.read(result.getResponse().getContentAsString(), "$.id");

        // Valida persist√™ncia REAL no banco
        Pedido pedido = pedidoRepository.findById(pedidoId).get();
        assertEquals("PAGO", pedido.getStatus());

        // Valida chamadas aos mocks
        verify(pagamentoGateway).processar(any());
        verify(emailService).enviar(eq("joao@mail.com"), contains("Pedido"));
    }
}
```

---

## üóÑÔ∏è Configura√ß√£o de Banco de Testes

### application-test.properties

```properties
# H2 em mem√≥ria (padr√£o)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop

# PostgreSQL em Docker (Testcontainers)
# spring.datasource.url=jdbc:postgresql://localhost:5432/testdb
# spring.datasource.username=test
# spring.datasource.password=test

# Logs SQL
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Desabilitar cache Redis em testes
spring.cache.type=none
```

### @ActiveProfiles

```java
@SpringBootTest
@ActiveProfiles("test")  // Usa application-test.properties
class ClienteServiceTest {
    // Usa configura√ß√µes espec√≠ficas de teste
}
```

### @Sql - Scripts SQL Antes dos Testes

```java
@SpringBootTest
@Sql(scripts = "/test-data.sql", executionPhase = ExecutionPhase.BEFORE_TEST_METHOD)
class ClienteRepositoryTest {

    @Autowired
    private ClienteRepository repository;

    @Test
    void deveEncontrarClientesInseridos() {
        List<Cliente> clientes = repository.findAll();
        assertEquals(5, clientes.size());  // test-data.sql insere 5 clientes
    }
}
```

**test-data.sql:**

```sql
INSERT INTO cliente (nome, email, cpf) VALUES ('Jo√£o', 'joao@mail.com', '12345678901');
INSERT INTO cliente (nome, email, cpf) VALUES ('Maria', 'maria@mail.com', '98765432109');
INSERT INTO cliente (nome, email, cpf) VALUES ('Pedro', 'pedro@mail.com', '11111111111');
```

---

## üîê Testes com Seguran√ßa

### @WithMockUser - Usu√°rio Autenticado

```java
@SpringBootTest
@AutoConfigureMockMvc
class SecureEndpointTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName("Deve retornar 401 quando n√£o autenticado")
    void deveRetornar401QuandoNaoAutenticado() throws Exception {
        mockMvc.perform(get("/api/admin/usuarios"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @WithMockUser(username = "admin", roles = {"ADMIN"})
    @DisplayName("Deve acessar endpoint admin quando autenticado")
    void deveAcessarQuandoAdmin() throws Exception {
        mockMvc.perform(get("/api/admin/usuarios"))
                .andExpect(status().isOk());
    }

    @Test
    @WithMockUser(username = "user", roles = {"USER"})
    @DisplayName("Deve retornar 403 quando sem permiss√£o")
    void deveRetornar403QuandoSemPermissao() throws Exception {
        mockMvc.perform(get("/api/admin/usuarios"))
                .andExpect(status().isForbidden());
    }
}
```

### @WithUserDetails - Usu√°rio do UserDetailsService

```java
@SpringBootTest
@AutoConfigureMockMvc
@Sql(scripts = "/test-users.sql")
class UserDetailsTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @WithUserDetails("joao@mail.com")
    @DisplayName("Deve autenticar com usu√°rio do banco")
    void deveAutenticarComUsuarioDoBanco() throws Exception {
        mockMvc.perform(get("/api/perfil"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.email").value("joao@mail.com"));
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Use @SpringBootTest para testes de integra√ß√£o completos
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)

// ‚úÖ Use test slices para testes focados
@WebMvcTest(ClienteController.class)  // Apenas controller
@DataJpaTest  // Apenas persistence

// ‚úÖ Use @MockBean para depend√™ncias externas
@MockBean private PagamentoGateway gateway;  // API externa
@MockBean private EmailService emailService;  // Servi√ßo de email

// ‚úÖ Use TestRestTemplate para HTTP real
@Autowired private TestRestTemplate restTemplate;

// ‚úÖ Use MockMvc para testes r√°pidos sem servidor
@Autowired private MockMvc mockMvc;

// ‚úÖ Profile de teste separado
@ActiveProfiles("test")

// ‚úÖ Limpar dados entre testes
@BeforeEach
void setUp() {
    repository.deleteAll();
}

// ‚úÖ Transa√ß√µes rollback autom√°tico
@Transactional  // Rollback ap√≥s cada teste
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Usar @SpringBootTest para tudo (lento)
@SpringBootTest  // Carrega contexto completo para teste simples

// ‚úÖ Use test slice espec√≠fico
@WebMvcTest(ClienteController.class)

// ‚ùå Mockar tudo em teste de integra√ß√£o
@MockBean private ClienteRepository repository;  // ‚ùå Deveria ser real
@MockBean private ClienteService service;  // ‚ùå

// ‚úÖ Mock apenas depend√™ncias externas
@MockBean private PagamentoGateway gateway;  // ‚úÖ API externa

// ‚ùå Compartilhar estado entre testes
static Cliente clienteGlobal;

@Test void test1() { clienteGlobal = save(...); }
@Test void test2() { update(clienteGlobal); }  // ‚ùå Depende de test1

// ‚ùå Hard-coded ports
restTemplate.getForEntity("http://localhost:8080/api/clientes", ...)

// ‚úÖ Use @LocalServerPort
@LocalServerPort private int port;
String url = "http://localhost:" + port + "/api/clientes";
```

---

## üìù Resumo

**Spring Context Testing** oferece:

- ‚úÖ **@SpringBootTest**: Contexto completo (integra√ß√£o)
- ‚úÖ **@WebMvcTest**: Apenas controllers (web layer)
- ‚úÖ **@DataJpaTest**: Apenas persistence (repository layer)
- ‚úÖ **@JsonTest**: Serializa√ß√£o/deserializa√ß√£o JSON
- ‚úÖ **@RestClientTest**: Clientes HTTP (RestTemplate/WebClient)
- ‚úÖ **TestRestTemplate**: Requisi√ß√µes HTTP reais
- ‚úÖ **MockMvc**: Requisi√ß√µes sem servidor HTTP
- ‚úÖ **@MockBean**: Substitui beans no contexto Spring
- ‚úÖ **@Sql**: Scripts SQL para dados de teste
- ‚úÖ **@WithMockUser**: Testes com seguran√ßa

**Regra de ouro:** Use **test slices** (@WebMvcTest, @DataJpaTest) quando poss√≠vel para **performance**, e **@SpringBootTest** apenas quando precisa **integra√ß√£o completa** entre componentes.
