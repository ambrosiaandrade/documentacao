# 06.1 Docker [INTERMEDI√ÅRIO] üê≥

## üéØ Objetivo

Containerizar aplica√ß√µes **Java/Spring Boot** usando **Docker** com **multi-stage builds**, **otimiza√ß√£o de imagem**, e integra√ß√£o com **Docker Compose** para ambientes completos.

---

## üìö O Que √â Docker?

**Docker** √© uma plataforma para criar, distribuir e executar aplica√ß√µes em **containers** isolados, garantindo consist√™ncia entre ambientes (dev, staging, prod).

### Analogia

Como **container de carga**:

- **Sem Docker**: "Funciona na minha m√°quina" (ambiente espec√≠fico)
- **Com Docker**: Container padr√£o que roda em qualquer navio (portabilidade)
- **Vantagem**: Mesmo ambiente em dev, homolog e prod

---

## ‚ùå Problema que Resolve

### Antes (Sem Docker)

```bash
# ‚ùå Instala√ß√£o manual em cada ambiente

# Servidor 1 (Dev)
$ sudo apt-get install openjdk-17-jdk
$ sudo apt-get install postgresql-14
$ git clone ...
$ ./mvnw clean install
$ java -jar target/app.jar

# Servidor 2 (Prod) - Vers√µes diferentes!
$ sudo yum install java-11-openjdk  # ‚ùå JDK 11 ao inv√©s de 17
$ sudo yum install postgresql-12     # ‚ùå PostgreSQL 12 ao inv√©s de 14
$ java -jar app.jar                  # ‚ùå Erro de compatibilidade
```

**Problemas:**

- ‚ùå Inconsist√™ncia de ambientes
- ‚ùå "Funciona na minha m√°quina"
- ‚ùå Depend√™ncias n√£o documentadas
- ‚ùå Configura√ß√£o manual propensa a erros

### Depois (Com Docker)

```bash
# ‚úÖ Mesmo container em todos os ambientes

# Dev
$ docker-compose up

# Prod
$ docker-compose up  # ‚úÖ Id√™ntico!
```

---

## üê≥ Dockerfile B√°sico

### Vers√£o Simples (N√ÉO recomendada para produ√ß√£o)

```dockerfile
# ‚ùå PROBLEMA: Imagem grande (~500 MB)

FROM openjdk:17-jdk

WORKDIR /app

# Copia JAR compilado
COPY target/pedidos-api-1.0.0.jar app.jar

# Exp√µe porta
EXPOSE 8080

# Executa aplica√ß√£o
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**Problemas:**

- ‚ùå Imagem grande (cont√©m JDK completo)
- ‚ùå Build fora do Docker (requer Maven local)
- ‚ùå Sem otimiza√ß√£o de layers

---

## ‚úÖ Dockerfile Multi-Stage (Recomendado)

```dockerfile
# ‚úÖ SOLU√á√ÉO: Multi-stage build otimizado

# Stage 1: Build
FROM maven:3.9-amazoncorretto-17 AS builder

WORKDIR /build

# Copia apenas pom.xml primeiro (cache de depend√™ncias)
COPY pom.xml .
RUN mvn dependency:go-offline

# Copia c√≥digo-fonte e compila
COPY src ./src
RUN mvn clean package -DskipTests

# Stage 2: Runtime
FROM amazoncorretto:17-alpine

# Cria usu√°rio n√£o-root (seguran√ßa)
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

WORKDIR /app

# Copia apenas JAR do stage anterior
COPY --from=builder /build/target/*.jar app.jar

# Metadados
LABEL maintainer="equipe@empresa.com"
LABEL version="1.0.0"

# Vari√°veis de ambiente
ENV JAVA_OPTS="-Xms512m -Xmx1024m" \
    SPRING_PROFILES_ACTIVE="prod"

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

# Exp√µe porta
EXPOSE 8080

# Executa aplica√ß√£o
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

**Benef√≠cios:**

- ‚úÖ Imagem pequena (~200 MB com Alpine)
- ‚úÖ Build dentro do Docker (reproduz√≠vel)
- ‚úÖ Cache de depend√™ncias
- ‚úÖ Usu√°rio n√£o-root (seguran√ßa)
- ‚úÖ Health check integrado

---

## üì¶ Build e Run

```bash
# Build da imagem
$ docker build -t pedidos-api:1.0.0 .

# Run simples
$ docker run -p 8080:8080 pedidos-api:1.0.0

# Run com vari√°veis de ambiente
$ docker run -p 8080:8080 \
    -e SPRING_PROFILES_ACTIVE=prod \
    -e DATABASE_URL=jdbc:postgresql://db:5432/pedidos \
    -e DATABASE_USERNAME=user \
    -e DATABASE_PASSWORD=password \
    pedidos-api:1.0.0

# Run em background (detached)
$ docker run -d -p 8080:8080 --name pedidos-api pedidos-api:1.0.0

# Ver logs
$ docker logs -f pedidos-api

# Parar container
$ docker stop pedidos-api

# Remover container
$ docker rm pedidos-api
```

---

## üîß Docker Compose

### docker-compose.yml Completo

```yaml
version: "3.8"

services:
  # Aplica√ß√£o Spring Boot
  app:
    build:
      context: .
      dockerfile: Dockerfile
    image: pedidos-api:latest
    container_name: pedidos-api
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      DATABASE_URL: jdbc:postgresql://db:5432/pedidos
      DATABASE_USERNAME: pedidos_user
      DATABASE_PASSWORD: pedidos_pass
      REDIS_HOST: redis
      REDIS_PORT: 6379
      RABBITMQ_HOST: rabbitmq
      RABBITMQ_PORT: 5672
      RABBITMQ_USERNAME: guest
      RABBITMQ_PASSWORD: guest
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      rabbitmq:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped

  # PostgreSQL
  db:
    image: postgres:15-alpine
    container_name: pedidos-db
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: pedidos
      POSTGRES_USER: pedidos_user
      POSTGRES_PASSWORD: pedidos_pass
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U pedidos_user -d pedidos"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis (Cache)
  redis:
    image: redis:7-alpine
    container_name: pedidos-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - app-network
    command: redis-server --appendonly yes
    restart: unless-stopped

  # RabbitMQ (Mensageria)
  rabbitmq:
    image: rabbitmq:3-management-alpine
    container_name: pedidos-rabbitmq
    ports:
      - "5672:5672" # AMQP
      - "15672:15672" # Management UI
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "ping"]
      interval: 30s
      timeout: 10s
      retries: 5
    restart: unless-stopped

  # Prometheus (M√©tricas)
  prometheus:
    image: prom/prometheus:latest
    container_name: pedidos-prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    command:
      - "--config.file=/etc/prometheus/prometheus.yml"
      - "--storage.tsdb.path=/prometheus"
    networks:
      - app-network
    restart: unless-stopped

  # Grafana (Dashboards)
  grafana:
    image: grafana/grafana:latest
    container_name: pedidos-grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus
    networks:
      - app-network
    restart: unless-stopped

volumes:
  postgres-data:
  redis-data:
  rabbitmq-data:
  prometheus-data:
  grafana-data:

networks:
  app-network:
    driver: bridge
```

### Comandos Docker Compose

```bash
# Subir todos os servi√ßos
$ docker-compose up -d

# Ver logs
$ docker-compose logs -f app

# Parar todos os servi√ßos
$ docker-compose down

# Rebuild e restart
$ docker-compose up -d --build

# Ver status
$ docker-compose ps

# Executar comando em container
$ docker-compose exec app sh

# Ver logs de servi√ßo espec√≠fico
$ docker-compose logs -f db
```

---

## ‚öôÔ∏è application-docker.yml

```yaml
# src/main/resources/application-docker.yml

spring:
  datasource:
    url: ${DATABASE_URL}
    username: ${DATABASE_USERNAME}
    password: ${DATABASE_PASSWORD}
    driver-class-name: org.postgresql.Driver
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        format_sql: true

  redis:
    host: ${REDIS_HOST}
    port: ${REDIS_PORT}

  rabbitmq:
    host: ${RABBITMQ_HOST}
    port: ${RABBITMQ_PORT}
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
```

---

## üîí .dockerignore

```
# .dockerignore

# Build artifacts
target/
!target/*.jar

# IDE
.idea/
.vscode/
*.iml

# Git
.git/
.gitignore

# Docs
README.md
*.md

# Logs
*.log

# OS
.DS_Store
Thumbs.db

# Docker
Dockerfile
docker-compose.yml
.dockerignore
```

---

## üéØ Dockerfile Otimizado (Avan√ßado)

### Com Layers Expl√≠citos

```dockerfile
# Multi-stage com layers otimizados

FROM maven:3.9-amazoncorretto-17 AS builder

WORKDIR /build

# Layer 1: Depend√™ncias (raramente muda)
COPY pom.xml .
RUN mvn dependency:go-offline

# Layer 2: C√≥digo-fonte (muda frequentemente)
COPY src ./src

# Layer 3: Build
RUN mvn clean package -DskipTests

# Extrai layers do Spring Boot
RUN java -Djarmode=layertools -jar target/*.jar extract

# Stage 2: Runtime otimizado
FROM amazoncorretto:17-alpine

RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

WORKDIR /app

# Copia layers na ordem de mudan√ßa (menos frequente primeiro)
COPY --from=builder /build/dependencies/ ./
COPY --from=builder /build/spring-boot-loader/ ./
COPY --from=builder /build/snapshot-dependencies/ ./
COPY --from=builder /build/application/ ./

ENV JAVA_OPTS="-Xms512m -Xmx1024m"

EXPOSE 8080

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS org.springframework.boot.loader.JarLauncher"]
```

**Benef√≠cios:**

- ‚úÖ Cache otimizado (depend√™ncias raramente mudam)
- ‚úÖ Rebuild r√°pido (apenas application layer muda)
- ‚úÖ Imagem ainda menor

---

## üìä Prometheus Configuration

```yaml
# prometheus.yml

global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: "pedidos-api"
    metrics_path: "/actuator/prometheus"
    static_configs:
      - targets: ["app:8080"]
```

---

## üß™ Testando Containers

### Teste de Health Check

```bash
# Verificar health da aplica√ß√£o
$ curl http://localhost:8080/actuator/health

{
  "status": "UP",
  "components": {
    "db": {"status": "UP"},
    "redis": {"status": "UP"},
    "rabbitmq": {"status": "UP"}
  }
}

# Verificar m√©tricas
$ curl http://localhost:8080/actuator/metrics

# Verificar Prometheus
$ curl http://localhost:9090/api/v1/query?query=up
```

### Teste de Conectividade

```bash
# Conectar no container
$ docker-compose exec app sh

# Dentro do container
$ ping db
$ ping redis
$ ping rabbitmq

# Testar banco
$ psql -h db -U pedidos_user -d pedidos

# Testar Redis
$ redis-cli -h redis ping
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```dockerfile
# ‚úÖ Use imagens oficiais e espec√≠ficas
FROM amazoncorretto:17-alpine  # ‚úÖ Oficial + Alpine (pequena)
FROM openjdk:17                # ‚ùå Gen√©rico + grande

# ‚úÖ Use multi-stage builds
FROM maven AS builder
FROM amazoncorretto AS runtime

# ‚úÖ Minimize layers
RUN apt-get update && \
    apt-get install -y curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*  # ‚úÖ Tudo em um RUN

# ‚ùå M√∫ltiplos RUN (mais layers)
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get clean

# ‚úÖ Usu√°rio n√£o-root
RUN adduser -S spring
USER spring

# ‚úÖ Health check
HEALTHCHECK CMD wget --spider http://localhost:8080/health

# ‚úÖ Metadata
LABEL maintainer="team@empresa.com"
LABEL version="1.0.0"

# ‚úÖ .dockerignore para evitar contexto grande
```

### ‚ùå Anti-Patterns

```dockerfile
# ‚ùå Usar latest (imprevis√≠vel)
FROM openjdk:latest

# ‚ùå Rodar como root
USER root

# ‚ùå Expor senhas hardcoded
ENV DATABASE_PASSWORD=senha123

# ‚ùå Instalar pacotes desnecess√°rios
RUN apt-get install -y vim nano emacs

# ‚ùå N√£o usar .dockerignore (contexto grande)
```

---

## üîç Debugging

### Logs

```bash
# Logs da aplica√ß√£o
$ docker-compose logs -f app

# Logs de todos os servi√ßos
$ docker-compose logs -f

# Logs com timestamp
$ docker-compose logs -f --timestamps
```

### Exec

```bash
# Shell no container
$ docker-compose exec app sh

# Executar comando
$ docker-compose exec db psql -U pedidos_user -d pedidos

# Ver processos
$ docker-compose exec app ps aux
```

### Inspecionar

```bash
# Inspecionar container
$ docker inspect pedidos-api

# Ver networks
$ docker network ls

# Ver volumes
$ docker volume ls

# Ver uso de recursos
$ docker stats
```

---

## üìä Tamanho de Imagens

| Base Image                | Tamanho | Recomenda√ß√£o |
| ------------------------- | ------- | ------------ |
| openjdk:17                | ~470 MB | ‚ùå Evitar    |
| openjdk:17-slim           | ~220 MB | ‚ö†Ô∏è OK        |
| amazoncorretto:17         | ~450 MB | ‚ùå Evitar    |
| amazoncorretto:17-alpine  | ~200 MB | ‚úÖ Preferir  |
| eclipse-temurin:17-alpine | ~180 MB | ‚úÖ Preferir  |

---

## üéØ Quando Usar Docker?

| Cen√°rio               | Usar Docker? |
| --------------------- | ------------ |
| Desenvolvimento local | ‚úÖ Sempre    |
| Ambientes isolados    | ‚úÖ Sempre    |
| CI/CD                 | ‚úÖ Sempre    |
| Produ√ß√£o (cloud)      | ‚úÖ Sempre    |
| Produ√ß√£o (bare metal) | ‚ö†Ô∏è Depende   |

---

## üîó Recursos

- [Docker Documentation](https://docs.docker.com/)
- [Docker Compose](https://docs.docker.com/compose/)
- [Spring Boot with Docker](https://spring.io/guides/topicals/spring-boot-docker)
- [Best Practices](https://docs.docker.com/develop/dev-best-practices/)

---

## üìù Resumo

**Docker** garante:

- ‚úÖ **Portabilidade**: Mesmo ambiente em dev/prod
- ‚úÖ **Reproduzibilidade**: Build id√™ntico toda vez
- ‚úÖ **Isolamento**: Containers independentes
- ‚úÖ **Escalabilidade**: F√°cil replicar containers

**Regra de ouro:** Use **multi-stage builds**, **Alpine images**, e **usu√°rio n√£o-root** para produ√ß√£o.
