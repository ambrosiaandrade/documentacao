# 06.6 Key Vault - Implementa√ß√£o Detalhada [AVAN√áADO] üîê

## üéØ Objetivo

Implementar **Key Vault** (Azure, AWS, GCP) para gerenciar **secrets**, **keys** e **certificados** de forma segura, com **rota√ß√£o autom√°tica**, **auditoria** e **integra√ß√£o com aplica√ß√µes Spring Boot**.

---

## üìö O Que √â Key Vault?

**Key Vault** √© um servi√ßo gerenciado de cloud para armazenar e acessar **secrets** (senhas, API keys), **keys criptogr√°ficas** (RSA, AES) e **certificados SSL/TLS**.

### Tipos de Dados

| Tipo             | Descri√ß√£o             | Exemplo                  |
| ---------------- | --------------------- | ------------------------ |
| **Secrets**      | Strings sens√≠veis     | Senhas, API keys, tokens |
| **Keys**         | Chaves criptogr√°ficas | RSA, AES para encryption |
| **Certificates** | Certificados SSL/TLS  | HTTPS, mTLS              |

---

## üî∑ Azure Key Vault (Implementa√ß√£o Completa)

### 1. Cria√ß√£o via Terraform

```hcl
# main.tf

# Resource Group
resource "azurerm_resource_group" "main" {
  name     = "pedidos-rg"
  location = "East US"
}

# Key Vault
resource "azurerm_key_vault" "main" {
  name                        = "pedidos-keyvault-${random_string.suffix.result}"
  location                    = azurerm_resource_group.main.location
  resource_group_name         = azurerm_resource_group.main.name
  tenant_id                   = data.azurerm_client_config.current.tenant_id
  sku_name                    = "standard"  # ou "premium" para HSM

  # Soft delete (recupera√ß√£o at√© 90 dias)
  soft_delete_retention_days  = 90
  purge_protection_enabled    = true  # Impede delete permanente acidental

  # Network rules
  network_acls {
    bypass         = "AzureServices"
    default_action = "Deny"  # Bloqueia tudo por padr√£o

    ip_rules = [
      "203.0.113.0/24"  # IP do escrit√≥rio
    ]

    virtual_network_subnet_ids = [
      azurerm_subnet.app.id
    ]
  }

  # Auditoria
  enabled_for_deployment          = false
  enabled_for_disk_encryption     = true
  enabled_for_template_deployment = true
}

# Managed Identity para aplica√ß√£o
resource "azurerm_user_assigned_identity" "app" {
  name                = "pedidos-api-identity"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
}

# Access Policy - App pode ler secrets
resource "azurerm_key_vault_access_policy" "app" {
  key_vault_id = azurerm_key_vault.main.id
  tenant_id    = data.azurerm_client_config.current.tenant_id
  object_id    = azurerm_user_assigned_identity.app.principal_id

  secret_permissions = [
    "Get",
    "List"
  ]

  key_permissions = [
    "Get",
    "Decrypt",
    "Encrypt"
  ]

  certificate_permissions = [
    "Get"
  ]
}

# Access Policy - Admin pode tudo
resource "azurerm_key_vault_access_policy" "admin" {
  key_vault_id = azurerm_key_vault.main.id
  tenant_id    = data.azurerm_client_config.current.tenant_id
  object_id    = data.azurerm_client_config.current.object_id

  secret_permissions = [
    "Get", "List", "Set", "Delete", "Recover", "Backup", "Restore", "Purge"
  ]

  key_permissions = [
    "Get", "List", "Create", "Delete", "Recover", "Backup", "Restore", "Purge",
    "Decrypt", "Encrypt", "Sign", "Verify", "WrapKey", "UnwrapKey"
  ]

  certificate_permissions = [
    "Get", "List", "Create", "Delete", "Recover", "Backup", "Restore", "Purge"
  ]
}

# Secrets
resource "azurerm_key_vault_secret" "db_username" {
  name         = "db-username"
  value        = "pedidos-user"
  key_vault_id = azurerm_key_vault.main.id

  depends_on = [azurerm_key_vault_access_policy.admin]
}

resource "azurerm_key_vault_secret" "db_password" {
  name         = "db-password"
  value        = random_password.db.result
  key_vault_id = azurerm_key_vault.main.id

  expiration_date = timeadd(timestamp(), "8760h")  # 1 ano

  depends_on = [azurerm_key_vault_access_policy.admin]
}

# Key criptogr√°fica
resource "azurerm_key_vault_key" "encryption" {
  name         = "data-encryption-key"
  key_vault_id = azurerm_key_vault.main.id
  key_type     = "RSA"
  key_size     = 2048

  key_opts = [
    "encrypt",
    "decrypt",
    "sign",
    "verify",
    "wrapKey",
    "unwrapKey"
  ]

  depends_on = [azurerm_key_vault_access_policy.admin]
}

# Certificado SSL
resource "azurerm_key_vault_certificate" "ssl" {
  name         = "api-empresa-com"
  key_vault_id = azurerm_key_vault.main.id

  certificate_policy {
    issuer_parameters {
      name = "Self"  # ou "DigiCert", "GlobalSign"
    }

    key_properties {
      exportable = true
      key_size   = 2048
      key_type   = "RSA"
      reuse_key  = true
    }

    lifetime_action {
      action {
        action_type = "AutoRenew"
      }

      trigger {
        days_before_expiry = 30
      }
    }

    secret_properties {
      content_type = "application/x-pkcs12"
    }

    x509_certificate_properties {
      extended_key_usage = ["1.3.6.1.5.5.7.3.1"]  # Server Authentication

      key_usage = [
        "cRLSign",
        "dataEncipherment",
        "digitalSignature",
        "keyAgreement",
        "keyCertSign",
        "keyEncipherment"
      ]

      subject            = "CN=api.empresa.com"
      validity_in_months = 12

      subject_alternative_names {
        dns_names = [
          "api.empresa.com",
          "*.api.empresa.com"
        ]
      }
    }
  }

  depends_on = [azurerm_key_vault_access_policy.admin]
}

# Log Analytics para auditoria
resource "azurerm_log_analytics_workspace" "main" {
  name                = "pedidos-logs"
  location            = azurerm_resource_group.main.location
  resource_group_name = azurerm_resource_group.main.name
  sku                 = "PerGB2018"
  retention_in_days   = 90
}

# Diagnostic Settings - Auditoria
resource "azurerm_monitor_diagnostic_setting" "keyvault" {
  name                       = "keyvault-audit"
  target_resource_id         = azurerm_key_vault.main.id
  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id

  log {
    category = "AuditEvent"
    enabled  = true

    retention_policy {
      enabled = true
      days    = 90
    }
  }

  metric {
    category = "AllMetrics"
    enabled  = true

    retention_policy {
      enabled = true
      days    = 90
    }
  }
}
```

### 2. Spring Boot + Azure Key Vault

```xml
<!-- pom.xml -->
<dependency>
    <groupId>com.azure.spring</groupId>
    <artifactId>spring-cloud-azure-starter-keyvault-secrets</artifactId>
    <version>5.7.0</version>
</dependency>

<dependency>
    <groupId>com.azure</groupId>
    <artifactId>azure-security-keyvault-keys</artifactId>
</dependency>

<dependency>
    <groupId>com.azure</groupId>
    <artifactId>azure-security-keyvault-certificates</artifactId>
</dependency>
```

```yaml
# application.yml
spring:
  cloud:
    azure:
      keyvault:
        secret:
          endpoint: https://pedidos-keyvault.vault.azure.net/
          credential:
            managed-identity-enabled: true
            client-id: ${AZURE_CLIENT_ID} # Managed Identity

# Habilitar refresh din√¢mico
management:
  endpoint:
    refresh:
      enabled: true
```

```java
// Configura√ß√£oConfig.java - Acesso a Secrets

@Configuration
public class DatabaseConfig {

    // ‚úÖ Busca automaticamente do Key Vault
    @Value("${db-username}")
    private String username;

    @Value("${db-password}")
    private String password;

    @Value("${db-host}")
    private String host;

    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://" + host + ":5432/pedidos");
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(10);
        config.setMinimumIdle(2);
        return new HikariDataSource(config);
    }
}

// API Keys
@Service
public class PaymentService {

    @Value("${payment-api-key}")
    private String apiKey;

    public PaymentResponse processar(PaymentRequest request) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("X-API-Key", apiKey);  // Key do Key Vault

        HttpEntity<PaymentRequest> entity = new HttpEntity<>(request, headers);

        return restTemplate.exchange(
            "https://gateway.payment.com/v1/charge",
            HttpMethod.POST,
            entity,
            PaymentResponse.class
        ).getBody();
    }
}
```

### 3. Encryption com Keys do Key Vault

```java
// EncryptionService.java

@Service
@RequiredArgsConstructor
public class EncryptionService {

    private final CryptographyClient cryptoClient;

    @PostConstruct
    public void init() {
        // Cliente para chave do Key Vault
        String keyVaultUrl = "https://pedidos-keyvault.vault.azure.net/";
        String keyName = "data-encryption-key";

        KeyClient keyClient = new KeyClientBuilder()
                .vaultUrl(keyVaultUrl)
                .credential(new DefaultAzureCredentialBuilder().build())
                .buildClient();

        KeyVaultKey key = keyClient.getKey(keyName);

        this.cryptoClient = new CryptographyClientBuilder()
                .credential(new DefaultAzureCredentialBuilder().build())
                .keyIdentifier(key.getId())
                .buildClient();
    }

    public String encrypt(String plainText) {
        byte[] plainBytes = plainText.getBytes(StandardCharsets.UTF_8);

        EncryptResult result = cryptoClient.encrypt(
            EncryptionAlgorithm.RSA_OAEP,
            plainBytes
        );

        return Base64.getEncoder().encodeToString(result.getCipherText());
    }

    public String decrypt(String encryptedText) {
        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedText);

        DecryptResult result = cryptoClient.decrypt(
            EncryptionAlgorithm.RSA_OAEP,
            encryptedBytes
        );

        return new String(result.getPlainText(), StandardCharsets.UTF_8);
    }
}

// Uso
@Service
public class ClienteService {

    private final EncryptionService encryptionService;

    public void salvarCliente(ClienteDTO dto) {
        Cliente cliente = new Cliente();
        cliente.setNome(dto.getNome());

        // ‚úÖ Encrypt CPF com chave do Key Vault
        String cpfEncrypted = encryptionService.encrypt(dto.getCpf());
        cliente.setCpf(cpfEncrypted);

        repository.save(cliente);
    }

    public ClienteDTO buscar(Long id) {
        Cliente cliente = repository.findById(id).orElseThrow();

        // ‚úÖ Decrypt CPF
        String cpfDecrypted = encryptionService.decrypt(cliente.getCpf());

        return ClienteDTO.builder()
                .id(cliente.getId())
                .nome(cliente.getNome())
                .cpf(cpfDecrypted)
                .build();
    }
}
```

### 4. Certificados SSL do Key Vault

```java
// SSLConfig.java

@Configuration
public class SSLConfig {

    @Bean
    public RestTemplate restTemplateWithMTLS() throws Exception {
        String keyVaultUrl = "https://pedidos-keyvault.vault.azure.net/";
        String certName = "client-certificate";

        CertificateClient certClient = new CertificateClientBuilder()
                .vaultUrl(keyVaultUrl)
                .credential(new DefaultAzureCredentialBuilder().build())
                .buildClient();

        KeyVaultCertificateWithPolicy certificate =
            certClient.getCertificate(certName);

        // Carrega certificado do Key Vault
        byte[] certBytes = certificate.getCer();

        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        X509Certificate x509Cert = (X509Certificate) cf.generateCertificate(
            new ByteArrayInputStream(certBytes)
        );

        // KeyStore
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(null, null);
        keyStore.setCertificateEntry("client-cert", x509Cert);

        // SSLContext
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm()
        );
        tmf.init(keyStore);

        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, tmf.getTrustManagers(), new SecureRandom());

        // RestTemplate com SSL
        HttpClient httpClient = HttpClients.custom()
                .setSSLContext(sslContext)
                .build();

        HttpComponentsClientHttpRequestFactory factory =
            new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(factory);
    }
}
```

### 5. Rota√ß√£o Autom√°tica de Secrets

```java
// SecretRotationScheduler.java

@Component
@EnableScheduling
@RequiredArgsConstructor
public class SecretRotationScheduler {

    private final SecretClient secretClient;
    private final DataSource dataSource;

    // Roda todo dia √† 1h da manh√£
    @Scheduled(cron = "0 0 1 * * *")
    public void rotateDbPassword() {
        log.info("Iniciando rota√ß√£o de senha do banco");

        try {
            // 1. Gera nova senha
            String newPassword = generateSecurePassword();

            // 2. Atualiza no banco
            try (Connection conn = dataSource.getConnection();
                 Statement stmt = conn.createStatement()) {

                stmt.execute(
                    "ALTER USER pedidos_user WITH PASSWORD '" + newPassword + "'"
                );

                log.info("Senha atualizada no banco");
            }

            // 3. Atualiza no Key Vault
            secretClient.setSecret(
                new KeyVaultSecret("db-password", newPassword)
                    .setProperties(new SecretProperties()
                        .setExpiresOn(OffsetDateTime.now().plusMonths(1)))
            );

            log.info("Senha atualizada no Key Vault");

            // 4. Notifica (opcional)
            sendNotification("Senha do banco rotacionada com sucesso");

        } catch (Exception e) {
            log.error("Erro ao rotacionar senha", e);
            sendAlert("Falha na rota√ß√£o de senha: " + e.getMessage());
        }
    }

    private String generateSecurePassword() {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%";
        SecureRandom random = new SecureRandom();

        return IntStream.range(0, 32)
                .map(i -> chars.charAt(random.nextInt(chars.length())))
                .collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
                .toString();
    }
}
```

---

## üü† AWS Secrets Manager (Implementa√ß√£o Completa)

### 1. Terraform

```hcl
# AWS Secrets Manager
resource "aws_secretsmanager_secret" "db_credentials" {
  name        = "prod/db/credentials"
  description = "Database credentials"

  rotation_rules {
    automatically_after_days = 30
  }
}

resource "aws_secretsmanager_secret_version" "db_credentials" {
  secret_id = aws_secretsmanager_secret.db_credentials.id
  secret_string = jsonencode({
    username = "pedidos_user"
    password = random_password.db.result
    host     = aws_db_instance.postgres.endpoint
    port     = 5432
    dbname   = "pedidos"
  })
}

# Lambda para rota√ß√£o
resource "aws_lambda_function" "rotate_secret" {
  filename      = "rotate_secret.zip"
  function_name = "rotate-db-credentials"
  role          = aws_iam_role.lambda_rotation.arn
  handler       = "index.handler"
  runtime       = "python3.11"
  timeout       = 30

  environment {
    variables = {
      SECRET_ARN = aws_secretsmanager_secret.db_credentials.arn
    }
  }
}

# Permission para Lambda rotacionar
resource "aws_secretsmanager_secret_rotation" "db" {
  secret_id           = aws_secretsmanager_secret.db_credentials.id
  rotation_lambda_arn = aws_lambda_function.rotate_secret.arn

  rotation_rules {
    automatically_after_days = 30
  }
}
```

### 2. Spring Boot + AWS Secrets Manager

```xml
<dependency>
    <groupId>com.amazonaws.secretsmanager</groupId>
    <artifactId>aws-secretsmanager-jdbc</artifactId>
    <version>1.0.8</version>
</dependency>
```

```java
// DatabaseConfig.java

@Configuration
public class DatabaseConfig {

    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();

        // ‚úÖ Driver especial que busca do Secrets Manager
        config.setDriverClassName(
            "com.amazonaws.secretsmanager.sql.AWSSecretsManagerPostgreSQLDriver"
        );

        config.setJdbcUrl(
            "jdbc-secretsmanager:postgresql://db.empresa.com:5432/pedidos"
        );

        // Nome do secret no Secrets Manager
        config.setUsername("prod/db/credentials");

        return new HikariDataSource(config);
    }
}

// Ou manualmente via SDK
@Configuration
public class DatabaseConfigManual {

    @Bean
    public DataSource dataSource() {
        SecretsManagerClient client = SecretsManagerClient.builder()
                .region(Region.US_EAST_1)
                .build();

        GetSecretValueRequest request = GetSecretValueRequest.builder()
                .secretId("prod/db/credentials")
                .build();

        GetSecretValueResponse response = client.getSecretValue(request);

        JsonNode secret = new ObjectMapper()
                .readTree(response.secretString());

        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(
            String.format("jdbc:postgresql://%s:%d/%s",
                secret.get("host").asText(),
                secret.get("port").asInt(),
                secret.get("dbname").asText()
            )
        );
        config.setUsername(secret.get("username").asText());
        config.setPassword(secret.get("password").asText());

        return new HikariDataSource(config);
    }
}
```

---

## üü° Google Cloud Secret Manager

### 1. Terraform

```hcl
resource "google_secret_manager_secret" "db_password" {
  secret_id = "db-password"

  replication {
    auto {}
  }
}

resource "google_secret_manager_secret_version" "db_password" {
  secret      = google_secret_manager_secret.db_password.id
  secret_data = random_password.db.result
}

# IAM
resource "google_secret_manager_secret_iam_member" "app" {
  secret_id = google_secret_manager_secret.db_password.id
  role      = "roles/secretmanager.secretAccessor"
  member    = "serviceAccount:${google_service_account.app.email}"
}
```

### 2. Spring Boot + GCP Secret Manager

```xml
<dependency>
    <groupId>com.google.cloud</groupId>
    <artifactId>spring-cloud-gcp-starter-secretmanager</artifactId>
</dependency>
```

```yaml
spring:
  cloud:
    gcp:
      secretmanager:
        enabled: true
```

```java
@Configuration
public class DatabaseConfig {

    @Value("${sm://db-username}")  // ‚úÖ sm:// busca do Secret Manager
    private String username;

    @Value("${sm://db-password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:postgresql://db:5432/pedidos");
        config.setUsername(username);
        config.setPassword(password);
        return new HikariDataSource(config);
    }
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```hcl
# ‚úÖ Soft delete habilitado
soft_delete_retention_days = 90

# ‚úÖ Purge protection
purge_protection_enabled = true

# ‚úÖ Network ACL (bloqueia acesso p√∫blico)
network_acls {
  default_action = "Deny"
}

# ‚úÖ Managed Identity (n√£o usar service principal)
credential:
  managed-identity-enabled: true

# ‚úÖ Auditoria
enabled_for_diagnostic_settings = true

# ‚úÖ Rota√ß√£o autom√°tica
rotation_rules {
  automatically_after_days = 30
}

# ‚úÖ Least privilege
secret_permissions = ["Get", "List"]  # N√£o "Set", "Delete"
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Senha hardcoded
String password = "senha123";

// ‚ùå Buscar secret a cada request (lento)
@GetMapping("/pedidos")
public List<Pedido> listar() {
    String apiKey = keyVaultClient.getSecret("api-key");  // ‚ùå A cada request
    // ...
}

// ‚úÖ Cache de secrets
@Service
public class SecretCache {

    @Cacheable(value = "secrets", key = "#secretName")
    public String getSecret(String secretName) {
        return keyVaultClient.getSecret(secretName).getValue();
    }
}

// ‚ùå Sem tratamento de erro
String secret = keyVault.getSecret("name");  // ‚ùå E se falhar?

// ‚úÖ Com fallback
@Retryable(maxAttempts = 3)
public String getSecret(String name) {
    return keyVault.getSecret(name);
}
```

---

## üìù Resumo

**Key Vault** garante:

- ‚úÖ **Seguran√ßa**: Secrets criptografados, n√£o no c√≥digo
- ‚úÖ **Rota√ß√£o**: Autom√°tica (30 dias)
- ‚úÖ **Auditoria**: Log de acessos
- ‚úÖ **Encryption**: Keys para criptografar dados
- ‚úÖ **Certificados**: SSL/TLS gerenciados

**Regra de ouro:** Use **Managed Identity** para autentica√ß√£o, habilite **soft delete** e configure **rota√ß√£o autom√°tica** de secrets.
