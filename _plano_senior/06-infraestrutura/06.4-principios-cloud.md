# 06.4 PrincÃ­pios de Cloud Computing [AVANÃ‡ADO] â˜ï¸

## ğŸ¯ Objetivo

Aplicar **princÃ­pios fundamentais de Cloud** (AWS, Azure, Google Cloud) para arquitetar soluÃ§Ãµes **escalÃ¡veis**, **resilientes** e **econÃ´micas**, considerando **impacto no negÃ³cio**.

---

## ğŸ“š O Que SÃ£o PrincÃ­pios de Cloud?

**PrincÃ­pios de Cloud** sÃ£o prÃ¡ticas arquiteturais que garantem aplicaÃ§Ãµes nativas da nuvem aproveitem **elasticidade**, **alta disponibilidade** e **custo otimizado**.

### Analogia

Como **princÃ­pios de construÃ§Ã£o civil**:

- **Sem princÃ­pios**: Casa sem fundaÃ§Ã£o, desaba com terremoto
- **Com princÃ­pios**: Estrutura resiliente, suporta terremotos
- **Vantagem**: Sistema resiliente, escala automaticamente, custo controlado

---

## ğŸ›ï¸ Os 6 Pilares do Well-Architected Framework

Estes pilares sÃ£o comuns Ã s **3 principais clouds** (AWS, Azure, Google Cloud).

### 1ï¸âƒ£ ExcelÃªncia Operacional

**Objetivo:** Rodar e monitorar sistemas, melhorar continuamente.

#### PrincÃ­pios:

- âœ… **Infrastructure as Code (IaC)**: Terraform, CloudFormation, ARM Templates
- âœ… **AutomaÃ§Ã£o**: CI/CD, deploy automatizado
- âœ… **Monitoramento**: Observabilidade completa (logs, mÃ©tricas, traces)
- âœ… **DocumentaÃ§Ã£o**: Runbooks, playbooks de incidentes
- âœ… **Melhorias contÃ­nuas**: Retrospectivas, post-mortems

#### Exemplo PrÃ¡tico:

```yaml
# Terraform - IaC para criar infraestrutura
resource "aws_instance" "app" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.medium"

  tags = {
    Name        = "pedidos-api"
    Environment = "prod"
  }
}

# CloudWatch Alarm - Monitoramento
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "pedidos-api-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  threshold           = "80"
  alarm_actions       = [aws_sns_topic.alerts.arn]
}
```

#### Impacto no NegÃ³cio:

- ğŸ’° **Custo**: Reduz downtime (perdas de vendas)
- â±ï¸ **Time-to-Market**: Deploy rÃ¡pido, mais features
- ğŸ›¡ï¸ **Confiabilidade**: Incidentes resolvidos rapidamente

---

### 2ï¸âƒ£ SeguranÃ§a

**Objetivo:** Proteger dados, sistemas e ativos.

#### PrincÃ­pios:

- âœ… **Identity & Access Management (IAM)**: Menor privilÃ©gio
- âœ… **Encryption**: Dados em repouso e em trÃ¢nsito
- âœ… **Network Security**: VPC, Security Groups, Firewall
- âœ… **Secrets Management**: Key Vault, AWS Secrets Manager
- âœ… **Auditoria**: CloudTrail, Azure Monitor, Cloud Audit Logs
- âœ… **Compliance**: LGPD, GDPR, PCI-DSS

#### Exemplo PrÃ¡tico:

```yaml
# AWS IAM Policy - Menor privilÃ©gio
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::pedidos-bucket/*"
    }
  ]
}

# Encryption em RDS
resource "aws_db_instance" "postgres" {
  engine               = "postgres"
  storage_encrypted    = true  # Encryption at rest
  kms_key_id           = aws_kms_key.db.arn
}
```

#### Exemplo Java - Secrets Manager:

```java
// AWS Secrets Manager
@Configuration
public class SecretsConfig {

    @Bean
    public AWSSecretsManager secretsManager() {
        return AWSSecretsManagerClientBuilder.standard()
                .withRegion("us-east-1")
                .build();
    }

    @Bean
    public DataSource dataSource(AWSSecretsManager secretsManager) {
        String secretName = "prod/db/credentials";

        GetSecretValueRequest request = new GetSecretValueRequest()
                .withSecretId(secretName);

        GetSecretValueResult result = secretsManager.getSecretValue(request);

        JsonNode secret = new ObjectMapper().readTree(result.getSecretString());

        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(secret.get("url").asText());
        config.setUsername(secret.get("username").asText());
        config.setPassword(secret.get("password").asText());

        return new HikariDataSource(config);
    }
}
```

#### Impacto no NegÃ³cio:

- ğŸ’° **Custo**: Evita multas LGPD/GDPR (atÃ© 2% faturamento)
- ğŸ›¡ï¸ **ReputaÃ§Ã£o**: Vazamento de dados destrÃ³i confianÃ§a
- âš–ï¸ **Compliance**: Atende regulamentaÃ§Ãµes do setor

---

### 3ï¸âƒ£ Confiabilidade

**Objetivo:** Sistema se recupera de falhas, atende demanda.

#### PrincÃ­pios:

- âœ… **RedundÃ¢ncia**: Multi-AZ, Multi-Region
- âœ… **Backup & Recovery**: Snapshots, RTO/RPO definidos
- âœ… **Auto-scaling**: Horizontal scaling automÃ¡tico
- âœ… **Health checks**: Liveness, readiness probes
- âœ… **Disaster Recovery**: Plano de contingÃªncia
- âœ… **Chaos Engineering**: Testa falhas propositalmente

#### Exemplo PrÃ¡tico:

```yaml
# AWS Auto Scaling Group
resource "aws_autoscaling_group" "app" {
  name                = "pedidos-api-asg"
  vpc_zone_identifier = [aws_subnet.private_a.id, aws_subnet.private_b.id]
  min_size            = 2
  max_size            = 10
  desired_capacity    = 3

  health_check_type         = "ELB"
  health_check_grace_period = 300

  target_group_arns = [aws_lb_target_group.app.arn]

  tag {
    key                 = "Name"
    value               = "pedidos-api"
    propagate_at_launch = true
  }
}

# AWS RDS - Multi-AZ
resource "aws_db_instance" "postgres" {
  engine         = "postgres"
  multi_az       = true  # RedundÃ¢ncia
  backup_retention_period = 7
}
```

#### Exemplo Java - Circuit Breaker (Resilience4j):

```java
@Service
public class PagamentoService {

    private final CircuitBreaker circuitBreaker;

    @CircuitBreaker(name = "pagamento", fallbackMethod = "fallbackPagamento")
    public PagamentoResponse processar(PagamentoRequest request) {
        // Chama API externa
        return gatewayClient.processar(request);
    }

    // Fallback quando gateway falha
    private PagamentoResponse fallbackPagamento(PagamentoRequest request, Exception ex) {
        log.warn("Gateway indisponÃ­vel, pagamento serÃ¡ processado async");

        // Envia para fila para retry posterior
        rabbitTemplate.convertAndSend("pagamentos-retry", request);

        return PagamentoResponse.builder()
                .status("PENDING")
                .message("Pagamento serÃ¡ processado em breve")
                .build();
    }
}
```

#### Impacto no NegÃ³cio:

- ğŸ’° **Custo**: Cada minuto de downtime = R$ perdidos
- ğŸ¯ **SLA**: 99.9% uptime = confianÃ§a do cliente
- ğŸ“ˆ **Escala**: Black Friday sem crash

**CÃ¡lculo financeiro:**

```
Downtime anual com 99.9% SLA: 8.76 horas/ano
Receita mÃ©dia: R$ 100.000/hora
Perda mÃ¡xima: R$ 876.000/ano

Downtime anual com 99.95% SLA: 4.38 horas/ano
Perda mÃ¡xima: R$ 438.000/ano

Economia: R$ 438.000/ano (justifica investimento em redundÃ¢ncia)
```

---

### 4ï¸âƒ£ Performance

**Objetivo:** Usar recursos computacionais eficientemente.

#### PrincÃ­pios:

- âœ… **Caching**: Redis, CloudFront CDN
- âœ… **Database optimization**: Ãndices, read replicas
- âœ… **Async processing**: Filas (SQS, RabbitMQ)
- âœ… **CDN**: CloudFront, Azure CDN, Cloud CDN
- âœ… **Right-sizing**: InstÃ¢ncias adequadas Ã  carga
- âœ… **Monitoramento**: APM (New Relic, Dynatrace)

#### Exemplo PrÃ¡tico:

```java
// Spring Cache + Redis
@Service
public class ProdutoService {

    @Cacheable(value = "produtos", key = "#id")
    public ProdutoDTO buscar(Long id) {
        log.info("Buscando produto do banco: id={}", id);
        return repository.findById(id)
                .map(mapper::toDTO)
                .orElseThrow(() -> new ResourceNotFoundException("Produto nÃ£o encontrado"));
    }

    @CacheEvict(value = "produtos", key = "#produto.id")
    public ProdutoDTO atualizar(ProdutoDTO produto) {
        // Invalida cache ao atualizar
        return save(produto);
    }
}
```

```yaml
# CloudFront CDN
resource "aws_cloudfront_distribution" "app" {
origin {
domain_name = aws_s3_bucket.static.bucket_regional_domain_name
origin_id   = "S3-static"
}

enabled             = true
default_root_object = "index.html"

default_cache_behavior {
allowed_methods        = ["GET", "HEAD"]
cached_methods         = ["GET", "HEAD"]
target_origin_id       = "S3-static"
viewer_protocol_policy = "redirect-to-https"

min_ttl     = 0
default_ttl = 3600
max_ttl     = 86400
}
}
```

#### Impacto no NegÃ³cio:

- ğŸ’° **Custo**: Menos instÃ¢ncias = menor custo AWS
- â±ï¸ **UX**: PÃ¡gina rÃ¡pida = mais conversÃµes (1s delay = 7% menos conversÃµes)
- ğŸ“ˆ **Escala**: 10x mais usuÃ¡rios sem aumentar custo

**Exemplo real:**

```
CenÃ¡rio 1 (sem cache):
- 1000 req/s ao banco
- RDS db.r5.4xlarge: $1,200/mÃªs
- LatÃªncia: 150ms

CenÃ¡rio 2 (com Redis):
- 950 req/s do cache (95% hit rate)
- 50 req/s ao banco
- RDS db.t3.large: $150/mÃªs
- ElastiCache r5.large: $100/mÃªs
- Total: $250/mÃªs (economia de $950/mÃªs)
- LatÃªncia: 5ms
```

---

### 5ï¸âƒ£ OtimizaÃ§Ã£o de Custos

**Objetivo:** Evitar gastos desnecessÃ¡rios, maximizar ROI.

#### PrincÃ­pios:

- âœ… **Right-sizing**: InstÃ¢ncias adequadas (nÃ£o over-provisioning)
- âœ… **Reserved Instances**: Desconto atÃ© 75% (workloads previsÃ­veis)
- âœ… **Spot Instances**: Desconto atÃ© 90% (workloads tolerantes a interrupÃ§Ã£o)
- âœ… **Auto-scaling**: Escala down em horÃ¡rios de baixa demanda
- âœ… **Storage lifecycle**: S3 Glacier para dados antigos
- âœ… **Monitoramento de custos**: AWS Cost Explorer, Azure Cost Management
- âœ… **Tagging**: Identificar custos por projeto/departamento

#### Exemplo PrÃ¡tico:

```yaml
# AWS Auto Scaling - Scale down Ã  noite
resource "aws_autoscaling_schedule" "scale_down" {
  scheduled_action_name  = "scale-down-night"
  min_size               = 1
  max_size               = 2
  desired_capacity       = 1
  recurrence             = "0 22 * * *"  # 22h todos os dias
  autoscaling_group_name = aws_autoscaling_group.app.name
}

resource "aws_autoscaling_schedule" "scale_up" {
  scheduled_action_name  = "scale-up-morning"
  min_size               = 3
  max_size               = 10
  desired_capacity       = 3
  recurrence             = "0 6 * * *"  # 6h todos os dias
  autoscaling_group_name = aws_autoscaling_group.app.name
}
```

```yaml
# S3 Lifecycle - Mover dados antigos para Glacier
resource "aws_s3_bucket_lifecycle_configuration" "logs" {
  bucket = aws_s3_bucket.logs.id

  rule {
    id     = "archive-old-logs"
    status = "Enabled"

    transition {
      days          = 30
      storage_class = "STANDARD_IA"  # Infrequent Access
    }

    transition {
      days          = 90
      storage_class = "GLACIER"  # Arquivo frio
    }

    expiration {
      days = 365  # Delete apÃ³s 1 ano
    }
  }
}
```

#### Impacto no NegÃ³cio:

- ğŸ’° **Custo**: ReduÃ§Ã£o direta de 30-50% na fatura cloud
- ğŸ“Š **Visibilidade**: Custos por projeto/cliente
- ğŸ¯ **Previsibilidade**: Budget alerts evitam surpresas

**Exemplo real:**

```
Empresa X - E-commerce:

Antes:
- ProduÃ§Ã£o: 20 instÃ¢ncias c5.2xlarge 24/7
- Custo: $6,000/mÃªs

Depois:
- 10 Reserved Instances (workload base): $2,000/mÃªs (-66%)
- 5-10 Spot Instances (picos): $300/mÃªs
- Auto-scaling: 5 instÃ¢ncias Ã  noite, 15 no horÃ¡rio comercial
- Total: $2,300/mÃªs

Economia: $3,700/mÃªs = $44,400/ano
```

---

### 6ï¸âƒ£ Sustentabilidade

**Objetivo:** Minimizar impacto ambiental da cloud.

#### PrincÃ­pios:

- âœ… **RegiÃµes eficientes**: Escolher datacenters com energia renovÃ¡vel
- âœ… **Right-sizing**: Menos recursos = menor consumo
- âœ… **Serverless**: Paga apenas pelo uso (sem idle)
- âœ… **Spot instances**: Aproveita capacidade ociosa
- âœ… **Data lifecycle**: Delete dados desnecessÃ¡rios

#### Exemplo PrÃ¡tico:

```yaml
# AWS Lambda - Serverless (zero idle)
resource "aws_lambda_function" "processor" {
  function_name = "pedido-processor"
  runtime       = "java17"
  handler       = "com.empresa.Handler::handleRequest"

  # Executa apenas quando necessÃ¡rio
  # Sem custo quando idle
}
```

#### Impacto no NegÃ³cio:

- ğŸŒ **ESG**: Sustentabilidade atrai investidores
- ğŸ’° **Custo**: EficiÃªncia energÃ©tica = menor custo
- ğŸ† **Marketing**: "Cloud verde" diferencial competitivo

---

## â˜ï¸ ComparaÃ§Ã£o entre Clouds

### AWS vs Azure vs Google Cloud

| ServiÃ§o        | AWS             | Azure            | Google Cloud    |
| -------------- | --------------- | ---------------- | --------------- |
| **Compute**    | EC2             | Virtual Machines | Compute Engine  |
| **Serverless** | Lambda          | Functions        | Cloud Functions |
| **Container**  | ECS/EKS         | AKS              | GKE             |
| **Database**   | RDS             | SQL Database     | Cloud SQL       |
| **NoSQL**      | DynamoDB        | Cosmos DB        | Firestore       |
| **Storage**    | S3              | Blob Storage     | Cloud Storage   |
| **Queue**      | SQS             | Service Bus      | Pub/Sub         |
| **Cache**      | ElastiCache     | Redis Cache      | Memorystore     |
| **Secrets**    | Secrets Manager | Key Vault        | Secret Manager  |
| **IAM**        | IAM             | Active Directory | IAM             |
| **Monitoring** | CloudWatch      | Monitor          | Operations      |
| **CDN**        | CloudFront      | CDN              | Cloud CDN       |

### Multi-Cloud Strategy

```java
// AbstraÃ§Ã£o para multi-cloud
public interface CloudStorageService {
    void upload(String bucket, String key, byte[] data);
    byte[] download(String bucket, String key);
}

@Profile("aws")
@Service
public class S3StorageService implements CloudStorageService {
    private final S3Client s3Client;

    public void upload(String bucket, String key, byte[] data) {
        s3Client.putObject(PutObjectRequest.builder()
                .bucket(bucket)
                .key(key)
                .build(),
                RequestBody.fromBytes(data));
    }
}

@Profile("azure")
@Service
public class AzureBlobStorageService implements CloudStorageService {
    private final BlobServiceClient blobClient;

    public void upload(String container, String blob, byte[] data) {
        BlobClient client = blobClient
                .getBlobContainerClient(container)
                .getBlobClient(blob);
        client.upload(BinaryData.fromBytes(data), true);
    }
}
```

---

## ğŸ—ï¸ PadrÃµes Arquiteturais Cloud-Native

### 1. Microservices

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Pedidos   â”‚â”€â”€â”€>â”‚  Pagamento  â”‚â”€â”€â”€>â”‚   Estoque   â”‚
â”‚   Service   â”‚    â”‚   Service   â”‚    â”‚   Service   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚                   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ API Gatewayâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Event-Driven

```java
// Pub/Sub pattern
@Service
public class PedidoService {

    private final EventPublisher eventPublisher;

    public PedidoDTO criar(PedidoRequest request) {
        Pedido pedido = repository.save(new Pedido(request));

        // Publica evento
        eventPublisher.publish(new PedidoCriadoEvent(pedido.getId()));

        return mapper.toDTO(pedido);
    }
}

@Component
public class PagamentoListener {

    @EventListener
    public void onPedidoCriado(PedidoCriadoEvent event) {
        // Processa pagamento assincronamente
        pagamentoService.processar(event.getPedidoId());
    }
}
```

### 3. CQRS (Command Query Responsibility Segregation)

```java
// Write Model
@Service
public class PedidoCommandService {
    private final PedidoRepository repository;

    public void criar(PedidoCommand command) {
        repository.save(new Pedido(command));
    }
}

// Read Model (otimizado para consultas)
@Service
public class PedidoQueryService {
    private final PedidoReadRepository readRepository;

    public List<PedidoDTO> listar(FiltroDTO filtro) {
        // Consulta banco otimizado para leitura (pode ser cache/read replica)
        return readRepository.findAll(filtro);
    }
}
```

---

## ğŸ“‹ Boas PrÃ¡ticas

### âœ… RecomendaÃ§Ãµes

```yaml
# âœ… Multi-AZ para alta disponibilidade
multi_az = true

# âœ… Backup automatizado
backup_retention_period = 7

# âœ… Encryption em repouso
storage_encrypted = true

# âœ… Secrets no Key Vault (nÃ£o no cÃ³digo)
secret = data.aws_secretsmanager_secret_version.db_password.secret_string

# âœ… Auto-scaling habilitado
min_size = 2
max_size = 10

# âœ… Monitoring e alertas
alarm_actions = [aws_sns_topic.alerts.arn]

# âœ… Tagging para custo
tags = {
  Project     = "pedidos"
  Environment = "prod"
  CostCenter  = "vendas"
}

# âœ… Lifecycle policies
transition {
  days          = 30
  storage_class = "GLACIER"
}
```

### âŒ Anti-Patterns

```yaml
# âŒ Single AZ (sem redundÃ¢ncia)
# (falha de datacenter = downtime completo)

# âŒ Sem backup
# (perda de dados irreversÃ­vel)

# âŒ Credentials no cÃ³digo
password = "senha123"  # âŒ

# âŒ Over-provisioning
instance_type = "c5.24xlarge"  # Uso: 5% CPU

# âŒ Sem monitoring
# (problema descoberto apenas quando cliente reclama)

# âŒ Sem tagging
# (impossÃ­vel rastrear custos por projeto)
```

---

## ğŸ¯ Quando Usar Cloud?

| CenÃ¡rio                       | Cloud PÃºblica | On-Premise |
| ----------------------------- | ------------- | ---------- |
| Startup (MVP rÃ¡pido)          | âœ… Sim        | âŒ NÃ£o     |
| Escala imprevisÃ­vel           | âœ… Sim        | âŒ NÃ£o     |
| Dados extremamente sensÃ­veis  | âš ï¸ Depende    | âœ… Sim     |
| Workload constante previsÃ­vel | âš ï¸ HÃ­brido    | âœ… Sim     |
| Budget limitado (longo prazo) | âš ï¸ Depende    | âœ… Sim     |

---

## ğŸ”— Recursos

### AWS

- [AWS Well-Architected Framework](https://aws.amazon.com/architecture/well-architected/)
- [AWS Solutions Library](https://aws.amazon.com/solutions/)

### Azure

- [Azure Architecture Center](https://learn.microsoft.com/en-us/azure/architecture/)
- [Azure Well-Architected Framework](https://learn.microsoft.com/en-us/azure/well-architected/)

### Google Cloud

- [Google Cloud Architecture Framework](https://cloud.google.com/architecture/framework)
- [Cloud Architecture Patterns](https://cloud.google.com/architecture)

---

## ğŸ“ Resumo

**PrincÃ­pios Cloud** garantem:

- âœ… **ExcelÃªncia Operacional**: IaC, automaÃ§Ã£o, monitoramento
- âœ… **SeguranÃ§a**: IAM, encryption, Key Vault
- âœ… **Confiabilidade**: Multi-AZ, backup, auto-scaling
- âœ… **Performance**: Cache, CDN, right-sizing
- âœ… **Custo**: Reserved Instances, auto-scaling, lifecycle
- âœ… **Sustentabilidade**: Serverless, regiÃµes eficientes

**Regra de ouro:** Arquitetura cloud nÃ£o Ã© apenas "lift-and-shift" - Ã© repensar a aplicaÃ§Ã£o para aproveitar **elasticidade**, **resiliÃªncia** e **custo otimizado**.
