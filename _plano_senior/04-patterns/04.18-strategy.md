# 04.18 Strategy Pattern [M√âDIO] üéØ

## üéØ Objetivo

Definir uma **fam√≠lia de algoritmos intercambi√°veis** encapsulados em classes separadas, permitindo trocar comportamento em runtime e facilitar **testes isolados de cada estrat√©gia**.

---

## üìö O Que √â?

**Strategy** √© um padr√£o comportamental GoF que permite selecionar algoritmos em runtime. Cada algoritmo fica em sua pr√≥pria classe, facilitando extens√£o (adicionar novas estrat√©gias) e teste (mockar estrat√©gias espec√≠ficas).

### Analogia

Como **escolher meio de transporte**:

- **Contexto**: Preciso ir ao trabalho
- **Estrat√©gias**: Carro, √înibus, Bicicleta, A p√©
- **Decis√£o runtime**: Baseado em dist√¢ncia, clima, hor√°rio
- **Vantagem**: Mudar estrat√©gia sem alterar "ir ao trabalho"

---

## ‚ùå Problema que Resolve

### Antes (If/Else ou Switch Gigante)

```java
// ‚ùå PROBLEMA: L√≥gica de c√°lculo espalhada em condicionais
public class CalculadoraFrete {
    public BigDecimal calcular(Pedido pedido, String tipo) {
        BigDecimal peso = pedido.getPesoTotal();
        BigDecimal distancia = pedido.getDistancia();

        if (tipo.equals("EXPRESSO")) {
            // L√≥gica complexa do expresso
            BigDecimal base = new BigDecimal("50.00");
            BigDecimal porKg = peso.multiply(new BigDecimal("5.00"));
            BigDecimal porKm = distancia.multiply(new BigDecimal("2.00"));
            return base.add(porKg).add(porKm);

        } else if (tipo.equals("NORMAL")) {
            // L√≥gica do normal
            BigDecimal base = new BigDecimal("20.00");
            BigDecimal porKg = peso.multiply(new BigDecimal("2.00"));
            return base.add(porKg);

        } else if (tipo.equals("ECONOMICO")) {
            // L√≥gica do econ√¥mico
            if (peso.compareTo(new BigDecimal("10")) > 0) {
                return new BigDecimal("15.00");
            }
            return new BigDecimal("10.00");

        } else {
            throw new IllegalArgumentException("Tipo inv√°lido: " + tipo);
        }
    }
}

// Problemas:
// - M√©todo gigante com m√∫ltiplas responsabilidades
// - Adicionar novo tipo = modificar CalculadoraFrete
// - Imposs√≠vel testar estrat√©gias isoladamente
// - Dif√≠cil mockar comportamento espec√≠fico
```

**Problemas**:

- üîß Viola√ß√£o do Open/Closed (modificar para adicionar)
- üß™ Imposs√≠vel testar estrat√©gias isoladamente
- üêõ Um bug afeta toda a classe
- üìè M√©todo gigante dif√≠cil de manter

### Depois (Strategy Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Cada estrat√©gia em sua pr√≥pria classe
interface FreteStrategy {
    BigDecimal calcular(Pedido pedido);
    String getTipo();
}

class CalculadoraFrete {
    private final FreteStrategy strategy;

    CalculadoraFrete(FreteStrategy strategy) {
        this.strategy = strategy;
    }

    BigDecimal calcular(Pedido pedido) {
        return strategy.calcular(pedido);
    }
}

// Testes isolados
@Test
void testaExpresso() {
    FreteStrategy expresso = new FreteExpresso();
    CalculadoraFrete calculadora = new CalculadoraFrete(expresso);

    BigDecimal frete = calculadora.calcular(pedido);

    assertEquals(new BigDecimal("100.00"), frete);
}

// Mock de estrat√©gia
@Test
void testaMock() {
    FreteStrategy mock = mock(FreteStrategy.class);
    when(mock.calcular(any())).thenReturn(BigDecimal.TEN);

    CalculadoraFrete calculadora = new CalculadoraFrete(mock);
    assertEquals(BigDecimal.TEN, calculadora.calcular(pedido));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface de Estrat√©gia

```java
@FunctionalInterface
interface FreteStrategy {
    BigDecimal calcular(Pedido pedido);

    default String getTipo() {
        return this.getClass().getSimpleName();
    }
}

record Pedido(
    String id,
    BigDecimal pesoKg,
    BigDecimal distanciaKm,
    String destino
) {}
```

### 2. Estrat√©gias Concretas

```java
final class FreteExpresso implements FreteStrategy {
    private static final BigDecimal TAXA_BASE = new BigDecimal("50.00");
    private static final BigDecimal CUSTO_POR_KG = new BigDecimal("5.00");
    private static final BigDecimal CUSTO_POR_KM = new BigDecimal("2.00");

    @Override
    public BigDecimal calcular(Pedido pedido) {
        BigDecimal custoPeso = pedido.pesoKg().multiply(CUSTO_POR_KG);
        BigDecimal custoDistancia = pedido.distanciaKm().multiply(CUSTO_POR_KM);

        BigDecimal total = TAXA_BASE.add(custoPeso).add(custoDistancia);

        System.out.println("üöÄ Frete Expresso: " + total);
        return total;
    }

    @Override
    public String getTipo() {
        return "EXPRESSO";
    }
}

final class FreteNormal implements FreteStrategy {
    private static final BigDecimal TAXA_BASE = new BigDecimal("20.00");
    private static final BigDecimal CUSTO_POR_KG = new BigDecimal("2.00");

    @Override
    public BigDecimal calcular(Pedido pedido) {
        BigDecimal custoPeso = pedido.pesoKg().multiply(CUSTO_POR_KG);
        BigDecimal total = TAXA_BASE.add(custoPeso);

        System.out.println("üì¶ Frete Normal: " + total);
        return total;
    }

    @Override
    public String getTipo() {
        return "NORMAL";
    }
}

final class FreteEconomico implements FreteStrategy {
    private static final BigDecimal TAXA_LEVE = new BigDecimal("10.00");
    private static final BigDecimal TAXA_PESADO = new BigDecimal("15.00");
    private static final BigDecimal LIMITE_PESO = new BigDecimal("10.00");

    @Override
    public BigDecimal calcular(Pedido pedido) {
        BigDecimal total = pedido.pesoKg().compareTo(LIMITE_PESO) > 0
            ? TAXA_PESADO
            : TAXA_LEVE;

        System.out.println("üí∞ Frete Econ√¥mico: " + total);
        return total;
    }

    @Override
    public String getTipo() {
        return "ECONOMICO";
    }
}
```

### 3. Contexto que Usa Estrat√©gia

```java
final class CalculadoraFrete {
    private final FreteStrategy strategy;

    // M√©tricas
    private final AtomicInteger calculosRealizados = new AtomicInteger(0);
    private final AtomicReference<BigDecimal> totalCalculado = new AtomicReference<>(BigDecimal.ZERO);

    CalculadoraFrete(FreteStrategy strategy) {
        this.strategy = strategy;
    }

    BigDecimal calcular(Pedido pedido) {
        calculosRealizados.incrementAndGet();

        BigDecimal valor = strategy.calcular(pedido);

        totalCalculado.updateAndGet(current -> current.add(valor));

        return valor;
    }

    String getTipoFrete() {
        return strategy.getTipo();
    }

    FreteMetrics getMetrics() {
        return new FreteMetrics(
            calculosRealizados.get(),
            totalCalculado.get(),
            strategy.getTipo()
        );
    }
}

record FreteMetrics(int calculos, BigDecimal totalCalculado, String estrategia) {}
```

### 4. Factory para Estrat√©gias

```java
final class FreteStrategyFactory {
    private final Map<String, FreteStrategy> strategies = new ConcurrentHashMap<>();

    FreteStrategyFactory() {
        // Registra estrat√©gias padr√£o
        registrar("EXPRESSO", new FreteExpresso());
        registrar("NORMAL", new FreteNormal());
        registrar("ECONOMICO", new FreteEconomico());
    }

    void registrar(String tipo, FreteStrategy strategy) {
        strategies.put(tipo.toUpperCase(), strategy);
        System.out.println("‚úÖ Estrat√©gia registrada: " + tipo);
    }

    FreteStrategy obter(String tipo) {
        FreteStrategy strategy = strategies.get(tipo.toUpperCase());

        if (strategy == null) {
            throw new IllegalArgumentException("Estrat√©gia n√£o encontrada: " + tipo);
        }

        return strategy;
    }

    Set<String> tiposDisponiveis() {
        return Collections.unmodifiableSet(strategies.keySet());
    }
}
```

### 5. Strategy Selector (Escolha Din√¢mica)

```java
final class FreteStrategySelector {

    FreteStrategy selecionar(Pedido pedido) {
        BigDecimal peso = pedido.pesoKg();
        BigDecimal distancia = pedido.distanciaKm();

        // L√≥gica de sele√ß√£o baseada em regras
        if (distancia.compareTo(new BigDecimal("500")) > 0) {
            return new FreteExpresso(); // Longa dist√¢ncia
        }

        if (peso.compareTo(new BigDecimal("20")) > 0) {
            return new FreteNormal(); // Peso alto
        }

        return new FreteEconomico(); // Demais casos
    }

    FreteStrategy selecionarPorDestino(String destino) {
        return switch (destino.toUpperCase()) {
            case "INTERNACIONAL" -> new FreteExpresso();
            case "CAPITAIS" -> new FreteNormal();
            default -> new FreteEconomico();
        };
    }
}
```

### 6. Strategy com Lambdas (Java Funcional)

```java
final class FreteStrategies {

    // Estrat√©gias como fun√ß√µes
    static final FreteStrategy EXPRESSO = pedido -> {
        BigDecimal base = new BigDecimal("50.00");
        BigDecimal peso = pedido.pesoKg().multiply(new BigDecimal("5.00"));
        BigDecimal dist = pedido.distanciaKm().multiply(new BigDecimal("2.00"));
        return base.add(peso).add(dist);
    };

    static final FreteStrategy NORMAL = pedido -> {
        BigDecimal base = new BigDecimal("20.00");
        BigDecimal peso = pedido.pesoKg().multiply(new BigDecimal("2.00"));
        return base.add(peso);
    };

    static final FreteStrategy ECONOMICO = pedido -> {
        boolean pesado = pedido.pesoKg().compareTo(new BigDecimal("10")) > 0;
        return pesado ? new BigDecimal("15.00") : new BigDecimal("10.00");
    };

    // Factory method
    static FreteStrategy porTipo(String tipo) {
        return switch (tipo.toUpperCase()) {
            case "EXPRESSO" -> EXPRESSO;
            case "NORMAL" -> NORMAL;
            case "ECONOMICO" -> ECONOMICO;
            default -> throw new IllegalArgumentException("Tipo inv√°lido: " + tipo);
        };
    }
}
```

---

## üß™ Como Testar

### 1. Testar Estrat√©gia Isoladamente

```java
@Test
void expressoDeverCalcularCorretamente() {
    // Arrange
    FreteStrategy expresso = new FreteExpresso();
    Pedido pedido = new Pedido(
        "P1",
        new BigDecimal("5.00"), // 5kg
        new BigDecimal("100"), // 100km
        "SP"
    );

    // Act
    BigDecimal frete = expresso.calcular(pedido);

    // Assert
    // Base: 50 + Peso: 5*5=25 + Dist√¢ncia: 100*2=200 = 275
    assertEquals(new BigDecimal("275.00"), frete);
}
```

### 2. Testar Calculadora com Estrat√©gia Mockada

```java
@Test
void calculadoraDeveUsarEstrategia() {
    // Arrange
    FreteStrategy mock = mock(FreteStrategy.class);
    when(mock.calcular(any())).thenReturn(new BigDecimal("99.99"));
    when(mock.getTipo()).thenReturn("MOCK");

    CalculadoraFrete calculadora = new CalculadoraFrete(mock);
    Pedido pedido = new Pedido("P1", BigDecimal.ONE, BigDecimal.ONE, "SP");

    // Act
    BigDecimal resultado = calculadora.calcular(pedido);

    // Assert
    assertEquals(new BigDecimal("99.99"), resultado);
    verify(mock).calcular(pedido);
}
```

### 3. Testar Troca de Estrat√©gia

```java
@Test
void deveTrocarEstrategiaEmRuntime() {
    // Arrange
    Pedido pedido = new Pedido("P1", new BigDecimal("5"), new BigDecimal("50"), "SP");

    // Act & Assert - Expresso
    CalculadoraFrete calculadoraExpresso = new CalculadoraFrete(new FreteExpresso());
    BigDecimal valorExpresso = calculadoraExpresso.calcular(pedido);
    assertEquals(new BigDecimal("175.00"), valorExpresso); // 50 + 25 + 100

    // Act & Assert - Normal
    CalculadoraFrete calculadoraNormal = new CalculadoraFrete(new FreteNormal());
    BigDecimal valorNormal = calculadoraNormal.calcular(pedido);
    assertEquals(new BigDecimal("30.00"), valorNormal); // 20 + 10

    // Act & Assert - Econ√¥mico
    CalculadoraFrete calculadoraEconomico = new CalculadoraFrete(new FreteEconomico());
    BigDecimal valorEconomico = calculadoraEconomico.calcular(pedido);
    assertEquals(new BigDecimal("10.00"), valorEconomico); // < 10kg
}
```

### 4. Testar Factory de Estrat√©gias

```java
@Test
void factoryDeveRetornarEstrategiaCorreta() {
    // Arrange
    FreteStrategyFactory factory = new FreteStrategyFactory();

    // Act
    FreteStrategy expresso = factory.obter("EXPRESSO");
    FreteStrategy normal = factory.obter("NORMAL");

    // Assert
    assertInstanceOf(FreteExpresso.class, expresso);
    assertInstanceOf(FreteNormal.class, normal);
    assertEquals(3, factory.tiposDisponiveis().size());
}
```

### 5. Testar Strategy Selector

```java
@Test
void selectorDeveEscolherExpressoParaLongaDistancia() {
    // Arrange
    FreteStrategySelector selector = new FreteStrategySelector();
    Pedido pedidoLonge = new Pedido(
        "P1",
        new BigDecimal("5"),
        new BigDecimal("600"), // > 500km
        "RJ"
    );

    // Act
    FreteStrategy strategy = selector.selecionar(pedidoLonge);

    // Assert
    assertInstanceOf(FreteExpresso.class, strategy);
}
```

### 6. Testar Estrat√©gia Lambda

```java
@Test
void estrategiaLambdaDeveFuncionar() {
    // Arrange
    FreteStrategy estrategia = pedido -> new BigDecimal("100.00");
    CalculadoraFrete calculadora = new CalculadoraFrete(estrategia);

    Pedido pedido = new Pedido("P1", BigDecimal.ONE, BigDecimal.ONE, "SP");

    // Act
    BigDecimal frete = calculadora.calcular(pedido);

    // Assert
    assertEquals(new BigDecimal("100.00"), frete);
}
```

### 7. Testar M√©tricas de C√°lculo

```java
@Test
void deveRastrearMetricasDeCalculo() {
    // Arrange
    CalculadoraFrete calculadora = new CalculadoraFrete(new FreteNormal());
    Pedido pedido1 = new Pedido("P1", new BigDecimal("5"), new BigDecimal("100"), "SP");
    Pedido pedido2 = new Pedido("P2", new BigDecimal("10"), new BigDecimal("200"), "RJ");

    // Act
    calculadora.calcular(pedido1); // 20 + 10 = 30
    calculadora.calcular(pedido2); // 20 + 20 = 40

    FreteMetrics metrics = calculadora.getMetrics();

    // Assert
    assertEquals(2, metrics.calculos());
    assertEquals(new BigDecimal("70.00"), metrics.totalCalculado());
    assertEquals("NORMAL", metrics.estrategia());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Estrat√©gia com estado mut√°vel
class FreteComDesconto implements FreteStrategy {
    private int descontos = 0; // Estado compartilhado!

    public BigDecimal calcular(Pedido pedido) {
        descontos++; // Thread-unsafe
        return BigDecimal.TEN.multiply(new BigDecimal(descontos));
    }
}

// ‚ùå L√≥gica de sele√ß√£o no cliente
if (pedido.getDistancia() > 500) {
    calculadora = new CalculadoraFrete(new FreteExpresso());
} else if (pedido.getPeso() > 20) {
    calculadora = new CalculadoraFrete(new FreteNormal());
} // Repete em m√∫ltiplos lugares!
```

### ‚úÖ Fazer

```java
// ‚úÖ Estrat√©gia stateless
class FreteExpresso implements FreteStrategy {
    public BigDecimal calcular(Pedido pedido) {
        // Sem estado interno
        return BigDecimal.TEN;
    }
}

// ‚úÖ L√≥gica de sele√ß√£o centralizada
class FreteStrategySelector {
    FreteStrategy selecionar(Pedido pedido) {
        if (pedido.distanciaKm().compareTo(new BigDecimal("500")) > 0) {
            return new FreteExpresso();
        }
        return new FreteEconomico();
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Estrat√©gias stateless**: Sem estado interno mut√°vel
- ‚úÖ **Interface simples**: Um m√©todo principal (calcular, processar, validar)
- ‚úÖ **Factory pattern**: Centralizar cria√ß√£o de estrat√©gias
- ‚úÖ **Selector pattern**: Encapsular l√≥gica de escolha
- ‚úÖ **Lambda-friendly**: @FunctionalInterface quando poss√≠vel
- ‚úÖ **Testes isolados**: Testar cada estrat√©gia separadamente
- ‚úÖ **M√©tricas**: Rastrear uso de cada estrat√©gia

---

## üîó Integra√ß√£o com Frameworks

### Spring Strategy

```java
@Component("expresso")
class FreteExpresso implements FreteStrategy { /*...*/ }

@Component("normal")
class FreteNormal implements FreteStrategy { /*...*/ }

@Service
class FreteService {
    private final Map<String, FreteStrategy> strategies;

    @Autowired
    FreteService(List<FreteStrategy> strategies) {
        this.strategies = strategies.stream()
            .collect(Collectors.toMap(
                FreteStrategy::getTipo,
                Function.identity()
            ));
    }

    BigDecimal calcular(String tipo, Pedido pedido) {
        return strategies.get(tipo).calcular(pedido);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens               | ‚ö†Ô∏è Desvantagens                       |
| -------------------------- | ------------------------------------- |
| Algoritmos intercambi√°veis | Mais classes para gerenciar           |
| Open/Closed Principle      | Cliente precisa conhecer estrat√©gias  |
| Testes isolados f√°ceis     | Overhead de abstra√ß√£o                 |
| Elimina if/else gigantes   | Pode ser excessivo para casos simples |

---

## üîç Compara√ß√£o

| Padr√£o              | Quando Usar                             | Complexidade |
| ------------------- | --------------------------------------- | ------------ |
| **Strategy**        | Algoritmos intercambi√°veis em runtime   | M√©dia        |
| **State**           | Comportamento muda baseado em estado    | Alta         |
| **Template Method** | Algoritmo fixo com passos customiz√°veis | Baixa        |
| **Command**         | Encapsular requisi√ß√µes como objetos     | M√©dia        |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar cache de estrat√©gias** (evitar criar inst√¢ncias repetidas)
2. **Strategy com fallback** (se falhar, tenta pr√≥xima estrat√©gia)
3. **Composite strategy** (combina m√∫ltiplas estrat√©gias)
4. **Strategy chain** (aplica m√∫ltiplas transforma√ß√µes sequencialmente)
5. **A/B testing** com estrat√©gias (50% usa estrat√©gia A, 50% B)

---

## üìö Relacionado

- **Factory Method**: Criar estrat√©gias dinamicamente
- **State Pattern**: Estrat√©gia baseada em estado interno
- **Template Method**: Algoritmo fixo, passos vari√°veis
- **Command Pattern**: Encapsular a√ß√µes como objetos

---

**Strategy Pattern facilita testes, extensibilidade e elimina condicionais complexas!** üéØ‚ú®
