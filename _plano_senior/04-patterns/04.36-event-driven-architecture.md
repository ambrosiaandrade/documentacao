# 04.36 Event-Driven Architecture (EDA) [AVAN√áADO] üì°

## üéØ Objetivo

Organizar aplica√ß√£o em torno de **eventos ass√≠ncronos**, onde produtores emitem eventos e consumidores reagem, permitindo **testes com eventos mock**, desacoplamento total e escalabilidade independente.

---

## üìö O Que √â?

**Event-Driven Architecture** estrutura aplica√ß√£o como fluxo de eventos: componentes publicam eventos quando algo acontece, e outros componentes reagem assinando esses eventos. Comunica√ß√£o ass√≠ncrona e desacoplada.

### Analogia

Como **not√≠cias e assinantes**:

- **Jornal (Produtor)**: Publica not√≠cias quando algo acontece
- **Banca (Event Bus)**: Distribui jornais
- **Assinantes (Consumidores)**: Recebem e reagem √†s not√≠cias
- **Vantagem**: Jornal n√£o precisa saber quem l√™; novos assinantes n√£o afetam publica√ß√£o

---

## ‚ùå Problema que Resolve

### Antes (Chamadas S√≠ncronas Acopladas)

```java
// ‚ùå PROBLEMA: Componentes acoplados com chamadas diretas

@Service
class PedidoService {

    @Autowired
    private EstoqueService estoqueService; // Acoplamento ‚ùå

    @Autowired
    private EmailService emailService; // Acoplamento ‚ùå

    @Autowired
    private NotaFiscalService notaFiscalService; // Acoplamento ‚ùå

    @Autowired
    private LogisticaService logisticaService; // Acoplamento ‚ùå

    @Transactional
    void criarPedido(Pedido pedido) {
        // Salva pedido
        repository.save(pedido);

        // Chama TODOS os servi√ßos s√≠ncronamente ‚ùå
        estoqueService.reservar(pedido); // Bloqueia se lento

        emailService.enviarConfirmacao(pedido); // Bloqueia se email cair

        notaFiscalService.emitir(pedido); // Bloqueia se SEFAZ fora

        logisticaService.agendar(pedido); // Bloqueia se log√≠stica lenta

        // Se UM falhar, TUDO falha ‚ùå
        // Transa√ß√£o longa = lock de banco ‚ùå
        // Adicionar nova funcionalidade = modificar c√≥digo ‚ùå
    }
}

// Problemas:
// - Acoplamento forte entre componentes ‚ùå
// - Bloqueio: tudo s√≠ncrono ‚ùå
// - Falha em um = falha em tudo ‚ùå
// - Adicionar listener = modificar produtor ‚ùå
// - Transa√ß√£o longa = lock de recursos ‚ùå
// - Dif√≠cil escalar (tudo junto) ‚ùå
```

**Problemas**:

- üîó Acoplamento forte
- ‚è±Ô∏è Bloqueio s√≠ncrono
- üí• Falha cascata
- üîß Adicionar funcionalidade = modificar c√≥digo
- ‚öñÔ∏è Dif√≠cil escalar independentemente

### Depois (Event-Driven Architecture)

```java
// ‚úÖ SOLU√á√ÉO: Publicar evento, consumidores reagem independentemente

// ==== PRODUTOR (emite evento) ====
@Service
class PedidoService {

    private final EventPublisher eventPublisher; // Apenas event bus ‚úÖ

    @Transactional
    void criarPedido(Pedido pedido) {
        // Salva pedido
        repository.save(pedido);

        // Publica evento ‚úÖ - n√£o espera processamento
        eventPublisher.publish(new PedidoCriadoEvent(
            pedido.getId(),
            pedido.getClienteId(),
            pedido.getItens()
        ));

        // Retorna imediatamente ‚úÖ
        // Consumidores processam em background ‚úÖ
    }
}

// ==== EVENTOS (DTOs imut√°veis) ====
record PedidoCriadoEvent(
    Long pedidoId,
    Long clienteId,
    List<ItemPedido> itens
) implements DomainEvent {
    LocalDateTime occurredAt() {
        return LocalDateTime.now();
    }
}

// ==== CONSUMIDORES (reagem ao evento) ====

// Consumidor 1: Reserva estoque
@Component
class EstoqueEventListener {

    @EventListener
    @Async // Processa em thread separada ‚úÖ
    void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üì¶ Reservando estoque para pedido: " + event.pedidoId());
        estoqueService.reservar(event.itens());
    }
}

// Consumidor 2: Envia email
@Component
class EmailEventListener {

    @EventListener
    @Async
    void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üìß Enviando email para pedido: " + event.pedidoId());
        emailService.enviarConfirmacao(event.clienteId());
    }
}

// Consumidor 3: Emite nota fiscal
@Component
class NotaFiscalEventListener {

    @EventListener
    @Async
    void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üìÑ Emitindo nota fiscal para pedido: " + event.pedidoId());
        notaFiscalService.emitir(event.pedidoId());
    }
}

// ‚úÖ Vantagens:
// - Desacoplamento total: produtor n√£o conhece consumidores ‚úÖ
// - Async: n√£o bloqueia ‚úÖ
// - Falha isolada: um consumidor falha, outros continuam ‚úÖ
// - Extens√≠vel: adicionar listener sem modificar produtor ‚úÖ
// - Escal√°vel: consumidores independentes ‚úÖ

// ‚úÖ Teste simples com evento mock
@Test
void deveProcessarPedidoComEvento() {
    // Arrange
    EventPublisher publisher = mock(EventPublisher.class);
    PedidoService service = new PedidoService(repository, publisher);

    // Act
    service.criarPedido(pedido);

    // Assert
    verify(publisher).publish(argThat(event ->
        event instanceof PedidoCriadoEvent &&
        ((PedidoCriadoEvent) event).pedidoId().equals(pedido.getId())
    ));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Event Bus (Publica√ß√£o Local - Spring)

```java
// Interface de evento
interface DomainEvent {
    LocalDateTime occurredAt();
}

// Eventos de dom√≠nio
record PedidoCriadoEvent(
    Long pedidoId,
    Long clienteId,
    List<ItemPedido> itens,
    LocalDateTime occurredAt
) implements DomainEvent {
    PedidoCriadoEvent(Long pedidoId, Long clienteId, List<ItemPedido> itens) {
        this(pedidoId, clienteId, itens, LocalDateTime.now());
    }
}

record PedidoAprovadoEvent(
    Long pedidoId,
    BigDecimal valorTotal,
    LocalDateTime occurredAt
) implements DomainEvent {
    PedidoAprovadoEvent(Long pedidoId, BigDecimal valorTotal) {
        this(pedidoId, valorTotal, LocalDateTime.now());
    }
}

record PedidoCanceladoEvent(
    Long pedidoId,
    String motivo,
    LocalDateTime occurredAt
) implements DomainEvent {
    PedidoCanceladoEvent(Long pedidoId, String motivo) {
        this(pedidoId, motivo, LocalDateTime.now());
    }
}

record EstoqueReservadoEvent(
    Long pedidoId,
    List<ItemPedido> itens,
    LocalDateTime occurredAt
) implements DomainEvent {
    EstoqueReservadoEvent(Long pedidoId, List<ItemPedido> itens) {
        this(pedidoId, itens, LocalDateTime.now());
    }
}

// Event Publisher (Spring ApplicationEventPublisher)
@Component
class EventPublisher {

    private final ApplicationEventPublisher springPublisher;
    private final AtomicLong eventCount = new AtomicLong();

    @Autowired
    EventPublisher(ApplicationEventPublisher springPublisher) {
        this.springPublisher = springPublisher;
    }

    void publish(DomainEvent event) {
        System.out.println("üì§ Publicando evento: " + event.getClass().getSimpleName());
        springPublisher.publishEvent(event);
        eventCount.incrementAndGet();
    }

    long getTotalEventosPublicados() {
        return eventCount.get();
    }
}
```

### 2. Produtor de Eventos (Aggregate Root)

```java
@Entity
@Table(name = "pedidos")
class Pedido {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "cliente_id", nullable = false)
    private Long clienteId;

    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL)
    private List<ItemPedido> itens = new ArrayList<>();

    @Column(name = "valor_total", nullable = false)
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    private StatusPedido status;

    // Domain events (transient - n√£o persistidos)
    @Transient
    private final List<DomainEvent> domainEvents = new ArrayList<>();

    // M√©todos de neg√≥cio que geram eventos
    void aprovar(BigDecimal valorTotal) {
        if (this.status != StatusPedido.PENDENTE) {
            throw new IllegalStateException("Apenas pedidos pendentes podem ser aprovados");
        }

        this.status = StatusPedido.APROVADO;
        this.valorTotal = valorTotal;

        // Registra evento
        domainEvents.add(new PedidoAprovadoEvent(id, valorTotal));
    }

    void cancelar(String motivo) {
        if (this.status == StatusPedido.CANCELADO) {
            throw new IllegalStateException("Pedido j√° est√° cancelado");
        }

        this.status = StatusPedido.CANCELADO;

        // Registra evento
        domainEvents.add(new PedidoCanceladoEvent(id, motivo));
    }

    List<DomainEvent> getDomainEvents() {
        return List.copyOf(domainEvents);
    }

    void clearDomainEvents() {
        domainEvents.clear();
    }
}

enum StatusPedido {
    PENDENTE, APROVADO, CANCELADO, PROCESSANDO
}

// Service que publica eventos
@Service
class PedidoService {

    private final PedidoRepository repository;
    private final EventPublisher eventPublisher;

    @Autowired
    PedidoService(PedidoRepository repository, EventPublisher eventPublisher) {
        this.repository = repository;
        this.eventPublisher = eventPublisher;
    }

    @Transactional
    Pedido criarPedido(CriarPedidoRequest request) {
        Pedido pedido = new Pedido();
        pedido.setClienteId(request.clienteId());
        pedido.setStatus(StatusPedido.PENDENTE);

        request.itens().forEach(item -> {
            ItemPedido itemPedido = new ItemPedido(
                item.produtoId(),
                item.quantidade(),
                item.precoUnitario()
            );
            pedido.adicionarItem(itemPedido);
        });

        Pedido salvo = repository.save(pedido);

        // Publica evento ap√≥s persistir
        eventPublisher.publish(new PedidoCriadoEvent(
            salvo.getId(),
            salvo.getClienteId(),
            salvo.getItens()
        ));

        return salvo;
    }

    @Transactional
    void aprovarPedido(Long pedidoId, BigDecimal valorTotal) {
        Pedido pedido = repository.findById(pedidoId)
            .orElseThrow(() -> new PedidoNaoEncontradoException(pedidoId));

        // M√©todo de dom√≠nio gera evento
        pedido.aprovar(valorTotal);

        repository.save(pedido);

        // Publica eventos de dom√≠nio
        pedido.getDomainEvents().forEach(eventPublisher::publish);
        pedido.clearDomainEvents();
    }

    @Transactional
    void cancelarPedido(Long pedidoId, String motivo) {
        Pedido pedido = repository.findById(pedidoId)
            .orElseThrow(() -> new PedidoNaoEncontradoException(pedidoId));

        pedido.cancelar(motivo);

        repository.save(pedido);

        pedido.getDomainEvents().forEach(eventPublisher::publish);
        pedido.clearDomainEvents();
    }
}
```

### 3. Consumidores de Eventos (Event Listeners)

```java
// Listener 1: Reserva de estoque
@Component
class EstoqueEventListener {

    private final EstoqueService estoqueService;
    private final EventPublisher eventPublisher;

    @Autowired
    EstoqueEventListener(EstoqueService estoqueService, EventPublisher eventPublisher) {
        this.estoqueService = estoqueService;
        this.eventPublisher = eventPublisher;
    }

    @EventListener
    @Async
    @Transactional
    public void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üì¶ [Estoque] Processando pedido: " + event.pedidoId());

        try {
            // Reserva itens no estoque
            event.itens().forEach(item ->
                estoqueService.reservar(item.produtoId(), item.quantidade())
            );

            // Publica evento de sucesso
            eventPublisher.publish(new EstoqueReservadoEvent(event.pedidoId(), event.itens()));

            System.out.println("‚úÖ [Estoque] Reservado com sucesso");

        } catch (EstoqueInsuficienteException e) {
            System.out.println("‚ùå [Estoque] Falha: " + e.getMessage());
            // Publica evento de falha (Saga compensation)
            eventPublisher.publish(new EstoqueReservadoEvent(event.pedidoId(), event.itens()));
        }
    }
}

// Listener 2: Envio de notifica√ß√µes
@Component
class NotificacaoEventListener {

    private final EmailService emailService;

    @Autowired
    NotificacaoEventListener(EmailService emailService) {
        this.emailService = emailService;
    }

    @EventListener
    @Async
    public void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üìß [Email] Enviando confirma√ß√£o para pedido: " + event.pedidoId());

        try {
            emailService.enviarConfirmacao(event.clienteId(), event.pedidoId());
            System.out.println("‚úÖ [Email] Enviado com sucesso");

        } catch (Exception e) {
            System.out.println("‚ùå [Email] Falha: " + e.getMessage());
            // Log mas n√£o falha o processo principal
        }
    }

    @EventListener
    @Async
    public void onPedidoAprovado(PedidoAprovadoEvent event) {
        System.out.println("üìß [Email] Notificando aprova√ß√£o: " + event.pedidoId());
        emailService.enviarNotificacaoAprovacao(event.pedidoId());
    }

    @EventListener
    @Async
    public void onPedidoCancelado(PedidoCanceladoEvent event) {
        System.out.println("üìß [Email] Notificando cancelamento: " + event.pedidoId());
        emailService.enviarNotificacaoCancelamento(event.pedidoId(), event.motivo());
    }
}

// Listener 3: Auditoria/Log
@Component
class AuditoriaEventListener {

    private final AuditoriaRepository auditoriaRepository;

    @Autowired
    AuditoriaEventListener(AuditoriaRepository auditoriaRepository) {
        this.auditoriaRepository = auditoriaRepository;
    }

    @EventListener
    @Async
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void onQualquerEvento(DomainEvent event) {
        System.out.println("üìù [Auditoria] Registrando evento: " + event.getClass().getSimpleName());

        Auditoria registro = new Auditoria();
        registro.setEventType(event.getClass().getSimpleName());
        registro.setEventData(toJson(event));
        registro.setOccurredAt(event.occurredAt());

        auditoriaRepository.save(registro);
    }

    private String toJson(Object obj) {
        try {
            return new ObjectMapper().writeValueAsString(obj);
        } catch (Exception e) {
            return obj.toString();
        }
    }
}

// Listener 4: M√©tricas
@Component
class MetricasEventListener {

    private final AtomicLong pedidosCriados = new AtomicLong();
    private final AtomicLong pedidosAprovados = new AtomicLong();
    private final AtomicLong pedidosCancelados = new AtomicLong();

    @EventListener
    public void onPedidoCriado(PedidoCriadoEvent event) {
        pedidosCriados.incrementAndGet();
    }

    @EventListener
    public void onPedidoAprovado(PedidoAprovadoEvent event) {
        pedidosAprovados.incrementAndGet();
    }

    @EventListener
    public void onPedidoCancelado(PedidoCanceladoEvent event) {
        pedidosCancelados.incrementAndGet();
    }

    Map<String, Long> getMetricas() {
        return Map.of(
            "pedidosCriados", pedidosCriados.get(),
            "pedidosAprovados", pedidosAprovados.get(),
            "pedidosCancelados", pedidosCancelados.get()
        );
    }
}
```

### 4. Mensageria com RabbitMQ (Distribu√≠do)

```java
// Configura√ß√£o RabbitMQ
@Configuration
class RabbitMQConfig {

    public static final String PEDIDO_EXCHANGE = "pedido.exchange";
    public static final String PEDIDO_CRIADO_QUEUE = "pedido.criado.queue";
    public static final String PEDIDO_APROVADO_QUEUE = "pedido.aprovado.queue";

    @Bean
    TopicExchange pedidoExchange() {
        return new TopicExchange(PEDIDO_EXCHANGE);
    }

    @Bean
    Queue pedidoCriadoQueue() {
        return new Queue(PEDIDO_CRIADO_QUEUE, true);
    }

    @Bean
    Queue pedidoAprovadoQueue() {
        return new Queue(PEDIDO_APROVADO_QUEUE, true);
    }

    @Bean
    Binding pedidoCriadoBinding(Queue pedidoCriadoQueue, TopicExchange pedidoExchange) {
        return BindingBuilder
            .bind(pedidoCriadoQueue)
            .to(pedidoExchange)
            .with("pedido.criado");
    }

    @Bean
    Binding pedidoAprovadoBinding(Queue pedidoAprovadoQueue, TopicExchange pedidoExchange) {
        return BindingBuilder
            .bind(pedidoAprovadoQueue)
            .to(pedidoExchange)
            .with("pedido.aprovado");
    }
}

// Publisher para RabbitMQ
@Component
class RabbitEventPublisher {

    private final RabbitTemplate rabbitTemplate;

    @Autowired
    RabbitEventPublisher(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    void publish(String routingKey, DomainEvent event) {
        System.out.println("üì§ [RabbitMQ] Publicando: " + routingKey);
        rabbitTemplate.convertAndSend(RabbitMQConfig.PEDIDO_EXCHANGE, routingKey, event);
    }
}

// Listener RabbitMQ (em outro servi√ßo/microservice)
@Component
class RabbitEventListener {

    @RabbitListener(queues = RabbitMQConfig.PEDIDO_CRIADO_QUEUE)
    public void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üì• [RabbitMQ] Recebido pedido criado: " + event.pedidoId());
        // Processa evento
    }

    @RabbitListener(queues = RabbitMQConfig.PEDIDO_APROVADO_QUEUE)
    public void onPedidoAprovado(PedidoAprovadoEvent event) {
        System.out.println("üì• [RabbitMQ] Recebido pedido aprovado: " + event.pedidoId());
        // Processa evento
    }
}
```

### 5. Event Sourcing (Armazenar Hist√≥rico de Eventos)

```java
// Event Store (armazena TODOS os eventos)
@Entity
@Table(name = "event_store")
class EventRecord {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "aggregate_id", nullable = false)
    private String aggregateId;

    @Column(name = "event_type", nullable = false)
    private String eventType;

    @Column(name = "event_data", nullable = false, columnDefinition = "TEXT")
    private String eventData;

    @Column(name = "occurred_at", nullable = false)
    private LocalDateTime occurredAt;

    @Version
    private Long version;

    // Getters, setters
}

@Repository
interface EventStoreRepository extends JpaRepository<EventRecord, Long> {
    List<EventRecord> findByAggregateIdOrderByVersionAsc(String aggregateId);
}

// Event Store Service
@Service
class EventStoreService {

    private final EventStoreRepository repository;
    private final ObjectMapper objectMapper;

    @Autowired
    EventStoreService(EventStoreRepository repository, ObjectMapper objectMapper) {
        this.repository = repository;
        this.objectMapper = objectMapper;
    }

    @Transactional
    void salvarEvento(String aggregateId, DomainEvent event) {
        try {
            EventRecord record = new EventRecord();
            record.setAggregateId(aggregateId);
            record.setEventType(event.getClass().getSimpleName());
            record.setEventData(objectMapper.writeValueAsString(event));
            record.setOccurredAt(event.occurredAt());

            repository.save(record);

        } catch (JsonProcessingException e) {
            throw new RuntimeException("Erro ao serializar evento", e);
        }
    }

    List<DomainEvent> buscarEventos(String aggregateId) {
        return repository.findByAggregateIdOrderByVersionAsc(aggregateId).stream()
            .map(this::deserializarEvento)
            .toList();
    }

    private DomainEvent deserializarEvento(EventRecord record) {
        try {
            Class<?> eventClass = Class.forName("com.example.events." + record.getEventType());
            return (DomainEvent) objectMapper.readValue(record.getEventData(), eventClass);
        } catch (Exception e) {
            throw new RuntimeException("Erro ao desserializar evento", e);
        }
    }

    // Reconstr√≥i estado de agregado a partir dos eventos
    Pedido reconstruirPedido(Long pedidoId) {
        List<DomainEvent> eventos = buscarEventos("Pedido-" + pedidoId);

        Pedido pedido = new Pedido();

        for (DomainEvent evento : eventos) {
            if (evento instanceof PedidoCriadoEvent e) {
                // Aplica evento
                pedido.setId(e.pedidoId());
                pedido.setClienteId(e.clienteId());
                // ...
            } else if (evento instanceof PedidoAprovadoEvent e) {
                pedido.setStatus(StatusPedido.APROVADO);
                pedido.setValorTotal(e.valorTotal());
            } else if (evento instanceof PedidoCanceladoEvent e) {
                pedido.setStatus(StatusPedido.CANCELADO);
            }
        }

        return pedido;
    }
}

// Listener que persiste eventos
@Component
class EventStoreListener {

    private final EventStoreService eventStoreService;

    @Autowired
    EventStoreListener(EventStoreService eventStoreService) {
        this.eventStoreService = eventStoreService;
    }

    @EventListener
    @Async
    public void onPedidoCriado(PedidoCriadoEvent event) {
        eventStoreService.salvarEvento("Pedido-" + event.pedidoId(), event);
    }

    @EventListener
    @Async
    public void onPedidoAprovado(PedidoAprovadoEvent event) {
        eventStoreService.salvarEvento("Pedido-" + event.pedidoId(), event);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Publica√ß√£o de Eventos

```java
@SpringBootTest
class EventPublisherTest {

    @Autowired
    private EventPublisher eventPublisher;

    @Autowired
    private ApplicationContext context;

    @Test
    void devePublicarEventoComSucesso() {
        // Arrange
        AtomicBoolean eventRecebido = new AtomicBoolean(false);

        context.addApplicationListener((ApplicationListener<PedidoCriadoEvent>) event -> {
            eventRecebido.set(true);
        });

        PedidoCriadoEvent event = new PedidoCriadoEvent(1L, 1L, List.of());

        // Act
        eventPublisher.publish(event);

        // Assert
        await().atMost(Duration.ofSeconds(2)).until(eventRecebido::get);
    }
}
```

### 2. Testar Listeners com Evento Mock

```java
@ExtendWith(MockitoExtension.class)
class EstoqueEventListenerTest {

    @Mock
    private EstoqueService estoqueService;

    @Mock
    private EventPublisher eventPublisher;

    @InjectMocks
    private EstoqueEventListener listener;

    @Test
    void deveReservarEstoqueAoReceberEvento() {
        // Arrange
        ItemPedido item = new ItemPedido("P1", 2, BigDecimal.TEN);
        PedidoCriadoEvent event = new PedidoCriadoEvent(1L, 1L, List.of(item));

        // Act
        listener.onPedidoCriado(event);

        // Assert
        verify(estoqueService).reservar("P1", 2);
        verify(eventPublisher).publish(any(EstoqueReservadoEvent.class));
    }
}
```

### 3. Testar Event Sourcing

```java
@SpringBootTest
@Transactional
class EventSourcingTest {

    @Autowired
    private EventStoreService eventStoreService;

    @Test
    void deveReconstruirPedidoAPartirDeEventos() {
        // Arrange - salva eventos
        String aggregateId = "Pedido-1";
        eventStoreService.salvarEvento(aggregateId, new PedidoCriadoEvent(1L, 1L, List.of()));
        eventStoreService.salvarEvento(aggregateId, new PedidoAprovadoEvent(1L, BigDecimal.valueOf(100)));

        // Act
        Pedido pedido = eventStoreService.reconstruirPedido(1L);

        // Assert
        assertEquals(StatusPedido.APROVADO, pedido.getStatus());
        assertEquals(BigDecimal.valueOf(100), pedido.getValorTotal());
    }
}
```

### 4. Testar Mensageria (RabbitMQ)

```java
@SpringBootTest
class RabbitMQIntegrationTest {

    @Autowired
    private RabbitEventPublisher publisher;

    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Test
    void devePublicarEReceberEventoViaRabbitMQ() throws Exception {
        // Arrange
        PedidoCriadoEvent event = new PedidoCriadoEvent(1L, 1L, List.of());

        // Act
        publisher.publish("pedido.criado", event);

        // Assert - verifica mensagem na fila
        Object mensagem = rabbitTemplate.receiveAndConvert(
            RabbitMQConfig.PEDIDO_CRIADO_QUEUE,
            5000
        );

        assertNotNull(mensagem);
        assertTrue(mensagem instanceof PedidoCriadoEvent);
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Eventos com muitos dados (enviar refer√™ncias)
record BadEvent(Pedido pedidoCompleto, Cliente clienteCompleto) {} // ‚ùå

// ‚ùå L√≥gica s√≠ncrona no listener
@EventListener
void onEvent(Event e) {
    // Bloqueio ‚ùå
    Thread.sleep(10000);
}

// ‚ùå Transa√ß√µes longas
@EventListener
@Transactional
void onEvent(Event e) {
    // Lock longo ‚ùå
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Eventos leves (apenas IDs)
record GoodEvent(Long pedidoId, Long clienteId) {} // ‚úÖ

// ‚úÖ Processamento ass√≠ncrono
@EventListener
@Async // ‚úÖ
void onEvent(Event e) {
    // Background
}

// ‚úÖ Transa√ß√µes curtas/independentes
@EventListener
@Async
@Transactional(propagation = Propagation.REQUIRES_NEW)
void onEvent(Event e) {
    // Transa√ß√£o pr√≥pria ‚úÖ
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Eventos imut√°veis**: Records/final fields
- ‚úÖ **Eventos leves**: Apenas IDs e dados essenciais
- ‚úÖ **Async listeners**: @Async para n√£o bloquear
- ‚úÖ **Idempot√™ncia**: Listeners devem ser idempotentes
- ‚úÖ **Dead Letter Queue**: Para eventos falhos
- ‚úÖ **Event Versioning**: Compatibilidade retroativa
- ‚úÖ **Auditoria**: Log todos os eventos

---

## üîó Padr√µes Relacionados

| Padr√£o             | Prop√≥sito                                  |
| ------------------ | ------------------------------------------ |
| **CQRS**           | Separar comandos (write) de queries (read) |
| **Saga**           | Transa√ß√µes distribu√≠das com compensa√ß√£o    |
| **Event Sourcing** | Armazenar hist√≥rico completo de eventos    |
| **Pub/Sub**        | Publicar para m√∫ltiplos assinantes         |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                          | ‚ö†Ô∏è Desvantagens                |
| ------------------------------------- | ------------------------------ |
| Desacoplamento total                  | Complexidade operacional       |
| Escalabilidade independente           | Consist√™ncia eventual          |
| Falhas isoladas                       | Debugging dif√≠cil              |
| Extensibilidade (adicionar listeners) | Ordem de eventos n√£o garantida |
| Async = performance                   | Requer mensageria/infra        |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Event-Driven quando:

- M√∫ltiplos sistemas precisam reagir a mudan√ßas
- Necessidade de auditoria/hist√≥rico completo
- Escalabilidade independente de componentes
- Integra√ß√£o com sistemas externos

### ‚ùå Evite Event-Driven quando:

- Aplica√ß√£o simples/pequena
- Consist√™ncia forte obrigat√≥ria
- Time sem experi√™ncia com async
- Infraestrutura limitada

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar Saga** (compensa√ß√£o de transa√ß√µes com eventos)
2. **CQRS** (separar read/write models com eventos)
3. **Replay de eventos** (reconstruir estado passado)
4. **Event versioning** (compatibilidade de schemas)
5. **Dead Letter Queue** (reprocessar eventos falhos)

---

## üìö Relacionado

- **Observer Pattern**: Base do event-driven
- **Pub/Sub Pattern**: Publicar para m√∫ltiplos assinantes
- **CQRS**: Comandos e queries separados
- **Saga Pattern**: Transa√ß√µes distribu√≠das

---

**Event-Driven Architecture desacopla componentes via eventos ass√≠ncronos, permitindo testes com mocks e escalabilidade independente!** üì°‚ú®
