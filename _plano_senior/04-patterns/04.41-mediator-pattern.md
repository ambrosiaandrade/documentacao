# 04.41 Mediator Pattern (Architectural) [AVAN√áADO] üéØ

## üéØ Objetivo

Centralizar **comunica√ß√£o entre componentes** atrav√©s de um mediador, reduzindo acoplamento direto e permitindo **testes com mock mediator** e orquestra√ß√£o de intera√ß√µes complexas.

---

## üìö O Que √â?

**Mediator Pattern** (arquitetural) usa um componente central que coordena comunica√ß√£o entre outros componentes, eliminando depend√™ncias diretas e encapsulando l√≥gica de intera√ß√£o.

### Analogia

Como **torre de controle de aeroporto**:

- **Torre (Mediator)**: Coordena todas as comunica√ß√µes
- **Avi√µes (Components)**: N√£o falam diretamente entre si
- **Mensagens (Events/Commands)**: Passam pela torre
- **Vantagem**: Avi√µes n√£o precisam conhecer uns aos outros

---

## ‚ùå Problema que Resolve

### Antes (Componentes Acoplados)

```java
// ‚ùå PROBLEMA: Componentes chamam uns aos outros diretamente

class PedidoService {

    @Autowired
    private EstoqueService estoqueService; // Acoplamento ‚ùå

    @Autowired
    private PagamentoService pagamentoService; // Acoplamento ‚ùå

    @Autowired
    private EmailService emailService; // Acoplamento ‚ùå

    @Autowired
    private NotaFiscalService notaFiscalService; // Acoplamento ‚ùå

    void criarPedido(Pedido pedido) {
        // Conhece TODOS os outros servi√ßos ‚ùå
        repository.save(pedido);

        estoqueService.reservar(pedido); // Chamada direta ‚ùå
        pagamentoService.processar(pedido); // Chamada direta ‚ùå
        notaFiscalService.emitir(pedido); // Chamada direta ‚ùå
        emailService.enviar(pedido); // Chamada direta ‚ùå
    }
}

class EstoqueService {

    @Autowired
    private PagamentoService pagamentoService; // Acoplamento ‚ùå

    void reservar(Pedido pedido) {
        // Reserva estoque
        // ...

        // Chama pr√≥ximo servi√ßo diretamente ‚ùå
        pagamentoService.processar(pedido);
    }
}

// Problemas:
// - Acoplamento N√óN entre componentes ‚ùå
// - Dif√≠cil adicionar novo componente ‚ùå
// - L√≥gica de coordena√ß√£o distribu√≠da ‚ùå
// - Dif√≠cil testar isoladamente ‚ùå
// - Mudan√ßa afeta m√∫ltiplos componentes ‚ùå
```

**Problemas**:

- üîó Acoplamento direto N√óN
- üß© Dif√≠cil adicionar componentes
- üìä L√≥gica distribu√≠da
- üß™ Dif√≠cil testar
- üîß Mudan√ßa propaga

### Depois (Mediator Centralizado)

```java
// ‚úÖ SOLU√á√ÉO: Mediator coordena tudo

// ==== MEDIATOR (coordenador central) ====
@Component
class PedidoMediator {

    private final EstoqueService estoqueService;
    private final PagamentoService pagamentoService;
    private final EmailService emailService;
    private final NotaFiscalService notaFiscalService;

    @Autowired
    PedidoMediator(
        EstoqueService estoqueService,
        PagamentoService pagamentoService,
        EmailService emailService,
        NotaFiscalService notaFiscalService
    ) {
        this.estoqueService = estoqueService;
        this.pagamentoService = pagamentoService;
        this.emailService = emailService;
        this.notaFiscalService = notaFiscalService;
    }

    // Orquestra toda a intera√ß√£o ‚úÖ
    void processarCriacaoPedido(Pedido pedido) {
        System.out.println("üéØ [Mediator] Processando cria√ß√£o de pedido");

        try {
            // 1. Reservar estoque
            System.out.println("1Ô∏è‚É£ Reservando estoque...");
            estoqueService.reservar(pedido.getItens());

            // 2. Processar pagamento
            System.out.println("2Ô∏è‚É£ Processando pagamento...");
            pagamentoService.processar(pedido.getValorTotal());

            // 3. Emitir nota
            System.out.println("3Ô∏è‚É£ Emitindo nota fiscal...");
            notaFiscalService.emitir(pedido);

            // 4. Enviar email
            System.out.println("4Ô∏è‚É£ Enviando confirma√ß√£o...");
            emailService.enviarConfirmacao(pedido);

            System.out.println("‚úÖ [Mediator] Pedido processado com sucesso");

        } catch (Exception e) {
            System.err.println("‚ùå [Mediator] Erro ao processar: " + e.getMessage());
            compensar(pedido);
            throw e;
        }
    }

    void processarCancelamento(Pedido pedido) {
        System.out.println("üéØ [Mediator] Processando cancelamento");

        estoqueService.liberar(pedido.getItens());
        pagamentoService.estornar(pedido.getId());
        emailService.enviarCancelamento(pedido);
    }

    private void compensar(Pedido pedido) {
        System.out.println("üîÑ [Mediator] Compensando opera√ß√£o");
        // L√≥gica de compensa√ß√£o centralizada
    }
}

// ==== COMPONENTES (desacoplados) ====

@Service
class PedidoService {

    private final PedidoRepository repository;
    private final PedidoMediator mediator; // Apenas mediator ‚úÖ

    @Autowired
    PedidoService(PedidoRepository repository, PedidoMediator mediator) {
        this.repository = repository;
        this.mediator = mediator;
    }

    void criarPedido(Pedido pedido) {
        repository.save(pedido);

        // Delega ao mediator ‚úÖ
        mediator.processarCriacaoPedido(pedido);
    }

    void cancelarPedido(Long pedidoId) {
        Pedido pedido = repository.findById(pedidoId).orElseThrow();
        pedido.setStatus(StatusPedido.CANCELADO);
        repository.save(pedido);

        // Delega ao mediator ‚úÖ
        mediator.processarCancelamento(pedido);
    }
}

@Service
class EstoqueService {
    // Sem depend√™ncias de outros servi√ßos ‚úÖ
    void reservar(List<ItemPedido> itens) {
        System.out.println("üì¶ Reservando estoque");
    }

    void liberar(List<ItemPedido> itens) {
        System.out.println("üì¶ Liberando estoque");
    }
}

@Service
class PagamentoService {
    // Sem depend√™ncias de outros servi√ßos ‚úÖ
    void processar(BigDecimal valor) {
        System.out.println("üí≥ Processando pagamento: " + valor);
    }

    void estornar(Long pedidoId) {
        System.out.println("üí≥ Estornando pagamento");
    }
}

// ‚úÖ Vantagens:
// - Componentes desacoplados ‚úÖ
// - L√≥gica de coordena√ß√£o centralizada ‚úÖ
// - F√°cil adicionar novos componentes ‚úÖ
// - Test√°vel (mock mediator) ‚úÖ
// - Mudan√ßas localizadas no mediator ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Mediator com Event Bus

```java
// Mediator usando eventos (desacoplamento total)

@Component
public class EventMediator {

    private final ApplicationEventPublisher eventPublisher;
    private final Map<Class<?>, List<EventHandler<?>>> handlers = new ConcurrentHashMap<>();

    @Autowired
    public EventMediator(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }

    // Registrar handlers
    public <T> void registerHandler(Class<T> eventType, EventHandler<T> handler) {
        handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
    }

    // Publicar evento
    public <T> void publish(T event) {
        System.out.println("üéØ [Mediator] Publicando evento: " + event.getClass().getSimpleName());

        // Notifica handlers registrados
        List<EventHandler<?>> eventHandlers = handlers.get(event.getClass());
        if (eventHandlers != null) {
            for (EventHandler handler : eventHandlers) {
                try {
                    handler.handle(event);
                } catch (Exception e) {
                    System.err.println("‚ùå Erro em handler: " + e.getMessage());
                }
            }
        }

        // Publica tamb√©m via Spring Events
        eventPublisher.publishEvent(event);
    }
}

// Interface de handler
@FunctionalInterface
interface EventHandler<T> {
    void handle(T event);
}

// Eventos
record PedidoCriadoEvent(Long pedidoId, List<ItemPedido> itens, BigDecimal valor) {}
record PagamentoProcessadoEvent(Long pedidoId, String transacaoId) {}
record EstoqueReservadoEvent(Long pedidoId, List<ItemPedido> itens) {}

// Componentes registram handlers
@Component
class EstoqueComponent {

    @Autowired
    void registrarHandlers(EventMediator mediator) {
        mediator.registerHandler(PedidoCriadoEvent.class, this::onPedidoCriado);
    }

    void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üì¶ [Estoque] Reservando para pedido: " + event.pedidoId());
        // Reserva estoque
        // Publica evento de sucesso
    }
}

@Component
class PagamentoComponent {

    @Autowired
    void registrarHandlers(EventMediator mediator) {
        mediator.registerHandler(EstoqueReservadoEvent.class, this::onEstoqueReservado);
    }

    void onEstoqueReservado(EstoqueReservadoEvent event) {
        System.out.println("üí≥ [Pagamento] Processando para pedido: " + event.pedidoId());
        // Processa pagamento
    }
}
```

### 2. Mediator com Command Pattern

```java
// Mediator processa comandos

@Component
public class CommandMediator {

    private final Map<Class<? extends Command>, CommandHandler<?>> handlers = new ConcurrentHashMap<>();

    // Registrar handler
    public <C extends Command, R> void registerHandler(
        Class<C> commandType,
        CommandHandler<C, R> handler
    ) {
        handlers.put(commandType, handler);
    }

    // Executar comando
    public <C extends Command, R> R execute(C command) {
        System.out.println("üéØ [Mediator] Executando: " + command.getClass().getSimpleName());

        CommandHandler<C, R> handler = (CommandHandler<C, R>) handlers.get(command.getClass());

        if (handler == null) {
            throw new IllegalArgumentException("Handler n√£o encontrado para: " + command.getClass());
        }

        return handler.handle(command);
    }
}

// Interfaces
interface Command {}

@FunctionalInterface
interface CommandHandler<C extends Command, R> {
    R handle(C command);
}

// Comandos
record CriarPedidoCommand(Long clienteId, List<ItemPedido> itens) implements Command {}
record AprovarPedidoCommand(Long pedidoId) implements Command {}
record CancelarPedidoCommand(Long pedidoId, String motivo) implements Command {}

// Handlers
@Component
class CriarPedidoHandler implements CommandHandler<CriarPedidoCommand, Pedido> {

    private final PedidoRepository repository;
    private final EventMediator eventMediator;

    @Autowired
    CriarPedidoHandler(PedidoRepository repository, EventMediator eventMediator) {
        this.repository = repository;
        this.eventMediator = eventMediator;
    }

    @Override
    @Transactional
    public Pedido handle(CriarPedidoCommand command) {
        System.out.println("üé¨ [Handler] Criando pedido");

        Pedido pedido = new Pedido();
        pedido.setClienteId(command.clienteId());
        pedido.setItens(command.itens());

        Pedido salvo = repository.save(pedido);

        // Publica evento via mediator
        eventMediator.publish(new PedidoCriadoEvent(
            salvo.getId(),
            salvo.getItens(),
            salvo.getValorTotal()
        ));

        return salvo;
    }
}

// Uso
@Service
class PedidoApplicationService {

    @Autowired
    private CommandMediator mediator;

    Pedido criarPedido(CriarPedidoRequest request) {
        CriarPedidoCommand command = new CriarPedidoCommand(
            request.clienteId(),
            request.itens()
        );

        return mediator.execute(command);
    }
}
```

### 3. Mediator com Pipeline

```java
// Mediator executa pipeline de handlers

@Component
public class PipelineMediator {

    public <T, R> R executePipeline(T input, Pipeline<T, R> pipeline) {
        System.out.println("üéØ [Mediator] Iniciando pipeline");

        Object current = input;

        for (PipelineStep step : pipeline.getSteps()) {
            System.out.println("‚öôÔ∏è Executando: " + step.getName());
            current = step.execute(current);
        }

        return (R) current;
    }
}

// Pipeline
class Pipeline<T, R> {
    private final List<PipelineStep> steps = new ArrayList<>();

    Pipeline<T, R> addStep(String name, Function<Object, Object> function) {
        steps.add(new PipelineStep(name, function));
        return this;
    }

    List<PipelineStep> getSteps() {
        return steps;
    }
}

record PipelineStep(String name, Function<Object, Object> function) {
    Object execute(Object input) {
        return function.apply(input);
    }
}

// Uso
@Service
class PedidoPipelineService {

    @Autowired
    private PipelineMediator mediator;

    Pedido processarPedido(CriarPedidoRequest request) {
        Pipeline<CriarPedidoRequest, Pedido> pipeline = new Pipeline<>();

        pipeline
            .addStep("Validar", input -> {
                System.out.println("‚úì Validando request");
                return input;
            })
            .addStep("Criar Pedido", input -> {
                System.out.println("üìù Criando pedido");
                return new Pedido();
            })
            .addStep("Reservar Estoque", input -> {
                System.out.println("üì¶ Reservando estoque");
                return input;
            })
            .addStep("Processar Pagamento", input -> {
                System.out.println("üí≥ Processando pagamento");
                return input;
            });

        return mediator.executePipeline(request, pipeline);
    }
}
```

### 4. Mediator com Saga Orchestration

```java
// Mediator coordena Saga (transa√ß√£o distribu√≠da)

@Component
public class SagaMediator {

    private final Map<Long, SagaInstance> sagas = new ConcurrentHashMap<>();

    public Long startSaga(SagaDefinition definition, Object initialData) {
        Long sagaId = System.currentTimeMillis();

        SagaInstance instance = new SagaInstance(sagaId, definition, initialData);
        sagas.put(sagaId, instance);

        System.out.println("üéØ [Saga Mediator] Iniciando saga: " + sagaId);

        executeSaga(instance);

        return sagaId;
    }

    private void executeSaga(SagaInstance instance) {
        for (SagaStep step : instance.definition().steps()) {
            try {
                System.out.println("‚öôÔ∏è Executando: " + step.name());
                step.execute(instance.data());
                instance.addCompletedStep(step);

            } catch (Exception e) {
                System.err.println("‚ùå Falha em: " + step.name());
                compensateSaga(instance);
                throw new SagaException("Saga falhou", e);
            }
        }
    }

    private void compensateSaga(SagaInstance instance) {
        System.out.println("üîÑ [Saga Mediator] Compensando saga: " + instance.sagaId());

        // Compensa em ordem inversa
        List<SagaStep> completed = instance.completedSteps();
        Collections.reverse(completed);

        for (SagaStep step : completed) {
            try {
                System.out.println("‚Ü©Ô∏è Compensando: " + step.name());
                step.compensate(instance.data());
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao compensar: " + e.getMessage());
            }
        }
    }
}

// Defini√ß√£o de Saga
record SagaDefinition(List<SagaStep> steps) {}

interface SagaStep {
    String name();
    void execute(Object data);
    void compensate(Object data);
}

@Data
class SagaInstance {
    private final Long sagaId;
    private final SagaDefinition definition;
    private final Object data;
    private final List<SagaStep> completedSteps = new ArrayList<>();

    void addCompletedStep(SagaStep step) {
        completedSteps.add(step);
    }
}

// Uso
@Service
class PedidoSagaService {

    @Autowired
    private SagaMediator mediator;

    Long criarPedidoComSaga(CriarPedidoRequest request) {
        SagaDefinition saga = new SagaDefinition(List.of(
            new ReservarEstoqueStep(),
            new ProcessarPagamentoStep(),
            new EmitirNotaStep()
        ));

        return mediator.startSaga(saga, request);
    }
}

class ReservarEstoqueStep implements SagaStep {
    @Override
    public String name() { return "Reservar Estoque"; }

    @Override
    public void execute(Object data) {
        System.out.println("üì¶ Reservando estoque");
    }

    @Override
    public void compensate(Object data) {
        System.out.println("üì¶ Liberando estoque");
    }
}
```

---

## üß™ Como Testar

### 1. Teste com Mock Mediator

```java
@ExtendWith(MockitoExtension.class)
class PedidoServiceTest {

    @Mock
    private PedidoMediator mediator; // Mock mediator ‚úÖ

    @Mock
    private PedidoRepository repository;

    @InjectMocks
    private PedidoService service;

    @Test
    void deveCriarPedidoDelegandoAoMediator() {
        // Arrange
        Pedido pedido = new Pedido();
        when(repository.save(any())).thenReturn(pedido);

        // Act
        service.criarPedido(pedido);

        // Assert
        verify(repository).save(pedido);
        verify(mediator).processarCriacaoPedido(pedido); // Verifica delega√ß√£o
    }
}
```

### 2. Teste de Integra√ß√£o do Mediator

```java
@SpringBootTest
class MediatorIntegrationTest {

    @Autowired
    private CommandMediator mediator;

    @MockBean
    private EstoqueService estoqueService;

    @MockBean
    private PagamentoService pagamentoService;

    @Test
    void mediatorDeveCoordenarComponentes() {
        // Arrange
        CriarPedidoCommand command = new CriarPedidoCommand(1L, List.of());

        // Act
        Pedido result = mediator.execute(command);

        // Assert
        assertNotNull(result);
        verify(estoqueService).reservar(any());
        verify(pagamentoService).processar(any());
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Single Responsibility**: Mediator apenas coordena
- ‚úÖ **Event-Driven**: Usar eventos para desacoplamento total
- ‚úÖ **Idempot√™ncia**: Opera√ß√µes podem ser reexecutadas
- ‚úÖ **Logging**: Registrar todas as intera√ß√µes
- ‚úÖ **Timeout**: Definir limites de tempo
- ‚úÖ **Circuit Breaker**: Proteger chamadas

---

## üîó Mediator vs Observer vs Orchestrator

| Padr√£o           | Prop√≥sito            | Acoplamento             |
| ---------------- | -------------------- | ----------------------- |
| **Mediator**     | Coordenar intera√ß√µes | Componentes ‚Üí Mediator  |
| **Observer**     | Notificar mudan√ßas   | Subject ‚Üí Observers     |
| **Orchestrator** | Executar workflows   | Orquestrador ‚Üí Services |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                  | ‚ö†Ô∏è Desvantagens                |
| ----------------------------- | ------------------------------ |
| Desacoplamento total          | Mediator pode virar God Object |
| L√≥gica centralizada           | SPOF (Single Point of Failure) |
| F√°cil testar componentes      | Complexidade no mediator       |
| Adicionar componentes simples | Performance (hop extra)        |
| Orquestra√ß√£o expl√≠cita        | Dif√≠cil debugar fluxo          |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Mediator quando:

- M√∫ltiplos componentes interagem
- L√≥gica de coordena√ß√£o complexa
- Necessidade de desacoplamento
- Workflows bem definidos

### ‚ùå Evite Mediator quando:

- Intera√ß√µes simples (2 componentes)
- Performance cr√≠tica (lat√™ncia)
- L√≥gica muito simples (overhead)
- Componentes j√° desacoplados

---

**Mediator centraliza comunica√ß√£o entre componentes, permitindo testes com mock e orquestra√ß√£o clara!** üéØ‚ú®
