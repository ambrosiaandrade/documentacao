# 04.20 Template Method Pattern [M√âDIO] üìã

## üéØ Objetivo

Definir o **esqueleto de um algoritmo** em uma classe base, delegando passos espec√≠ficos para subclasses sem alterar a estrutura geral, permitindo **testar comportamento comum e varia√ß√µes isoladamente**.

---

## üìö O Que √â?

**Template Method** √© um padr√£o comportamental GoF que define a estrutura de um algoritmo em um m√©todo (template), com passos implementados em m√©todos abstratos ou hooks que subclasses podem customizar. Garante que a sequ√™ncia do algoritmo seja preservada.

### Analogia

Como uma **receita de bolo**:

- **Template (receita base)**: Pr√©-aquecer ‚Üí Misturar ‚Üí Assar ‚Üí Decorar
- **Passos fixos**: Ordem sempre igual (n√£o pode assar antes de misturar)
- **Passos customiz√°veis**: Tipo de cobertura, tempo de forno, ingredientes
- **Hooks**: Adicionar frutas (opcional)

---

## ‚ùå Problema que Resolve

### Antes (C√≥digo Duplicado em Subclasses)

```java
// ‚ùå PROBLEMA: L√≥gica duplicada em cada tipo de relat√≥rio
class RelatorioVendas {
    public void gerar() {
        System.out.println("Abrindo conex√£o...");
        // DUPLICADO
        buscarDados();
        formatarVendas();
        System.out.println("Salvando arquivo...");
        // DUPLICADO
        System.out.println("Fechando conex√£o...");
        // DUPLICADO
    }

    private void buscarDados() { /* SQL espec√≠fico vendas */ }
    private void formatarVendas() { /* Formato espec√≠fico */ }
}

class RelatorioEstoque {
    public void gerar() {
        System.out.println("Abrindo conex√£o...");
        // DUPLICADO ‚ùå
        buscarDados();
        formatarEstoque();
        System.out.println("Salvando arquivo...");
        // DUPLICADO ‚ùå
        System.out.println("Fechando conex√£o...");
        // DUPLICADO ‚ùå
    }

    private void buscarDados() { /* SQL espec√≠fico estoque */ }
    private void formatarEstoque() { /* Formato espec√≠fico */ }
}

// Problemas:
// - C√≥digo de conex√£o/fechamento duplicado
// - Mudan√ßa na ordem = modificar todas as classes
// - Imposs√≠vel testar estrutura comum isoladamente
```

**Problemas**:

- üìã Estrutura do algoritmo duplicada
- üîß Mudan√ßa na sequ√™ncia = modificar tudo
- üß™ Imposs√≠vel testar fluxo comum
- üêõ F√°cil esquecer passos obrigat√≥rios

### Depois (Template Method)

```java
// ‚úÖ SOLU√á√ÉO: Estrutura comum na classe base
abstract class RelatorioTemplate {

    // Template Method (final - n√£o pode ser sobrescrito)
    public final void gerar() {
        abrirConexao();      // Passo fixo
        buscarDados();       // Passo abstrato (cada subclasse implementa)
        formatarDados();     // Passo abstrato

        if (deveAdicionarRodape()) { // Hook (opcional)
            adicionarRodape();
        }

        salvarArquivo();     // Passo fixo
        fecharConexao();     // Passo fixo
    }

    // Passos fixos (comuns a todos)
    private void abrirConexao() {
        System.out.println("üìÇ Abrindo conex√£o...");
    }

    private void salvarArquivo() {
        System.out.println("üíæ Salvando arquivo...");
    }

    private void fecharConexao() {
        System.out.println("üîí Fechando conex√£o...");
    }

    // Passos abstratos (subclasses implementam)
    protected abstract void buscarDados();
    protected abstract void formatarDados();

    // Hook method (implementa√ß√£o padr√£o vazia)
    protected boolean deveAdicionarRodape() {
        return false;
    }

    protected void adicionarRodape() {
        // Implementa√ß√£o padr√£o vazia
    }
}

class RelatorioVendas extends RelatorioTemplate {
    @Override
    protected void buscarDados() {
        System.out.println("üìä Buscando dados de vendas...");
    }

    @Override
    protected void formatarDados() {
        System.out.println("üìà Formatando relat√≥rio de vendas");
    }

    @Override
    protected boolean deveAdicionarRodape() {
        return true;
    }

    @Override
    protected void adicionarRodape() {
        System.out.println("üìÑ Rodap√©: Total de vendas");
    }
}

// Teste da estrutura comum
@Test
void deveExecutarPassosNaOrdemCorreta() {
    RelatorioTemplate relatorio = spy(new RelatorioVendas());

    relatorio.gerar();

    InOrder inOrder = inOrder(relatorio);
    inOrder.verify(relatorio).buscarDados();
    inOrder.verify(relatorio).formatarDados();
    inOrder.verify(relatorio).adicionarRodape();
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Template Base (Estrutura do Algoritmo)

```java
abstract class ProcessadorPedidoTemplate {

    // Template Method - define sequ√™ncia do algoritmo
    public final ResultadoProcessamento processar(Pedido pedido) {
        System.out.println("üöÄ Iniciando processamento do pedido: " + pedido.id());

        // Passo 1: Validar (obrigat√≥rio)
        if (!validar(pedido)) {
            return ResultadoProcessamento.erro("Valida√ß√£o falhou");
        }

        // Passo 2: Calcular valor (obrigat√≥rio)
        BigDecimal valor = calcularValor(pedido);

        // Passo 3: Aplicar desconto (hook - opcional)
        if (deveAplicarDesconto(pedido)) {
            valor = aplicarDesconto(pedido, valor);
        }

        // Passo 4: Processar pagamento (obrigat√≥rio)
        boolean pagamentoOk = processarPagamento(pedido, valor);
        if (!pagamentoOk) {
            return ResultadoProcessamento.erro("Pagamento falhou");
        }

        // Passo 5: Finalizar (hook - opcional)
        onProcessamentoCompleto(pedido, valor);

        return ResultadoProcessamento.sucesso(pedido.id(), valor);
    }

    // Passos abstratos (obrigat√≥rios nas subclasses)
    protected abstract boolean validar(Pedido pedido);
    protected abstract BigDecimal calcularValor(Pedido pedido);
    protected abstract boolean processarPagamento(Pedido pedido, BigDecimal valor);

    // Hooks (m√©todos com implementa√ß√£o padr√£o - opcionais)
    protected boolean deveAplicarDesconto(Pedido pedido) {
        return false; // Padr√£o: sem desconto
    }

    protected BigDecimal aplicarDesconto(Pedido pedido, BigDecimal valor) {
        return valor; // Padr√£o: sem altera√ß√£o
    }

    protected void onProcessamentoCompleto(Pedido pedido, BigDecimal valor) {
        // Hook vazio - subclasse pode implementar
    }
}

record Pedido(String id, String tipo, List<Item> itens, String clienteId) {}
record Item(String produtoId, int quantidade, BigDecimal preco) {}

sealed interface ResultadoProcessamento permits ProcessamentoSucesso, ProcessamentoErro {}
record ProcessamentoSucesso(String pedidoId, BigDecimal valorTotal) implements ResultadoProcessamento {}
record ProcessamentoErro(String mensagem) implements ResultadoProcessamento {}
```

### 2. Implementa√ß√µes Concretas

```java
final class ProcessadorPedidoNormal extends ProcessadorPedidoTemplate {

    @Override
    protected boolean validar(Pedido pedido) {
        System.out.println("‚úÖ Validando pedido normal");
        return pedido.itens() != null && !pedido.itens().isEmpty();
    }

    @Override
    protected BigDecimal calcularValor(Pedido pedido) {
        System.out.println("üí∞ Calculando valor normal");
        return pedido.itens().stream()
            .map(item -> item.preco().multiply(BigDecimal.valueOf(item.quantidade())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Override
    protected boolean processarPagamento(Pedido pedido, BigDecimal valor) {
        System.out.println("üí≥ Processando pagamento normal: " + valor);
        return valor.compareTo(BigDecimal.ZERO) > 0;
    }
}

final class ProcessadorPedidoVIP extends ProcessadorPedidoTemplate {
    private static final BigDecimal DESCONTO_VIP = new BigDecimal("0.10"); // 10%

    @Override
    protected boolean validar(Pedido pedido) {
        System.out.println("‚≠ê Validando pedido VIP");
        return pedido.itens() != null
            && !pedido.itens().isEmpty()
            && pedido.clienteId() != null;
    }

    @Override
    protected BigDecimal calcularValor(Pedido pedido) {
        System.out.println("üíé Calculando valor VIP");
        return pedido.itens().stream()
            .map(item -> item.preco().multiply(BigDecimal.valueOf(item.quantidade())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    @Override
    protected boolean deveAplicarDesconto(Pedido pedido) {
        return true; // VIP sempre tem desconto
    }

    @Override
    protected BigDecimal aplicarDesconto(Pedido pedido, BigDecimal valor) {
        BigDecimal desconto = valor.multiply(DESCONTO_VIP);
        BigDecimal valorComDesconto = valor.subtract(desconto);
        System.out.println("üéÅ Desconto VIP aplicado: " + desconto);
        return valorComDesconto;
    }

    @Override
    protected boolean processarPagamento(Pedido pedido, BigDecimal valor) {
        System.out.println("üí≥ Processamento VIP priorit√°rio: " + valor);
        // Processamento priorit√°rio para VIP
        return true;
    }

    @Override
    protected void onProcessamentoCompleto(Pedido pedido, BigDecimal valor) {
        System.out.println("üéâ Notificando gerente sobre pedido VIP: " + pedido.id());
    }
}

final class ProcessadorPedidoExpresso extends ProcessadorPedidoTemplate {

    @Override
    protected boolean validar(Pedido pedido) {
        System.out.println("‚ö° Valida√ß√£o expressa");
        // Valida√ß√£o simplificada para expresso
        return pedido.itens() != null && pedido.itens().size() <= 5;
    }

    @Override
    protected BigDecimal calcularValor(Pedido pedido) {
        System.out.println("üíµ C√°lculo + taxa expressa");
        BigDecimal subtotal = pedido.itens().stream()
            .map(item -> item.preco().multiply(BigDecimal.valueOf(item.quantidade())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);

        // Taxa expressa
        BigDecimal taxaExpressa = new BigDecimal("15.00");
        return subtotal.add(taxaExpressa);
    }

    @Override
    protected boolean processarPagamento(Pedido pedido, BigDecimal valor) {
        System.out.println("‚ö° Pagamento expresso: " + valor);
        return true;
    }
}
```

### 3. Factory para Template Methods

```java
final class ProcessadorPedidoFactory {

    ProcessadorPedidoTemplate criar(String tipo) {
        return switch (tipo.toUpperCase()) {
            case "NORMAL" -> new ProcessadorPedidoNormal();
            case "VIP" -> new ProcessadorPedidoVIP();
            case "EXPRESSO" -> new ProcessadorPedidoExpresso();
            default -> throw new IllegalArgumentException("Tipo inv√°lido: " + tipo);
        };
    }
}
```

### 4. Template com Callbacks (Alternativa Funcional)

```java
final class ProcessadorPedidoComCallback {

    @FunctionalInterface
    interface ValidadorPedido {
        boolean validar(Pedido pedido);
    }

    @FunctionalInterface
    interface CalculadorValor {
        BigDecimal calcular(Pedido pedido);
    }

    @FunctionalInterface
    interface ProcessadorPagamento {
        boolean processar(Pedido pedido, BigDecimal valor);
    }

    private final ValidadorPedido validador;
    private final CalculadorValor calculador;
    private final ProcessadorPagamento processadorPagamento;

    ProcessadorPedidoComCallback(
        ValidadorPedido validador,
        CalculadorValor calculador,
        ProcessadorPagamento processadorPagamento
    ) {
        this.validador = validador;
        this.calculador = calculador;
        this.processadorPagamento = processadorPagamento;
    }

    // Template Method usando callbacks
    public ResultadoProcessamento processar(Pedido pedido) {
        if (!validador.validar(pedido)) {
            return new ProcessamentoErro("Valida√ß√£o falhou");
        }

        BigDecimal valor = calculador.calcular(pedido);

        if (!processadorPagamento.processar(pedido, valor)) {
            return new ProcessamentoErro("Pagamento falhou");
        }

        return new ProcessamentoSucesso(pedido.id(), valor);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Sequ√™ncia de Execu√ß√£o

```java
@Test
void deveExecutarPassosNaOrdemCorreta() {
    // Arrange
    ProcessadorPedidoTemplate processador = spy(new ProcessadorPedidoNormal());
    Pedido pedido = criarPedidoTeste();

    // Act
    processador.processar(pedido);

    // Assert - Verifica ordem de execu√ß√£o
    InOrder inOrder = inOrder(processador);
    inOrder.verify(processador).validar(pedido);
    inOrder.verify(processador).calcularValor(pedido);
    inOrder.verify(processador).processarPagamento(eq(pedido), any());
}
```

### 2. Testar Hook Method Customizado

```java
@Test
void vipDeveAplicarDesconto() {
    // Arrange
    ProcessadorPedidoVIP processador = new ProcessadorPedidoVIP();
    Pedido pedido = new Pedido(
        "P1",
        "VIP",
        List.of(new Item("PROD1", 1, new BigDecimal("100.00"))),
        "C1"
    );

    // Act
    ResultadoProcessamento resultado = processador.processar(pedido);

    // Assert
    assertInstanceOf(ProcessamentoSucesso.class, resultado);
    ProcessamentoSucesso sucesso = (ProcessamentoSucesso) resultado;

    // 100 - 10% = 90
    assertEquals(new BigDecimal("90.00"), sucesso.valorTotal());
}
```

### 3. Testar Hook Method Padr√£o (N√£o Customizado)

```java
@Test
void normalNaoDeveAplicarDesconto() {
    // Arrange
    ProcessadorPedidoNormal processador = new ProcessadorPedidoNormal();
    Pedido pedido = new Pedido(
        "P1",
        "NORMAL",
        List.of(new Item("PROD1", 1, new BigDecimal("100.00"))),
        "C1"
    );

    // Act
    ResultadoProcessamento resultado = processador.processar(pedido);

    // Assert
    assertInstanceOf(ProcessamentoSucesso.class, resultado);
    ProcessamentoSucesso sucesso = (ProcessamentoSucesso) resultado;

    // Sem desconto
    assertEquals(new BigDecimal("100.00"), sucesso.valorTotal());
}
```

### 4. Testar Valida√ß√£o Falha (Interrompe Fluxo)

```java
@Test
void deveInterromperSeValidacaoFalhar() {
    // Arrange
    ProcessadorPedidoTemplate processador = spy(new ProcessadorPedidoNormal());
    Pedido pedidoInvalido = new Pedido("P1", "NORMAL", List.of(), "C1"); // Sem itens

    // Act
    ResultadoProcessamento resultado = processador.processar(pedidoInvalido);

    // Assert
    assertInstanceOf(ProcessamentoErro.class, resultado);

    // Verifica que passos seguintes N√ÉO foram executados
    verify(processador).validar(pedidoInvalido);
    verify(processador, never()).calcularValor(any());
    verify(processador, never()).processarPagamento(any(), any());
}
```

### 5. Testar Diferentes Implementa√ß√µes do Template

```java
@Test
void expressoDeverAdicionarTaxa() {
    // Arrange
    ProcessadorPedidoExpresso expresso = new ProcessadorPedidoExpresso();
    Pedido pedido = new Pedido(
        "P1",
        "EXPRESSO",
        List.of(new Item("PROD1", 1, new BigDecimal("100.00"))),
        "C1"
    );

    // Act
    ResultadoProcessamento resultado = expresso.processar(pedido);

    // Assert
    assertInstanceOf(ProcessamentoSucesso.class, resultado);
    ProcessamentoSucesso sucesso = (ProcessamentoSucesso) resultado;

    // 100 + 15 (taxa) = 115
    assertEquals(new BigDecimal("115.00"), sucesso.valorTotal());
}
```

### 6. Testar Template com Callback (Funcional)

```java
@Test
void callbackDevePermitirCustomizacao() {
    // Arrange
    ProcessadorPedidoComCallback processador = new ProcessadorPedidoComCallback(
        pedido -> !pedido.itens().isEmpty(),
        pedido -> new BigDecimal("50.00"),
        (pedido, valor) -> true
    );

    Pedido pedido = new Pedido(
        "P1",
        "CUSTOM",
        List.of(new Item("PROD1", 1, BigDecimal.TEN)),
        "C1"
    );

    // Act
    ResultadoProcessamento resultado = processador.processar(pedido);

    // Assert
    assertInstanceOf(ProcessamentoSucesso.class, resultado);
    ProcessamentoSucesso sucesso = (ProcessamentoSucesso) resultado;
    assertEquals(new BigDecimal("50.00"), sucesso.valorTotal());
}
```

### 7. Testar M√©todo Template N√£o Pode Ser Sobrescrito

```java
@Test
void templateMethodDeveSeFinal() throws NoSuchMethodException {
    // Arrange
    Method metodoProcessar = ProcessadorPedidoTemplate.class
        .getMethod("processar", Pedido.class);

    // Assert - Verifica que m√©todo √© final
    assertTrue(Modifier.isFinal(metodoProcessar.getModifiers()),
        "Template Method deve ser final para garantir sequ√™ncia");
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Template method n√£o-final (pode ser sobrescrito)
public ResultadoProcessamento processar(Pedido pedido) {
    // Subclasse pode quebrar sequ√™ncia!
}

// ‚ùå Muitos passos abstratos (dificulta implementa√ß√£o)
abstract class Template {
    protected abstract void passo1();
    protected abstract void passo2();
    protected abstract void passo3();
    protected abstract void passo4();
    protected abstract void passo5();
    protected abstract void passo6(); // Muitos passos!
}

// ‚ùå L√≥gica de neg√≥cio nos hooks
@Override
protected void onCompleto(Pedido pedido) {
    // ‚ùå L√≥gica complexa no hook
    if (pedido.getValor().compareTo(BigDecimal.valueOf(1000)) > 0) {
        enviarEmail();
        notificarGerente();
        atualizarDashboard();
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Template method final
public final ResultadoProcessamento processar(Pedido pedido) {
    // Sequ√™ncia garantida
}

// ‚úÖ Poucos passos abstratos essenciais
abstract class Template {
    protected abstract void validar();
    protected abstract void processar();
    // Apenas essenciais
}

// ‚úÖ Hooks simples
@Override
protected void onCompleto(Pedido pedido) {
    // Hook delegando para service
    notificacaoService.notificar(pedido);
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Template method final**: Garantir sequ√™ncia n√£o seja alterada
- ‚úÖ **Poucos passos abstratos**: Apenas essenciais (3-5)
- ‚úÖ **Hooks opcionais**: Implementa√ß√£o padr√£o vazia
- ‚úÖ **Nomenclatura clara**: `onCompleto()`, `deveAplicar()`, `antes()`
- ‚úÖ **Documenta√ß√£o**: Javadoc explicando quando sobrescrever
- ‚úÖ **Fail fast**: Validar e retornar cedo
- ‚úÖ **Test√°vel**: Spy para verificar ordem de execu√ß√£o

---

## üîó Integra√ß√£o com Frameworks

### Spring Template Pattern

```java
// JdbcTemplate (Spring JDBC)
jdbcTemplate.query(
    "SELECT * FROM users",
    (rs, rowNum) -> new User(rs.getString("name"))
);

// RestTemplate (Spring REST)
restTemplate.execute(
    "http://api.com/resource",
    HttpMethod.GET,
    requestCallback,
    responseExtractor
);
```

### Servlet Template

```java
abstract class BaseServlet extends HttpServlet {

    @Override
    protected final void doGet(HttpServletRequest req, HttpServletResponse resp) {
        if (!validarPermissao(req)) {
            resp.setStatus(403);
            return;
        }

        processarRequisicao(req, resp);

        onRequisicaoCompleta(req);
    }

    protected abstract void processarRequisicao(HttpServletRequest req, HttpServletResponse resp);

    protected boolean validarPermissao(HttpServletRequest req) {
        return true; // Hook
    }

    protected void onRequisicaoCompleta(HttpServletRequest req) {
        // Hook vazio
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                         | ‚ö†Ô∏è Desvantagens                                |
| ------------------------------------ | ---------------------------------------------- |
| Elimina c√≥digo duplicado             | Heran√ßa (acoplamento com superclasse)          |
| Garante sequ√™ncia do algoritmo       | Dif√≠cil entender fluxo completo                |
| Hooks facilitam customiza√ß√£o         | N√∫mero de m√©todos pode crescer                 |
| Facilita testes de ordem de execu√ß√£o | Alternativas funcionais podem ser mais simples |

---

## üîç Compara√ß√£o

| Padr√£o                      | Estrutura  | Flexibilidade                   | Quando Usar                    |
| --------------------------- | ---------- | ------------------------------- | ------------------------------ |
| **Template Method**         | Heran√ßa    | Baixa (sequ√™ncia fixa)          | Algoritmo com passos vari√°veis |
| **Strategy**                | Composi√ß√£o | Alta (troca algoritmo completo) | Algoritmos intercambi√°veis     |
| **Chain of Responsibility** | Composi√ß√£o | M√©dia (ordem din√¢mica)          | Pipeline de processamento      |
| **Command**                 | Composi√ß√£o | Alta (encapsula a√ß√µes)          | Undo/redo, queue               |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar template com retry** (onFalha hook para retry)
2. **Template ass√≠ncrono** com CompletableFuture em cada passo
3. **Template com m√©tricas** (tempo de execu√ß√£o de cada passo)
4. **Template com rollback** (onErro desfaz passos anteriores)
5. **Converter template method para callback** (comparar abordagens)

---

## üìö Relacionado

- **Strategy Pattern**: Trocar algoritmo inteiro vs customizar passos
- **Factory Method**: Criar objetos seguindo template
- **Decorator**: Adicionar comportamento dinamicamente
- **Builder**: Constru√ß√£o em passos (mas sem heran√ßa)

---

**Template Method garante sequ√™ncia de algoritmo e elimina duplica√ß√£o com heran√ßa controlada!** üìã‚ú®
