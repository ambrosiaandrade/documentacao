# 04.21 Adapter Pattern [M√âDIO] üîå

## üéØ Objetivo

Converter a **interface de uma classe** em outra interface esperada pelo cliente, permitindo que classes incompat√≠veis trabalhem juntas e facilitando **testes com mocks de APIs externas**.

---

## üìö O Que √â?

**Adapter** (tamb√©m conhecido como Wrapper) √© um padr√£o estrutural GoF que atua como intermedi√°rio entre duas interfaces incompat√≠veis. Essencial para integrar sistemas legados, APIs de terceiros e criar abstra√ß√µes test√°veis.

### Analogia

Como um **adaptador de tomada**:

- **Cliente**: Aparelho com plug brasileiro (3 pinos)
- **Servi√ßo**: Tomada americana (2 pinos)
- **Adapter**: Adaptador que converte entre os dois
- **Vantagem**: Usar aparelho sem modific√°-lo

---

## ‚ùå Problema que Resolve

### Antes (Acoplamento com API Externa)

```java
// ‚ùå PROBLEMA: C√≥digo acoplado com API de terceiro
import com.external.legacy.LegacyPaymentGateway;
import com.external.legacy.LegacyTransaction;

public class CheckoutService {
    private final LegacyPaymentGateway gateway = new LegacyPaymentGateway();

    public void processar(Pedido pedido) {
        // Formato espec√≠fico da API legada
        LegacyTransaction transaction = new LegacyTransaction();
        transaction.setAccountId(pedido.getClienteId());
        transaction.setAmount(pedido.getValor().doubleValue());
        transaction.setCurrency("BRL");
        transaction.setDescription("Pedido: " + pedido.getId());

        try {
            gateway.executePayment(transaction);
        } catch (LegacyException e) {
            throw new RuntimeException("Falha no pagamento", e);
        }
    }
}

// Problemas:
// - Acoplamento forte com API legada
// - Imposs√≠vel mockar LegacyPaymentGateway para testes
// - Trocar gateway = reescrever CheckoutService
// - Exce√ß√µes da API legada vazam para dom√≠nio
```

**Problemas**:

- üîó Acoplamento forte com implementa√ß√£o externa
- üß™ Dif√≠cil testar (depend√™ncia real da API)
- üîß Trocar implementa√ß√£o = reescrever cliente
- üêõ Exce√ß√µes e tipos externos vazam

### Depois (Adapter Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Interface pr√≥pria + Adapter
interface PagamentoGateway {
    ResultadoPagamento processar(DadosPagamento dados);
}

record DadosPagamento(String clienteId, BigDecimal valor, String descricao) {}
record ResultadoPagamento(boolean sucesso, String transacaoId, String mensagem) {}

// Adapter para API legada
class LegacyGatewayAdapter implements PagamentoGateway {
    private final LegacyPaymentGateway legacyGateway;

    LegacyGatewayAdapter(LegacyPaymentGateway legacyGateway) {
        this.legacyGateway = legacyGateway;
    }

    @Override
    public ResultadoPagamento processar(DadosPagamento dados) {
        // Converte formato pr√≥prio ‚Üí legado
        LegacyTransaction transaction = new LegacyTransaction();
        transaction.setAccountId(dados.clienteId());
        transaction.setAmount(dados.valor().doubleValue());
        transaction.setCurrency("BRL");
        transaction.setDescription(dados.descricao());

        try {
            legacyGateway.executePayment(transaction);
            return new ResultadoPagamento(true, "TXN-123", "Sucesso");
        } catch (LegacyException e) {
            return new ResultadoPagamento(false, null, e.getMessage());
        }
    }
}

// Service desacoplado
public class CheckoutService {
    private final PagamentoGateway gateway;

    public CheckoutService(PagamentoGateway gateway) {
        this.gateway = gateway;
    }

    public void processar(Pedido pedido) {
        DadosPagamento dados = new DadosPagamento(
            pedido.getClienteId(),
            pedido.getValor(),
            "Pedido: " + pedido.getId()
        );

        ResultadoPagamento resultado = gateway.processar(dados);

        if (!resultado.sucesso()) {
            throw new PagamentoException(resultado.mensagem());
        }
    }
}

// Teste com mock
@Test
void deveProcessarPagamento() {
    PagamentoGateway mock = mock(PagamentoGateway.class);
    when(mock.processar(any())).thenReturn(
        new ResultadoPagamento(true, "TXN-1", "OK")
    );

    CheckoutService service = new CheckoutService(mock);
    service.processar(pedido);

    verify(mock).processar(any());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Target (Nossa Interface)

```java
interface NotificacaoService {
    void enviar(Notificacao notificacao);
    boolean isDisponivel();
}

record Notificacao(
    String destinatario,
    String assunto,
    String mensagem,
    TipoNotificacao tipo
) {}

enum TipoNotificacao { EMAIL, SMS, PUSH }
```

### 2. Adapter para Email (API Externa)

```java
// API externa que queremos adaptar
class ExternalEmailAPI {
    public void sendMessage(String to, String subject, String body, Map<String, String> headers) {
        System.out.println("üìß ExternalEmailAPI.sendMessage()");
        System.out.println("   To: " + to);
        System.out.println("   Subject: " + subject);
    }

    public boolean isServiceOnline() {
        return true;
    }
}

// Adapter
final class EmailAdapter implements NotificacaoService {
    private final ExternalEmailAPI emailAPI;

    EmailAdapter(ExternalEmailAPI emailAPI) {
        this.emailAPI = emailAPI;
    }

    @Override
    public void enviar(Notificacao notificacao) {
        if (notificacao.tipo() != TipoNotificacao.EMAIL) {
            throw new IllegalArgumentException("Adapter s√≥ suporta EMAIL");
        }

        // Converte nosso formato ‚Üí formato da API externa
        Map<String, String> headers = Map.of(
            "X-Priority", "Normal",
            "Content-Type", "text/plain"
        );

        emailAPI.sendMessage(
            notificacao.destinatario(),
            notificacao.assunto(),
            notificacao.mensagem(),
            headers
        );

        System.out.println("‚úÖ Email adaptado e enviado");
    }

    @Override
    public boolean isDisponivel() {
        return emailAPI.isServiceOnline();
    }
}
```

### 3. Adapter para SMS (API Diferente)

```java
// Outra API externa com interface completamente diferente
class ThirdPartySMSGateway {
    public int send(String phoneNumber, String text) {
        System.out.println("üì± ThirdPartySMSGateway.send()");
        System.out.println("   Phone: " + phoneNumber);
        System.out.println("   Text: " + text);
        return 200; // C√≥digo de status
    }

    public String getStatus() {
        return "ONLINE";
    }
}

// Adapter
final class SMSAdapter implements NotificacaoService {
    private final ThirdPartySMSGateway smsGateway;

    SMSAdapter(ThirdPartySMSGateway smsGateway) {
        this.smsGateway = smsGateway;
    }

    @Override
    public void enviar(Notificacao notificacao) {
        if (notificacao.tipo() != TipoNotificacao.SMS) {
            throw new IllegalArgumentException("Adapter s√≥ suporta SMS");
        }

        // Formata mensagem para SMS
        String textoCompleto = notificacao.assunto() + ": " + notificacao.mensagem();

        int statusCode = smsGateway.send(
            notificacao.destinatario(),
            textoCompleto
        );

        if (statusCode != 200) {
            throw new RuntimeException("Falha ao enviar SMS: " + statusCode);
        }

        System.out.println("‚úÖ SMS adaptado e enviado");
    }

    @Override
    public boolean isDisponivel() {
        return "ONLINE".equals(smsGateway.getStatus());
    }
}
```

### 4. Adapter com M√©tricas e Circuit Breaker

```java
final class NotificacaoAdapterComMetricas implements NotificacaoService {
    private final NotificacaoService delegate;
    private final AtomicInteger envios = new AtomicInteger(0);
    private final AtomicInteger falhas = new AtomicInteger(0);
    private final String adapterName;

    NotificacaoAdapterComMetricas(String name, NotificacaoService delegate) {
        this.adapterName = name;
        this.delegate = delegate;
    }

    @Override
    public void enviar(Notificacao notificacao) {
        envios.incrementAndGet();

        try {
            long inicio = System.currentTimeMillis();

            delegate.enviar(notificacao);

            long duracao = System.currentTimeMillis() - inicio;
            System.out.println("‚è± " + adapterName + " - Dura√ß√£o: " + duracao + "ms");

        } catch (Exception e) {
            falhas.incrementAndGet();
            System.err.println("‚ùå " + adapterName + " - Falha: " + e.getMessage());
            throw e;
        }
    }

    @Override
    public boolean isDisponivel() {
        return delegate.isDisponivel();
    }

    AdapterMetrics getMetrics() {
        return new AdapterMetrics(
            adapterName,
            envios.get(),
            falhas.get(),
            calcularTaxaSucesso()
        );
    }

    private double calcularTaxaSucesso() {
        int total = envios.get();
        if (total == 0) return 100.0;

        int sucessos = total - falhas.get();
        return (sucessos * 100.0) / total;
    }
}

record AdapterMetrics(String adapter, int envios, int falhas, double taxaSucesso) {}
```

### 5. Service com Multiple Adapters

```java
final class NotificacaoCompostaService {
    private final Map<TipoNotificacao, NotificacaoService> adapters = new EnumMap<>(TipoNotificacao.class);

    void registrar(TipoNotificacao tipo, NotificacaoService adapter) {
        adapters.put(tipo, adapter);
        System.out.println("‚úÖ Adapter registrado: " + tipo);
    }

    void enviar(Notificacao notificacao) {
        NotificacaoService adapter = adapters.get(notificacao.tipo());

        if (adapter == null) {
            throw new IllegalArgumentException(
                "Nenhum adapter registrado para: " + notificacao.tipo()
            );
        }

        if (!adapter.isDisponivel()) {
            throw new RuntimeException(
                "Adapter indispon√≠vel: " + notificacao.tipo()
            );
        }

        adapter.enviar(notificacao);
    }

    void enviarParaTodos(String mensagem) {
        adapters.forEach((tipo, adapter) -> {
            try {
                Notificacao notif = new Notificacao(
                    "destinatario@example.com",
                    "Alerta",
                    mensagem,
                    tipo
                );
                adapter.enviar(notif);
            } catch (Exception e) {
                System.err.println("‚ùå Falha ao enviar via " + tipo + ": " + e.getMessage());
            }
        });
    }

    Set<TipoNotificacao> tiposDisponiveis() {
        return adapters.entrySet().stream()
            .filter(entry -> entry.getValue().isDisponivel())
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet());
    }
}
```

### 6. Object Adapter vs Class Adapter

```java
// Object Adapter (Composi√ß√£o) - PREFERIDO
class EmailObjectAdapter implements NotificacaoService {
    private final ExternalEmailAPI emailAPI; // Composi√ß√£o

    EmailObjectAdapter(ExternalEmailAPI emailAPI) {
        this.emailAPI = emailAPI;
    }

    @Override
    public void enviar(Notificacao notificacao) {
        emailAPI.sendMessage(
            notificacao.destinatario(),
            notificacao.assunto(),
            notificacao.mensagem(),
            Map.of()
        );
    }

    @Override
    public boolean isDisponivel() {
        return emailAPI.isServiceOnline();
    }
}

// Class Adapter (Heran√ßa) - EVITAR em Java (heran√ßa √∫nica)
// Apenas ilustrativo - n√£o recomendado
abstract class EmailClassAdapter extends ExternalEmailAPI implements NotificacaoService {
    @Override
    public void enviar(Notificacao notificacao) {
        super.sendMessage(
            notificacao.destinatario(),
            notificacao.assunto(),
            notificacao.mensagem(),
            Map.of()
        );
    }

    @Override
    public boolean isDisponivel() {
        return super.isServiceOnline();
    }
}
```

---

## üß™ Como Testar

### 1. Testar Adapter Converte Corretamente

```java
@Test
void adapterDeveConverterFormatoCorretamente() {
    // Arrange
    ExternalEmailAPI apiMock = mock(ExternalEmailAPI.class);
    EmailAdapter adapter = new EmailAdapter(apiMock);

    Notificacao notif = new Notificacao(
        "test@example.com",
        "Assunto Teste",
        "Mensagem teste",
        TipoNotificacao.EMAIL
    );

    // Act
    adapter.enviar(notif);

    // Assert - Verifica convers√£o de formato
    ArgumentCaptor<String> toCaptor = ArgumentCaptor.forClass(String.class);
    ArgumentCaptor<String> subjectCaptor = ArgumentCaptor.forClass(String.class);
    ArgumentCaptor<String> bodyCaptor = ArgumentCaptor.forClass(String.class);

    verify(apiMock).sendMessage(
        toCaptor.capture(),
        subjectCaptor.capture(),
        bodyCaptor.capture(),
        any()
    );

    assertEquals("test@example.com", toCaptor.getValue());
    assertEquals("Assunto Teste", subjectCaptor.getValue());
    assertEquals("Mensagem teste", bodyCaptor.getValue());
}
```

### 2. Testar Service Desacoplado

```java
@Test
void serviceDeveUsarAdapterSemConhecerImplementacao() {
    // Arrange
    NotificacaoService adapterMock = mock(NotificacaoService.class);
    when(adapterMock.isDisponivel()).thenReturn(true);

    NotificacaoCompostaService service = new NotificacaoCompostaService();
    service.registrar(TipoNotificacao.EMAIL, adapterMock);

    Notificacao notif = new Notificacao(
        "test@example.com",
        "Teste",
        "Mensagem",
        TipoNotificacao.EMAIL
    );

    // Act
    service.enviar(notif);

    // Assert
    verify(adapterMock).enviar(notif);
}
```

### 3. Testar M√∫ltiplos Adapters

```java
@Test
void deveSuportarMultiplosAdapters() {
    // Arrange
    NotificacaoCompostaService service = new NotificacaoCompostaService();

    NotificacaoService emailMock = mock(NotificacaoService.class);
    NotificacaoService smsMock = mock(NotificacaoService.class);

    when(emailMock.isDisponivel()).thenReturn(true);
    when(smsMock.isDisponivel()).thenReturn(true);

    service.registrar(TipoNotificacao.EMAIL, emailMock);
    service.registrar(TipoNotificacao.SMS, smsMock);

    // Act & Assert - Email
    Notificacao email = new Notificacao("test@email.com", "T", "M", TipoNotificacao.EMAIL);
    service.enviar(email);
    verify(emailMock).enviar(email);

    // Act & Assert - SMS
    Notificacao sms = new Notificacao("+5511999999999", "T", "M", TipoNotificacao.SMS);
    service.enviar(sms);
    verify(smsMock).enviar(sms);
}
```

### 4. Testar M√©tricas do Adapter

```java
@Test
void adapterComMetricasDeveRastrearEnvios() {
    // Arrange
    NotificacaoService delegateMock = mock(NotificacaoService.class);
    NotificacaoAdapterComMetricas adapter = new NotificacaoAdapterComMetricas(
        "TestAdapter",
        delegateMock
    );

    Notificacao notif = new Notificacao("test", "T", "M", TipoNotificacao.EMAIL);

    // Act
    adapter.enviar(notif);
    adapter.enviar(notif);
    adapter.enviar(notif);

    AdapterMetrics metrics = adapter.getMetrics();

    // Assert
    assertEquals(3, metrics.envios());
    assertEquals(0, metrics.falhas());
    assertEquals(100.0, metrics.taxaSucesso());
}
```

### 5. Testar Fallback em Falha

```java
@Test
void adapterDeveTratarFalhasDaAPIExterna() {
    // Arrange
    ExternalEmailAPI apiMock = mock(ExternalEmailAPI.class);
    doThrow(new RuntimeException("API indispon√≠vel"))
        .when(apiMock).sendMessage(anyString(), anyString(), anyString(), any());

    EmailAdapter adapter = new EmailAdapter(apiMock);
    Notificacao notif = new Notificacao("test", "T", "M", TipoNotificacao.EMAIL);

    // Act & Assert
    assertThrows(RuntimeException.class, () -> adapter.enviar(notif));
}
```

### 6. Testar Adapter Rejeita Tipo Incompat√≠vel

```java
@Test
void emailAdapterDeveRejeitarSMS() {
    // Arrange
    EmailAdapter adapter = new EmailAdapter(new ExternalEmailAPI());
    Notificacao smshNotif = new Notificacao(
        "+5511999999999",
        "SMS",
        "Mensagem",
        TipoNotificacao.SMS // Tipo incompat√≠vel!
    );

    // Act & Assert
    IllegalArgumentException ex = assertThrows(
        IllegalArgumentException.class,
        () -> adapter.enviar(smsNotif)
    );

    assertTrue(ex.getMessage().contains("EMAIL"));
}
```

### 7. Testar Disponibilidade do Adapter

```java
@Test
void deveVerificarDisponibilidadeAntesDeEnviar() {
    // Arrange
    NotificacaoService adapterMock = mock(NotificacaoService.class);
    when(adapterMock.isDisponivel()).thenReturn(false);

    NotificacaoCompostaService service = new NotificacaoCompostaService();
    service.registrar(TipoNotificacao.EMAIL, adapterMock);

    Notificacao notif = new Notificacao("test", "T", "M", TipoNotificacao.EMAIL);

    // Act & Assert
    RuntimeException ex = assertThrows(
        RuntimeException.class,
        () -> service.enviar(notif)
    );

    assertTrue(ex.getMessage().contains("indispon√≠vel"));
    verify(adapterMock, never()).enviar(any());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Vazamento de tipos externos
public LegacyTransaction processar(Pedido pedido) {
    // Retorna tipo da API externa ‚ùå
    return legacyGateway.execute();
}

// ‚ùå Adapter com l√≥gica de neg√≥cio
class EmailAdapter implements NotificacaoService {
    public void enviar(Notificacao notif) {
        // Valida√ß√£o de neg√≥cio no adapter ‚ùå
        if (notif.mensagem().length() > 1000) {
            throw new BusinessException("Mensagem muito longa");
        }
        emailAPI.send(notif);
    }
}

// ‚ùå Adapter stateful
class SMSAdapter {
    private int contadorEnvios = 0; // Estado ‚ùå

    public void enviar(Notificacao notif) {
        contadorEnvios++; // N√£o √© responsabilidade do adapter
        smsAPI.send(notif);
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Retornar tipos pr√≥prios
public ResultadoPagamento processar(DadosPagamento dados) {
    LegacyTransaction tx = legacyGateway.execute();
    // Converte para tipo pr√≥prio
    return new ResultadoPagamento(tx.isSuccess(), tx.getId());
}

// ‚úÖ Adapter apenas adapta
class EmailAdapter implements NotificacaoService {
    public void enviar(Notificacao notif) {
        // Apenas convers√£o de formato
        emailAPI.sendMessage(
            notif.destinatario(),
            notif.assunto(),
            notif.mensagem(),
            Map.of()
        );
    }
}

// ‚úÖ Stateless
class SMSAdapter {
    public void enviar(Notificacao notif) {
        // Sem estado interno
        smsAPI.send(notif.destinatario(), notif.mensagem());
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Composi√ß√£o sobre heran√ßa**: Object Adapter prefer√≠vel
- ‚úÖ **Interface pr√≥pria**: N√£o vazar tipos externos
- ‚úÖ **Stateless**: Adapter sem estado interno
- ‚úÖ **Apenas convers√£o**: Sem l√≥gica de neg√≥cio
- ‚úÖ **Tratamento de exce√ß√µes**: Converter exce√ß√µes externas
- ‚úÖ **M√©tricas**: Instrumentar adapters para observabilidade
- ‚úÖ **M√∫ltiplos adapters**: Strategy para trocar implementa√ß√µes

---

## üîó Integra√ß√£o com Frameworks

### Spring Adapter Pattern

```java
@Configuration
public class NotificacaoConfig {

    @Bean
    @ConditionalOnProperty(name = "notificacao.tipo", havingValue = "email")
    public NotificacaoService emailAdapter() {
        return new EmailAdapter(new ExternalEmailAPI());
    }

    @Bean
    @ConditionalOnProperty(name = "notificacao.tipo", havingValue = "sms")
    public NotificacaoService smsAdapter() {
        return new SMSAdapter(new ThirdPartySMSGateway());
    }
}
```

### Retrofit Adapter (HTTP Client)

```java
interface GitHubService {
    @GET("users/{user}/repos")
    Call<List<Repo>> listRepos(@Path("user") String user);
}

// Retrofit usa Adapter Pattern internamente
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("https://api.github.com/")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                               | ‚ö†Ô∏è Desvantagens                   |
| ------------------------------------------ | --------------------------------- |
| Desacopla c√≥digo de APIs externas          | Camada adicional de indire√ß√£o     |
| Facilita testes com mocks                  | Mais classes para manter          |
| Trocar implementa√ß√£o sem modificar cliente | Convers√£o de dados pode ter custo |
| Isola mudan√ßas de APIs externas            | Pode esconder complexidade        |

---

## üîç Compara√ß√£o

| Padr√£o        | Prop√≥sito                        | Quando Usar                    |
| ------------- | -------------------------------- | ------------------------------ |
| **Adapter**   | Converter interface incompat√≠vel | Integrar APIs externas/legadas |
| **Facade**    | Simplificar interface complexa   | Unificar m√∫ltiplas APIs        |
| **Decorator** | Adicionar comportamento          | Enriquecer funcionalidade      |
| **Proxy**     | Controlar acesso                 | Lazy loading, cache, seguran√ßa |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Adapter com cache** (cachear respostas da API externa)
2. **Adapter com retry** (tentar novamente em falha)
3. **Adapter bidirecional** (converter nos dois sentidos)
4. **Adapter para gRPC** (converter REST ‚Üí gRPC)
5. **Adapter com rate limiting** (limitar chamadas √† API externa)

---

## üìö Relacionado

- **Facade**: Simplificar interface complexa
- **Bridge**: Separar abstra√ß√£o de implementa√ß√£o
- **Proxy**: Controlar acesso a objeto
- **Decorator**: Adicionar comportamento dinamicamente

---

**Adapter Pattern isola c√≥digo de depend√™ncias externas e facilita testes com mocks!** üîå‚ú®
