# 04.42 REST Architecture (RESTful APIs) [INTERMEDI√ÅRIO] üåê

## üéØ Objetivo

Criar APIs usando **recursos HTTP** com opera√ß√µes padronizadas (GET, POST, PUT, DELETE), permitindo **testes de contrato REST** e comunica√ß√£o stateless escal√°vel.

---

## üìö O Que √â?

**REST (Representational State Transfer)** √© um estilo arquitetural para APIs web que usa HTTP como protocolo, trata recursos como entidades identificadas por URIs, e opera com verbos HTTP padronizados.

### Analogia

Como **biblioteca p√∫blica**:

- **Livros (Recursos)**: Cada livro tem um c√≥digo √∫nico (URI)
- **A√ß√µes (Verbos HTTP)**: Consultar (GET), Reservar (POST), Atualizar (PUT), Devolver (DELETE)
- **Fichas (JSON)**: Informa√ß√µes sobre o livro
- **Vantagem**: Sistema padronizado que qualquer um entende

---

## ‚ùå Problema que Resolve

### Antes (API N√£o-RESTful)

```java
// ‚ùå PROBLEMA: API sem padr√£o, verbos inconsistentes

@RestController
class PedidoController {

    // Tudo via POST ‚ùå
    @PostMapping("/criarPedido")
    PedidoDTO criarPedido(@RequestBody PedidoRequest request) {
        // ...
    }

    @PostMapping("/buscarPedido")
    PedidoDTO buscarPedido(@RequestBody Long id) { // ID no body ‚ùå
        // ...
    }

    @PostMapping("/atualizarPedido")
    void atualizarPedido(@RequestBody PedidoRequest request) {
        // ...
    }

    @PostMapping("/deletarPedido")
    void deletarPedido(@RequestBody Long id) {
        // ...
    }

    // URLs n√£o padronizadas ‚ùå
    @GetMapping("/getPedidoById")
    @GetMapping("/pedido-por-id")
    @GetMapping("/pedidos/buscar")

    // Status codes incorretos ‚ùå
    @PostMapping("/criar")
    ResponseEntity<PedidoDTO> criar() {
        return ResponseEntity.ok(pedido); // 200 em vez de 201 ‚ùå
    }
}

// Problemas:
// - Verbos HTTP inconsistentes ‚ùå
// - URLs n√£o padronizadas ‚ùå
// - Status codes incorretos ‚ùå
// - Sem HATEOAS (links) ‚ùå
// - Dif√≠cil documentar ‚ùå
// - Sem versionamento ‚ùå
```

**Problemas**:

- üîÄ Verbos inconsistentes
- üìç URLs n√£o padronizadas
- üö¶ Status codes incorretos
- üîó Sem navegabilidade (HATEOAS)
- üìÑ Dif√≠cil documentar

### Depois (RESTful API)

```java
// ‚úÖ SOLU√á√ÉO: API RESTful com padr√µes

@RestController
@RequestMapping("/api/v1/pedidos") // Versionamento ‚úÖ
public class PedidoController {

    private final PedidoService service;

    @Autowired
    public PedidoController(PedidoService service) {
        this.service = service;
    }

    // CREATE - POST retorna 201 Created ‚úÖ
    @PostMapping
    public ResponseEntity<PedidoDTO> criar(@RequestBody @Valid CriarPedidoRequest request) {
        PedidoDTO pedido = service.criarPedido(request);

        // URI do recurso criado ‚úÖ
        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(pedido.getId())
            .toUri();

        return ResponseEntity.created(location).body(pedido);
    }

    // READ - GET retorna 200 OK ou 404 Not Found ‚úÖ
    @GetMapping("/{id}")
    public ResponseEntity<PedidoDTO> buscar(@PathVariable Long id) {
        return service.buscarPedido(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    // READ ALL - GET com pagina√ß√£o ‚úÖ
    @GetMapping
    public ResponseEntity<Page<PedidoDTO>> listar(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size,
        @RequestParam(required = false) String status
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<PedidoDTO> pedidos = service.listarPedidos(status, pageable);

        return ResponseEntity.ok(pedidos);
    }

    // UPDATE - PUT atualiza completamente ‚úÖ
    @PutMapping("/{id}")
    public ResponseEntity<PedidoDTO> atualizar(
        @PathVariable Long id,
        @RequestBody @Valid AtualizarPedidoRequest request
    ) {
        PedidoDTO atualizado = service.atualizarPedido(id, request);
        return ResponseEntity.ok(atualizado);
    }

    // PARTIAL UPDATE - PATCH atualiza parcialmente ‚úÖ
    @PatchMapping("/{id}/status")
    public ResponseEntity<PedidoDTO> atualizarStatus(
        @PathVariable Long id,
        @RequestBody @Valid AtualizarStatusRequest request
    ) {
        PedidoDTO atualizado = service.atualizarStatus(id, request.status());
        return ResponseEntity.ok(atualizado);
    }

    // DELETE - DELETE retorna 204 No Content ‚úÖ
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletar(@PathVariable Long id) {
        service.deletarPedido(id);
        return ResponseEntity.noContent().build();
    }

    // Sub-recursos ‚úÖ
    @GetMapping("/{id}/itens")
    public ResponseEntity<List<ItemPedidoDTO>> listarItens(@PathVariable Long id) {
        List<ItemPedidoDTO> itens = service.buscarItensPedido(id);
        return ResponseEntity.ok(itens);
    }

    // A√ß√µes customizadas (n√£o-CRUD) ‚úÖ
    @PostMapping("/{id}/aprovar")
    public ResponseEntity<PedidoDTO> aprovar(@PathVariable Long id) {
        PedidoDTO aprovado = service.aprovarPedido(id);
        return ResponseEntity.ok(aprovado);
    }

    @PostMapping("/{id}/cancelar")
    public ResponseEntity<PedidoDTO> cancelar(
        @PathVariable Long id,
        @RequestBody @Valid CancelarPedidoRequest request
    ) {
        PedidoDTO cancelado = service.cancelarPedido(id, request.motivo());
        return ResponseEntity.ok(cancelado);
    }
}

// ‚úÖ Vantagens:
// - Verbos HTTP padronizados (GET/POST/PUT/PATCH/DELETE) ‚úÖ
// - URLs claras e hier√°rquicas ‚úÖ
// - Status codes corretos (200, 201, 204, 404, 400) ‚úÖ
// - Stateless (sem sess√£o no servidor) ‚úÖ
// - Cacheable (GET requests) ‚úÖ
// - Versionamento expl√≠cito (/api/v1) ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Controller RESTful Completo

```java
// Controller com todos os recursos REST

@RestController
@RequestMapping("/api/v1/produtos")
@Validated
public class ProdutoController {

    private final ProdutoService service;

    @Autowired
    public ProdutoController(ProdutoService service) {
        this.service = service;
    }

    // CREATE
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ResponseEntity<ProdutoDTO> criar(
        @RequestBody @Valid CriarProdutoRequest request
    ) {
        System.out.println("üì• POST /api/v1/produtos");

        ProdutoDTO produto = service.criar(request);

        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(produto.getId())
            .toUri();

        return ResponseEntity
            .created(location)
            .body(produto);
    }

    // READ
    @GetMapping("/{id}")
    public ResponseEntity<ProdutoDTO> buscar(@PathVariable Long id) {
        System.out.println("üì• GET /api/v1/produtos/" + id);

        return service.buscarPorId(id)
            .map(produto -> ResponseEntity
                .ok()
                .cacheControl(CacheControl.maxAge(60, TimeUnit.SECONDS))
                .body(produto))
            .orElse(ResponseEntity.notFound().build());
    }

    // READ ALL com filtros e pagina√ß√£o
    @GetMapping
    public ResponseEntity<Page<ProdutoDTO>> listar(
        @RequestParam(required = false) String nome,
        @RequestParam(required = false) BigDecimal precoMax,
        @RequestParam(required = false) Boolean disponivel,
        @PageableDefault(size = 20, sort = "nome") Pageable pageable
    ) {
        System.out.println("üì• GET /api/v1/produtos?page=" + pageable.getPageNumber());

        ProdutoFiltro filtro = new ProdutoFiltro(nome, precoMax, disponivel);
        Page<ProdutoDTO> produtos = service.listar(filtro, pageable);

        return ResponseEntity.ok(produtos);
    }

    // UPDATE completo
    @PutMapping("/{id}")
    public ResponseEntity<ProdutoDTO> atualizar(
        @PathVariable Long id,
        @RequestBody @Valid AtualizarProdutoRequest request
    ) {
        System.out.println("üì• PUT /api/v1/produtos/" + id);

        ProdutoDTO atualizado = service.atualizar(id, request);
        return ResponseEntity.ok(atualizado);
    }

    // PARTIAL UPDATE
    @PatchMapping("/{id}")
    public ResponseEntity<ProdutoDTO> atualizarParcial(
        @PathVariable Long id,
        @RequestBody Map<String, Object> updates
    ) {
        System.out.println("üì• PATCH /api/v1/produtos/" + id);

        ProdutoDTO atualizado = service.atualizarParcial(id, updates);
        return ResponseEntity.ok(atualizado);
    }

    // DELETE
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletar(@PathVariable Long id) {
        System.out.println("üì• DELETE /api/v1/produtos/" + id);

        service.deletar(id);
        return ResponseEntity.noContent().build();
    }

    // Sub-recursos
    @GetMapping("/{id}/avaliacoes")
    public ResponseEntity<List<AvaliacaoDTO>> listarAvaliacoes(@PathVariable Long id) {
        List<AvaliacaoDTO> avaliacoes = service.buscarAvaliacoes(id);
        return ResponseEntity.ok(avaliacoes);
    }

    @PostMapping("/{id}/avaliacoes")
    public ResponseEntity<AvaliacaoDTO> adicionarAvaliacao(
        @PathVariable Long id,
        @RequestBody @Valid CriarAvaliacaoRequest request
    ) {
        AvaliacaoDTO avaliacao = service.adicionarAvaliacao(id, request);
        return ResponseEntity.status(HttpStatus.CREATED).body(avaliacao);
    }

    // A√ß√µes n√£o-CRUD
    @PostMapping("/{id}/estoque/reservar")
    public ResponseEntity<Void> reservarEstoque(
        @PathVariable Long id,
        @RequestBody @Valid ReservarEstoqueRequest request
    ) {
        service.reservarEstoque(id, request.quantidade());
        return ResponseEntity.ok().build();
    }

    @PostMapping("/{id}/estoque/liberar")
    public ResponseEntity<Void> liberarEstoque(
        @PathVariable Long id,
        @RequestBody @Valid LiberarEstoqueRequest request
    ) {
        service.liberarEstoque(id, request.quantidade());
        return ResponseEntity.ok().build();
    }

    // HEAD - verificar exist√™ncia
    @RequestMapping(value = "/{id}", method = RequestMethod.HEAD)
    public ResponseEntity<Void> verificarExistencia(@PathVariable Long id) {
        boolean existe = service.existe(id);
        return existe ? ResponseEntity.ok().build() : ResponseEntity.notFound().build();
    }

    // OPTIONS - retorna opera√ß√µes permitidas
    @RequestMapping(method = RequestMethod.OPTIONS)
    public ResponseEntity<Void> options() {
        return ResponseEntity
            .ok()
            .allow(HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT,
                   HttpMethod.PATCH, HttpMethod.DELETE, HttpMethod.HEAD, HttpMethod.OPTIONS)
            .build();
    }
}
```

### 2. DTOs e Valida√ß√£o

```java
// Request DTOs com valida√ß√£o

public record CriarProdutoRequest(
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String nome,

    @NotBlank(message = "Descri√ß√£o √© obrigat√≥ria")
    @Size(max = 500, message = "Descri√ß√£o deve ter no m√°ximo 500 caracteres")
    String descricao,

    @NotNull(message = "Pre√ßo √© obrigat√≥rio")
    @DecimalMin(value = "0.01", message = "Pre√ßo deve ser maior que zero")
    BigDecimal preco,

    @NotNull(message = "Estoque √© obrigat√≥rio")
    @Min(value = 0, message = "Estoque n√£o pode ser negativo")
    Integer estoque,

    @NotNull(message = "Categoria √© obrigat√≥ria")
    Long categoriaId
) {}

public record AtualizarProdutoRequest(
    @NotBlank String nome,
    String descricao,
    @DecimalMin("0.01") BigDecimal preco,
    @Min(0) Integer estoque,
    Long categoriaId
) {}

// Response DTO com HATEOAS
public class ProdutoDTO {
    private Long id;
    private String nome;
    private String descricao;
    private BigDecimal preco;
    private Integer estoque;
    private CategoriaDTO categoria;
    private LocalDateTime dataCriacao;
    private LocalDateTime dataAtualizacao;

    // HATEOAS - links relacionados
    private Map<String, String> links;

    public static ProdutoDTO from(Produto produto) {
        ProdutoDTO dto = new ProdutoDTO();
        dto.setId(produto.getId());
        dto.setNome(produto.getNome());
        dto.setDescricao(produto.getDescricao());
        dto.setPreco(produto.getPreco());
        dto.setEstoque(produto.getEstoque());
        dto.setCategoria(CategoriaDTO.from(produto.getCategoria()));
        dto.setDataCriacao(produto.getDataCriacao());
        dto.setDataAtualizacao(produto.getDataAtualizacao());

        // Adicionar links (HATEOAS)
        dto.setLinks(Map.of(
            "self", "/api/v1/produtos/" + produto.getId(),
            "avaliacoes", "/api/v1/produtos/" + produto.getId() + "/avaliacoes",
            "categoria", "/api/v1/categorias/" + produto.getCategoria().getId()
        ));

        return dto;
    }

    // Getters e Setters
}

// Response paginado
public class PageResponse<T> {
    private List<T> content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;

    public static <T> PageResponse<T> from(Page<T> page) {
        PageResponse<T> response = new PageResponse<>();
        response.setContent(page.getContent());
        response.setPage(page.getNumber());
        response.setSize(page.getSize());
        response.setTotalElements(page.getTotalElements());
        response.setTotalPages(page.getTotalPages());
        response.setFirst(page.isFirst());
        response.setLast(page.isLast());
        return response;
    }
}
```

### 3. Exception Handling (REST)

```java
// Global exception handler para respostas REST

@RestControllerAdvice
public class RestExceptionHandler {

    // 404 Not Found
    @ExceptionHandler(ResourceNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ErrorResponse handleNotFound(ResourceNotFoundException ex) {
        System.err.println("‚ùå 404 Not Found: " + ex.getMessage());

        return new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            "Recurso n√£o encontrado",
            ex.getMessage(),
            LocalDateTime.now()
        );
    }

    // 400 Bad Request - valida√ß√£o
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ValidationErrorResponse handleValidation(MethodArgumentNotValidException ex) {
        System.err.println("‚ùå 400 Bad Request: Valida√ß√£o falhou");

        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );

        return new ValidationErrorResponse(
            HttpStatus.BAD_REQUEST.value(),
            "Erro de valida√ß√£o",
            errors,
            LocalDateTime.now()
        );
    }

    // 409 Conflict
    @ExceptionHandler(BusinessRuleException.class)
    @ResponseStatus(HttpStatus.CONFLICT)
    public ErrorResponse handleBusinessRule(BusinessRuleException ex) {
        System.err.println("‚ùå 409 Conflict: " + ex.getMessage());

        return new ErrorResponse(
            HttpStatus.CONFLICT.value(),
            "Regra de neg√≥cio violada",
            ex.getMessage(),
            LocalDateTime.now()
        );
    }

    // 500 Internal Server Error
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ErrorResponse handleGeneric(Exception ex) {
        System.err.println("‚ùå 500 Internal Error: " + ex.getMessage());
        ex.printStackTrace();

        return new ErrorResponse(
            HttpStatus.INTERNAL_SERVER_ERROR.value(),
            "Erro interno do servidor",
            "Ocorreu um erro inesperado",
            LocalDateTime.now()
        );
    }
}

// Error response DTOs
public record ErrorResponse(
    int status,
    String error,
    String message,
    LocalDateTime timestamp
) {}

public record ValidationErrorResponse(
    int status,
    String error,
    Map<String, String> violations,
    LocalDateTime timestamp
) {}
```

### 4. CORS e Seguran√ßa

```java
// Configura√ß√£o CORS para APIs REST

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins("http://localhost:3000", "https://app.example.com")
            .allowedMethods("GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS")
            .allowedHeaders("*")
            .exposedHeaders("Location", "Content-Disposition")
            .allowCredentials(true)
            .maxAge(3600);
    }
}

// Security para REST API
@Configuration
@EnableWebSecurity
public class RestSecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // Desabilitar CSRF para APIs stateless
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS) // Stateless
            .and()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/public/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/v1/produtos/**").permitAll()
                .requestMatchers("/api/v1/produtos/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic(); // Ou JWT

        return http.build();
    }
}
```

### 5. Versionamento de API

```java
// Estrat√©gias de versionamento

// 1. Versionamento por URI (mais comum)
@RestController
@RequestMapping("/api/v1/produtos")
class ProdutoControllerV1 { }

@RestController
@RequestMapping("/api/v2/produtos")
class ProdutoControllerV2 { }

// 2. Versionamento por Header
@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @GetMapping(headers = "X-API-Version=1")
    public List<ProdutoDTO> listarV1() { }

    @GetMapping(headers = "X-API-Version=2")
    public List<ProdutoDTO> listarV2() { }
}

// 3. Versionamento por Content Negotiation
@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    @GetMapping(produces = "application/vnd.api.v1+json")
    public List<ProdutoDTO> listarV1() { }

    @GetMapping(produces = "application/vnd.api.v2+json")
    public List<ProdutoDTO> listarV2() { }
}
```

### 6. Cliente REST (Consumer)

```java
// Cliente para consumir API REST

@Service
public class ProdutoRestClient {

    private final RestTemplate restTemplate;
    private final String baseUrl;

    public ProdutoRestClient(
        @Value("${produto.api.url}") String baseUrl,
        RestTemplate restTemplate
    ) {
        this.baseUrl = baseUrl;
        this.restTemplate = restTemplate;
    }

    public ProdutoDTO criar(CriarProdutoRequest request) {
        System.out.println("üì§ POST " + baseUrl + "/produtos");

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(getToken());

        HttpEntity<CriarProdutoRequest> entity = new HttpEntity<>(request, headers);

        ResponseEntity<ProdutoDTO> response = restTemplate.exchange(
            baseUrl + "/produtos",
            HttpMethod.POST,
            entity,
            ProdutoDTO.class
        );

        return response.getBody();
    }

    public Optional<ProdutoDTO> buscar(Long id) {
        System.out.println("üì§ GET " + baseUrl + "/produtos/" + id);

        try {
            ProdutoDTO produto = restTemplate.getForObject(
                baseUrl + "/produtos/{id}",
                ProdutoDTO.class,
                id
            );
            return Optional.ofNullable(produto);

        } catch (HttpClientErrorException.NotFound e) {
            return Optional.empty();
        }
    }

    public Page<ProdutoDTO> listar(int page, int size) {
        System.out.println("üì§ GET " + baseUrl + "/produtos?page=" + page);

        UriComponentsBuilder builder = UriComponentsBuilder
            .fromHttpUrl(baseUrl + "/produtos")
            .queryParam("page", page)
            .queryParam("size", size);

        ResponseEntity<RestPage<ProdutoDTO>> response = restTemplate.exchange(
            builder.toUriString(),
            HttpMethod.GET,
            null,
            new ParameterizedTypeReference<>() {}
        );

        return response.getBody();
    }

    public void deletar(Long id) {
        System.out.println("üì§ DELETE " + baseUrl + "/produtos/" + id);

        restTemplate.delete(baseUrl + "/produtos/{id}", id);
    }

    private String getToken() {
        // Obter token de autentica√ß√£o
        return "your-jwt-token";
    }
}

// RestTemplate configuration
@Configuration
public class RestTemplateConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder
            .setConnectTimeout(Duration.ofSeconds(10))
            .setReadTimeout(Duration.ofSeconds(30))
            .interceptors(new LoggingInterceptor())
            .errorHandler(new CustomErrorHandler())
            .build();
    }
}

// Interceptor para logging
class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(
        HttpRequest request,
        byte[] body,
        ClientHttpRequestExecution execution
    ) throws IOException {

        System.out.println("üì° Request: " + request.getMethod() + " " + request.getURI());

        ClientHttpResponse response = execution.execute(request, body);

        System.out.println("üì° Response: " + response.getStatusCode());

        return response;
    }
}
```

---

## üß™ Como Testar

### 1. Teste de Controller (MockMvc)

```java
@WebMvcTest(ProdutoController.class)
class ProdutoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProdutoService service;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    void deveCriarProdutoComStatus201() throws Exception {
        // Arrange
        CriarProdutoRequest request = new CriarProdutoRequest(
            "Notebook",
            "Notebook Dell",
            new BigDecimal("3000"),
            10,
            1L
        );

        ProdutoDTO produtoDTO = new ProdutoDTO();
        produtoDTO.setId(1L);
        produtoDTO.setNome(request.nome());

        when(service.criar(any())).thenReturn(produtoDTO);

        // Act & Assert
        mockMvc.perform(post("/api/v1/produtos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(header().exists("Location"))
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.nome").value("Notebook"));
    }

    @Test
    void deveBuscarProdutoComStatus200() throws Exception {
        // Arrange
        ProdutoDTO produto = new ProdutoDTO();
        produto.setId(1L);
        produto.setNome("Notebook");

        when(service.buscarPorId(1L)).thenReturn(Optional.of(produto));

        // Act & Assert
        mockMvc.perform(get("/api/v1/produtos/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.nome").value("Notebook"));
    }

    @Test
    void deveRetornar404QuandoProdutoNaoExiste() throws Exception {
        // Arrange
        when(service.buscarPorId(999L)).thenReturn(Optional.empty());

        // Act & Assert
        mockMvc.perform(get("/api/v1/produtos/999"))
            .andExpect(status().isNotFound());
    }

    @Test
    void deveRetornar400QuandoValidacaoFalha() throws Exception {
        // Arrange - request inv√°lido
        String invalidRequest = """
            {
                "nome": "",
                "preco": -10
            }
            """;

        // Act & Assert
        mockMvc.perform(post("/api/v1/produtos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(invalidRequest))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.violations").exists());
    }

    @Test
    void deveDeletarProdutoComStatus204() throws Exception {
        // Arrange
        doNothing().when(service).deletar(1L);

        // Act & Assert
        mockMvc.perform(delete("/api/v1/produtos/1"))
            .andExpect(status().isNoContent());
    }
}
```

### 2. Teste de Integra√ß√£o REST

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ProdutoRestIntegrationTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Autowired
    private ProdutoRepository repository;

    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }

    @Test
    void deveCriarBuscarAtualizarDeletarProduto() {
        String baseUrl = "http://localhost:" + port + "/api/v1/produtos";

        // 1. CREATE
        CriarProdutoRequest request = new CriarProdutoRequest(
            "Notebook",
            "Notebook Dell",
            new BigDecimal("3000"),
            10,
            1L
        );

        ResponseEntity<ProdutoDTO> createResponse = restTemplate.postForEntity(
            baseUrl,
            request,
            ProdutoDTO.class
        );

        assertEquals(HttpStatus.CREATED, createResponse.getStatusCode());
        assertNotNull(createResponse.getHeaders().getLocation());
        Long produtoId = createResponse.getBody().getId();

        // 2. READ
        ResponseEntity<ProdutoDTO> getResponse = restTemplate.getForEntity(
            baseUrl + "/" + produtoId,
            ProdutoDTO.class
        );

        assertEquals(HttpStatus.OK, getResponse.getStatusCode());
        assertEquals("Notebook", getResponse.getBody().getNome());

        // 3. UPDATE
        AtualizarProdutoRequest updateRequest = new AtualizarProdutoRequest(
            "Notebook Atualizado",
            "Descri√ß√£o atualizada",
            new BigDecimal("3500"),
            15,
            1L
        );

        restTemplate.put(baseUrl + "/" + produtoId, updateRequest);

        ProdutoDTO updated = restTemplate.getForObject(
            baseUrl + "/" + produtoId,
            ProdutoDTO.class
        );

        assertEquals("Notebook Atualizado", updated.getNome());

        // 4. DELETE
        restTemplate.delete(baseUrl + "/" + produtoId);

        ResponseEntity<ProdutoDTO> deletedResponse = restTemplate.getForEntity(
            baseUrl + "/" + produtoId,
            ProdutoDTO.class
        );

        assertEquals(HttpStatus.NOT_FOUND, deletedResponse.getStatusCode());
    }
}
```

### 3. Teste de Cliente REST

```java
@SpringBootTest
class ProdutoRestClientTest {

    @Autowired
    private ProdutoRestClient client;

    private MockRestServiceServer mockServer;

    @BeforeEach
    void setUp() {
        RestTemplate restTemplate = client.getRestTemplate();
        mockServer = MockRestServiceServer.createServer(restTemplate);
    }

    @Test
    void deveBuscarProdutoViaRestClient() throws Exception {
        // Arrange
        String expectedJson = """
            {
                "id": 1,
                "nome": "Notebook",
                "preco": 3000
            }
            """;

        mockServer.expect(requestTo(containsString("/produtos/1")))
            .andExpect(method(HttpMethod.GET))
            .andRespond(withSuccess(expectedJson, MediaType.APPLICATION_JSON));

        // Act
        Optional<ProdutoDTO> resultado = client.buscar(1L);

        // Assert
        assertTrue(resultado.isPresent());
        assertEquals("Notebook", resultado.get().getNome());

        mockServer.verify();
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Verbos HTTP**: GET (read), POST (create), PUT (update), DELETE (delete)
- ‚úÖ **Status Codes**: 200 (OK), 201 (Created), 204 (No Content), 400 (Bad Request), 404 (Not Found)
- ‚úÖ **Stateless**: N√£o manter sess√£o no servidor
- ‚úÖ **Versionamento**: /api/v1, /api/v2
- ‚úÖ **Pagina√ß√£o**: Usar Page/Pageable
- ‚úÖ **Filtros**: Query params para filtros
- ‚úÖ **HATEOAS**: Incluir links relacionados
- ‚úÖ **Cache**: Usar ETags e Cache-Control

---

## üîó REST vs Outras Arquiteturas

| Caracter√≠stica    | REST                | GraphQL                  | SOAP     | gRPC              |
| ----------------- | ------------------- | ------------------------ | -------- | ----------------- |
| **Protocolo**     | HTTP/JSON           | HTTP/JSON                | HTTP/XML | HTTP/2 + Protobuf |
| **Performance**   | Boa                 | Boa                      | Baixa    | Excelente         |
| **Verbos**        | GET/POST/PUT/DELETE | POST (queries/mutations) | POST     | Streaming         |
| **Documenta√ß√£o**  | OpenAPI             | Schema                   | WSDL     | Proto files       |
| **Flexibilidade** | M√©dia               | Alta                     | Baixa    | M√©dia             |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens          | ‚ö†Ô∏è Desvantagens              |
| --------------------- | ---------------------------- |
| Simples e intuitivo   | Over-fetching/Under-fetching |
| Stateless (escal√°vel) | M√∫ltiplas requisi√ß√µes        |
| Cacheable             | Sem tipagem forte            |
| Padronizado           | Sem streaming nativo         |
| Tooling maduro        | Versionamento manual         |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use REST quando:

- API p√∫blica/aberta
- CRUD simples
- Recursos bem definidos
- Compatibilidade ampla necess√°ria

### ‚ùå Evite REST quando:

- Queries complexas (use GraphQL)
- Performance cr√≠tica (use gRPC)
- Real-time necess√°rio (use WebSocket)
- Streaming de dados (use gRPC)

---

**REST Architecture cria APIs com recursos HTTP padronizados, permitindo comunica√ß√£o stateless e testes de contrato!** üåê‚ú®
