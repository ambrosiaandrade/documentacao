# 04.38 Orchestrator Pattern [AVAN√áADO] üé≠

## üéØ Objetivo

Coordenar **workflows complexos** atrav√©s de um orquestrador centralizado que gerencia a sequ√™ncia de chamadas a servi√ßos, permitindo **testes de saga** e compensa√ß√£o em caso de falhas.

---

## üìö O Que √â?

**Orchestrator Pattern** usa um componente central (orquestrador) para coordenar a execu√ß√£o de m√∫ltiplos servi√ßos em uma sequ√™ncia definida. O orquestrador conhece toda a l√≥gica de neg√≥cio e decide qual servi√ßo chamar e quando.

### Analogia

Como **maestro de orquestra**:

- **Maestro (Orchestrator)**: Coordena todos os m√∫sicos
- **M√∫sicos (Servi√ßos)**: Tocam quando maestro indica
- **Partitura (Workflow)**: Define a sequ√™ncia de execu√ß√£o
- **Vantagem**: Coordena√ß√£o centralizada, m√∫sicos n√£o precisam conhecer a m√∫sica completa

---

## ‚ùå Problema que Resolve

### Antes (Servi√ßos Chamando Uns aos Outros - Choreography)

```java
// ‚ùå PROBLEMA: L√≥gica distribu√≠da, dif√≠cil rastrear fluxo

// Servi√ßo 1: Pedido chama Estoque
@Service
class PedidoService {

    @Autowired
    private EstoqueClient estoqueClient; // Conhece pr√≥ximo passo ‚ùå

    @Transactional
    void criarPedido(Pedido pedido) {
        repository.save(pedido);

        // Chama pr√≥ximo servi√ßo ‚ùå
        estoqueClient.reservar(pedido.getItens());
    }
}

// Servi√ßo 2: Estoque chama Pagamento
@Service
class EstoqueService {

    @Autowired
    private PagamentoClient pagamentoClient; // Conhece pr√≥ximo passo ‚ùå

    void reservar(List<Item> itens) {
        // Reserva estoque
        for (Item item : itens) {
            reservarItem(item);
        }

        // Chama pr√≥ximo servi√ßo ‚ùå
        pagamentoClient.processar(calcularTotal(itens));
    }
}

// Servi√ßo 3: Pagamento chama Nota Fiscal
@Service
class PagamentoService {

    @Autowired
    private NotaFiscalClient notaFiscalClient; // Conhece pr√≥ximo passo ‚ùå

    void processar(BigDecimal valor) {
        // Processa pagamento
        processarPagamento(valor);

        // Chama pr√≥ximo servi√ßo ‚ùå
        notaFiscalClient.emitir(valor);
    }
}

// Problemas:
// - L√≥gica de workflow distribu√≠da em v√°rios servi√ßos ‚ùå
// - Dif√≠cil rastrear fluxo completo ‚ùå
// - Compensa√ß√£o complexa (quem reverte o qu√™?) ‚ùå
// - Acoplamento entre servi√ßos ‚ùå
// - Dif√≠cil testar fluxo completo ‚ùå
// - Mudan√ßa no workflow = alterar m√∫ltiplos servi√ßos ‚ùå
```

**Problemas**:

- üåê L√≥gica distribu√≠da
- üîç Dif√≠cil rastrear
- ‚Ü©Ô∏è Compensa√ß√£o complexa
- üîó Acoplamento entre servi√ßos
- üß™ Dif√≠cil testar

### Depois (Orchestrator Centralizado)

```java
// ‚úÖ SOLU√á√ÉO: Orquestrador centraliza l√≥gica de workflow

@Service
class PedidoOrchestrator {

    private final PedidoRepository pedidoRepository;
    private final EstoqueService estoqueService;
    private final PagamentoService pagamentoService;
    private final NotaFiscalService notaFiscalService;
    private final EmailService emailService;

    @Transactional
    PedidoDTO executarWorkflow(CriarPedidoRequest request) {
        System.out.println("üé≠ [Orchestrator] Iniciando workflow de pedido");

        // Contexto da saga
        WorkflowContext ctx = new WorkflowContext();

        try {
            // 1. Criar pedido
            System.out.println("1Ô∏è‚É£ Criando pedido...");
            Pedido pedido = pedidoRepository.save(new Pedido(request));
            ctx.setPedidoId(pedido.getId());

            // 2. Reservar estoque
            System.out.println("2Ô∏è‚É£ Reservando estoque...");
            ReservaResponse reserva = estoqueService.reservar(request.itens());
            ctx.setReservaId(reserva.id());

            // 3. Processar pagamento
            System.out.println("3Ô∏è‚É£ Processando pagamento...");
            PagamentoResponse pagamento = pagamentoService.processar(
                new PagamentoRequest(pedido.getValorTotal(), request.cartao())
            );
            ctx.setPagamentoId(pagamento.transacaoId());

            // 4. Emitir nota fiscal
            System.out.println("4Ô∏è‚É£ Emitindo nota fiscal...");
            NotaFiscalResponse nf = notaFiscalService.emitir(
                new EmitirNotaRequest(pedido.getId(), request.clienteId())
            );
            ctx.setNotaFiscalId(nf.numero());

            // 5. Enviar confirma√ß√£o
            System.out.println("5Ô∏è‚É£ Enviando confirma√ß√£o...");
            emailService.enviarConfirmacao(request.clienteId(), pedido.getId());

            // 6. Atualizar status
            pedido.setStatus(StatusPedido.CONFIRMADO);
            pedidoRepository.save(pedido);

            System.out.println("‚úÖ [Orchestrator] Workflow conclu√≠do com sucesso!");

            return PedidoDTO.from(pedido);

        } catch (Exception e) {
            System.err.println("‚ùå [Orchestrator] Erro no workflow: " + e.getMessage());

            // Compensa√ß√£o centralizada ‚úÖ
            compensar(ctx);

            throw new WorkflowException("Falha ao executar workflow", e);
        }
    }

    // Compensa√ß√£o centralizada (Saga Rollback) ‚úÖ
    private void compensar(WorkflowContext ctx) {
        System.out.println("üîÑ [Orchestrator] Iniciando compensa√ß√£o...");

        // Ordem inversa de compensa√ß√£o
        if (ctx.getNotaFiscalId() != null) {
            try {
                notaFiscalService.cancelar(ctx.getNotaFiscalId());
                System.out.println("‚Ü©Ô∏è Nota fiscal cancelada");
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao cancelar nota: " + e.getMessage());
            }
        }

        if (ctx.getPagamentoId() != null) {
            try {
                pagamentoService.estornar(ctx.getPagamentoId());
                System.out.println("‚Ü©Ô∏è Pagamento estornado");
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao estornar: " + e.getMessage());
            }
        }

        if (ctx.getReservaId() != null) {
            try {
                estoqueService.liberar(ctx.getReservaId());
                System.out.println("‚Ü©Ô∏è Estoque liberado");
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao liberar estoque: " + e.getMessage());
            }
        }

        if (ctx.getPedidoId() != null) {
            try {
                Pedido pedido = pedidoRepository.findById(ctx.getPedidoId()).orElse(null);
                if (pedido != null) {
                    pedido.setStatus(StatusPedido.CANCELADO);
                    pedidoRepository.save(pedido);
                }
                System.out.println("‚Ü©Ô∏è Pedido cancelado");
            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao cancelar pedido: " + e.getMessage());
            }
        }

        System.out.println("‚úÖ [Orchestrator] Compensa√ß√£o conclu√≠da");
    }
}

// Contexto que rastreia o workflow
@Data
class WorkflowContext {
    private Long pedidoId;
    private String reservaId;
    private String pagamentoId;
    private String notaFiscalId;
}

// ‚úÖ Vantagens:
// - L√≥gica de workflow centralizada ‚úÖ
// - F√°cil rastrear fluxo completo ‚úÖ
// - Compensa√ß√£o simples e confi√°vel ‚úÖ
// - Servi√ßos desacoplados ‚úÖ
// - F√°cil testar (mock services) ‚úÖ
// - Mudan√ßa no workflow = alterar apenas orquestrador ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Orquestrador com State Machine

```java
// Orquestrador com m√°quina de estados

@Service
public class PedidoWorkflowOrchestrator {

    private final Map<Long, WorkflowState> workflows = new ConcurrentHashMap<>();

    private final PedidoRepository pedidoRepository;
    private final EstoqueService estoqueService;
    private final PagamentoService pagamentoService;
    private final NotaFiscalService notaFiscalService;
    private final LogisticaService logisticaService;

    @Autowired
    public PedidoWorkflowOrchestrator(
        PedidoRepository pedidoRepository,
        EstoqueService estoqueService,
        PagamentoService pagamentoService,
        NotaFiscalService notaFiscalService,
        LogisticaService logisticaService
    ) {
        this.pedidoRepository = pedidoRepository;
        this.estoqueService = estoqueService;
        this.pagamentoService = pagamentoService;
        this.notaFiscalService = notaFiscalService;
        this.logisticaService = logisticaService;
    }

    public WorkflowResult executarWorkflow(CriarPedidoRequest request) {
        WorkflowState state = new WorkflowState();
        Long workflowId = System.currentTimeMillis();
        workflows.put(workflowId, state);

        try {
            // Etapa 1: Criar Pedido
            state.setCurrentStep(WorkflowStep.CRIAR_PEDIDO);
            Pedido pedido = executarCriarPedido(request, state);

            // Etapa 2: Validar Cliente
            state.setCurrentStep(WorkflowStep.VALIDAR_CLIENTE);
            executarValidarCliente(pedido.getClienteId(), state);

            // Etapa 3: Reservar Estoque
            state.setCurrentStep(WorkflowStep.RESERVAR_ESTOQUE);
            executarReservarEstoque(pedido, state);

            // Etapa 4: Processar Pagamento
            state.setCurrentStep(WorkflowStep.PROCESSAR_PAGAMENTO);
            executarProcessarPagamento(pedido, state);

            // Etapa 5: Emitir Nota Fiscal
            state.setCurrentStep(WorkflowStep.EMITIR_NOTA);
            executarEmitirNota(pedido, state);

            // Etapa 6: Agendar Entrega
            state.setCurrentStep(WorkflowStep.AGENDAR_ENTREGA);
            executarAgendarEntrega(pedido, state);

            // Etapa 7: Enviar Notifica√ß√µes
            state.setCurrentStep(WorkflowStep.NOTIFICAR_CLIENTE);
            executarNotificarCliente(pedido, state);

            // Finaliza√ß√£o
            state.setCurrentStep(WorkflowStep.CONCLUIDO);
            pedido.setStatus(StatusPedido.CONFIRMADO);
            pedidoRepository.save(pedido);

            return new WorkflowResult(true, pedido.getId(), state);

        } catch (Exception e) {
            System.err.println("‚ùå Falha em: " + state.getCurrentStep());

            // Compensa√ß√£o baseada no estado
            compensarAteEtapa(state);

            state.setCurrentStep(WorkflowStep.FALHOU);
            state.setErrorMessage(e.getMessage());

            return new WorkflowResult(false, null, state);
        }
    }

    private Pedido executarCriarPedido(CriarPedidoRequest request, WorkflowState state) {
        System.out.println("üé¨ Executando: CRIAR_PEDIDO");

        Pedido pedido = new Pedido();
        pedido.setClienteId(request.clienteId());
        pedido.setStatus(StatusPedido.PROCESSANDO);

        request.itens().forEach(itemReq -> {
            ItemPedido item = new ItemPedido(
                itemReq.produtoId(),
                itemReq.quantidade(),
                itemReq.precoUnitario()
            );
            pedido.adicionarItem(item);
        });

        Pedido salvo = pedidoRepository.save(pedido);
        state.setPedidoId(salvo.getId());

        return salvo;
    }

    private void executarValidarCliente(Long clienteId, WorkflowState state) {
        System.out.println("üé¨ Executando: VALIDAR_CLIENTE");

        // Simula√ß√£o de valida√ß√£o
        if (clienteId == null || clienteId <= 0) {
            throw new ClienteInvalidoException("Cliente inv√°lido: " + clienteId);
        }

        state.setClienteValidado(true);
    }

    private void executarReservarEstoque(Pedido pedido, WorkflowState state) {
        System.out.println("üé¨ Executando: RESERVAR_ESTOQUE");

        List<ItemReservaRequest> itens = pedido.getItens().stream()
            .map(item -> new ItemReservaRequest(item.getProdutoId(), item.getQuantidade()))
            .toList();

        ReservaResponse reserva = estoqueService.reservar(new ReservaRequest(itens));
        state.setReservaId(reserva.id());
    }

    private void executarProcessarPagamento(Pedido pedido, WorkflowState state) {
        System.out.println("üé¨ Executando: PROCESSAR_PAGAMENTO");

        PagamentoResponse pagamento = pagamentoService.processar(
            new PagamentoRequest(pedido.getValorTotal(), "CARTAO-123")
        );

        state.setPagamentoId(pagamento.transacaoId());
    }

    private void executarEmitirNota(Pedido pedido, WorkflowState state) {
        System.out.println("üé¨ Executando: EMITIR_NOTA");

        NotaFiscalResponse nf = notaFiscalService.emitir(
            new EmitirNotaRequest(pedido.getId(), pedido.getClienteId())
        );

        state.setNotaFiscalId(nf.numero());
    }

    private void executarAgendarEntrega(Pedido pedido, WorkflowState state) {
        System.out.println("üé¨ Executando: AGENDAR_ENTREGA");

        EntregaResponse entrega = logisticaService.agendar(
            new AgendarEntregaRequest(pedido.getId(), pedido.getClienteId())
        );

        state.setEntregaId(entrega.codigoRastreio());
    }

    private void executarNotificarCliente(Pedido pedido, WorkflowState state) {
        System.out.println("üé¨ Executando: NOTIFICAR_CLIENTE");

        // Notifica√ß√£o (pode falhar sem afetar workflow principal)
        try {
            // emailService.enviar(...)
            state.setClienteNotificado(true);
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao notificar (n√£o cr√≠tico): " + e.getMessage());
            state.setClienteNotificado(false);
        }
    }

    private void compensarAteEtapa(WorkflowState state) {
        System.out.println("üîÑ Compensando at√© etapa: " + state.getCurrentStep());

        WorkflowStep etapaFalha = state.getCurrentStep();

        // Compensa√ß√£o em ordem inversa
        if (etapaFalha.ordinal() >= WorkflowStep.AGENDAR_ENTREGA.ordinal()
            && state.getEntregaId() != null) {
            compensarAgendarEntrega(state);
        }

        if (etapaFalha.ordinal() >= WorkflowStep.EMITIR_NOTA.ordinal()
            && state.getNotaFiscalId() != null) {
            compensarEmitirNota(state);
        }

        if (etapaFalha.ordinal() >= WorkflowStep.PROCESSAR_PAGAMENTO.ordinal()
            && state.getPagamentoId() != null) {
            compensarProcessarPagamento(state);
        }

        if (etapaFalha.ordinal() >= WorkflowStep.RESERVAR_ESTOQUE.ordinal()
            && state.getReservaId() != null) {
            compensarReservarEstoque(state);
        }

        if (state.getPedidoId() != null) {
            compensarCriarPedido(state);
        }
    }

    private void compensarAgendarEntrega(WorkflowState state) {
        try {
            logisticaService.cancelarEntrega(state.getEntregaId());
            System.out.println("‚Ü©Ô∏è Entrega cancelada");
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao cancelar entrega: " + e.getMessage());
        }
    }

    private void compensarEmitirNota(WorkflowState state) {
        try {
            notaFiscalService.cancelar(state.getNotaFiscalId());
            System.out.println("‚Ü©Ô∏è Nota fiscal cancelada");
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao cancelar nota: " + e.getMessage());
        }
    }

    private void compensarProcessarPagamento(WorkflowState state) {
        try {
            pagamentoService.estornar(state.getPagamentoId());
            System.out.println("‚Ü©Ô∏è Pagamento estornado");
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao estornar pagamento: " + e.getMessage());
        }
    }

    private void compensarReservarEstoque(WorkflowState state) {
        try {
            estoqueService.liberar(state.getReservaId());
            System.out.println("‚Ü©Ô∏è Estoque liberado");
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao liberar estoque: " + e.getMessage());
        }
    }

    private void compensarCriarPedido(WorkflowState state) {
        try {
            Pedido pedido = pedidoRepository.findById(state.getPedidoId()).orElse(null);
            if (pedido != null) {
                pedido.setStatus(StatusPedido.CANCELADO);
                pedidoRepository.save(pedido);
            }
            System.out.println("‚Ü©Ô∏è Pedido cancelado");
        } catch (Exception e) {
            System.err.println("‚ö†Ô∏è Falha ao cancelar pedido: " + e.getMessage());
        }
    }

    public WorkflowState getWorkflowState(Long workflowId) {
        return workflows.get(workflowId);
    }
}

// Estados do workflow
enum WorkflowStep {
    CRIAR_PEDIDO,
    VALIDAR_CLIENTE,
    RESERVAR_ESTOQUE,
    PROCESSAR_PAGAMENTO,
    EMITIR_NOTA,
    AGENDAR_ENTREGA,
    NOTIFICAR_CLIENTE,
    CONCLUIDO,
    FALHOU
}

// Estado do workflow
@Data
class WorkflowState {
    private WorkflowStep currentStep;
    private Long pedidoId;
    private String reservaId;
    private String pagamentoId;
    private String notaFiscalId;
    private String entregaId;
    private boolean clienteValidado;
    private boolean clienteNotificado;
    private String errorMessage;
    private LocalDateTime startTime = LocalDateTime.now();
    private LocalDateTime endTime;
}

// Resultado do workflow
record WorkflowResult(
    boolean sucesso,
    Long pedidoId,
    WorkflowState state
) {}
```

### 2. Orquestrador Ass√≠ncrono

```java
// Orquestrador com execu√ß√£o ass√≠ncrona

@Service
public class AsyncPedidoOrchestrator {

    private final ExecutorService executor = Executors.newFixedThreadPool(10);

    @Async
    public CompletableFuture<PedidoDTO> executarWorkflowAsync(CriarPedidoRequest request) {
        return CompletableFuture.supplyAsync(() -> {
            System.out.println("üé≠ [Async Orchestrator] Iniciando workflow ass√≠ncrono");

            try {
                // Etapa 1: Criar pedido
                Pedido pedido = criarPedido(request);

                // Etapas paralelas (independentes)
                CompletableFuture<ReservaResponse> estoqueFuture =
                    CompletableFuture.supplyAsync(() ->
                        estoqueService.reservar(new ReservaRequest(request.itens())),
                        executor
                    );

                CompletableFuture<ClienteDTO> clienteFuture =
                    CompletableFuture.supplyAsync(() ->
                        clienteService.buscar(request.clienteId()),
                        executor
                    );

                // Aguarda tarefas paralelas
                CompletableFuture.allOf(estoqueFuture, clienteFuture).join();

                ReservaResponse reserva = estoqueFuture.get();
                ClienteDTO cliente = clienteFuture.get();

                // Etapas sequenciais
                PagamentoResponse pagamento = processarPagamento(pedido);
                NotaFiscalResponse nf = emitirNota(pedido);

                // Finaliza√ß√£o
                pedido.setStatus(StatusPedido.CONFIRMADO);
                pedidoRepository.save(pedido);

                System.out.println("‚úÖ [Async Orchestrator] Workflow conclu√≠do");

                return PedidoDTO.from(pedido);

            } catch (Exception e) {
                System.err.println("‚ùå [Async Orchestrator] Erro: " + e.getMessage());
                throw new CompletionException(e);
            }
        }, executor);
    }
}
```

### 3. Orquestrador com Retry e Circuit Breaker

```java
// Orquestrador resiliente

@Service
public class ResilientOrchestrator {

    private final CircuitBreaker circuitBreaker;
    private final Retry retry;

    public ResilientOrchestrator() {
        // Circuit Breaker
        CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
            .failureRateThreshold(50)
            .waitDurationInOpenState(Duration.ofSeconds(30))
            .slidingWindowSize(10)
            .build();

        this.circuitBreaker = CircuitBreaker.of("pedido-workflow", cbConfig);

        // Retry
        RetryConfig retryConfig = RetryConfig.custom()
            .maxAttempts(3)
            .waitDuration(Duration.ofSeconds(2))
            .retryExceptions(TransientException.class)
            .build();

        this.retry = Retry.of("pedido-workflow", retryConfig);
    }

    public PedidoDTO executarComResiliencia(CriarPedidoRequest request) {
        // Combina Retry + Circuit Breaker
        Supplier<PedidoDTO> supplier = () -> executarWorkflow(request);

        supplier = Retry.decorateSupplier(retry, supplier);
        supplier = CircuitBreaker.decorateSupplier(circuitBreaker, supplier);

        try {
            return supplier.get();
        } catch (Exception e) {
            System.err.println("‚ùå Workflow falhou ap√≥s retries: " + e.getMessage());
            throw new WorkflowException("Falha persistente no workflow", e);
        }
    }

    private PedidoDTO executarWorkflow(CriarPedidoRequest request) {
        // L√≥gica do workflow
        // ...
        return new PedidoDTO();
    }
}
```

---

## üß™ Como Testar

### 1. Teste de Workflow Completo

```java
@SpringBootTest
class PedidoOrchestratorTest {

    @MockBean
    private EstoqueService estoqueService;

    @MockBean
    private PagamentoService pagamentoService;

    @MockBean
    private NotaFiscalService notaFiscalService;

    @Autowired
    private PedidoWorkflowOrchestrator orchestrator;

    @Test
    void deveExecutarWorkflowCompletoComSucesso() {
        // Arrange
        when(estoqueService.reservar(any()))
            .thenReturn(new ReservaResponse("R123", List.of(), LocalDateTime.now()));

        when(pagamentoService.processar(any()))
            .thenReturn(new PagamentoResponse("P123", true));

        when(notaFiscalService.emitir(any()))
            .thenReturn(new NotaFiscalResponse("NF123"));

        // Act
        WorkflowResult result = orchestrator.executarWorkflow(criarRequest());

        // Assert
        assertTrue(result.sucesso());
        assertEquals(WorkflowStep.CONCLUIDO, result.state().getCurrentStep());

        // Verifica ordem de chamadas
        InOrder inOrder = inOrder(estoqueService, pagamentoService, notaFiscalService);
        inOrder.verify(estoqueService).reservar(any());
        inOrder.verify(pagamentoService).processar(any());
        inOrder.verify(notaFiscalService).emitir(any());
    }
}
```

### 2. Teste de Compensa√ß√£o

```java
@Test
void deveCompensarQuandoFalharEmEtapaIntermediaria() {
    // Arrange - falha no pagamento
    when(estoqueService.reservar(any()))
        .thenReturn(new ReservaResponse("R123", List.of(), LocalDateTime.now()));

    when(pagamentoService.processar(any()))
        .thenThrow(new PagamentoException("Cart√£o recusado"));

    // Act
    WorkflowResult result = orchestrator.executarWorkflow(criarRequest());

    // Assert
    assertFalse(result.sucesso());
    assertEquals(WorkflowStep.FALHOU, result.state().getCurrentStep());

    // Verifica compensa√ß√£o
    verify(estoqueService).liberar("R123"); // Compensou reserva
    verify(pagamentoService, never()).estornar(any()); // N√£o processou
}
```

### 3. Teste de Estado do Workflow

```java
@Test
void deveRastrearEstadoDoWorkflow() {
    // Arrange
    when(estoqueService.reservar(any()))
        .thenReturn(new ReservaResponse("R123", List.of(), LocalDateTime.now()));

    // Act
    WorkflowResult result = orchestrator.executarWorkflow(criarRequest());
    WorkflowState state = result.state();

    // Assert
    assertNotNull(state.getPedidoId());
    assertEquals("R123", state.getReservaId());
    assertTrue(state.isClienteValidado());
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Idempot√™ncia**: Opera√ß√µes podem ser reexecutadas
- ‚úÖ **Timeout**: Definir limites de tempo por etapa
- ‚úÖ **Logging**: Registrar cada etapa para auditoria
- ‚úÖ **Compensa√ß√£o**: Ordem inversa de execu√ß√£o
- ‚úÖ **State Machine**: Rastrear estado do workflow
- ‚úÖ **Async**: Etapas independentes em paralelo
- ‚úÖ **Retry**: Tentar novamente falhas transientes

---

## üîó Orchestration vs Choreography

| Caracter√≠stica      | Orchestration           | Choreography        |
| ------------------- | ----------------------- | ------------------- |
| **Coordena√ß√£o**     | Centralizada            | Distribu√≠da         |
| **Controle**        | Orquestrador            | Cada servi√ßo        |
| **Rastreabilidade** | F√°cil                   | Dif√≠cil             |
| **Acoplamento**     | Alto (orquestrador)     | Baixo               |
| **Complexidade**    | Simples de entender     | Complexo            |
| **Compensa√ß√£o**     | Centralizada            | Distribu√≠da         |
| **Uso**             | Workflows bem definidos | Eventos ass√≠ncronos |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens         | ‚ö†Ô∏è Desvantagens             |
| -------------------- | --------------------------- |
| L√≥gica centralizada  | Orquestrador √© SPOF         |
| F√°cil rastrear fluxo | Pode se tornar God Class    |
| Compensa√ß√£o simples  | Acoplamento ao orquestrador |
| Test√°vel com mocks   | Performance (hop extra)     |
| Mudan√ßas localizadas | Escalabilidade limitada     |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Orchestrator quando:

- Workflow com etapas bem definidas
- Necessidade de rastreabilidade
- Compensa√ß√£o complexa (Saga)
- Transa√ß√µes de longa dura√ß√£o

### ‚ùå Evite Orchestrator quando:

- Eventos desacoplados (use Choreography)
- Alta escalabilidade obrigat√≥ria
- Servi√ßos completamente independentes
- Performance cr√≠tica (lat√™ncia)

---

**Orchestrator centraliza coordena√ß√£o de workflows complexos, permitindo testes de saga e compensa√ß√£o confi√°vel!** üé≠‚ú®
