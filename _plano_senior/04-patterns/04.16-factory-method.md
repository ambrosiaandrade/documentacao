# 04.16 Factory Method Pattern [M√âDIO] üè≠

## üéØ Objetivo

Delegar a **cria√ß√£o de objetos** para subclasses ou m√©todos especializados, permitindo extensibilidade sem modificar c√≥digo cliente e facilitando **inje√ß√£o de depend√™ncias test√°veis**.

---

## üìö O Que √â?

**Factory Method** √© um padr√£o criacional GoF que define uma interface para criar objetos, mas deixa subclasses decidirem qual classe instanciar. Em testes, elimina acoplamento direto com `new`, permitindo substituir implementa√ß√µes facilmente.

### Analogia

Como uma **f√°brica de carros**:

- **Cliente**: Pede "carro esportivo" sem saber se ser√° Ferrari ou Porsche
- **Factory**: Decide qual modelo fabricar baseado em crit√©rios (pre√ßo, disponibilidade)
- **Vantagem**: Cliente n√£o precisa conhecer detalhes de constru√ß√£o

---

## ‚ùå Problema que Resolve

### Antes (Acoplamento com `new`)

```java
// ‚ùå PROBLEMA: Cliente acoplado √† implementa√ß√£o concreta
public class PagamentoService {
    public void processar(String tipo, BigDecimal valor) {
        Pagamento pagamento;

        // C√≥digo cliente decide implementa√ß√£o
        if (tipo.equals("CREDITO")) {
            pagamento = new PagamentoCredito(valor, "API_GATEWAY_PROD");
        } else if (tipo.equals("DEBITO")) {
            pagamento = new PagamentoDebito(valor, "BANCO_PROD");
        } else if (tipo.equals("PIX")) {
            pagamento = new PagamentoPix(valor, "BCB_PROD");
        } else {
            throw new IllegalArgumentException("Tipo inv√°lido: " + tipo);
        }

        pagamento.executar();
    }
}

// Problemas:
// - Imposs√≠vel testar sem depend√™ncias reais (API_GATEWAY_PROD)
// - Adicionar novo tipo = modificar PagamentoService
// - Viola√ß√£o do Open/Closed Principle
```

**Problemas**:

- üîí Acoplamento forte com implementa√ß√µes concretas
- üß™ Imposs√≠vel mockar para testes
- üîß Adicionar tipos = modificar m√∫ltiplos pontos
- üêõ Configura√ß√µes de produ√ß√£o vazam para testes

### Depois (Factory Method)

```java
// ‚úÖ SOLU√á√ÉO: Factory Method + Inje√ß√£o de Depend√™ncia
interface Pagamento {
    void executar();
    String getTipo();
}

interface PagamentoFactory {
    Pagamento criar(String tipo, BigDecimal valor);
}

public class PagamentoService {
    private final PagamentoFactory factory;

    public PagamentoService(PagamentoFactory factory) {
        this.factory = factory;
    }

    public void processar(String tipo, BigDecimal valor) {
        Pagamento pagamento = factory.criar(tipo, valor);
        pagamento.executar();
    }
}

// Testes podem injetar factory mockada
@Test
void deveProcessarPagamento() {
    PagamentoFactory factoryMock = mock(PagamentoFactory.class);
    Pagamento pagamentoMock = mock(Pagamento.class);
    when(factoryMock.criar("CREDITO", BigDecimal.TEN)).thenReturn(pagamentoMock);

    PagamentoService service = new PagamentoService(factoryMock);
    service.processar("CREDITO", BigDecimal.TEN);

    verify(pagamentoMock).executar();
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface de Produto

```java
sealed interface Pagamento permits PagamentoCredito, PagamentoDebito, PagamentoPix {
    void executar();
    String getTipo();
    BigDecimal getValor();
}

record ResultadoPagamento(
    String transacaoId,
    String tipo,
    BigDecimal valor,
    boolean sucesso,
    String mensagem
) {}
```

### 2. Implementa√ß√µes Concretas

```java
final class PagamentoCredito implements Pagamento {
    private final BigDecimal valor;
    private final String gateway;

    PagamentoCredito(BigDecimal valor, String gateway) {
        this.valor = valor;
        this.gateway = gateway;
    }

    @Override
    public void executar() {
        System.out.println("üí≥ Processando cart√£o de cr√©dito via " + gateway);
        // L√≥gica real de integra√ß√£o
    }

    @Override
    public String getTipo() { return "CREDITO"; }

    @Override
    public BigDecimal getValor() { return valor; }
}

final class PagamentoDebito implements Pagamento {
    private final BigDecimal valor;
    private final String banco;

    PagamentoDebito(BigDecimal valor, String banco) {
        this.valor = valor;
        this.banco = banco;
    }

    @Override
    public void executar() {
        System.out.println("üè¶ Processando d√©bito via " + banco);
    }

    @Override
    public String getTipo() { return "DEBITO"; }

    @Override
    public BigDecimal getValor() { return valor; }
}

final class PagamentoPix implements Pagamento {
    private final BigDecimal valor;
    private final String bcb;

    PagamentoPix(BigDecimal valor, String bcb) {
        this.valor = valor;
        this.bcb = bcb;
    }

    @Override
    public void executar() {
        System.out.println("üì± Processando PIX via " + bcb);
    }

    @Override
    public String getTipo() { return "PIX"; }

    @Override
    public BigDecimal getValor() { return valor; }
}
```

### 3. Factory Interface e Implementa√ß√£o

```java
@FunctionalInterface
interface PagamentoFactory {
    Pagamento criar(String tipo, BigDecimal valor);
}

final class PagamentoFactoryImpl implements PagamentoFactory {
    private final String gatewayUrl;
    private final String bancoUrl;
    private final String bcbUrl;

    PagamentoFactoryImpl(String gatewayUrl, String bancoUrl, String bcbUrl) {
        this.gatewayUrl = gatewayUrl;
        this.bancoUrl = bancoUrl;
        this.bcbUrl = bcbUrl;
    }

    @Override
    public Pagamento criar(String tipo, BigDecimal valor) {
        return switch (tipo.toUpperCase()) {
            case "CREDITO" -> new PagamentoCredito(valor, gatewayUrl);
            case "DEBITO" -> new PagamentoDebito(valor, bancoUrl);
            case "PIX" -> new PagamentoPix(valor, bcbUrl);
            default -> throw new IllegalArgumentException("Tipo inv√°lido: " + tipo);
        };
    }
}
```

### 4. Factory com Registry (Extens√≠vel)

```java
final class PagamentoFactoryRegistry implements PagamentoFactory {
    private final Map<String, BiFunction<BigDecimal, String, Pagamento>> registry
        = new ConcurrentHashMap<>();

    private final Map<String, String> configs = new ConcurrentHashMap<>();

    void registrar(String tipo, BiFunction<BigDecimal, String, Pagamento> constructor) {
        registry.put(tipo.toUpperCase(), constructor);
        System.out.println("‚úÖ Registrado: " + tipo);
    }

    void configurar(String tipo, String config) {
        configs.put(tipo.toUpperCase(), config);
    }

    @Override
    public Pagamento criar(String tipo, BigDecimal valor) {
        BiFunction<BigDecimal, String, Pagamento> constructor =
            registry.get(tipo.toUpperCase());

        if (constructor == null) {
            throw new IllegalArgumentException("Tipo n√£o registrado: " + tipo);
        }

        String config = configs.getOrDefault(tipo.toUpperCase(), "default");
        return constructor.apply(valor, config);
    }

    int tiposRegistrados() {
        return registry.size();
    }
}
```

### 5. Service com Factory Injetada

```java
final class PagamentoService {
    private final PagamentoFactory factory;
    private final AtomicInteger processados = new AtomicInteger(0);

    PagamentoService(PagamentoFactory factory) {
        this.factory = factory;
    }

    ResultadoPagamento processar(String tipo, BigDecimal valor) {
        try {
            Pagamento pagamento = factory.criar(tipo, valor);
            pagamento.executar();

            processados.incrementAndGet();

            return new ResultadoPagamento(
                UUID.randomUUID().toString(),
                pagamento.getTipo(),
                pagamento.getValor(),
                true,
                "Pagamento processado"
            );

        } catch (Exception e) {
            return new ResultadoPagamento(
                null,
                tipo,
                valor,
                false,
                e.getMessage()
            );
        }
    }

    int getTotalProcessados() {
        return processados.get();
    }
}
```

---

## üß™ Como Testar

### 1. Testar Factory Cria Tipo Correto

```java
@Test
void factoryDeveCriarPagamentoCredito() {
    // Arrange
    PagamentoFactory factory = new PagamentoFactoryImpl(
        "gateway.com",
        "banco.com",
        "bcb.gov.br"
    );

    // Act
    Pagamento pagamento = factory.criar("CREDITO", new BigDecimal("100.00"));

    // Assert
    assertInstanceOf(PagamentoCredito.class, pagamento);
    assertEquals("CREDITO", pagamento.getTipo());
    assertEquals(new BigDecimal("100.00"), pagamento.getValor());
}
```

### 2. Testar Factory com Tipo Inv√°lido

```java
@Test
void factoryDeveLancarExcecaoParaTipoInvalido() {
    // Arrange
    PagamentoFactory factory = new PagamentoFactoryImpl(
        "gateway.com",
        "banco.com",
        "bcb.gov.br"
    );

    // Act & Assert
    IllegalArgumentException ex = assertThrows(
        IllegalArgumentException.class,
        () -> factory.criar("BOLETO", BigDecimal.TEN)
    );

    assertTrue(ex.getMessage().contains("BOLETO"));
}
```

### 3. Testar Service com Factory Mockada

```java
@Test
void serviceDeveUsarFactoryParaCriarPagamento() {
    // Arrange
    PagamentoFactory factoryMock = mock(PagamentoFactory.class);
    Pagamento pagamentoMock = mock(Pagamento.class);

    when(factoryMock.criar("PIX", new BigDecimal("50.00")))
        .thenReturn(pagamentoMock);
    when(pagamentoMock.getTipo()).thenReturn("PIX");
    when(pagamentoMock.getValor()).thenReturn(new BigDecimal("50.00"));

    PagamentoService service = new PagamentoService(factoryMock);

    // Act
    ResultadoPagamento resultado = service.processar("PIX", new BigDecimal("50.00"));

    // Assert
    assertTrue(resultado.sucesso());
    assertEquals("PIX", resultado.tipo());
    verify(pagamentoMock).executar();
}
```

### 4. Testar Registry Factory (Extensibilidade)

```java
@Test
void registryDevePermitirAdicionarNovosTipos() {
    // Arrange
    PagamentoFactoryRegistry registry = new PagamentoFactoryRegistry();

    // Registra tipos
    registry.registrar("CREDITO", PagamentoCredito::new);
    registry.registrar("DEBITO", PagamentoDebito::new);
    registry.registrar("PIX", PagamentoPix::new);

    // Act
    Pagamento credito = registry.criar("CREDITO", BigDecimal.TEN);
    Pagamento pix = registry.criar("PIX", BigDecimal.ONE);

    // Assert
    assertEquals(3, registry.tiposRegistrados());
    assertEquals("CREDITO", credito.getTipo());
    assertEquals("PIX", pix.getTipo());
}
```

### 5. Testar Isolamento de Configura√ß√µes

```java
@Test
void factoriesIndependentesDevemTerConfiguracoesIsoladas() {
    // Arrange - Factory de produ√ß√£o
    PagamentoFactory factoryProd = new PagamentoFactoryImpl(
        "https://gateway.prod.com",
        "https://banco.prod.com",
        "https://bcb.gov.br"
    );

    // Arrange - Factory de teste
    PagamentoFactory factoryTest = new PagamentoFactoryImpl(
        "http://localhost:8080/gateway",
        "http://localhost:8080/banco",
        "http://localhost:8080/bcb"
    );

    // Act
    Pagamento pagProd = factoryProd.criar("CREDITO", BigDecimal.TEN);
    Pagamento pagTest = factoryTest.criar("CREDITO", BigDecimal.TEN);

    // Assert - Ambos s√£o PagamentoCredito mas com configs diferentes
    assertInstanceOf(PagamentoCredito.class, pagProd);
    assertInstanceOf(PagamentoCredito.class, pagTest);
    assertNotSame(pagProd, pagTest);
}
```

### 6. Testar Factory N√£o Registra Tipo Duplicado

```java
@Test
void registryNaoDevePermitirSobrescreverTipoSemAlerta() {
    // Arrange
    PagamentoFactoryRegistry registry = new PagamentoFactoryRegistry();
    registry.registrar("CREDITO", PagamentoCredito::new);

    // Act - Registrar novamente (sobrescreve silenciosamente)
    registry.registrar("CREDITO", PagamentoPix::new);

    Pagamento pagamento = registry.criar("CREDITO", BigDecimal.TEN);

    // Assert - √öltima vers√£o registrada prevalece
    assertInstanceOf(PagamentoPix.class, pagamento);
}
```

### 7. Testar M√©tricas de Processamento

```java
@Test
void serviceDeveContabilizarPagamentosProcessados() {
    // Arrange
    PagamentoFactory factory = new PagamentoFactoryImpl(
        "gateway", "banco", "bcb"
    );
    PagamentoService service = new PagamentoService(factory);

    // Act
    service.processar("CREDITO", new BigDecimal("100"));
    service.processar("DEBITO", new BigDecimal("200"));
    service.processar("PIX", new BigDecimal("300"));

    // Assert
    assertEquals(3, service.getTotalProcessados());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Factory com l√≥gica de neg√≥cio
class PagamentoFactory {
    public Pagamento criar(String tipo, BigDecimal valor) {
        // Valida√ß√µes de neg√≥cio na factory ‚ùå
        if (valor.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Valor inv√°lido");
        }
        if (tipo.equals("CREDITO") && valor.compareTo(new BigDecimal("5000")) > 0) {
            throw new BusinessException("Limite excedido");
        }
        return new PagamentoCredito(valor, "gateway");
    }
}

// ‚ùå Factory stateful (estado compartilhado)
class PagamentoFactory {
    private int contador = 0; // Estado compartilhado perigoso!

    public Pagamento criar(String tipo, BigDecimal valor) {
        contador++; // Thread-unsafe
        return new PagamentoCredito(valor, "gateway");
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Factory apenas cria objetos
class PagamentoFactory {
    private final String gatewayUrl;

    public Pagamento criar(String tipo, BigDecimal valor) {
        // Apenas cria√ß√£o, sem valida√ß√µes de neg√≥cio
        return new PagamentoCredito(valor, gatewayUrl);
    }
}

// ‚úÖ Valida√ß√µes no service
class PagamentoService {
    public ResultadoPagamento processar(String tipo, BigDecimal valor) {
        // Valida√ß√µes aqui
        if (valor.compareTo(BigDecimal.ZERO) <= 0) {
            return new ResultadoPagamento(null, tipo, valor, false, "Valor inv√°lido");
        }

        Pagamento pagamento = factory.criar(tipo, valor);
        pagamento.executar();
        return new ResultadoPagamento(/*...*/);
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Factory stateless**: N√£o manter estado interno
- ‚úÖ **Inje√ß√£o de configura√ß√£o**: Passar URLs/configs no construtor
- ‚úÖ **Interface simples**: M√©todo `criar()` com par√¢metros essenciais
- ‚úÖ **Fail fast**: Validar tipo no momento da cria√ß√£o
- ‚úÖ **Registry pattern**: Para tipos extens√≠veis dinamicamente
- ‚úÖ **Sealed interfaces**: Garantir tipos conhecidos em compile-time
- ‚úÖ **Mock-friendly**: Permitir inje√ß√£o para testes

---

## üîó Integra√ß√£o com Frameworks

### Spring Framework

```java
@Configuration
public class PagamentoConfig {

    @Bean
    public PagamentoFactory pagamentoFactory(
        @Value("${gateway.url}") String gatewayUrl,
        @Value("${banco.url}") String bancoUrl,
        @Value("${bcb.url}") String bcbUrl
    ) {
        return new PagamentoFactoryImpl(gatewayUrl, bancoUrl, bcbUrl);
    }

    @Bean
    public PagamentoService pagamentoService(PagamentoFactory factory) {
        return new PagamentoService(factory);
    }
}
```

### Testes com Spring

```java
@SpringBootTest
class PagamentoServiceIntegrationTest {

    @MockBean
    private PagamentoFactory factoryMock;

    @Autowired
    private PagamentoService service;

    @Test
    void deveProcessarComFactoryMockada() {
        Pagamento mock = mock(Pagamento.class);
        when(factoryMock.criar(anyString(), any())).thenReturn(mock);

        ResultadoPagamento resultado = service.processar("PIX", BigDecimal.TEN);

        assertTrue(resultado.sucesso());
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens              | ‚ö†Ô∏è Desvantagens                        |
| ------------------------- | -------------------------------------- |
| Desacopla cria√ß√£o de uso  | Adiciona camada de indire√ß√£o           |
| Facilita testes com mocks | Mais classes para manter               |
| Extens√≠vel (Open/Closed)  | Pode complicar c√≥digo simples          |
| Configura√ß√µes isoladas    | Requer disciplina (n√£o colocar l√≥gica) |

---

## üîç Compara√ß√£o

| Padr√£o               | Quando Usar                             | Testabilidade          |
| -------------------- | --------------------------------------- | ---------------------- |
| **Factory Method**   | Criar objetos relacionados, extens√≠vel  | Alta (f√°cil mock)      |
| **Abstract Factory** | Fam√≠lias de objetos relacionados        | M√©dia                  |
| **Builder**          | Objetos complexos com muitos par√¢metros | Alta                   |
| **Singleton**        | Inst√¢ncia √∫nica global                  | Baixa (dif√≠cil testar) |
| **Prototype**        | Clonar objetos existentes               | M√©dia                  |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar Abstract Factory** para fam√≠lias (PagamentoBrasil, PagamentoUSA)
2. **Factory com valida√ß√£o** de tipos em compile-time (sealed + enum)
3. **Registry din√¢mico** com ServiceLoader para descobrir implementa√ß√µes
4. **Factory ass√≠ncrona** retornando `CompletableFuture<Pagamento>`
5. **M√©tricas por tipo** (quantos CREDITO, DEBITO, PIX foram criados)

---

## üìö Relacionado

- **Builder Pattern**: Cria√ß√£o de objetos complexos
- **Strategy Pattern**: Trocar algoritmos em runtime
- **Dependency Injection**: Spring gerencia factories automaticamente
- **Abstract Factory**: Fam√≠lias de objetos relacionados

---

**Factory Method torna c√≥digo test√°vel ao eliminar acoplamento com `new` e permitir inje√ß√£o de mocks!** üè≠‚ú®
