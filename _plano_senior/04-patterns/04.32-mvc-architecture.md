# 04.32 MVC Architecture (Model-View-Controller) [M√âDIO] üé≠

## üéØ Objetivo

Separar **interface do usu√°rio**, **l√≥gica de neg√≥cio** e **dados** em tr√™s componentes distintos, facilitando **testes isolados do controller** e permitindo mudan√ßas independentes em cada parte.

---

## üìö O Que √â?

**MVC (Model-View-Controller)** √© um padr√£o arquitetural que divide aplica√ß√µes interativas em tr√™s componentes: Model (dados/l√≥gica), View (apresenta√ß√£o), Controller (coordena√ß√£o). Popular em aplica√ß√µes web.

### Analogia

Como um **restaurante**:

- **Chef (Model)**: Prepara comida, conhece receitas (l√≥gica de neg√≥cio)
- **Gar√ßom (Controller)**: Recebe pedidos, coordena entre cliente e cozinha
- **Card√°pio/Prato (View)**: Apresenta√ß√£o visual para o cliente
- **Vantagem**: Chef n√£o precisa saber como apresentar, gar√ßom coordena tudo

---

## ‚ùå Problema que Resolve

### Antes (UI Misturada com L√≥gica e Dados)

```java
// ‚ùå PROBLEMA: Tudo junto em uma √∫nica classe
class ProdutoServlet extends HttpServlet {

    private Connection conn;

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        try {
            // SQL direto no servlet ‚ùå
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM produtos");

            // HTML gerado no c√≥digo ‚ùå
            PrintWriter out = resp.getWriter();
            out.println("<html><body><table>");
            out.println("<tr><th>Nome</th><th>Pre√ßo</th></tr>");

            while (rs.next()) {
                String nome = rs.getString("nome");
                double preco = rs.getDouble("preco");

                // L√≥gica de neg√≥cio no meio ‚ùå
                String desconto = "";
                if (preco > 100) {
                    preco *= 0.9; // 10% desconto
                    desconto = " (10% OFF)";
                }

                // Mais HTML ‚ùå
                out.println("<tr>");
                out.println("<td>" + nome + desconto + "</td>");
                out.println("<td>R$ " + preco + "</td>");
                out.println("</tr>");
            }

            out.println("</table></body></html>");

        } catch (SQLException e) {
            // Tratamento gen√©rico ‚ùå
        }
    }
}

// Problemas:
// - UI + L√≥gica + SQL tudo junto ‚ùå
// - Imposs√≠vel testar sem servidor web ‚ùå
// - Trocar UI = refatorar tudo ‚ùå
// - HTML hardcoded no c√≥digo ‚ùå
// - Reutiliza√ß√£o imposs√≠vel ‚ùå
```

**Problemas**:

- üß© UI, l√≥gica e dados misturados
- üß™ Dif√≠cil testar sem servidor
- üé® Trocar design = refatorar c√≥digo
- üîß L√≥gica n√£o reutiliz√°vel
- üìö Manuten√ß√£o complexa

### Depois (MVC Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Model-View-Controller separados

// ==== MODEL (Dados + L√≥gica) ====
class Produto {
    private final Long id;
    private final String nome;
    private final BigDecimal preco;

    Produto(Long id, String nome, BigDecimal preco) {
        this.id = id;
        this.nome = nome;
        this.preco = preco;
    }

    // L√≥gica de neg√≥cio no Model
    BigDecimal getPrecoComDesconto() {
        if (preco.compareTo(BigDecimal.valueOf(100)) > 0) {
            return preco.multiply(BigDecimal.valueOf(0.9)); // 10% desconto
        }
        return preco;
    }

    boolean temDesconto() {
        return preco.compareTo(BigDecimal.valueOf(100)) > 0;
    }

    // Getters
    Long getId() { return id; }
    String getNome() { return nome; }
    BigDecimal getPreco() { return preco; }
}

// Service (parte do Model)
@Service
class ProdutoService {
    @Autowired
    private ProdutoRepository repository;

    List<Produto> listarTodos() {
        return repository.findAll();
    }
}

// ==== CONTROLLER (Coordena√ß√£o) ====
@Controller
@RequestMapping("/produtos")
class ProdutoController {

    private final ProdutoService service;

    @Autowired
    ProdutoController(ProdutoService service) {
        this.service = service;
    }

    @GetMapping
    String listar(Model model) {
        // Apenas coordena: busca dados e passa para view
        List<Produto> produtos = service.listarTodos();
        model.addAttribute("produtos", produtos);
        return "produtos/lista"; // Nome da view
    }
}

// ==== VIEW (Apresenta√ß√£o - Thymeleaf) ====
<!-- produtos/lista.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<body>
    <table>
        <tr><th>Nome</th><th>Pre√ßo</th></tr>
        <tr th:each="produto : ${produtos}">
            <td th:text="${produto.nome}"></td>
            <td>
                <span th:text="${produto.precoComDesconto}"></span>
                <span th:if="${produto.temDesconto}">(10% OFF)</span>
            </td>
        </tr>
    </table>
</body>
</html>

// ‚úÖ Teste simples do Controller
@WebMvcTest(ProdutoController.class)
class ProdutoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProdutoService service;

    @Test
    void deveListarProdutos() throws Exception {
        // Arrange
        when(service.listarTodos()).thenReturn(List.of(
            new Produto(1L, "Notebook", BigDecimal.valueOf(3000))
        ));

        // Act & Assert
        mockMvc.perform(get("/produtos"))
            .andExpect(status().isOk())
            .andExpect(view().name("produtos/lista"))
            .andExpect(model().attributeExists("produtos"));
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Model (Entidade + Service)

```java
// Entidade de dom√≠nio
@Entity
@Table(name = "pedidos")
class Pedido {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String cliente;

    @Column(name = "valor_total", nullable = false)
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPedido status;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ItemPedido> itens = new ArrayList<>();

    // Construtor, getters, setters
    protected Pedido() {}

    Pedido(String cliente) {
        this.cliente = cliente;
        this.status = StatusPedido.PENDENTE;
        this.criadoEm = LocalDateTime.now();
        this.valorTotal = BigDecimal.ZERO;
    }

    // L√≥gica de neg√≥cio no Model
    void adicionarItem(ItemPedido item) {
        itens.add(item);
        item.setPedido(this);
        recalcularTotal();
    }

    void removerItem(ItemPedido item) {
        itens.remove(item);
        item.setPedido(null);
        recalcularTotal();
    }

    void aprovar() {
        if (status != StatusPedido.PENDENTE) {
            throw new IllegalStateException("Apenas pedidos pendentes podem ser aprovados");
        }
        this.status = StatusPedido.APROVADO;
    }

    private void recalcularTotal() {
        this.valorTotal = itens.stream()
            .map(ItemPedido::getSubtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Getters/Setters
    Long getId() { return id; }
    String getCliente() { return cliente; }
    BigDecimal getValorTotal() { return valorTotal; }
    StatusPedido getStatus() { return status; }
    LocalDateTime getCriadoEm() { return criadoEm; }
    List<ItemPedido> getItens() { return List.copyOf(itens); }
}

@Entity
@Table(name = "pedido_itens")
class ItemPedido {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "pedido_id", nullable = false)
    private Pedido pedido;

    @Column(name = "produto_nome", nullable = false)
    private String produtoNome;

    @Column(nullable = false)
    private Integer quantidade;

    @Column(name = "preco_unitario", nullable = false)
    private BigDecimal precoUnitario;

    protected ItemPedido() {}

    ItemPedido(String produtoNome, int quantidade, BigDecimal precoUnitario) {
        this.produtoNome = produtoNome;
        this.quantidade = quantidade;
        this.precoUnitario = precoUnitario;
    }

    BigDecimal getSubtotal() {
        return precoUnitario.multiply(BigDecimal.valueOf(quantidade));
    }

    // Getters/Setters
    Long getId() { return id; }
    String getProdutoNome() { return produtoNome; }
    Integer getQuantidade() { return quantidade; }
    BigDecimal getPrecoUnitario() { return precoUnitario; }
    void setPedido(Pedido pedido) { this.pedido = pedido; }
}

enum StatusPedido {
    PENDENTE, APROVADO, REJEITADO, ENTREGUE
}

// Service (parte do Model - l√≥gica de aplica√ß√£o)
@Service
class PedidoService {

    private final PedidoRepository repository;

    @Autowired
    PedidoService(PedidoRepository repository) {
        this.repository = repository;
    }

    @Transactional
    Pedido criarPedido(String cliente, List<ItemPedido> itens) {
        Pedido pedido = new Pedido(cliente);
        itens.forEach(pedido::adicionarItem);
        return repository.save(pedido);
    }

    @Transactional(readOnly = true)
    List<Pedido> listarTodos() {
        return repository.findAll();
    }

    @Transactional(readOnly = true)
    Optional<Pedido> buscarPorId(Long id) {
        return repository.findById(id);
    }

    @Transactional
    Pedido aprovarPedido(Long id) {
        Pedido pedido = repository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Pedido n√£o encontrado"));

        pedido.aprovar();
        return repository.save(pedido);
    }

    @Transactional(readOnly = true)
    List<Pedido> buscarPorStatus(StatusPedido status) {
        return repository.findByStatus(status);
    }
}

// Repository (acesso a dados)
@Repository
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByStatus(StatusPedido status);
    List<Pedido> findByCliente(String cliente);
}
```

### 2. View (Thymeleaf Templates)

```html
<!-- templates/pedidos/lista.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <title>Lista de Pedidos</title>
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <h1>Pedidos</h1>

    <!-- Filtro -->
    <form th:action="@{/pedidos}" method="get">
      <label>Status:</label>
      <select name="status">
        <option value="">Todos</option>
        <option
          th:each="status : ${T(StatusPedido).values()}"
          th:value="${status}"
          th:text="${status}"
          th:selected="${status == statusFiltro}"
        ></option>
      </select>
      <button type="submit">Filtrar</button>
    </form>

    <!-- Tabela de pedidos -->
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Cliente</th>
          <th>Valor Total</th>
          <th>Status</th>
          <th>Criado Em</th>
          <th>A√ß√µes</th>
        </tr>
      </thead>
      <tbody>
        <tr th:each="pedido : ${pedidos}">
          <td th:text="${pedido.id}"></td>
          <td th:text="${pedido.cliente}"></td>
          <td th:text="${#numbers.formatCurrency(pedido.valorTotal)}"></td>
          <td>
            <span
              th:text="${pedido.status}"
              th:classappend="${pedido.status == T(StatusPedido).APROVADO} ? 'badge-success' : 'badge-warning'"
            >
            </span>
          </td>
          <td
            th:text="${#temporals.format(pedido.criadoEm, 'dd/MM/yyyy HH:mm')}"
          ></td>
          <td>
            <a th:href="@{/pedidos/{id}(id=${pedido.id})}">Ver</a>
            <a
              th:href="@{/pedidos/{id}/aprovar(id=${pedido.id})}"
              th:if="${pedido.status == T(StatusPedido).PENDENTE}"
            >
              Aprovar
            </a>
          </td>
        </tr>
      </tbody>
    </table>

    <!-- Mensagem se vazio -->
    <div th:if="${#lists.isEmpty(pedidos)}">
      <p>Nenhum pedido encontrado.</p>
    </div>

    <a th:href="@{/pedidos/novo}">Novo Pedido</a>
  </body>
</html>

<!-- templates/pedidos/detalhe.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <title>Detalhes do Pedido</title>
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <h1>Pedido #<span th:text="${pedido.id}"></span></h1>

    <div class="info">
      <p><strong>Cliente:</strong> <span th:text="${pedido.cliente}"></span></p>
      <p><strong>Status:</strong> <span th:text="${pedido.status}"></span></p>
      <p>
        <strong>Criado em:</strong>
        <span
          th:text="${#temporals.format(pedido.criadoEm, 'dd/MM/yyyy HH:mm')}"
        ></span>
      </p>
    </div>

    <h2>Itens</h2>
    <table>
      <thead>
        <tr>
          <th>Produto</th>
          <th>Quantidade</th>
          <th>Pre√ßo Unit√°rio</th>
          <th>Subtotal</th>
        </tr>
      </thead>
      <tbody>
        <tr th:each="item : ${pedido.itens}">
          <td th:text="${item.produtoNome}"></td>
          <td th:text="${item.quantidade}"></td>
          <td th:text="${#numbers.formatCurrency(item.precoUnitario)}"></td>
          <td th:text="${#numbers.formatCurrency(item.subtotal)}"></td>
        </tr>
      </tbody>
      <tfoot>
        <tr>
          <td colspan="3"><strong>Total:</strong></td>
          <td>
            <strong
              th:text="${#numbers.formatCurrency(pedido.valorTotal)}"
            ></strong>
          </td>
        </tr>
      </tfoot>
    </table>

    <div class="actions">
      <a th:href="@{/pedidos}">Voltar</a>
      <form
        th:action="@{/pedidos/{id}/aprovar(id=${pedido.id})}"
        method="post"
        th:if="${pedido.status == T(StatusPedido).PENDENTE}"
      >
        <button type="submit">Aprovar Pedido</button>
      </form>
    </div>
  </body>
</html>

<!-- templates/pedidos/formulario.html -->
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
  <head>
    <title>Novo Pedido</title>
    <link rel="stylesheet" href="/css/style.css" />
  </head>
  <body>
    <h1>Novo Pedido</h1>

    <form th:action="@{/pedidos}" method="post" th:object="${pedidoForm}">
      <div>
        <label>Cliente:</label>
        <input type="text" th:field="*{cliente}" required />
        <span
          th:if="${#fields.hasErrors('cliente')}"
          th:errors="*{cliente}"
        ></span>
      </div>

      <h2>Itens</h2>
      <div id="itens">
        <div th:each="item, stat : *{itens}" class="item">
          <input
            type="text"
            th:field="*{itens[__${stat.index}__].produtoNome}"
            placeholder="Produto"
            required
          />
          <input
            type="number"
            th:field="*{itens[__${stat.index}__].quantidade}"
            placeholder="Qtd"
            min="1"
            required
          />
          <input
            type="number"
            th:field="*{itens[__${stat.index}__].precoUnitario}"
            placeholder="Pre√ßo"
            step="0.01"
            min="0.01"
            required
          />
        </div>
      </div>

      <button type="button" onclick="adicionarItem()">Adicionar Item</button>

      <div class="actions">
        <button type="submit">Criar Pedido</button>
        <a th:href="@{/pedidos}">Cancelar</a>
      </div>
    </form>

    <script>
      function adicionarItem() {
        // L√≥gica JavaScript para adicionar linha dinamicamente
      }
    </script>
  </body>
</html>
```

### 3. Controller (Coordena√ß√£o)

```java
// Controller Web (Spring MVC)
@Controller
@RequestMapping("/pedidos")
class PedidoController {

    private final PedidoService service;

    @Autowired
    PedidoController(PedidoService service) {
        this.service = service;
    }

    // GET /pedidos - Lista todos
    @GetMapping
    String listar(
        @RequestParam(required = false) StatusPedido status,
        Model model
    ) {
        List<Pedido> pedidos = status != null
            ? service.buscarPorStatus(status)
            : service.listarTodos();

        model.addAttribute("pedidos", pedidos);
        model.addAttribute("statusFiltro", status);

        return "pedidos/lista";
    }

    // GET /pedidos/{id} - Detalhe
    @GetMapping("/{id}")
    String detalhe(@PathVariable Long id, Model model) {
        Pedido pedido = service.buscarPorId(id)
            .orElseThrow(() -> new ResponseStatusException(
                HttpStatus.NOT_FOUND,
                "Pedido n√£o encontrado"
            ));

        model.addAttribute("pedido", pedido);
        return "pedidos/detalhe";
    }

    // GET /pedidos/novo - Formul√°rio
    @GetMapping("/novo")
    String novoForm(Model model) {
        PedidoForm form = new PedidoForm();
        form.getItens().add(new ItemForm()); // Pelo menos 1 item

        model.addAttribute("pedidoForm", form);
        return "pedidos/formulario";
    }

    // POST /pedidos - Criar
    @PostMapping
    String criar(@Valid @ModelAttribute PedidoForm form, BindingResult result, Model model) {
        if (result.hasErrors()) {
            model.addAttribute("pedidoForm", form);
            return "pedidos/formulario";
        }

        // Converte form ‚Üí entidades
        List<ItemPedido> itens = form.getItens().stream()
            .map(i -> new ItemPedido(i.getProdutoNome(), i.getQuantidade(), i.getPrecoUnitario()))
            .toList();

        Pedido pedido = service.criarPedido(form.getCliente(), itens);

        return "redirect:/pedidos/" + pedido.getId();
    }

    // POST /pedidos/{id}/aprovar - Aprovar
    @PostMapping("/{id}/aprovar")
    String aprovar(@PathVariable Long id, RedirectAttributes redirect) {
        try {
            service.aprovarPedido(id);
            redirect.addFlashAttribute("mensagem", "Pedido aprovado com sucesso!");
        } catch (IllegalStateException e) {
            redirect.addFlashAttribute("erro", e.getMessage());
        }

        return "redirect:/pedidos/" + id;
    }

    // Exception handler
    @ExceptionHandler(EntityNotFoundException.class)
    public String handleNotFound(EntityNotFoundException ex, Model model) {
        model.addAttribute("erro", ex.getMessage());
        return "erro/404";
    }
}

// Form DTO (binding do formul√°rio)
class PedidoForm {

    @NotBlank(message = "Cliente √© obrigat√≥rio")
    private String cliente;

    @Valid
    @Size(min = 1, message = "Pelo menos 1 item √© obrigat√≥rio")
    private List<ItemForm> itens = new ArrayList<>();

    // Getters/Setters
    String getCliente() { return cliente; }
    void setCliente(String cliente) { this.cliente = cliente; }
    List<ItemForm> getItens() { return itens; }
    void setItens(List<ItemForm> itens) { this.itens = itens; }
}

class ItemForm {

    @NotBlank(message = "Nome do produto √© obrigat√≥rio")
    private String produtoNome;

    @Min(value = 1, message = "Quantidade deve ser >= 1")
    private Integer quantidade;

    @DecimalMin(value = "0.01", message = "Pre√ßo deve ser > 0")
    private BigDecimal precoUnitario;

    // Getters/Setters
    String getProdutoNome() { return produtoNome; }
    void setProdutoNome(String produtoNome) { this.produtoNome = produtoNome; }
    Integer getQuantidade() { return quantidade; }
    void setQuantidade(Integer quantidade) { this.quantidade = quantidade; }
    BigDecimal getPrecoUnitario() { return precoUnitario; }
    void setPrecoUnitario(BigDecimal precoUnitario) { this.precoUnitario = precoUnitario; }
}
```

### 4. Controller REST API (JSON)

```java
// Controller REST (para APIs JSON)
@RestController
@RequestMapping("/api/pedidos")
class PedidoRestController {

    private final PedidoService service;

    @Autowired
    PedidoRestController(PedidoService service) {
        this.service = service;
    }

    @GetMapping
    List<PedidoDTO> listar(@RequestParam(required = false) StatusPedido status) {
        List<Pedido> pedidos = status != null
            ? service.buscarPorStatus(status)
            : service.listarTodos();

        return pedidos.stream()
            .map(PedidoDTO::from)
            .toList();
    }

    @GetMapping("/{id}")
    ResponseEntity<PedidoDTO> buscar(@PathVariable Long id) {
        return service.buscarPorId(id)
            .map(PedidoDTO::from)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    ResponseEntity<PedidoDTO> criar(@Valid @RequestBody PedidoCreateRequest request) {
        List<ItemPedido> itens = request.itens().stream()
            .map(i -> new ItemPedido(i.produtoNome(), i.quantidade(), i.precoUnitario()))
            .toList();

        Pedido pedido = service.criarPedido(request.cliente(), itens);

        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(PedidoDTO.from(pedido));
    }

    @PostMapping("/{id}/aprovar")
    ResponseEntity<PedidoDTO> aprovar(@PathVariable Long id) {
        Pedido pedido = service.aprovarPedido(id);
        return ResponseEntity.ok(PedidoDTO.from(pedido));
    }
}

// DTOs para API REST
record PedidoDTO(
    Long id,
    String cliente,
    BigDecimal valorTotal,
    StatusPedido status,
    LocalDateTime criadoEm,
    List<ItemDTO> itens
) {
    static PedidoDTO from(Pedido pedido) {
        return new PedidoDTO(
            pedido.getId(),
            pedido.getCliente(),
            pedido.getValorTotal(),
            pedido.getStatus(),
            pedido.getCriadoEm(),
            pedido.getItens().stream().map(ItemDTO::from).toList()
        );
    }
}

record ItemDTO(String produtoNome, int quantidade, BigDecimal precoUnitario, BigDecimal subtotal) {
    static ItemDTO from(ItemPedido item) {
        return new ItemDTO(
            item.getProdutoNome(),
            item.getQuantidade(),
            item.getPrecoUnitario(),
            item.getSubtotal()
        );
    }
}

record PedidoCreateRequest(
    @NotBlank String cliente,
    @NotEmpty List<ItemCreateRequest> itens
) {}

record ItemCreateRequest(
    @NotBlank String produtoNome,
    @Min(1) int quantidade,
    @DecimalMin("0.01") BigDecimal precoUnitario
) {}
```

---

## üß™ Como Testar

### 1. Testar Model (L√≥gica de Neg√≥cio)

```java
@Test
void pedidoDeveCalcularTotalCorretamente() {
    // Arrange
    Pedido pedido = new Pedido("Jo√£o");
    pedido.adicionarItem(new ItemPedido("Produto A", 2, BigDecimal.valueOf(10)));
    pedido.adicionarItem(new ItemPedido("Produto B", 3, BigDecimal.valueOf(15)));

    // Act & Assert
    assertEquals(BigDecimal.valueOf(65), pedido.getValorTotal());
}

@Test
void deveAprovarApenasPedidosPendentes() {
    // Arrange
    Pedido pedido = new Pedido("Maria");
    pedido.adicionarItem(new ItemPedido("Produto", 1, BigDecimal.TEN));

    // Act
    pedido.aprovar();

    // Assert
    assertEquals(StatusPedido.APROVADO, pedido.getStatus());
}
```

### 2. Testar Service

```java
@ExtendWith(MockitoExtension.class)
class PedidoServiceTest {

    @Mock
    private PedidoRepository repository;

    @InjectMocks
    private PedidoService service;

    @Test
    void deveCriarPedidoComItens() {
        // Arrange
        List<ItemPedido> itens = List.of(
            new ItemPedido("Produto A", 2, BigDecimal.valueOf(10))
        );

        when(repository.save(any())).thenAnswer(inv -> {
            Pedido p = inv.getArgument(0);
            // Simula ID gerado
            return p; // Assume que setId foi chamado
        });

        // Act
        Pedido pedido = service.criarPedido("Jo√£o", itens);

        // Assert
        assertEquals("Jo√£o", pedido.getCliente());
        assertEquals(1, pedido.getItens().size());
        verify(repository).save(any());
    }
}
```

### 3. Testar Controller Web (MockMvc)

```java
@WebMvcTest(PedidoController.class)
class PedidoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PedidoService service;

    @Test
    void deveListarPedidos() throws Exception {
        // Arrange
        Pedido pedido = new Pedido("Jo√£o");
        pedido.adicionarItem(new ItemPedido("Produto", 1, BigDecimal.TEN));

        when(service.listarTodos()).thenReturn(List.of(pedido));

        // Act & Assert
        mockMvc.perform(get("/pedidos"))
            .andExpect(status().isOk())
            .andExpect(view().name("pedidos/lista"))
            .andExpect(model().attributeExists("pedidos"))
            .andExpect(model().attribute("pedidos", hasSize(1)));
    }

    @Test
    void deveMostrarDetalheDoPedido() throws Exception {
        // Arrange
        Pedido pedido = new Pedido("Maria");
        when(service.buscarPorId(1L)).thenReturn(Optional.of(pedido));

        // Act & Assert
        mockMvc.perform(get("/pedidos/1"))
            .andExpect(status().isOk())
            .andExpect(view().name("pedidos/detalhe"))
            .andExpect(model().attribute("pedido", pedido));
    }
}
```

### 4. Testar Controller REST

```java
@WebMvcTest(PedidoRestController.class)
class PedidoRestControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PedidoService service;

    @Test
    void deveRetornarPedidosEmJSON() throws Exception {
        // Arrange
        Pedido pedido = new Pedido("Jo√£o");
        when(service.listarTodos()).thenReturn(List.of(pedido));

        // Act & Assert
        mockMvc.perform(get("/api/pedidos")
                .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$", hasSize(1)))
            .andExpect(jsonPath("$[0].cliente").value("Jo√£o"));
    }
}
```

### 5. Teste de Integra√ß√£o (End-to-End)

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
class PedidoMVCIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void deveCriarPedidoViaAPI() {
        // Arrange
        PedidoCreateRequest request = new PedidoCreateRequest(
            "Jo√£o",
            List.of(new ItemCreateRequest("Produto A", 2, BigDecimal.TEN))
        );

        // Act
        ResponseEntity<PedidoDTO> response = restTemplate.postForEntity(
            "/api/pedidos",
            request,
            PedidoDTO.class
        );

        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("Jo√£o", response.getBody().cliente());
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå L√≥gica de neg√≥cio no Controller
class BadController {
    @PostMapping
    void criar() {
        // C√°lculos complexos aqui ‚ùå
        double total = ...;
    }
}

// ‚ùå Controller manipulando View diretamente
class BadController {
    void metodo() {
        PrintWriter out = ...;
        out.println("<html>..."); // ‚ùå
    }
}

// ‚ùå View acessando dados diretamente
// template.html
// ${userRepository.findAll()} ‚ùå
```

### ‚úÖ Fazer

```java
// ‚úÖ Controller apenas coordena
class GoodController {
    @PostMapping
    void criar() {
        // Delega para Service
        service.criar(...);
    }
}

// ‚úÖ View recebe dados prontos do Model
// template.html
// ${usuarios} ‚úÖ (dados preparados pelo Controller)
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Controller magro**: Apenas coordena√ß√£o
- ‚úÖ **Model rico**: L√≥gica de neg√≥cio
- ‚úÖ **View burra**: Apenas apresenta√ß√£o
- ‚úÖ **DTOs**: N√£o exponha entidades na View
- ‚úÖ **Valida√ß√£o**: Bean Validation no form
- ‚úÖ **Transa√ß√µes**: No Service, n√£o no Controller
- ‚úÖ **Exception Handling**: @ExceptionHandler

---

## üîó Varia√ß√µes

### MVP (Model-View-Presenter)

- Presenter substitui Controller
- View mais passiva (interface)
- Mais test√°vel que MVC tradicional

### MVVM (Model-View-ViewModel)

- ViewModel com binding bidirecional
- Popular em Angular, Vue, WPF
- Data binding autom√°tico

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                     | ‚ö†Ô∏è Desvantagens              |
| -------------------------------- | ---------------------------- |
| Separa√ß√£o clara UI/l√≥gica/dados  | Overhead para apps simples   |
| Controller test√°vel isoladamente | Pode haver duplica√ß√£o (DTOs) |
| View reutiliz√°vel                | Curva de aprendizado         |
| Manuten√ß√£o facilitada            | Mais arquivos/classes        |

---

## üîç Compara√ß√£o

| Padr√£o     | Foco                 | Quando Usar                |
| ---------- | -------------------- | -------------------------- |
| **MVC**    | Web tradicional      | Apps server-side rendering |
| **MVP**    | Testabilidade        | Apps desktop/mobile        |
| **MVVM**   | Binding autom√°tico   | SPAs, apps reativas        |
| **Layers** | Separa√ß√£o horizontal | Qualquer tipo de app       |

---

## üß† Exerc√≠cios Pr√°ticos

1. **MVC com AJAX** (Controller retorna JSON para updates parciais)
2. **MVC com WebSockets** (atualiza√ß√£o em tempo real)
3. **MVC com cache** (cache de views renderizadas)
4. **MVC com temas** (m√∫ltiplas views para mesma l√≥gica)
5. **Migrar para MVVM** (adicionar ViewModels com binding)

---

## üìö Relacionado

- **Front Controller**: Ponto √∫nico de entrada
- **View Helper**: Fun√ß√µes auxiliares em templates
- **Layers Architecture**: Organiza√ß√£o mais ampla
- **REST**: Controllers como endpoints REST

---

**MVC separa UI, l√≥gica e dados, facilitando testes e manuten√ß√£o!** üé≠‚ú®
