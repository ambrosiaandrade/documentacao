# 04.6 Saga Pattern [EXPERT] üîÑ

## üéØ Objetivo

Coordenar **transa√ß√µes distribu√≠das** entre m√∫ltiplos microsservi√ßos atrav√©s de uma sequ√™ncia de transa√ß√µes locais com **compensa√ß√µes autom√°ticas** em caso de falha, garantindo consist√™ncia eventual sem usar bloqueios globais (2PC).

---

## üìö O Que √â?

**Saga Pattern** √© um padr√£o arquitetural para gerenciar transa√ß√µes distribu√≠das em sistemas de microsservi√ßos. Cada opera√ß√£o √© uma transa√ß√£o local em um servi√ßo, e se alguma falha, as transa√ß√µes anteriores s√£o **compensadas** (revertidas logicamente).

### Analogia

Como um **processo de montagem em linha**: cada esta√ß√£o completa sua parte e, se algo falha no final, cada esta√ß√£o anterior desfaz seu trabalho na ordem inversa.

### Tipos de Saga

1. **Orquestrada (Orchestration)**: Coordenador central controla sequ√™ncia e compensa√ß√µes
2. **Coreografada (Choreography)**: Servi√ßos reagem a eventos sem coordenador central

---

## ‚ùå Problema que Resolve

### Antes (Transa√ß√£o Distribu√≠da 2PC)

```java
// ‚ùå PROBLEMA: Bloqueio global, timeout, deadlock
@Transactional
void processarPedido(Pedido pedido) {
    // Bloqueia recursos em 3 bancos at√© commit/rollback
    pagamentoService.debitar(pedido);     // DB1 bloqueado
    estoqueService.reservar(pedido);      // DB2 bloqueado
    entregaService.agendar(pedido);       // DB3 bloqueado
    // Se entrega falhar -> rollback bloqueia tudo
}
```

**Problemas**:

- üîí Bloqueios distribu√≠dos (contention alta)
- ‚è± Timeouts longos (indisponibilidade)
- üêå N√£o escala (coordena√ß√£o centralizada)

### Depois (Saga Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Transa√ß√µes locais + compensa√ß√µes
final class PedidoSaga {
    SagaResult executar(Pedido pedido) {
        List<SagaStep> passos = List.of(
            new ReservarEstoqueStep(pedido),
            new DebitarPagamentoStep(pedido),
            new AgendarEntregaStep(pedido)
        );

        return orchestrator.executar(passos);
        // Falha em entrega -> compensa pagamento -> compensa estoque
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Passos e Resultados

```java
// Resultados poss√≠veis de cada passo
sealed interface SagaStepResult
    permits StepOk, StepFailed, StepCompensated {}

record StepOk(String descricao) implements SagaStepResult {}
record StepFailed(String motivo, Exception causa) implements SagaStepResult {}
record StepCompensated(String descricao) implements SagaStepResult {}

// Contrato de cada passo da saga
interface SagaStep {
    String getNome();
    StepOk executar() throws Exception;
    StepCompensated compensar();
}
```

### 2. Implementa√ß√£o de Passos Espec√≠ficos

```java
final class ReservaEstoqueStep implements SagaStep {
    private final EstoqueService estoqueService;
    private final String sku;
    private final int quantidade;
    private boolean reservado = false;

    ReservaEstoqueStep(EstoqueService service, String sku, int qtd) {
        this.estoqueService = service;
        this.sku = sku;
        this.quantidade = qtd;
    }

    @Override
    public String getNome() {
        return "ReservarEstoque";
    }

    @Override
    public StepOk executar() throws Exception {
        estoqueService.reservar(sku, quantidade);
        reservado = true;
        return new StepOk("Estoque reservado: " + sku + " x" + quantidade);
    }

    @Override
    public StepCompensated compensar() {
        if (reservado) {
            estoqueService.liberar(sku, quantidade);
            return new StepCompensated("Estoque liberado: " + sku);
        }
        return new StepCompensated("Nada a compensar (n√£o foi reservado)");
    }
}

final class DebitoPagamentoStep implements SagaStep {
    private final PagamentoService pagamentoService;
    private final String pedidoId;
    private final BigDecimal valor;
    private String transacaoId;

    DebitoPagamentoStep(PagamentoService service, String pedido, BigDecimal valor) {
        this.pagamentoService = service;
        this.pedidoId = pedido;
        this.valor = valor;
    }

    @Override
    public String getNome() {
        return "DebitarPagamento";
    }

    @Override
    public StepOk executar() throws Exception {
        transacaoId = pagamentoService.debitar(pedidoId, valor);
        return new StepOk("Pagamento debitado: R$ " + valor + " [" + transacaoId + "]");
    }

    @Override
    public StepCompensated compensar() {
        if (transacaoId != null) {
            pagamentoService.estornar(transacaoId);
            return new StepCompensated("Pagamento estornado: " + transacaoId);
        }
        return new StepCompensated("Nada a estornar");
    }
}

final class AgendarEntregaStep implements SagaStep {
    private final EntregaService entregaService;
    private final String pedidoId;
    private String agendamentoId;

    AgendarEntregaStep(EntregaService service, String pedido) {
        this.entregaService = service;
        this.pedidoId = pedido;
    }

    @Override
    public String getNome() {
        return "AgendarEntrega";
    }

    @Override
    public StepOk executar() throws Exception {
        agendamentoId = entregaService.agendar(pedidoId);
        return new StepOk("Entrega agendada: " + agendamentoId);
    }

    @Override
    public StepCompensated compensar() {
        if (agendamentoId != null) {
            entregaService.cancelar(agendamentoId);
            return new StepCompensated("Entrega cancelada: " + agendamentoId);
        }
        return new StepCompensated("Nada a cancelar");
    }
}
```

### 3. Orquestrador da Saga

```java
record SagaResult(
    boolean sucesso,
    List<SagaStepResult> historico,
    Optional<Exception> falha
) {}

final class SagaOrchestrator {
    private final List<SagaStep> passos;

    SagaOrchestrator(List<SagaStep> passos) {
        this.passos = List.copyOf(passos);
    }

    public SagaResult executar() {
        List<SagaStepResult> historico = new ArrayList<>();
        List<SagaStep> executados = new ArrayList<>();

        // Fase 1: Executar passos sequencialmente
        for (SagaStep passo : passos) {
            try {
                StepOk resultado = passo.executar();
                historico.add(resultado);
                executados.add(passo);
                System.out.println("‚úÖ " + passo.getNome() + ": " + resultado.descricao());

            } catch (Exception e) {
                System.err.println("‚ùå " + passo.getNome() + " falhou: " + e.getMessage());
                historico.add(new StepFailed(passo.getNome(), e));

                // Fase 2: Compensar na ordem inversa
                compensarPassos(executados, historico);

                return new SagaResult(false, historico, Optional.of(e));
            }
        }

        return new SagaResult(true, historico, Optional.empty());
    }

    private void compensarPassos(List<SagaStep> executados, List<SagaStepResult> historico) {
        Collections.reverse(executados);

        for (SagaStep passo : executados) {
            try {
                StepCompensated compensacao = passo.compensar();
                historico.add(compensacao);
                System.out.println("üîÑ Compensando " + passo.getNome() + ": " + compensacao.descricao());

            } catch (Exception e) {
                System.err.println("‚ö†Ô∏è Falha ao compensar " + passo.getNome() + ": " + e.getMessage());
                // Registrar em sistema de alertas - compensa√ß√£o falhou!
            }
        }
    }
}
```

### 4. Exemplo de Uso

```java
public class PedidoService {
    private final EstoqueService estoqueService;
    private final PagamentoService pagamentoService;
    private final EntregaService entregaService;

    public SagaResult processarPedido(Pedido pedido) {
        var saga = new SagaOrchestrator(List.of(
            new ReservaEstoqueStep(estoqueService, pedido.getSku(), pedido.getQuantidade()),
            new DebitoPagamentoStep(pagamentoService, pedido.getId(), pedido.getValor()),
            new AgendarEntregaStep(entregaService, pedido.getId())
        ));

        SagaResult resultado = saga.executar();

        if (resultado.sucesso()) {
            pedido.setStatus(StatusPedido.CONFIRMADO);
        } else {
            pedido.setStatus(StatusPedido.CANCELADO);
            pedido.setMotivoFalha(resultado.falha().get().getMessage());
        }

        return resultado;
    }
}
```

---

## üß™ Como Testar

### 1. Saga com Sucesso Completo

```java
@Test
void deveExecutarTodosPassosComSucesso() {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);
    var entrega = mock(EntregaService.class);

    when(pagamento.debitar(anyString(), any())).thenReturn("TXN123");
    when(entrega.agendar(anyString())).thenReturn("AGD456");

    var saga = new SagaOrchestrator(List.of(
        new ReservaEstoqueStep(estoque, "SKU1", 5),
        new DebitoPagamentoStep(pagamento, "PED1", new BigDecimal("100")),
        new AgendarEntregaStep(entrega, "PED1")
    ));

    // Act
    SagaResult resultado = saga.executar();

    // Assert
    assertTrue(resultado.sucesso());
    assertEquals(3, resultado.historico().stream()
        .filter(r -> r instanceof StepOk).count());
    assertTrue(resultado.falha().isEmpty());

    verify(estoque).reservar("SKU1", 5);
    verify(pagamento).debitar("PED1", new BigDecimal("100"));
    verify(entrega).agendar("PED1");
}
```

### 2. Falha no Segundo Passo Compensa o Primeiro

```java
@Test
void deveFalharNoPagamentoECompensarEstoque() {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);

    doThrow(new RuntimeException("Saldo insuficiente"))
        .when(pagamento).debitar(anyString(), any());

    var saga = new SagaOrchestrator(List.of(
        new ReservaEstoqueStep(estoque, "SKU1", 5),
        new DebitoPagamentoStep(pagamento, "PED1", new BigDecimal("100"))
    ));

    // Act
    SagaResult resultado = saga.executar();

    // Assert
    assertFalse(resultado.sucesso());
    assertTrue(resultado.falha().isPresent());
    assertEquals("Saldo insuficiente", resultado.falha().get().getMessage());

    // Verifica que estoque foi compensado
    verify(estoque).reservar("SKU1", 5);
    verify(estoque).liberar("SKU1", 5);
    verify(pagamento).debitar(anyString(), any());
    verify(pagamento, never()).estornar(anyString());
}
```

### 3. Falha no Terceiro Passo Compensa os Dois Anteriores

```java
@Test
void deveFalharNaEntregaECompensarPagamentoEEstoque() {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);
    var entrega = mock(EntregaService.class);

    when(pagamento.debitar(anyString(), any())).thenReturn("TXN123");
    doThrow(new RuntimeException("Regi√£o n√£o atendida"))
        .when(entrega).agendar(anyString());

    var saga = new SagaOrchestrator(List.of(
        new ReservaEstoqueStep(estoque, "SKU1", 5),
        new DebitoPagamentoStep(pagamento, "PED1", new BigDecimal("100")),
        new AgendarEntregaStep(entrega, "PED1")
    ));

    // Act
    SagaResult resultado = saga.executar();

    // Assert
    assertFalse(resultado.sucesso());

    // Verifica ordem de compensa√ß√£o (inversa)
    InOrder inOrder = inOrder(entrega, pagamento, estoque);
    inOrder.verify(estoque).reservar("SKU1", 5);
    inOrder.verify(pagamento).debitar("PED1", new BigDecimal("100"));
    inOrder.verify(entrega).agendar("PED1");
    inOrder.verify(pagamento).estornar("TXN123");
    inOrder.verify(estoque).liberar("SKU1", 5);
}
```

### 4. Verificar Hist√≥rico de Execu√ß√£o

```java
@Test
void deveRegistrarHistoricoCompleto() {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);

    when(pagamento.debitar(anyString(), any())).thenReturn("TXN123");
    doThrow(new RuntimeException("Erro X"))
        .when(pagamento).debitar(anyString(), any());

    var saga = new SagaOrchestrator(List.of(
        new ReservaEstoqueStep(estoque, "SKU1", 5),
        new DebitoPagamentoStep(pagamento, "PED1", new BigDecimal("100"))
    ));

    // Act
    SagaResult resultado = saga.executar();

    // Assert
    List<SagaStepResult> hist = resultado.historico();
    assertEquals(3, hist.size());
    assertInstanceOf(StepOk.class, hist.get(0));           // Estoque OK
    assertInstanceOf(StepFailed.class, hist.get(1));       // Pagamento falhou
    assertInstanceOf(StepCompensated.class, hist.get(2));  // Estoque compensado
}
```

### 5. Testar Idempot√™ncia de Compensa√ß√£o

```java
@Test
void compensacaoDeveSerIdempotente() {
    // Arrange
    var step = new ReservaEstoqueStep(mock(EstoqueService.class), "SKU1", 5);

    // Act - executar e compensar m√∫ltiplas vezes
    step.executar();
    StepCompensated comp1 = step.compensar();
    StepCompensated comp2 = step.compensar();

    // Assert - segunda compensa√ß√£o n√£o deve fazer nada
    assertNotNull(comp1);
    assertTrue(comp2.descricao().contains("Nada a compensar"));
}
```

### 6. Testar Concorr√™ncia (Race Condition)

```java
@Test
void deveSerThreadSafe() throws Exception {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);

    CountDownLatch latch = new CountDownLatch(10);
    List<SagaResult> resultados = new CopyOnWriteArrayList<>();

    // Act - 10 threads executando saga simultaneamente
    for (int i = 0; i < 10; i++) {
        new Thread(() -> {
            var saga = new SagaOrchestrator(List.of(
                new ReservaEstoqueStep(estoque, "SKU" + Thread.currentThread().getId(), 1),
                new DebitoPagamentoStep(pagamento, "PED" + Thread.currentThread().getId(), BigDecimal.TEN)
            ));
            resultados.add(saga.executar());
            latch.countDown();
        }).start();
    }

    latch.await(5, TimeUnit.SECONDS);

    // Assert
    assertEquals(10, resultados.size());
    verify(estoque, times(10)).reservar(anyString(), anyInt());
}
```

### 7. Testar Timeout em Passo da Saga

```java
@Test
void deveCompensarQuandoPassoExcederTimeout() {
    // Arrange
    var estoque = mock(EstoqueService.class);
    var pagamento = mock(PagamentoService.class);

    doAnswer(inv -> {
        Thread.sleep(3000); // Simula opera√ß√£o lenta
        return "TXN123";
    }).when(pagamento).debitar(anyString(), any());

    // Act & Assert
    assertTimeout(Duration.ofSeconds(5), () -> {
        var saga = new SagaOrchestrator(List.of(
            new ReservaEstoqueStep(estoque, "SKU1", 5),
            new DebitoPagamentoStep(pagamento, "PED1", BigDecimal.TEN)
        ));

        SagaResult resultado = saga.executar();

        // Verifica que compensa√ß√£o ocorreu
        verify(estoque).liberar("SKU1", 5);
    });
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Compensa√ß√£o n√£o idempotente
@Override
public StepCompensated compensar() {
    saldo -= valor; // Se chamar 2x, subtrai 2x!
    return new StepCompensated("Compensado");
}

// ‚ùå Ignorar falhas de compensa√ß√£o
try {
    passo.compensar();
} catch (Exception e) {
    // Ignorar silenciosamente - NUNCA!
}

// ‚ùå Estado compartilhado mut√°vel
static List<SagaStep> executados = new ArrayList<>(); // Race condition!
```

### ‚úÖ Fazer

```java
// ‚úÖ Compensa√ß√£o idempotente com flag
private boolean compensado = false;

@Override
public StepCompensated compensar() {
    if (!reservado || compensado) {
        return new StepCompensated("J√° compensado");
    }
    estoqueService.liberar(sku, quantidade);
    compensado = true;
    return new StepCompensated("Compensado com sucesso");
}

// ‚úÖ Alertar falhas de compensa√ß√£o
try {
    passo.compensar();
} catch (Exception e) {
    alertService.enviarAlerta("COMPENSA√á√ÉO FALHOU: " + passo.getNome(), e);
    // Registrar para interven√ß√£o manual
}

// ‚úÖ Saga imut√°vel
record SagaConfig(List<SagaStep> passos) {
    SagaConfig {
        passos = List.copyOf(passos); // C√≥pia defensiva
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Idempot√™ncia**: Compensa√ß√µes devem ser cham√°veis m√∫ltiplas vezes sem efeito colateral
- ‚úÖ **Ordem de compensa√ß√£o**: Sempre inversa √† ordem de execu√ß√£o
- ‚úÖ **Timeout por passo**: Cada passo deve ter timeout configurado
- ‚úÖ **Auditoria**: Log detalhado de execu√ß√£o e compensa√ß√µes
- ‚úÖ **Alertas**: Notificar quando compensa√ß√£o falhar (requer interven√ß√£o manual)
- ‚úÖ **Versionamento**: Passos da saga devem ter vers√£o para evolu√ß√£o
- ‚úÖ **Isolamento**: Cada passo deve ser independente (sem estado compartilhado)

---

## üîó Integra√ß√£o com Frameworks

### Spring com Axon Framework

```java
@Saga
public class PedidoSaga {

    @StartSaga
    @SagaEventHandler(associationProperty = "pedidoId")
    public void on(PedidoCriadoEvent event) {
        commandGateway.send(new ReservarEstoqueCommand(event.pedidoId(), event.sku()));
    }

    @SagaEventHandler(associationProperty = "pedidoId")
    public void on(EstoqueReservadoEvent event) {
        commandGateway.send(new DebitarPagamentoCommand(event.pedidoId()));
    }

    @SagaEventHandler(associationProperty = "pedidoId")
    public void on(PagamentoFalhouEvent event) {
        // Compensa√ß√£o autom√°tica
        commandGateway.send(new LiberarEstoqueCommand(event.pedidoId()));
    }

    @EndSaga
    @SagaEventHandler(associationProperty = "pedidoId")
    public void on(PedidoFinalizadoEvent event) {
        // Saga conclu√≠da
    }
}
```

### MicroProfile LRA (Long Running Actions)

```java
@Path("/pedido")
public class PedidoResource {

    @POST
    @LRA(value = LRA.Type.REQUIRES_NEW, end = false)
    public Response criar(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId, Pedido pedido) {
        estoqueService.reservar(pedido);
        return Response.ok().build();
    }

    @PUT
    @Path("/compensate")
    @Compensate
    public Response compensar(@HeaderParam(LRA_HTTP_CONTEXT_HEADER) String lraId) {
        estoqueService.liberar(lraId);
        return Response.ok().build();
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                            | ‚ö†Ô∏è Desvantagens                        |
| --------------------------------------- | -------------------------------------- |
| Escalabilidade sem bloqueios globais    | Complexidade de implementa√ß√£o          |
| Resili√™ncia (falha parcial compens√°vel) | Consist√™ncia eventual (n√£o imediata)   |
| Independ√™ncia de servi√ßos               | Compensa√ß√µes podem falhar              |
| Sem deadlocks distribu√≠dos              | Dificulta debugging (log distribu√≠do)  |
| Melhor performance (sem 2PC)            | Requer idempot√™ncia em todos os passos |

---

## üîç Compara√ß√£o com Outras Abordagens

| Aspecto          | Saga     | 2PC (Two-Phase Commit) | Event Sourcing |
| ---------------- | -------- | ---------------------- | -------------- |
| **Consist√™ncia** | Eventual | Forte (ACID)           | Eventual       |
| **Bloqueios**    | Nenhum   | Global                 | Nenhum         |
| **Performance**  | Alta     | Baixa                  | Alta           |
| **Complexidade** | M√©dia    | Baixa                  | Alta           |
| **Compensa√ß√£o**  | Manual   | Autom√°tica             | Via eventos    |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar saga coreografada** usando eventos do Spring Event
2. **Adicionar retry** em cada passo da saga (combinar com Retry Pattern)
3. **Criar dashboard** de monitoramento de sagas em execu√ß√£o
4. **Implementar saga com timeout** por passo (combinar com Timeout Pattern)
5. **Versionar passos** da saga para permitir evolu√ß√£o sem quebrar sagas em andamento

---

## üìö Relacionado

- **Circuit Breaker**: Proteger cada passo da saga de falhas em cascata
- **Retry Pattern**: Tentar novamente passos que falharam temporariamente
- **Event Sourcing**: Armazenar cada passo como evento imut√°vel
- **CQRS**: Separar comandos (saga) de consultas (leitura)
- **Idempot√™ncia**: Essencial para compensa√ß√µes seguras

---

**Saga Pattern √© fundamental para transa√ß√µes distribu√≠das em microsservi√ßos, mas requer design cuidadoso de compensa√ß√µes e monitoramento robusto!** üîÑ‚ú®
