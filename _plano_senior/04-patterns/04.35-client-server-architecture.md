# 04.35 Client-Server Architecture [M√âDIO] üñ•Ô∏è‚ÜîÔ∏èüíª

## üéØ Objetivo

Separar **cliente** (interface/apresenta√ß√£o) de **servidor** (l√≥gica/dados) atrav√©s de **APIs REST**, permitindo **testes isolados de endpoints** e desenvolvimento independente de front/backend.

---

## üìö O Que √â?

**Client-Server Architecture** divide aplica√ß√£o em duas partes: servidor (backend) que processa requisi√ß√µes e gerencia dados, e cliente (frontend) que apresenta interface e faz requisi√ß√µes HTTP.

### Analogia

Como um **restaurante**:

- **Cliente**: Mesa onde voc√™ est√° sentado
- **Gar√ßom (API)**: Intermedi√°rio que leva pedidos e traz comida
- **Cozinha (Servidor)**: Prepara os pratos (processa l√≥gica)
- **Vantagem**: Cozinha pode atender m√∫ltiplos clientes simultaneamente, trocar card√°pio sem mudar mesas

---

## ‚ùå Problema que Resolve

### Antes (Aplica√ß√£o Monol√≠tica Desktop/Web)

```java
// ‚ùå PROBLEMA: UI e l√≥gica acopladas

// Swing/JavaFX - UI misturada com l√≥gica
class PedidoForm extends JFrame {

    private JTextField clienteField;
    private JButton salvarButton;
    private Connection dbConnection; // BD direto na UI ‚ùå

    void salvarButtonClicked() {
        String cliente = clienteField.getText();

        // SQL direto na UI ‚ùå
        try (PreparedStatement stmt = dbConnection.prepareStatement(
            "INSERT INTO pedidos (cliente, valor) VALUES (?, ?)")) {

            stmt.setString(1, cliente);
            stmt.setDouble(2, calcularTotal()); // L√≥gica na UI ‚ùå
            stmt.executeUpdate();

            JOptionPane.showMessageDialog(this, "Salvo!");

        } catch (SQLException e) {
            JOptionPane.showMessageDialog(this, "Erro: " + e);
        }
    }

    private double calcularTotal() {
        // L√≥gica de neg√≥cio na UI ‚ùå
        double total = 0;
        for (Item item : itens) {
            total += item.getPreco() * item.getQuantidade();
        }
        return total;
    }
}

// Problemas:
// - UI e l√≥gica misturadas ‚ùå
// - Imposs√≠vel criar app mobile/web reutilizando l√≥gica ‚ùå
// - Testar UI = testar banco ‚ùå
// - 1 cliente conectado = 1 conex√£o BD ‚ùå
// - Distribuir mudan√ßas = reinstalar em todos clientes ‚ùå
```

**Problemas**:

- üß© UI e l√≥gica acopladas
- üì± Dif√≠cil criar m√∫ltiplos clientes (web, mobile, desktop)
- üß™ Testar UI = testar tudo
- üîß Deploy de cliente = reinstalar em m√°quinas
- üíæ M√∫ltiplas conex√µes diretas ao BD

### Depois (Client-Server com REST API)

```java
// ‚úÖ SOLU√á√ÉO: Servidor exp√µe API REST, cliente consome

// ==== SERVIDOR (Backend - Spring Boot) ====
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service;

    @PostMapping
    ResponseEntity<PedidoDTO> criar(@RequestBody PedidoRequest request) {
        // Apenas coordena - l√≥gica no service
        Pedido pedido = service.criar(request);
        return ResponseEntity.ok(PedidoDTO.from(pedido));
    }

    @GetMapping
    List<PedidoDTO> listar() {
        return service.listarTodos().stream()
            .map(PedidoDTO::from)
            .toList();
    }
}

@Service
class PedidoService {
    // L√≥gica de neg√≥cio isolada
    Pedido criar(PedidoRequest request) {
        // Calcula total, valida, salva
        return repository.save(pedido);
    }
}

// ==== CLIENTE 1: Web (JavaScript/React) ====
// fetch('/api/pedidos', { method: 'POST', body: JSON.stringify(data) })

// ==== CLIENTE 2: Mobile (Kotlin/Swift) ====
// URLSession.shared.dataTask(with: url) { data, response, error in ... }

// ==== CLIENTE 3: Desktop (JavaFX) ====
class PedidoFormFX extends VBox {
    private final PedidoApiClient apiClient; // Cliente HTTP ‚úÖ

    void salvar() {
        PedidoRequest request = new PedidoRequest(
            clienteField.getText(),
            itens
        );

        // Chama API via HTTP ‚úÖ
        apiClient.criar(request)
            .thenAccept(pedido -> {
                Alert alert = new Alert(AlertType.INFORMATION, "Pedido criado: " + pedido.id());
                alert.show();
            })
            .exceptionally(ex -> {
                Alert alert = new Alert(AlertType.ERROR, "Erro: " + ex.getMessage());
                alert.show();
                return null;
            });
    }
}

// Cliente HTTP (reutiliz√°vel)
class PedidoApiClient {
    private final HttpClient httpClient = HttpClient.newHttpClient();
    private final String baseUrl = "http://localhost:8080/api";

    CompletableFuture<PedidoDTO> criar(PedidoRequest request) {
        HttpRequest httpRequest = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/pedidos"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(toJson(request)))
            .build();

        return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
            .thenApply(response -> fromJson(response.body(), PedidoDTO.class));
    }
}

// ‚úÖ Vantagens:
// - M√∫ltiplos clientes (web, mobile, desktop) ‚úÖ
// - L√≥gica centralizada no servidor ‚úÖ
// - Testes de API independentes de UI ‚úÖ
// - Deploy de servidor n√£o afeta clientes ‚úÖ
// - Pool de conex√µes BD gerenciado ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Servidor REST API (Backend)

```java
// ===== SERVER: Spring Boot REST API =====

// Entidade de Dom√≠nio
@Entity
@Table(name = "produtos")
class Produto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String nome;

    @Column(nullable = false)
    private String descricao;

    @Column(nullable = false)
    private BigDecimal preco;

    @Column(nullable = false)
    private Integer estoque;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    // Construtores, getters, setters
    protected Produto() {}

    Produto(String nome, String descricao, BigDecimal preco, int estoque) {
        this.nome = nome;
        this.descricao = descricao;
        this.preco = preco;
        this.estoque = estoque;
        this.criadoEm = LocalDateTime.now();
    }
}

// Repository
@Repository
interface ProdutoRepository extends JpaRepository<Produto, Long> {
    List<Produto> findByNomeContainingIgnoreCase(String nome);
    List<Produto> findByPrecoLessThanEqual(BigDecimal preco);
}

// Service (L√≥gica de Neg√≥cio)
@Service
class ProdutoService {

    private final ProdutoRepository repository;

    @Autowired
    ProdutoService(ProdutoRepository repository) {
        this.repository = repository;
    }

    @Transactional
    public Produto criar(CriarProdutoRequest request) {
        validarPreco(request.preco());

        Produto produto = new Produto(
            request.nome(),
            request.descricao(),
            request.preco(),
            request.estoque()
        );

        return repository.save(produto);
    }

    @Transactional(readOnly = true)
    public List<Produto> listarTodos() {
        return repository.findAll();
    }

    @Transactional(readOnly = true)
    public Optional<Produto> buscarPorId(Long id) {
        return repository.findById(id);
    }

    @Transactional
    public Produto atualizar(Long id, AtualizarProdutoRequest request) {
        Produto produto = repository.findById(id)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(id));

        if (request.nome() != null) {
            produto.setNome(request.nome());
        }
        if (request.preco() != null) {
            validarPreco(request.preco());
            produto.setPreco(request.preco());
        }
        if (request.estoque() != null) {
            produto.setEstoque(request.estoque());
        }

        return repository.save(produto);
    }

    @Transactional
    public void deletar(Long id) {
        if (!repository.existsById(id)) {
            throw new ProdutoNaoEncontradoException(id);
        }
        repository.deleteById(id);
    }

    public List<Produto> buscarPorNome(String nome) {
        return repository.findByNomeContainingIgnoreCase(nome);
    }

    private void validarPreco(BigDecimal preco) {
        if (preco.compareTo(BigDecimal.ZERO) <= 0) {
            throw new PrecoInvalidoException("Pre√ßo deve ser maior que zero");
        }
    }
}

// REST Controller (Endpoints)
@RestController
@RequestMapping("/api/produtos")
@CrossOrigin(origins = "*") // Permite acesso de qualquer origem (dev)
class ProdutoController {

    private final ProdutoService service;

    @Autowired
    ProdutoController(ProdutoService service) {
        this.service = service;
    }

    // POST /api/produtos
    @PostMapping
    ResponseEntity<ProdutoDTO> criar(@Valid @RequestBody CriarProdutoRequest request) {
        Produto produto = service.criar(request);
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(ProdutoDTO.from(produto));
    }

    // GET /api/produtos
    @GetMapping
    ResponseEntity<List<ProdutoDTO>> listar(@RequestParam(required = false) String nome) {
        List<Produto> produtos = nome != null
            ? service.buscarPorNome(nome)
            : service.listarTodos();

        List<ProdutoDTO> dtos = produtos.stream()
            .map(ProdutoDTO::from)
            .toList();

        return ResponseEntity.ok(dtos);
    }

    // GET /api/produtos/{id}
    @GetMapping("/{id}")
    ResponseEntity<ProdutoDTO> buscar(@PathVariable Long id) {
        return service.buscarPorId(id)
            .map(ProdutoDTO::from)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    // PUT /api/produtos/{id}
    @PutMapping("/{id}")
    ResponseEntity<ProdutoDTO> atualizar(
        @PathVariable Long id,
        @Valid @RequestBody AtualizarProdutoRequest request
    ) {
        Produto produto = service.atualizar(id, request);
        return ResponseEntity.ok(ProdutoDTO.from(produto));
    }

    // DELETE /api/produtos/{id}
    @DeleteMapping("/{id}")
    ResponseEntity<Void> deletar(@PathVariable Long id) {
        service.deletar(id);
        return ResponseEntity.noContent().build();
    }

    // Exception Handlers
    @ExceptionHandler(ProdutoNaoEncontradoException.class)
    ResponseEntity<ErrorResponse> handleNotFound(ProdutoNaoEncontradoException ex) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(ex.getMessage()));
    }

    @ExceptionHandler(PrecoInvalidoException.class)
    ResponseEntity<ErrorResponse> handleValidation(PrecoInvalidoException ex) {
        return ResponseEntity
            .badRequest()
            .body(new ErrorResponse(ex.getMessage()));
    }
}

// DTOs (Data Transfer Objects)
record CriarProdutoRequest(
    @NotBlank(message = "Nome √© obrigat√≥rio")
    String nome,

    @NotBlank(message = "Descri√ß√£o √© obrigat√≥ria")
    String descricao,

    @NotNull(message = "Pre√ßo √© obrigat√≥rio")
    @DecimalMin(value = "0.01", message = "Pre√ßo deve ser maior que zero")
    BigDecimal preco,

    @NotNull(message = "Estoque √© obrigat√≥rio")
    @Min(value = 0, message = "Estoque n√£o pode ser negativo")
    Integer estoque
) {}

record AtualizarProdutoRequest(
    String nome,
    BigDecimal preco,
    Integer estoque
) {}

record ProdutoDTO(
    Long id,
    String nome,
    String descricao,
    BigDecimal preco,
    Integer estoque,
    LocalDateTime criadoEm
) {
    static ProdutoDTO from(Produto produto) {
        return new ProdutoDTO(
            produto.getId(),
            produto.getNome(),
            produto.getDescricao(),
            produto.getPreco(),
            produto.getEstoque(),
            produto.getCriadoEm()
        );
    }
}

record ErrorResponse(String mensagem) {}

// Exceptions
class ProdutoNaoEncontradoException extends RuntimeException {
    ProdutoNaoEncontradoException(Long id) {
        super("Produto n√£o encontrado: " + id);
    }
}

class PrecoInvalidoException extends RuntimeException {
    PrecoInvalidoException(String mensagem) {
        super(mensagem);
    }
}

// application.yml
/*
server:
  port: 8080

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/produtos_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
*/
```

### 2. Cliente HTTP (API Client - Biblioteca Reutiliz√°vel)

```java
// ===== CLIENT: HTTP Client Library =====

// Interface do Cliente API
interface ProdutoApiClient {
    CompletableFuture<ProdutoDTO> criar(CriarProdutoRequest request);
    CompletableFuture<List<ProdutoDTO>> listar(String filtroNome);
    CompletableFuture<ProdutoDTO> buscar(Long id);
    CompletableFuture<ProdutoDTO> atualizar(Long id, AtualizarProdutoRequest request);
    CompletableFuture<Void> deletar(Long id);
}

// Implementa√ß√£o com HttpClient (Java 11+)
class ProdutoApiClientImpl implements ProdutoApiClient {

    private final HttpClient httpClient;
    private final String baseUrl;
    private final ObjectMapper objectMapper;

    ProdutoApiClientImpl(String baseUrl) {
        this.httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(10))
            .build();
        this.baseUrl = baseUrl;
        this.objectMapper = new ObjectMapper()
            .registerModule(new JavaTimeModule());
    }

    @Override
    public CompletableFuture<ProdutoDTO> criar(CriarProdutoRequest request) {
        try {
            String json = objectMapper.writeValueAsString(request);

            HttpRequest httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/api/produtos"))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(json))
                .build();

            return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
                .thenApply(response -> {
                    if (response.statusCode() != 201) {
                        throw new ApiException("Erro ao criar produto: " + response.statusCode());
                    }
                    try {
                        return objectMapper.readValue(response.body(), ProdutoDTO.class);
                    } catch (IOException e) {
                        throw new ApiException("Erro ao parsear resposta", e);
                    }
                });

        } catch (IOException e) {
            return CompletableFuture.failedFuture(new ApiException("Erro ao serializar request", e));
        }
    }

    @Override
    public CompletableFuture<List<ProdutoDTO>> listar(String filtroNome) {
        String url = baseUrl + "/api/produtos";
        if (filtroNome != null) {
            url += "?nome=" + URLEncoder.encode(filtroNome, StandardCharsets.UTF_8);
        }

        HttpRequest httpRequest = HttpRequest.newBuilder()
            .uri(URI.create(url))
            .GET()
            .build();

        return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
            .thenApply(response -> {
                if (response.statusCode() != 200) {
                    throw new ApiException("Erro ao listar produtos: " + response.statusCode());
                }
                try {
                    return objectMapper.readValue(
                        response.body(),
                        new TypeReference<List<ProdutoDTO>>() {}
                    );
                } catch (IOException e) {
                    throw new ApiException("Erro ao parsear resposta", e);
                }
            });
    }

    @Override
    public CompletableFuture<ProdutoDTO> buscar(Long id) {
        HttpRequest httpRequest = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/api/produtos/" + id))
            .GET()
            .build();

        return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
            .thenApply(response -> {
                if (response.statusCode() == 404) {
                    throw new ProdutoNaoEncontradoException(id);
                }
                if (response.statusCode() != 200) {
                    throw new ApiException("Erro ao buscar produto: " + response.statusCode());
                }
                try {
                    return objectMapper.readValue(response.body(), ProdutoDTO.class);
                } catch (IOException e) {
                    throw new ApiException("Erro ao parsear resposta", e);
                }
            });
    }

    @Override
    public CompletableFuture<ProdutoDTO> atualizar(Long id, AtualizarProdutoRequest request) {
        try {
            String json = objectMapper.writeValueAsString(request);

            HttpRequest httpRequest = HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/api/produtos/" + id))
                .header("Content-Type", "application/json")
                .PUT(HttpRequest.BodyPublishers.ofString(json))
                .build();

            return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
                .thenApply(response -> {
                    if (response.statusCode() != 200) {
                        throw new ApiException("Erro ao atualizar produto: " + response.statusCode());
                    }
                    try {
                        return objectMapper.readValue(response.body(), ProdutoDTO.class);
                    } catch (IOException e) {
                        throw new ApiException("Erro ao parsear resposta", e);
                    }
                });

        } catch (IOException e) {
            return CompletableFuture.failedFuture(new ApiException("Erro ao serializar request", e));
        }
    }

    @Override
    public CompletableFuture<Void> deletar(Long id) {
        HttpRequest httpRequest = HttpRequest.newBuilder()
            .uri(URI.create(baseUrl + "/api/produtos/" + id))
            .DELETE()
            .build();

        return httpClient.sendAsync(httpRequest, HttpResponse.BodyHandlers.ofString())
            .thenApply(response -> {
                if (response.statusCode() != 204) {
                    throw new ApiException("Erro ao deletar produto: " + response.statusCode());
                }
                return null;
            });
    }
}

class ApiException extends RuntimeException {
    ApiException(String mensagem) {
        super(mensagem);
    }

    ApiException(String mensagem, Throwable causa) {
        super(mensagem, causa);
    }
}
```

### 3. Cliente Desktop (JavaFX)

```java
// ===== CLIENT: JavaFX Desktop Application =====

@ApplicationScoped
class ProdutoFormController {

    @FXML
    private TextField nomeField;

    @FXML
    private TextArea descricaoArea;

    @FXML
    private TextField precoField;

    @FXML
    private TextField estoqueField;

    @FXML
    private TableView<ProdutoDTO> tabelaProdutos;

    @FXML
    private Label statusLabel;

    private final ProdutoApiClient apiClient;

    public ProdutoFormController() {
        this.apiClient = new ProdutoApiClientImpl("http://localhost:8080");
    }

    @FXML
    public void initialize() {
        carregarProdutos();
    }

    @FXML
    private void salvarProduto() {
        try {
            CriarProdutoRequest request = new CriarProdutoRequest(
                nomeField.getText(),
                descricaoArea.getText(),
                new BigDecimal(precoField.getText()),
                Integer.parseInt(estoqueField.getText())
            );

            apiClient.criar(request)
                .thenAccept(produto -> Platform.runLater(() -> {
                    statusLabel.setText("‚úÖ Produto criado: " + produto.nome());
                    limparFormulario();
                    carregarProdutos();
                }))
                .exceptionally(ex -> {
                    Platform.runLater(() ->
                        statusLabel.setText("‚ùå Erro: " + ex.getMessage())
                    );
                    return null;
                });

        } catch (Exception e) {
            statusLabel.setText("‚ùå Dados inv√°lidos: " + e.getMessage());
        }
    }

    @FXML
    private void deletarProdutoSelecionado() {
        ProdutoDTO selecionado = tabelaProdutos.getSelectionModel().getSelectedItem();
        if (selecionado == null) {
            statusLabel.setText("‚ö†Ô∏è Selecione um produto");
            return;
        }

        apiClient.deletar(selecionado.id())
            .thenRun(() -> Platform.runLater(() -> {
                statusLabel.setText("‚úÖ Produto deletado");
                carregarProdutos();
            }))
            .exceptionally(ex -> {
                Platform.runLater(() ->
                    statusLabel.setText("‚ùå Erro ao deletar: " + ex.getMessage())
                );
                return null;
            });
    }

    private void carregarProdutos() {
        apiClient.listar(null)
            .thenAccept(produtos -> Platform.runLater(() -> {
                tabelaProdutos.getItems().setAll(produtos);
                statusLabel.setText("üìä " + produtos.size() + " produtos carregados");
            }))
            .exceptionally(ex -> {
                Platform.runLater(() ->
                    statusLabel.setText("‚ùå Erro ao carregar: " + ex.getMessage())
                );
                return null;
            });
    }

    private void limparFormulario() {
        nomeField.clear();
        descricaoArea.clear();
        precoField.clear();
        estoqueField.clear();
    }
}
```

### 4. Cliente Web (JavaScript/Fetch API)

```javascript
// ===== CLIENT: Web JavaScript =====

class ProdutoApiClient {
  constructor(baseUrl = "http://localhost:8080") {
    this.baseUrl = baseUrl;
  }

  async criar(produto) {
    const response = await fetch(`${this.baseUrl}/api/produtos`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(produto),
    });

    if (!response.ok) {
      throw new Error(`Erro ${response.status}: ${await response.text()}`);
    }

    return response.json();
  }

  async listar(filtroNome = null) {
    const url = filtroNome
      ? `${this.baseUrl}/api/produtos?nome=${encodeURIComponent(filtroNome)}`
      : `${this.baseUrl}/api/produtos`;

    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Erro ${response.status}`);
    }

    return response.json();
  }

  async buscar(id) {
    const response = await fetch(`${this.baseUrl}/api/produtos/${id}`);

    if (response.status === 404) {
      throw new Error("Produto n√£o encontrado");
    }
    if (!response.ok) {
      throw new Error(`Erro ${response.status}`);
    }

    return response.json();
  }

  async atualizar(id, produto) {
    const response = await fetch(`${this.baseUrl}/api/produtos/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(produto),
    });

    if (!response.ok) {
      throw new Error(`Erro ${response.status}`);
    }

    return response.json();
  }

  async deletar(id) {
    const response = await fetch(`${this.baseUrl}/api/produtos/${id}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      throw new Error(`Erro ${response.status}`);
    }
  }
}

// Uso na p√°gina HTML
const apiClient = new ProdutoApiClient();

async function carregarProdutos() {
  try {
    const produtos = await apiClient.listar();
    renderizarTabela(produtos);
  } catch (erro) {
    console.error("Erro ao carregar produtos:", erro);
    alert("Erro ao carregar produtos: " + erro.message);
  }
}

async function salvarProduto() {
  const produto = {
    nome: document.getElementById("nome").value,
    descricao: document.getElementById("descricao").value,
    preco: parseFloat(document.getElementById("preco").value),
    estoque: parseInt(document.getElementById("estoque").value),
  };

  try {
    await apiClient.criar(produto);
    alert("‚úÖ Produto criado com sucesso!");
    carregarProdutos();
  } catch (erro) {
    alert("‚ùå Erro: " + erro.message);
  }
}
```

---

## üß™ Como Testar

### 1. Testar Servidor (Endpoints)

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
class ProdutoControllerTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void deveCriarProdutoComSucesso() {
        // Arrange
        CriarProdutoRequest request = new CriarProdutoRequest(
            "Notebook",
            "Dell Inspiron",
            BigDecimal.valueOf(3000),
            10
        );

        // Act
        ResponseEntity<ProdutoDTO> response = restTemplate.postForEntity(
            "/api/produtos",
            request,
            ProdutoDTO.class
        );

        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("Notebook", response.getBody().nome());
    }

    @Test
    void deveListarProdutos() {
        // Act
        ResponseEntity<ProdutoDTO[]> response = restTemplate.getForEntity(
            "/api/produtos",
            ProdutoDTO[].class
        );

        // Assert
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertNotNull(response.getBody());
    }
}
```

### 2. Testar Cliente HTTP

```java
class ProdutoApiClientTest {

    private ProdutoApiClient client;
    private MockWebServer mockServer;

    @BeforeEach
    void setup() throws IOException {
        mockServer = new MockWebServer();
        mockServer.start();
        client = new ProdutoApiClientImpl(mockServer.url("/").toString());
    }

    @AfterEach
    void teardown() throws IOException {
        mockServer.shutdown();
    }

    @Test
    void deveCriarProdutoViaChamadaHTTP() throws Exception {
        // Arrange - mock da resposta do servidor
        mockServer.enqueue(new MockResponse()
            .setResponseCode(201)
            .setBody("""
                {
                    "id": 1,
                    "nome": "Notebook",
                    "descricao": "Dell",
                    "preco": 3000,
                    "estoque": 10,
                    "criadoEm": "2025-01-01T10:00:00"
                }
                """)
            .addHeader("Content-Type", "application/json"));

        CriarProdutoRequest request = new CriarProdutoRequest(
            "Notebook", "Dell", BigDecimal.valueOf(3000), 10
        );

        // Act
        ProdutoDTO produto = client.criar(request).get();

        // Assert
        assertEquals("Notebook", produto.nome());
        assertEquals(1L, produto.id());
    }
}
```

### 3. Teste de Integra√ß√£o (End-to-End)

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
class ClientServerE2ETest {

    private ProdutoApiClient client;

    @BeforeEach
    void setup() {
        client = new ProdutoApiClientImpl("http://localhost:8080");
    }

    @Test
    void deveRealizarFluxoCompletoViaAPI() throws Exception {
        // Criar
        CriarProdutoRequest criarReq = new CriarProdutoRequest(
            "Mouse", "Logitech", BigDecimal.valueOf(50), 100
        );
        ProdutoDTO criado = client.criar(criarReq).get();
        assertNotNull(criado.id());

        // Buscar
        ProdutoDTO buscado = client.buscar(criado.id()).get();
        assertEquals("Mouse", buscado.nome());

        // Atualizar
        AtualizarProdutoRequest atualizarReq = new AtualizarProdutoRequest(
            "Mouse Gamer", BigDecimal.valueOf(80), 50
        );
        ProdutoDTO atualizado = client.atualizar(criado.id(), atualizarReq).get();
        assertEquals("Mouse Gamer", atualizado.nome());

        // Deletar
        client.deletar(criado.id()).get();

        // Verificar dele√ß√£o
        assertThrows(ProdutoNaoEncontradoException.class, () -> {
            client.buscar(criado.id()).get();
        });
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Cliente acessando BD diretamente
class BadClient {
    private Connection dbConnection; // ‚ùå
}

// ‚ùå Servidor com estado (sess√µes)
@RestController
class BadController {
    private List<String> carrinho; // ‚ùå Estado no servidor
}

// ‚ùå Endpoint sem valida√ß√£o
@PostMapping
void criar(@RequestBody Produto p) { // ‚ùå Sem @Valid
    service.save(p);
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Cliente via HTTP
class GoodClient {
    private HttpClient httpClient; // ‚úÖ
}

// ‚úÖ Servidor stateless
@RestController
class GoodController {
    // Sem estado - cada requisi√ß√£o independente ‚úÖ
}

// ‚úÖ Valida√ß√£o de entrada
@PostMapping
void criar(@Valid @RequestBody ProdutoRequest p) { // ‚úÖ
    service.save(p);
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Stateless Server**: Servidor sem estado de sess√£o
- ‚úÖ **REST Principles**: Usar verbos HTTP corretamente
- ‚úÖ **DTOs**: N√£o expor entidades diretamente
- ‚úÖ **Versionamento**: `/api/v1/produtos`
- ‚úÖ **CORS**: Configurar para web clients
- ‚úÖ **HTTPS**: Sempre em produ√ß√£o
- ‚úÖ **Rate Limiting**: Proteger APIs

---

## üîó Padr√µes REST

| Verbo      | Endpoint             | A√ß√£o               |
| ---------- | -------------------- | ------------------ |
| **GET**    | `/api/produtos`      | Listar todos       |
| **GET**    | `/api/produtos/{id}` | Buscar por ID      |
| **POST**   | `/api/produtos`      | Criar novo         |
| **PUT**    | `/api/produtos/{id}` | Atualizar completo |
| **PATCH**  | `/api/produtos/{id}` | Atualizar parcial  |
| **DELETE** | `/api/produtos/{id}` | Deletar            |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                              | ‚ö†Ô∏è Desvantagens                  |
| ----------------------------------------- | -------------------------------- |
| M√∫ltiplos clientes (web, mobile, desktop) | Lat√™ncia de rede                 |
| L√≥gica centralizada                       | Requer conectividade             |
| Escalabilidade do servidor                | Mais complexo que app standalone |
| Deploy independente cliente/servidor      | Versionamento de API             |

---

## üîç Compara√ß√£o

| Padr√£o            | Comunica√ß√£o      | Quando Usar                   |
| ----------------- | ---------------- | ----------------------------- |
| **Client-Server** | HTTP/REST        | Web, mobile, desktop          |
| **Peer-to-Peer**  | Direto           | Torrent, blockchain           |
| **Microservices** | HTTP + Messaging | Sistemas distribu√≠dos grandes |
| **Monol√≠tico**    | In-process       | Apps pequenos/simples         |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Adicionar autentica√ß√£o** (JWT, OAuth)
2. **Implementar pagina√ß√£o** (Page, Pageable)
3. **Adicionar cache** (Redis, ETag)
4. **WebSockets** (comunica√ß√£o bidirecional)
5. **GraphQL** (alternativa ao REST)

---

## üìö Relacionado

- **REST API Design**: Princ√≠pios de APIs RESTful
- **API Gateway**: Proxy para m√∫ltiplas APIs
- **BFF Pattern**: Backend For Frontend
- **HATEOAS**: Hypermedia As The Engine Of Application State

---

**Client-Server Architecture separa UI de l√≥gica via APIs REST, permitindo m√∫ltiplos clientes e testes isolados!** üñ•Ô∏è‚ÜîÔ∏èüíª‚ú®
