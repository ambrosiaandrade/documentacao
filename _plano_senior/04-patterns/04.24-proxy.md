# 04.24 Proxy Pattern [M√âDIO] üö™

## üéØ Objetivo

Fornecer um **substituto ou placeholder** para outro objeto para controlar acesso, adicionar lazy loading, cache, logging ou valida√ß√£o de permiss√µes, facilitando **testes com doubles**.

---

## üìö O Que √â?

**Proxy** √© um padr√£o estrutural GoF que fornece um objeto representante (proxy) que controla acesso a outro objeto (real subject). O proxy implementa a mesma interface do objeto real, atuando como intermedi√°rio transparente.

### Analogia

Como um **cart√£o de cr√©dito**:

- **Dinheiro real**: Subject real (objeto caro/distante)
- **Cart√£o**: Proxy (substituto conveniente)
- **Vantagens**: Controle de acesso, rastreamento, prote√ß√£o
- **Transparente**: Cliente usa cart√£o como se fosse dinheiro

---

## ‚ùå Problema que Resolve

### Antes (Acesso Direto)

```java
// ‚ùå PROBLEMA: Objeto pesado criado sempre, sem controle
class RelatorioService {
    private final DatabaseConnection db = new DatabaseConnection(); // Pesado ‚ùå

    Relatorio gerar(String tipo) {
        // Conecta sempre, mesmo se desnecess√°rio ‚ùå
        db.connect();

        List<Dados> dados = db.query("SELECT * FROM transacoes");
        return new Relatorio(tipo, dados);
    }
}

// Problemas:
// - Conex√£o BD criada mesmo se n√£o usada
// - Sem cache (busca sempre)
// - Sem controle de permiss√£o
// - Dif√≠cil testar (depend√™ncia real do BD)
```

**Problemas**:

- üêå Objeto pesado criado antecipadamente
- üîì Sem controle de acesso/permiss√µes
- üîÑ Sem cache (opera√ß√µes caras repetidas)
- üß™ Dif√≠cil testar (acoplamento com recurso real)
- üìù Sem logging transparente

### Depois (Proxy Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Proxy controla acesso ao objeto real
interface RelatorioService {
    Relatorio gerar(String tipo);
}

// Subject real (objeto pesado)
class RelatorioServiceReal implements RelatorioService {
    private final DatabaseConnection db;

    RelatorioServiceReal(DatabaseConnection db) {
        this.db = db;
    }

    public Relatorio gerar(String tipo) {
        System.out.println("üîç Buscando dados do BD...");
        db.connect();
        List<Dados> dados = db.query("SELECT * FROM transacoes");
        return new Relatorio(tipo, dados);
    }
}

// Proxy com lazy loading + cache
class RelatorioServiceProxy implements RelatorioService {
    private RelatorioServiceReal real;
    private final DatabaseConnection db;
    private final Map<String, Relatorio> cache = new HashMap<>();

    RelatorioServiceProxy(DatabaseConnection db) {
        this.db = db;
    }

    public Relatorio gerar(String tipo) {
        // 1. Cache
        if (cache.containsKey(tipo)) {
            System.out.println("üéØ Cache HIT: " + tipo);
            return cache.get(tipo);
        }

        // 2. Lazy loading
        if (real == null) {
            System.out.println("‚öôÔ∏è Inicializando servi√ßo real...");
            real = new RelatorioServiceReal(db);
        }

        // 3. Delega√ß√£o
        Relatorio relatorio = real.gerar(tipo);
        cache.put(tipo, relatorio);

        return relatorio;
    }
}

// Teste com mock
@Test
void proxyDeveFazerLazyLoading() {
    DatabaseConnection dbMock = mock(DatabaseConnection.class);
    RelatorioService proxy = new RelatorioServiceProxy(dbMock);

    // Subject real s√≥ criado quando necess√°rio
    proxy.gerar("vendas");

    verify(dbMock).connect();
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Subject

```java
interface PedidoRepository {
    Pedido buscar(String id);
    void salvar(Pedido pedido);
    List<Pedido> listarTodos();
    void remover(String id);
}

record Pedido(String id, String cliente, BigDecimal valor, Status status) {}
enum Status { PENDENTE, APROVADO, CANCELADO }
```

### 2. Real Subject (Implementa√ß√£o Real)

```java
final class PedidoRepositoryImpl implements PedidoRepository {
    private final Map<String, Pedido> storage = new ConcurrentHashMap<>();

    @Override
    public Pedido buscar(String id) {
        System.out.println("üíæ [REAL] Buscando pedido: " + id);

        // Simula opera√ß√£o cara
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        Pedido pedido = storage.get(id);
        if (pedido == null) {
            throw new RuntimeException("Pedido n√£o encontrado: " + id);
        }

        return pedido;
    }

    @Override
    public void salvar(Pedido pedido) {
        System.out.println("üíæ [REAL] Salvando pedido: " + pedido.id());

        // Simula opera√ß√£o cara
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        storage.put(pedido.id(), pedido);
    }

    @Override
    public List<Pedido> listarTodos() {
        System.out.println("üíæ [REAL] Listando todos os pedidos");
        return new ArrayList<>(storage.values());
    }

    @Override
    public void remover(String id) {
        System.out.println("üíæ [REAL] Removendo pedido: " + id);
        storage.remove(id);
    }
}
```

### 3. Virtual Proxy (Lazy Loading)

```java
final class LazyPedidoRepositoryProxy implements PedidoRepository {
    private PedidoRepository real;
    private final Supplier<PedidoRepository> realSupplier;

    LazyPedidoRepositoryProxy(Supplier<PedidoRepository> realSupplier) {
        this.realSupplier = realSupplier;
    }

    private PedidoRepository getReal() {
        if (real == null) {
            System.out.println("üîß [PROXY] Inicializando repository real (lazy)...");
            real = realSupplier.get();
        }
        return real;
    }

    @Override
    public Pedido buscar(String id) {
        return getReal().buscar(id);
    }

    @Override
    public void salvar(Pedido pedido) {
        getReal().salvar(pedido);
    }

    @Override
    public List<Pedido> listarTodos() {
        return getReal().listarTodos();
    }

    @Override
    public void remover(String id) {
        getReal().remover(id);
    }
}
```

### 4. Caching Proxy

```java
final class CachingPedidoRepositoryProxy implements PedidoRepository {
    private final PedidoRepository real;
    private final Map<String, Pedido> cache = new ConcurrentHashMap<>();
    private final AtomicInteger hits = new AtomicInteger(0);
    private final AtomicInteger misses = new AtomicInteger(0);

    CachingPedidoRepositoryProxy(PedidoRepository real) {
        this.real = real;
    }

    @Override
    public Pedido buscar(String id) {
        Pedido cached = cache.get(id);

        if (cached != null) {
            hits.incrementAndGet();
            System.out.println("üéØ [PROXY] Cache HIT: " + id + " (hits: " + hits.get() + ")");
            return cached;
        }

        misses.incrementAndGet();
        System.out.println("‚ùå [PROXY] Cache MISS: " + id + " (misses: " + misses.get() + ")");

        Pedido pedido = real.buscar(id);
        cache.put(id, pedido);

        return pedido;
    }

    @Override
    public void salvar(Pedido pedido) {
        real.salvar(pedido);
        cache.put(pedido.id(), pedido); // Atualiza cache
        System.out.println("üîÑ [PROXY] Cache atualizado: " + pedido.id());
    }

    @Override
    public List<Pedido> listarTodos() {
        return real.listarTodos();
    }

    @Override
    public void remover(String id) {
        real.remover(id);
        cache.remove(id);
        System.out.println("üóë [PROXY] Cache invalidado: " + id);
    }

    void invalidarCache() {
        cache.clear();
        System.out.println("üóë [PROXY] Todo cache invalidado");
    }

    CacheStats getStats() {
        int total = hits.get() + misses.get();
        double hitRate = total == 0 ? 0.0 : (hits.get() * 100.0) / total;
        return new CacheStats(hits.get(), misses.get(), hitRate, cache.size());
    }
}

record CacheStats(int hits, int misses, double hitRate, int tamanhoCache) {}
```

### 5. Protection Proxy (Controle de Acesso)

```java
final class ProtectionPedidoRepositoryProxy implements PedidoRepository {
    private final PedidoRepository real;
    private final UsuarioContext usuarioContext;

    ProtectionPedidoRepositoryProxy(PedidoRepository real, UsuarioContext usuarioContext) {
        this.real = real;
        this.usuarioContext = usuarioContext;
    }

    @Override
    public Pedido buscar(String id) {
        verificarPermissao("READ");
        return real.buscar(id);
    }

    @Override
    public void salvar(Pedido pedido) {
        verificarPermissao("WRITE");
        real.salvar(pedido);
    }

    @Override
    public List<Pedido> listarTodos() {
        verificarPermissao("READ");
        return real.listarTodos();
    }

    @Override
    public void remover(String id) {
        verificarPermissao("DELETE");
        real.remover(id);
    }

    private void verificarPermissao(String operacao) {
        Usuario usuario = usuarioContext.getUsuarioAtual();

        if (usuario == null) {
            throw new SecurityException("Usu√°rio n√£o autenticado");
        }

        if (!usuario.temPermissao(operacao)) {
            System.err.println("üö´ [PROXY] Acesso negado: " + usuario.nome() +
                             " tentou " + operacao);
            throw new SecurityException(
                "Usu√°rio " + usuario.nome() + " n√£o tem permiss√£o: " + operacao
            );
        }

        System.out.println("‚úÖ [PROXY] Acesso permitido: " + usuario.nome() +
                         " - " + operacao);
    }
}

record Usuario(String nome, Set<String> permissoes) {
    boolean temPermissao(String permissao) {
        return permissoes.contains(permissao) || permissoes.contains("ADMIN");
    }
}

class UsuarioContext {
    private static final ThreadLocal<Usuario> currentUser = new ThreadLocal<>();

    void setUsuarioAtual(Usuario usuario) {
        currentUser.set(usuario);
    }

    Usuario getUsuarioAtual() {
        return currentUser.get();
    }

    void limpar() {
        currentUser.remove();
    }
}
```

### 6. Logging Proxy

```java
final class LoggingPedidoRepositoryProxy implements PedidoRepository {
    private final PedidoRepository real;
    private final String proxyName;

    LoggingPedidoRepositoryProxy(String name, PedidoRepository real) {
        this.proxyName = name;
        this.real = real;
    }

    @Override
    public Pedido buscar(String id) {
        System.out.println("üìã [" + proxyName + "] Buscando: " + id);
        long inicio = System.currentTimeMillis();

        try {
            Pedido resultado = real.buscar(id);
            long duracao = System.currentTimeMillis() - inicio;
            System.out.println("‚úÖ [" + proxyName + "] Encontrado em " + duracao + "ms");
            return resultado;

        } catch (Exception e) {
            System.err.println("‚ùå [" + proxyName + "] Erro: " + e.getMessage());
            throw e;
        }
    }

    @Override
    public void salvar(Pedido pedido) {
        System.out.println("üìã [" + proxyName + "] Salvando: " + pedido.id());
        long inicio = System.currentTimeMillis();

        try {
            real.salvar(pedido);
            long duracao = System.currentTimeMillis() - inicio;
            System.out.println("‚úÖ [" + proxyName + "] Salvo em " + duracao + "ms");

        } catch (Exception e) {
            System.err.println("‚ùå [" + proxyName + "] Erro ao salvar: " + e.getMessage());
            throw e;
        }
    }

    @Override
    public List<Pedido> listarTodos() {
        System.out.println("üìã [" + proxyName + "] Listando todos");
        List<Pedido> resultado = real.listarTodos();
        System.out.println("‚úÖ [" + proxyName + "] Encontrados: " + resultado.size());
        return resultado;
    }

    @Override
    public void remover(String id) {
        System.out.println("üìã [" + proxyName + "] Removendo: " + id);
        real.remover(id);
        System.out.println("‚úÖ [" + proxyName + "] Removido");
    }
}
```

### 7. Remote Proxy (Simula Acesso Remoto)

```java
final class RemotePedidoRepositoryProxy implements PedidoRepository {
    private final String serverUrl;
    private final HttpClient httpClient;

    RemotePedidoRepositoryProxy(String serverUrl, HttpClient httpClient) {
        this.serverUrl = serverUrl;
        this.httpClient = httpClient;
    }

    @Override
    public Pedido buscar(String id) {
        System.out.println("üåê [REMOTE] GET " + serverUrl + "/pedidos/" + id);

        try {
            // Simula chamada HTTP
            String json = httpClient.get(serverUrl + "/pedidos/" + id);
            return deserializarPedido(json);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao buscar pedido remoto: " + id, e);
        }
    }

    @Override
    public void salvar(Pedido pedido) {
        System.out.println("üåê [REMOTE] POST " + serverUrl + "/pedidos");

        try {
            String json = serializarPedido(pedido);
            httpClient.post(serverUrl + "/pedidos", json);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao salvar pedido remoto", e);
        }
    }

    @Override
    public List<Pedido> listarTodos() {
        System.out.println("üåê [REMOTE] GET " + serverUrl + "/pedidos");

        try {
            String json = httpClient.get(serverUrl + "/pedidos");
            return deserializarLista(json);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao listar pedidos remotos", e);
        }
    }

    @Override
    public void remover(String id) {
        System.out.println("üåê [REMOTE] DELETE " + serverUrl + "/pedidos/" + id);

        try {
            httpClient.delete(serverUrl + "/pedidos/" + id);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao remover pedido remoto: " + id, e);
        }
    }

    private String serializarPedido(Pedido pedido) {
        return "{\"id\":\"" + pedido.id() + "\",\"cliente\":\"" + pedido.cliente() + "\"}";
    }

    private Pedido deserializarPedido(String json) {
        // Simplificado - usar Jackson/Gson em produ√ß√£o
        return new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);
    }

    private List<Pedido> deserializarLista(String json) {
        return List.of(deserializarPedido(json));
    }
}

// Interface HTTP simplificada
interface HttpClient {
    String get(String url);
    void post(String url, String body);
    void delete(String url);
}
```

### 8. Composi√ß√£o de Proxies

```java
final class ProxyChain {

    static PedidoRepository criar(PedidoRepository real, ConfiguracaoProxy config) {
        PedidoRepository proxy = real;

        // Ordem importa: Protection ‚Üí Cache ‚Üí Logging ‚Üí Lazy

        if (config.habilitarLazy()) {
            PedidoRepository finalProxy = proxy;
            proxy = new LazyPedidoRepositoryProxy(() -> finalProxy);
            System.out.println("‚úÖ Lazy Loading habilitado");
        }

        if (config.habilitarLogging()) {
            proxy = new LoggingPedidoRepositoryProxy("PedidoRepo", proxy);
            System.out.println("‚úÖ Logging habilitado");
        }

        if (config.habilitarCache()) {
            proxy = new CachingPedidoRepositoryProxy(proxy);
            System.out.println("‚úÖ Cache habilitado");
        }

        if (config.habilitarProtection()) {
            proxy = new ProtectionPedidoRepositoryProxy(proxy, config.usuarioContext());
            System.out.println("‚úÖ Protection habilitado");
        }

        return proxy;
    }
}

record ConfiguracaoProxy(
    boolean habilitarLazy,
    boolean habilitarCache,
    boolean habilitarLogging,
    boolean habilitarProtection,
    UsuarioContext usuarioContext
) {
    static ConfiguracaoProxy padrao() {
        return new ConfiguracaoProxy(true, true, true, false, null);
    }

    static ConfiguracaoProxy completa(UsuarioContext context) {
        return new ConfiguracaoProxy(true, true, true, true, context);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Lazy Loading

```java
@Test
void lazyProxyNaoDeveCriarRealAteUsado() {
    // Arrange
    AtomicBoolean criado = new AtomicBoolean(false);

    PedidoRepository proxy = new LazyPedidoRepositoryProxy(() -> {
        criado.set(true);
        return new PedidoRepositoryImpl();
    });

    // Assert - Real n√£o criado ainda
    assertFalse(criado.get());

    // Act - Primeira chamada cria real
    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);
    proxy.salvar(pedido);

    // Assert - Agora foi criado
    assertTrue(criado.get());
}
```

### 2. Testar Cache

```java
@Test
void cachingProxyDeveEvitarChamadasRedundantes() {
    // Arrange
    PedidoRepository realMock = mock(PedidoRepository.class);
    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);
    when(realMock.buscar("PED-001")).thenReturn(pedido);

    CachingPedidoRepositoryProxy proxy = new CachingPedidoRepositoryProxy(realMock);

    // Act
    Pedido primeira = proxy.buscar("PED-001"); // MISS
    Pedido segunda = proxy.buscar("PED-001");  // HIT
    Pedido terceira = proxy.buscar("PED-001"); // HIT

    // Assert
    verify(realMock, times(1)).buscar("PED-001"); // Apenas 1 chamada!

    CacheStats stats = proxy.getStats();
    assertEquals(2, stats.hits());
    assertEquals(1, stats.misses());
}
```

### 3. Testar Protection Proxy

```java
@Test
void protectionProxyDeveBloquearUsuarioSemPermissao() {
    // Arrange
    PedidoRepository real = new PedidoRepositoryImpl();
    UsuarioContext context = new UsuarioContext();

    Usuario usuarioSemPermissao = new Usuario("User", Set.of()); // Sem permiss√µes
    context.setUsuarioAtual(usuarioSemPermissao);

    PedidoRepository proxy = new ProtectionPedidoRepositoryProxy(real, context);

    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);

    // Act & Assert
    SecurityException ex = assertThrows(
        SecurityException.class,
        () -> proxy.salvar(pedido)
    );

    assertTrue(ex.getMessage().contains("n√£o tem permiss√£o"));
}
```

### 4. Testar Permission Granted

```java
@Test
void protectionProxyDevePermitirUsuarioComPermissao() {
    // Arrange
    PedidoRepository real = new PedidoRepositoryImpl();
    UsuarioContext context = new UsuarioContext();

    Usuario usuarioComPermissao = new Usuario("Admin", Set.of("READ", "WRITE"));
    context.setUsuarioAtual(usuarioComPermissao);

    PedidoRepository proxy = new ProtectionPedidoRepositoryProxy(real, context);

    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);

    // Act & Assert - N√£o deve lan√ßar exce√ß√£o
    assertDoesNotThrow(() -> proxy.salvar(pedido));
    assertDoesNotThrow(() -> proxy.buscar("PED-001"));
}
```

### 5. Testar Logging Proxy

```java
@Test
void loggingProxyDeveLogarOperacoes() {
    // Arrange
    PedidoRepository realMock = mock(PedidoRepository.class);
    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);
    when(realMock.buscar("PED-001")).thenReturn(pedido);

    PedidoRepository proxy = new LoggingPedidoRepositoryProxy("TestRepo", realMock);

    // Act
    proxy.buscar("PED-001");

    // Assert
    verify(realMock).buscar("PED-001");
}
```

### 6. Testar Composi√ß√£o de Proxies

```java
@Test
void deveComporMultiplosProxies() {
    // Arrange
    PedidoRepository real = new PedidoRepositoryImpl();

    // Cache ‚Üí Logging ‚Üí Real
    PedidoRepository proxy = new LoggingPedidoRepositoryProxy("Test",
        new CachingPedidoRepositoryProxy(real)
    );

    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);

    // Act
    proxy.salvar(pedido);
    Pedido resultado1 = proxy.buscar("PED-001"); // MISS + Log
    Pedido resultado2 = proxy.buscar("PED-001"); // HIT + Log

    // Assert
    assertEquals(pedido, resultado1);
    assertEquals(pedido, resultado2);
}
```

### 7. Testar Remote Proxy

```java
@Test
void remoteProxyDeveSerializarChamadas() {
    // Arrange
    HttpClient httpMock = mock(HttpClient.class);
    when(httpMock.get(anyString())).thenReturn("{\"id\":\"PED-001\"}");

    PedidoRepository proxy = new RemotePedidoRepositoryProxy("http://api", httpMock);

    // Act
    proxy.buscar("PED-001");

    // Assert
    verify(httpMock).get("http://api/pedidos/PED-001");
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Proxy modifica comportamento
class BadProxy implements PedidoRepository {
    public Pedido buscar(String id) {
        // Retorna objeto diferente ‚ùå
        return new Pedido("FAKE", "Fake", BigDecimal.ZERO, Status.PENDENTE);
    }
}

// ‚ùå Proxy com l√≥gica de neg√≥cio
class BusinessProxy implements PedidoRepository {
    public void salvar(Pedido pedido) {
        // Regra de neg√≥cio no proxy ‚ùå
        if (pedido.valor().compareTo(new BigDecimal("1000")) > 0) {
            pedido = aplicarDesconto(pedido);
        }
        real.salvar(pedido);
    }
}

// ‚ùå Vazamento de abstra√ß√£o
class LeakyProxy implements PedidoRepository {
    public Pedido buscar(String id) {
        if (real == null) {
            throw new RuntimeException("Real n√£o inicializado"); // Detalhe interno vaza ‚ùå
        }
        return real.buscar(id);
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Proxy transparente
class GoodProxy implements PedidoRepository {
    public Pedido buscar(String id) {
        // Apenas controla acesso, n√£o modifica
        log("Buscando: " + id);
        return real.buscar(id);
    }
}

// ‚úÖ Proxy com responsabilidade clara (cache)
class CachingProxy implements PedidoRepository {
    public Pedido buscar(String id) {
        // Apenas cache, sem regras de neg√≥cio
        if (cache.containsKey(id)) {
            return cache.get(id);
        }
        return real.buscar(id);
    }
}

// ‚úÖ Tratamento de erro consistente
class RobustProxy implements PedidoRepository {
    public Pedido buscar(String id) {
        try {
            return getReal().buscar(id);
        } catch (Exception e) {
            // Trata erro sem vazar detalhes
            throw new RepositoryException("Erro ao buscar pedido", e);
        }
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Transpar√™ncia**: Proxy preserva comportamento do subject
- ‚úÖ **Interface comum**: Proxy e subject implementam mesma interface
- ‚úÖ **Responsabilidade √∫nica**: Cada proxy uma preocupa√ß√£o (cache, security, log)
- ‚úÖ **Lazy loading**: Adiar cria√ß√£o de objetos caros
- ‚úÖ **Composi√ß√£o**: Permitir encadear m√∫ltiplos proxies
- ‚úÖ **Thread-safety**: Cache/estado compartilhado precisa ser thread-safe
- ‚úÖ **Testes com mocks**: Facilita testar controles (cache, permiss√µes)

---

## üîó Integra√ß√£o com Frameworks

### Spring AOP (Proxy Din√¢mico)

```java
@Aspect
@Component
public class CachingAspect {

    @Around("@annotation(Cacheable)")
    public Object cache(ProceedingJoinPoint pjp) throws Throwable {
        String key = generateKey(pjp);

        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        Object result = pjp.proceed();
        cache.put(key, result);
        return result;
    }
}

// Spring cria proxy automaticamente
@Service
public class PedidoService {

    @Cacheable
    public Pedido buscar(String id) {
        // Spring cria CachingProxy em volta
        return repository.buscar(id);
    }
}
```

### JPA/Hibernate (Lazy Loading Proxy)

```java
@Entity
public class Pedido {

    @OneToMany(fetch = FetchType.LAZY)
    private List<Item> itens; // Proxy at√© acessar
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                              | ‚ö†Ô∏è Desvantagens                  |
| ----------------------------------------- | -------------------------------- |
| Controla acesso ao subject                | Adiciona lat√™ncia (camada extra) |
| Lazy loading (performance)                | Debug pode ser complexo          |
| Cache transparente                        | Ordem dos proxies importa        |
| Security/validation sem modificar subject | Pode esconder o subject real     |
| Facilita testes (mock subject)            | Complexidade adicional           |

---

## üîç Compara√ß√£o

| Padr√£o        | Prop√≥sito               | Quando Usar                           |
| ------------- | ----------------------- | ------------------------------------- |
| **Proxy**     | Controlar acesso        | Lazy load, cache, security, remote    |
| **Decorator** | Adicionar comportamento | Cross-cutting concerns (log, metrics) |
| **Adapter**   | Converter interface     | Integrar APIs incompat√≠veis           |
| **Facade**    | Simplificar interface   | Unificar subsistemas complexos        |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Smart Proxy** (contagem de refer√™ncias, garbage collection)
2. **Copy-on-Write Proxy** (clone objeto apenas ao modificar)
3. **Firewall Proxy** (filtrar requisi√ß√µes maliciosas)
4. **Synchronization Proxy** (adicionar locks thread-safe)
5. **Circuit Breaker Proxy** (abrir circuito ap√≥s falhas)

---

## üìö Relacionado

- **Decorator**: Adiciona comportamento dinamicamente
- **Adapter**: Converte interface incompat√≠vel
- **Facade**: Simplifica interface complexa
- **Flyweight**: Compartilha objetos para economizar mem√≥ria

---

**Proxy Pattern controla acesso a objetos, adiciona lazy loading e facilita testes com mocks!** üö™‚ú®
