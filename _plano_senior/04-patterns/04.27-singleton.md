# 04.27 Singleton Pattern [F√ÅCIL] üîí

## üéØ Objetivo

Garantir que uma classe tenha **apenas uma inst√¢ncia** e fornecer ponto de acesso global, controlando recursos compartilhados e facilitando **testes com dependency injection**.

---

## üìö O Que √â?

**Singleton** √© um padr√£o criacional GoF que garante que uma classe tenha apenas uma inst√¢ncia durante toda a execu√ß√£o da aplica√ß√£o, fornecendo um ponto de acesso global a ela. √ötil para gerenciar recursos compartilhados como configura√ß√µes, conex√µes, caches.

### Analogia

Como um **governo de um pa√≠s**:

- **√önico presidente**: Apenas um por vez
- **Acesso global**: Todo cidad√£o pode acessar
- **Recurso compartilhado**: Decis√µes afetam todos
- **Vantagem**: Coordena√ß√£o centralizada, evita conflitos

---

## ‚ùå Problema que Resolve

### Antes (M√∫ltiplas Inst√¢ncias)

```java
// ‚ùå PROBLEMA: M√∫ltiplas inst√¢ncias de recurso caro
class ConfiguracaoService {
    private Properties config = new Properties();

    public ConfiguracaoService() {
        // Carrega configura√ß√£o do arquivo (opera√ß√£o cara) ‚ùå
        carregarArquivo("config.properties");
    }
}

// Cada new cria nova inst√¢ncia ‚ùå
ConfiguracaoService config1 = new ConfiguracaoService(); // Carrega arquivo
ConfiguracaoService config2 = new ConfiguracaoService(); // Carrega arquivo novamente!
ConfiguracaoService config3 = new ConfiguracaoService(); // E novamente!

// Problemas:
// - Desperd√≠cio de mem√≥ria (m√∫ltiplas c√≥pias)
// - Opera√ß√£o cara repetida (I/O)
// - Inconsist√™ncia (cada inst√¢ncia pode ter dados diferentes)
// - Dif√≠cil coordenar estado compartilhado
```

**Problemas**:

- üíæ Desperd√≠cio de mem√≥ria (m√∫ltiplas inst√¢ncias)
- üêå Opera√ß√µes caras repetidas (I/O, inicializa√ß√£o)
- üîÄ Inconsist√™ncia de estado
- üß™ Dif√≠cil mockar em testes (new espalhado)
- üîß Sem controle sobre cria√ß√£o

### Depois (Singleton Pattern)

```java
// ‚úÖ SOLU√á√ÉO: √önica inst√¢ncia garantida
class ConfiguracaoService {
    private static ConfiguracaoService instance;
    private final Properties config = new Properties();

    // Construtor privado ‚ùå new fora da classe
    private ConfiguracaoService() {
        System.out.println("üîß Inicializando Singleton...");
        carregarArquivo("config.properties");
    }

    // Ponto de acesso global
    public static synchronized ConfiguracaoService getInstance() {
        if (instance == null) {
            instance = new ConfiguracaoService();
        }
        return instance;
    }

    public String getConfig(String chave) {
        return config.getProperty(chave);
    }
}

// Sempre a mesma inst√¢ncia ‚úÖ
ConfiguracaoService config1 = ConfiguracaoService.getInstance();
ConfiguracaoService config2 = ConfiguracaoService.getInstance();
ConfiguracaoService config3 = ConfiguracaoService.getInstance();

// config1 == config2 == config3 (mesma refer√™ncia!)

// Teste com inje√ß√£o de depend√™ncia
@Test
void deveUsarSingletonMockado() {
    ConfiguracaoService mock = mock(ConfiguracaoService.class);
    // Injeta mock via DI em vez de getInstance()
    MyService service = new MyService(mock);
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Singleton Cl√°ssico (Lazy + Synchronized)

```java
final class ConfiguracaoSingleton {
    private static ConfiguracaoSingleton instance;
    private final Map<String, String> configuracoes = new ConcurrentHashMap<>();
    private final LocalDateTime inicializadoEm;

    // Construtor privado
    private ConfiguracaoSingleton() {
        System.out.println("üîß Inicializando ConfiguracaoSingleton...");
        this.inicializadoEm = LocalDateTime.now();
        carregarConfiguracoes();
    }

    // Thread-safe com synchronized
    public static synchronized ConfiguracaoSingleton getInstance() {
        if (instance == null) {
            instance = new ConfiguracaoSingleton();
        }
        return instance;
    }

    private void carregarConfiguracoes() {
        // Simula carregamento de arquivo
        configuracoes.put("app.name", "MeuApp");
        configuracoes.put("app.version", "1.0.0");
        configuracoes.put("db.url", "jdbc:postgresql://localhost:5432/mydb");
        System.out.println("‚úÖ " + configuracoes.size() + " configura√ß√µes carregadas");
    }

    public String getConfig(String chave) {
        return configuracoes.get(chave);
    }

    public void setConfig(String chave, String valor) {
        configuracoes.put(chave, valor);
    }

    public LocalDateTime getInicializadoEm() {
        return inicializadoEm;
    }

    // Para testes - CUIDADO!
    public static void resetarParaTestes() {
        instance = null;
    }
}
```

### 2. Singleton Eager (Inicializa√ß√£o Antecipada)

```java
// Eager initialization - criado ao carregar classe
final class LoggerSingleton {
    // Inst√¢ncia criada imediatamente (class loading)
    private static final LoggerSingleton INSTANCE = new LoggerSingleton();

    private final List<String> logs = new CopyOnWriteArrayList<>();
    private final AtomicInteger contador = new AtomicInteger(0);

    private LoggerSingleton() {
        System.out.println("üîß LoggerSingleton inicializado (eager)");
    }

    public static LoggerSingleton getInstance() {
        return INSTANCE;
    }

    public void log(String mensagem) {
        int num = contador.incrementAndGet();
        String logEntry = String.format("[%d] %s - %s",
            num, LocalDateTime.now(), mensagem);

        logs.add(logEntry);
        System.out.println("üìù " + logEntry);
    }

    public List<String> getLogs() {
        return List.copyOf(logs);
    }

    public int getTotalLogs() {
        return logs.size();
    }
}
```

### 3. Singleton Double-Checked Locking (Performance)

```java
final class CacheSingleton {
    // volatile para visibilidade entre threads
    private static volatile CacheSingleton instance;

    private final Map<String, Object> cache = new ConcurrentHashMap<>();
    private final AtomicInteger hits = new AtomicInteger(0);
    private final AtomicInteger misses = new AtomicInteger(0);

    private CacheSingleton() {
        System.out.println("üîß CacheSingleton inicializado (double-checked locking)");
    }

    // Double-checked locking para performance
    public static CacheSingleton getInstance() {
        if (instance == null) { // 1¬™ verifica√ß√£o (sem lock)
            synchronized (CacheSingleton.class) {
                if (instance == null) { // 2¬™ verifica√ß√£o (com lock)
                    instance = new CacheSingleton();
                }
            }
        }
        return instance;
    }

    public void put(String chave, Object valor) {
        cache.put(chave, valor);
        System.out.println("üíæ Cache armazenado: " + chave);
    }

    public Object get(String chave) {
        Object valor = cache.get(chave);

        if (valor != null) {
            hits.incrementAndGet();
            System.out.println("üéØ Cache HIT: " + chave);
        } else {
            misses.incrementAndGet();
            System.out.println("‚ùå Cache MISS: " + chave);
        }

        return valor;
    }

    public CacheStats getStats() {
        int total = hits.get() + misses.get();
        double hitRate = total == 0 ? 0.0 : (hits.get() * 100.0) / total;

        return new CacheStats(hits.get(), misses.get(), hitRate, cache.size());
    }

    public void limpar() {
        cache.clear();
        System.out.println("üóë Cache limpo");
    }
}

record CacheStats(int hits, int misses, double hitRate, int tamanhoCache) {}
```

### 4. Singleton com Enum (Bill Pugh - Melhor Pr√°tica)

```java
// Enum singleton - thread-safe, serialization-safe, reflection-safe
enum DatabaseConnectionSingleton {
    INSTANCE;

    private final String connectionString;
    private final AtomicInteger queries = new AtomicInteger(0);

    DatabaseConnectionSingleton() {
        System.out.println("üîß DatabaseConnectionSingleton inicializado (enum)");
        this.connectionString = "jdbc:postgresql://localhost:5432/mydb";
    }

    public String getConnectionString() {
        return connectionString;
    }

    public void executeQuery(String sql) {
        int num = queries.incrementAndGet();
        System.out.println("üîç Query #" + num + ": " + sql);
    }

    public int getTotalQueries() {
        return queries.get();
    }
}

// Uso
DatabaseConnectionSingleton.INSTANCE.executeQuery("SELECT * FROM users");
```

### 5. Singleton com Holder (Bill Pugh Pattern)

```java
final class MetricsSingleton {

    // Inner static class holder (lazy + thread-safe)
    private static class Holder {
        private static final MetricsSingleton INSTANCE = new MetricsSingleton();
    }

    private final Map<String, AtomicInteger> metricas = new ConcurrentHashMap<>();

    private MetricsSingleton() {
        System.out.println("üîß MetricsSingleton inicializado (holder pattern)");
    }

    public static MetricsSingleton getInstance() {
        return Holder.INSTANCE;
    }

    public void incrementar(String metrica) {
        metricas.computeIfAbsent(metrica, k -> new AtomicInteger())
                .incrementAndGet();

        System.out.println("üìä " + metrica + ": " + metricas.get(metrica).get());
    }

    public int getValor(String metrica) {
        AtomicInteger valor = metricas.get(metrica);
        return valor == null ? 0 : valor.get();
    }

    public Map<String, Integer> getTodasMetricas() {
        return metricas.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().get()
            ));
    }
}
```

### 6. Singleton com Dependency Injection (Test√°vel)

```java
// Interface para facilitar testes
interface ConfiguracaoService {
    String getConfig(String chave);
    void setConfig(String chave, String valor);
}

// Implementa√ß√£o Singleton
final class ConfiguracaoServiceImpl implements ConfiguracaoService {
    private static ConfiguracaoServiceImpl instance;
    private final Map<String, String> config = new ConcurrentHashMap<>();

    private ConfiguracaoServiceImpl() {
        System.out.println("üîß ConfiguracaoServiceImpl inicializado");
        carregarPadrao();
    }

    public static synchronized ConfiguracaoServiceImpl getInstance() {
        if (instance == null) {
            instance = new ConfiguracaoServiceImpl();
        }
        return instance;
    }

    private void carregarPadrao() {
        config.put("ambiente", "producao");
        config.put("timeout", "30000");
    }

    @Override
    public String getConfig(String chave) {
        return config.get(chave);
    }

    @Override
    public void setConfig(String chave, String valor) {
        config.put(chave, valor);
    }

    public static void resetarParaTestes() {
        instance = null;
    }
}

// Service usando interface (test√°vel)
class PedidoService {
    private final ConfiguracaoService config;

    // Dependency Injection
    public PedidoService(ConfiguracaoService config) {
        this.config = config;
    }

    // Construtor com singleton (produ√ß√£o)
    public PedidoService() {
        this(ConfiguracaoServiceImpl.getInstance());
    }

    public void processar() {
        String ambiente = config.getConfig("ambiente");
        System.out.println("Processando em: " + ambiente);
    }
}

// Teste com mock
@Test
void deveProcessarComConfigMock() {
    ConfiguracaoService mockConfig = mock(ConfiguracaoService.class);
    when(mockConfig.getConfig("ambiente")).thenReturn("teste");

    PedidoService service = new PedidoService(mockConfig);
    service.processar();

    verify(mockConfig).getConfig("ambiente");
}
```

### 7. Singleton Registry (Multi-Instance)

```java
final class SingletonRegistry {
    private static final Map<String, Object> instances = new ConcurrentHashMap<>();

    private SingletonRegistry() {}

    @SuppressWarnings("unchecked")
    public static <T> T getInstance(String chave, Supplier<T> criador) {
        return (T) instances.computeIfAbsent(chave, k -> {
            System.out.println("üîß Criando singleton: " + chave);
            return criador.get();
        });
    }

    public static boolean existe(String chave) {
        return instances.containsKey(chave);
    }

    public static void remover(String chave) {
        instances.remove(chave);
        System.out.println("üóë Singleton removido: " + chave);
    }

    public static void limparTodos() {
        instances.clear();
        System.out.println("üóë Todos os singletons removidos");
    }

    public static int total() {
        return instances.size();
    }
}

// Uso
CacheSingleton cache = SingletonRegistry.getInstance(
    "cache",
    CacheSingleton::new
);
```

### 8. Singleton com Controle de Ciclo de Vida

```java
final class ApplicationContextSingleton {
    private static ApplicationContextSingleton instance;
    private final LocalDateTime iniciadoEm;
    private LocalDateTime finalizadoEm;
    private boolean rodando = false;

    private ApplicationContextSingleton() {
        this.iniciadoEm = LocalDateTime.now();
    }

    public static synchronized ApplicationContextSingleton getInstance() {
        if (instance == null) {
            instance = new ApplicationContextSingleton();
        }
        return instance;
    }

    public void iniciar() {
        if (rodando) {
            throw new IllegalStateException("J√° est√° rodando");
        }

        System.out.println("üöÄ Aplica√ß√£o iniciada em: " + iniciadoEm);
        rodando = true;
    }

    public void finalizar() {
        if (!rodando) {
            throw new IllegalStateException("N√£o est√° rodando");
        }

        finalizadoEm = LocalDateTime.now();
        rodando = false;

        Duration duracao = Duration.between(iniciadoEm, finalizadoEm);
        System.out.println("üõë Aplica√ß√£o finalizada ap√≥s: " + duracao.toSeconds() + "s");
    }

    public boolean isRodando() {
        return rodando;
    }

    public LocalDateTime getIniciadoEm() {
        return iniciadoEm;
    }

    public Optional<LocalDateTime> getFinalizadoEm() {
        return Optional.ofNullable(finalizadoEm);
    }
}
```

---

## üß™ Como Testar

### 1. Testar √önica Inst√¢ncia

```java
@Test
void deveRetornarMesmaInstancia() {
    // Act
    ConfiguracaoSingleton instancia1 = ConfiguracaoSingleton.getInstance();
    ConfiguracaoSingleton instancia2 = ConfiguracaoSingleton.getInstance();
    ConfiguracaoSingleton instancia3 = ConfiguracaoSingleton.getInstance();

    // Assert - Mesma refer√™ncia
    assertSame(instancia1, instancia2);
    assertSame(instancia2, instancia3);
}
```

### 2. Testar Thread-Safety

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    // Arrange
    int numThreads = 10;
    Set<ConfiguracaoSingleton> instancias = ConcurrentHashMap.newKeySet();
    CountDownLatch latch = new CountDownLatch(numThreads);

    // Act - M√∫ltiplas threads tentam criar
    for (int i = 0; i < numThreads; i++) {
        new Thread(() -> {
            instancias.add(ConfiguracaoSingleton.getInstance());
            latch.countDown();
        }).start();
    }

    latch.await();

    // Assert - Apenas 1 inst√¢ncia criada
    assertEquals(1, instancias.size());
}
```

### 3. Testar Lazy Loading

```java
@Test
void deveInicializarApenasChamado() {
    // Arrange
    ConfiguracaoSingleton.resetarParaTestes();

    // Assert - N√£o inicializado ainda
    // (validar que n√£o h√° inicializa√ß√£o ao carregar classe)

    // Act - Primeira chamada inicializa
    ConfiguracaoSingleton instancia = ConfiguracaoSingleton.getInstance();

    // Assert
    assertNotNull(instancia);
    assertNotNull(instancia.getInicializadoEm());
}
```

### 4. Testar com Dependency Injection

```java
@Test
void deveInjetarMockEmVezDeSingleton() {
    // Arrange
    ConfiguracaoService mockConfig = mock(ConfiguracaoService.class);
    when(mockConfig.getConfig("ambiente")).thenReturn("teste");

    PedidoService service = new PedidoService(mockConfig);

    // Act
    service.processar();

    // Assert
    verify(mockConfig).getConfig("ambiente");
}
```

### 5. Testar Estado Compartilhado

```java
@Test
void deveCompartilharEstadoEntreInstancias() {
    // Arrange
    ConfiguracaoSingleton instancia1 = ConfiguracaoSingleton.getInstance();

    // Act
    instancia1.setConfig("teste", "valor123");

    // Assert - Outra "inst√¢ncia" v√™ mudan√ßa
    ConfiguracaoSingleton instancia2 = ConfiguracaoSingleton.getInstance();
    assertEquals("valor123", instancia2.getConfig("teste"));
}
```

### 6. Testar Enum Singleton

```java
@Test
void enumSingletonDeveSerUnico() {
    // Act
    DatabaseConnectionSingleton db1 = DatabaseConnectionSingleton.INSTANCE;
    DatabaseConnectionSingleton db2 = DatabaseConnectionSingleton.INSTANCE;

    // Assert
    assertSame(db1, db2);
    assertEquals(db1.getConnectionString(), db2.getConnectionString());
}
```

### 7. Testar Singleton Registry

```java
@Test
void registryDeveManterInstanciasUnicas() {
    // Arrange
    SingletonRegistry.limparTodos();

    // Act
    CacheSingleton cache1 = SingletonRegistry.getInstance("cache", CacheSingleton::new);
    CacheSingleton cache2 = SingletonRegistry.getInstance("cache", CacheSingleton::new);

    // Assert
    assertSame(cache1, cache2);
    assertEquals(1, SingletonRegistry.total());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Singleton sem thread-safety
class UnsafeSingleton {
    private static UnsafeSingleton instance;

    public static UnsafeSingleton getInstance() {
        if (instance == null) { // Race condition! ‚ùå
            instance = new UnsafeSingleton();
        }
        return instance;
    }
}

// ‚ùå Construtor p√∫blico
class BadSingleton {
    private static BadSingleton instance;

    public BadSingleton() {} // ‚ùå Permite new BadSingleton()
}

// ‚ùå Singleton com estado mut√°vel n√£o thread-safe
class UnsafeStateSingleton {
    private static UnsafeStateSingleton instance;
    private int contador = 0; // ‚ùå Race condition em contador++

    public void incrementar() {
        contador++; // N√£o √© thread-safe!
    }
}

// ‚ùå Acoplamento global (dificulta testes)
class TightlyCoupled {
    void processar() {
        // Acoplado diretamente com singleton ‚ùå
        String config = ConfiguracaoSingleton.getInstance().getConfig("x");
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Thread-safe com synchronized ou enum
enum GoodSingleton {
    INSTANCE;
    // Thread-safe por natureza
}

// ‚úÖ Construtor privado
class PrivateConstructor {
    private static PrivateConstructor instance;

    private PrivateConstructor() {} // ‚úÖ Privado
}

// ‚úÖ Estado thread-safe
class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;
    private final AtomicInteger contador = new AtomicInteger(0); // ‚úÖ Thread-safe

    public void incrementar() {
        contador.incrementAndGet();
    }
}

// ‚úÖ Dependency Injection (test√°vel)
class Testable {
    private final ConfiguracaoService config;

    Testable(ConfiguracaoService config) { // ‚úÖ Injeta interface
        this.config = config;
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Enum prefer√≠vel**: Thread-safe, serialization-safe, simples
- ‚úÖ **Construtor privado**: Prevenir new externo
- ‚úÖ **Thread-safe**: synchronized, double-checked, enum, holder
- ‚úÖ **Dependency Injection**: Injetar via interface para testes
- ‚úÖ **Lazy loading**: Inicializar apenas quando necess√°rio
- ‚úÖ **Evitar estado mut√°vel**: Ou usar estruturas thread-safe
- ‚úÖ **Cuidado com serializa√ß√£o**: Implementar readResolve()

---

## üîó Integra√ß√£o com Frameworks

### Spring Singleton Scope (Default)

```java
@Component // Spring singleton por padr√£o
public class ConfiguracaoService {
    // Spring garante √∫nica inst√¢ncia
}

@Bean
@Scope("singleton") // Expl√≠cito
public CacheService cacheService() {
    return new CacheService();
}
```

### Jakarta EE Singleton

```java
@Singleton // Jakarta EE
@Startup   // Eager initialization
public class ApplicationConfig {
    @PostConstruct
    void init() {
        System.out.println("Singleton inicializado");
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                       | ‚ö†Ô∏è Desvantagens                       |
| ---------------------------------- | ------------------------------------- |
| √önica inst√¢ncia (economia mem√≥ria) | Estado global (acoplamento)           |
| Acesso global controlado           | Dificulta testes unit√°rios            |
| Lazy loading (performance)         | Viola Single Responsibility Principle |
| Inicializa√ß√£o cara feita 1x        | Concorr√™ncia complexa (locks)         |
| Coordena√ß√£o de recursos            | Pode esconder depend√™ncias            |

---

## üîç Compara√ß√£o

| Padr√£o        | Prop√≥sito                  | Quando Usar                     |
| ------------- | -------------------------- | ------------------------------- |
| **Singleton** | √önica inst√¢ncia global     | Configura√ß√£o, cache, logging    |
| **Factory**   | Criar objetos              | M√∫ltiplas inst√¢ncias com l√≥gica |
| **Prototype** | Clonar objetos             | Criar c√≥pias de objetos         |
| **Multiton**  | N inst√¢ncias identificadas | Pools, registries               |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Singleton com serializa√ß√£o** (implementar readResolve())
2. **Singleton com destrui√ß√£o** (cleanup de recursos)
3. **Singleton pregui√ßoso por demanda** (registry pattern)
4. **Singleton com configura√ß√£o externa** (arquivo, env vars)
5. **Comparar performance**: eager vs lazy vs holder vs enum

---

## üìö Relacionado

- **Factory Method**: Criar objetos sem especificar classe
- **Multiton**: M√∫ltiplas inst√¢ncias √∫nicas por chave
- **Object Pool**: Reutilizar objetos caros
- **Dependency Injection**: Injetar depend√™ncias (testabilidade)

---

**Singleton Pattern garante √∫nica inst√¢ncia, mas use Dependency Injection para testes!** üîí‚ú®
