# 04.43 GraphQL Architecture [AVAN√áADO] üé®

## üéØ Objetivo

Criar API com **query language flex√≠vel** onde cliente especifica exatamente quais dados quer, permitindo **testes de schema** e eliminando over-fetching/under-fetching.

---

## üìö O Que √â?

**GraphQL** √© uma linguagem de consulta e runtime para APIs que permite clientes solicitarem exatamente os dados necess√°rios atrav√©s de um √∫nico endpoint, com schema fortemente tipado.

### Analogia

Como **restaurante √† la carte**:

- **Menu (Schema)**: Todos os pratos dispon√≠veis
- **Pedido (Query)**: Cliente escolhe exatamente o que quer
- **Cozinha (Resolvers)**: Prepara apenas o solicitado
- **Vantagem**: N√£o traz comida que voc√™ n√£o pediu

---

## ‚ùå Problema que Resolve

### Antes (REST com Over-fetching/Under-fetching)

```java
// ‚ùå PROBLEMA: REST retorna dados fixos

// REST endpoint retorna TUDO ‚ùå
@GetMapping("/api/produtos/{id}")
ProdutoDTO buscarProduto(@PathVariable Long id) {
    return new ProdutoDTO(
        produto.getId(),
        produto.getNome(),
        produto.getDescricao(), // Cliente pode n√£o precisar ‚ùå
        produto.getPreco(),
        produto.getEstoque(),
        produto.getCategoria(), // Nested object inteiro ‚ùå
        produto.getAvaliacoes(), // Lista completa ‚ùå
        produto.getFornecedor(), // Mais dados n√£o solicitados ‚ùå
        produto.getImagens() // Imagens pesadas ‚ùå
    );
}

// Cliente precisa de m√∫ltiplas chamadas ‚ùå
class ClienteApp {
    void exibirProduto(Long id) {
        // 1. Buscar produto
        Produto produto = api.get("/produtos/" + id);

        // 2. Buscar avalia√ß√µes (N+1 problem) ‚ùå
        List<Avaliacao> avaliacoes = api.get("/produtos/" + id + "/avaliacoes");

        // 3. Buscar categoria ‚ùå
        Categoria categoria = api.get("/categorias/" + produto.getCategoriaId());

        // 3 requisi√ß√µes para dados relacionados ‚ùå
    }
}

// Problemas:
// - Over-fetching: retorna dados n√£o solicitados ‚ùå
// - Under-fetching: necessita m√∫ltiplas requisi√ß√µes ‚ùå
// - Versionamento: /api/v1, /api/v2 ‚ùå
// - Endpoints proliferam ‚ùå
```

**Problemas**:

- üìä Over-fetching (dados n√£o necess√°rios)
- üîÑ Under-fetching (m√∫ltiplas requisi√ß√µes)
- üåê M√∫ltiplos endpoints
- üì± Performance (mobile)
- üîß Versionamento complexo

### Depois (GraphQL - Cliente Define os Dados)

```graphql
# ‚úÖ SOLU√á√ÉO: Cliente solicita exatamente o que precisa

# Schema (contrato)
type Query {
  produto(id: ID!): Produto
  produtos(filtro: ProdutoFiltro, page: Int, size: Int): ProdutoPage
}

type Produto {
  id: ID!
  nome: String!
  descricao: String
  preco: Float!
  estoque: Int!
  categoria: Categoria
  avaliacoes: [Avaliacao!]!
  fornecedor: Fornecedor
}

type Categoria {
  id: ID!
  nome: String!
}

type Avaliacao {
  id: ID!
  nota: Int!
  comentario: String
  autor: String
}

# Cliente solicita apenas o necess√°rio ‚úÖ
query BuscarProdutoSimples {
  produto(id: "1") {
    nome
    preco
  }
}

# Resposta: Apenas nome e pre√ßo ‚úÖ
{
  "data": {
    "produto": {
      "nome": "Notebook",
      "preco": 3000.00
    }
  }
}

# Cliente solicita dados relacionados (sem N+1) ‚úÖ
query BuscarProdutoCompleto {
  produto(id: "1") {
    nome
    preco
    categoria {
      nome
    }
    avaliacoes {
      nota
      comentario
    }
  }
}

# UMA requisi√ß√£o, dados personalizados ‚úÖ
```

```java
// Implementa√ß√£o Java (Spring GraphQL)

@Controller
public class ProdutoGraphQLController {

    @Autowired
    private ProdutoService service;

    // Query resolver
    @QueryMapping
    public Produto produto(@Argument Long id) {
        System.out.println("üîç [GraphQL] Query: produto(id: " + id + ")");

        return service.buscarPorId(id)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(id));
    }

    @QueryMapping
    public Page<Produto> produtos(
        @Argument ProdutoFiltro filtro,
        @Argument Integer page,
        @Argument Integer size
    ) {
        System.out.println("üîç [GraphQL] Query: produtos");

        Pageable pageable = PageRequest.of(
            page != null ? page : 0,
            size != null ? size : 20
        );

        return service.listar(filtro, pageable);
    }

    // Mutation resolver
    @MutationMapping
    public Produto criarProduto(@Argument CriarProdutoInput input) {
        System.out.println("‚úèÔ∏è [GraphQL] Mutation: criarProduto");

        return service.criar(input);
    }

    // Field resolver (evita N+1)
    @SchemaMapping(typeName = "Produto", field = "categoria")
    public Categoria categoria(Produto produto) {
        System.out.println("üîó [GraphQL] Resolvendo categoria do produto: " + produto.getId());

        return categoriaService.buscarPorId(produto.getCategoriaId());
    }

    @SchemaMapping(typeName = "Produto", field = "avaliacoes")
    public List<Avaliacao> avaliacoes(Produto produto) {
        System.out.println("üîó [GraphQL] Resolvendo avalia√ß√µes do produto: " + produto.getId());

        return avaliacaoService.buscarPorProduto(produto.getId());
    }
}

// ‚úÖ Vantagens:
// - Cliente define exatamente os dados necess√°rios ‚úÖ
// - Uma requisi√ß√£o para dados relacionados ‚úÖ
// - Schema fortemente tipado ‚úÖ
// - Sem over-fetching/under-fetching ‚úÖ
// - DataLoader evita N+1 automaticamente ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Schema GraphQL

```graphql
# schema.graphqls

# ===== QUERIES (Read) =====
type Query {
  # Produtos
  produto(id: ID!): Produto
  produtos(
    filtro: ProdutoFiltro
    ordenacao: ProdutoOrdenacao
    page: Int
    size: Int
  ): ProdutoPage!

  # Categorias
  categoria(id: ID!): Categoria
  categorias: [Categoria!]!

  # Busca
  buscarProdutos(termo: String!): [Produto!]!
}

# ===== MUTATIONS (Write) =====
type Mutation {
  # Produtos
  criarProduto(input: CriarProdutoInput!): Produto!
  atualizarProduto(id: ID!, input: AtualizarProdutoInput!): Produto!
  deletarProduto(id: ID!): Boolean!

  # Avalia√ß√µes
  adicionarAvaliacao(produtoId: ID!, input: CriarAvaliacaoInput!): Avaliacao!
}

# ===== SUBSCRIPTIONS (Real-time) =====
type Subscription {
  produtoCriado: Produto!
  produtoAtualizado(id: ID!): Produto!
  avaliacaoAdicionada(produtoId: ID!): Avaliacao!
}

# ===== TYPES =====
type Produto {
  id: ID!
  nome: String!
  descricao: String
  preco: Float!
  estoque: Int!
  disponivel: Boolean!
  dataCriacao: String!

  # Relacionamentos (resolvidos sob demanda)
  categoria: Categoria
  avaliacoes: [Avaliacao!]!
  fornecedor: Fornecedor
  imagens: [Imagem!]!

  # Campos computados
  precoComDesconto(percentual: Float!): Float!
  mediaAvaliacoes: Float
}

type Categoria {
  id: ID!
  nome: String!
  descricao: String
  produtos: [Produto!]!
}

type Avaliacao {
  id: ID!
  nota: Int!
  comentario: String
  autor: String!
  data: String!
}

type Fornecedor {
  id: ID!
  nome: String!
  cnpj: String!
  email: String!
}

type Imagem {
  id: ID!
  url: String!
  principal: Boolean!
}

# ===== INPUTS =====
input CriarProdutoInput {
  nome: String!
  descricao: String
  preco: Float!
  estoque: Int!
  categoriaId: ID!
  fornecedorId: ID
}

input AtualizarProdutoInput {
  nome: String
  descricao: String
  preco: Float
  estoque: Int
  categoriaId: ID
}

input CriarAvaliacaoInput {
  nota: Int!
  comentario: String
  autor: String!
}

input ProdutoFiltro {
  nome: String
  precoMin: Float
  precoMax: Float
  categoriaId: ID
  disponivel: Boolean
}

enum ProdutoOrdenacao {
  NOME_ASC
  NOME_DESC
  PRECO_ASC
  PRECO_DESC
  DATA_ASC
  DATA_DESC
}

# ===== PAGINATION =====
type ProdutoPage {
  content: [Produto!]!
  totalElements: Int!
  totalPages: Int!
  page: Int!
  size: Int!
  hasNext: Boolean!
  hasPrevious: Boolean!
}

# ===== ERRORS =====
type Error {
  message: String!
  path: [String!]
  extensions: ErrorExtensions
}

type ErrorExtensions {
  code: String!
  timestamp: String!
}
```

### 2. Resolvers (Controllers)

```java
// Query Resolvers

@Controller
public class ProdutoQueryResolver {

    private final ProdutoService service;

    @Autowired
    public ProdutoQueryResolver(ProdutoService service) {
        this.service = service;
    }

    @QueryMapping
    public Produto produto(@Argument Long id) {
        System.out.println("üîç [GraphQL Query] produto(id: " + id + ")");

        return service.buscarPorId(id)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(id));
    }

    @QueryMapping
    public ProdutoPage produtos(
        @Argument ProdutoFiltro filtro,
        @Argument ProdutoOrdenacao ordenacao,
        @Argument Integer page,
        @Argument Integer size
    ) {
        System.out.println("üîç [GraphQL Query] produtos");

        Pageable pageable = PageRequest.of(
            page != null ? page : 0,
            size != null ? size : 20,
            getSort(ordenacao)
        );

        Page<Produto> result = service.listar(filtro, pageable);

        return ProdutoPage.from(result);
    }

    @QueryMapping
    public List<Produto> buscarProdutos(@Argument String termo) {
        System.out.println("üîç [GraphQL Query] buscarProdutos(termo: " + termo + ")");

        return service.buscarPorNome(termo);
    }

    private Sort getSort(ProdutoOrdenacao ordenacao) {
        if (ordenacao == null) return Sort.unsorted();

        return switch (ordenacao) {
            case NOME_ASC -> Sort.by("nome").ascending();
            case NOME_DESC -> Sort.by("nome").descending();
            case PRECO_ASC -> Sort.by("preco").ascending();
            case PRECO_DESC -> Sort.by("preco").descending();
            case DATA_ASC -> Sort.by("dataCriacao").ascending();
            case DATA_DESC -> Sort.by("dataCriacao").descending();
        };
    }
}

// Mutation Resolvers

@Controller
public class ProdutoMutationResolver {

    private final ProdutoService service;
    private final SimpMessagingTemplate messagingTemplate; // Para subscriptions

    @Autowired
    public ProdutoMutationResolver(
        ProdutoService service,
        SimpMessagingTemplate messagingTemplate
    ) {
        this.service = service;
        this.messagingTemplate = messagingTemplate;
    }

    @MutationMapping
    public Produto criarProduto(@Argument CriarProdutoInput input) {
        System.out.println("‚úèÔ∏è [GraphQL Mutation] criarProduto");

        Produto produto = service.criar(input);

        // Notificar subscriptions
        messagingTemplate.convertAndSend("/topic/produtoCriado", produto);

        return produto;
    }

    @MutationMapping
    public Produto atualizarProduto(
        @Argument Long id,
        @Argument AtualizarProdutoInput input
    ) {
        System.out.println("‚úèÔ∏è [GraphQL Mutation] atualizarProduto(id: " + id + ")");

        Produto atualizado = service.atualizar(id, input);

        // Notificar subscriptions
        messagingTemplate.convertAndSend(
            "/topic/produtoAtualizado/" + id,
            atualizado
        );

        return atualizado;
    }

    @MutationMapping
    public Boolean deletarProduto(@Argument Long id) {
        System.out.println("‚úèÔ∏è [GraphQL Mutation] deletarProduto(id: " + id + ")");

        service.deletar(id);
        return true;
    }

    @MutationMapping
    public Avaliacao adicionarAvaliacao(
        @Argument Long produtoId,
        @Argument CriarAvaliacaoInput input
    ) {
        System.out.println("‚úèÔ∏è [GraphQL Mutation] adicionarAvaliacao");

        Avaliacao avaliacao = service.adicionarAvaliacao(produtoId, input);

        // Notificar subscriptions
        messagingTemplate.convertAndSend(
            "/topic/avaliacaoAdicionada/" + produtoId,
            avaliacao
        );

        return avaliacao;
    }
}

// Field Resolvers (para dados relacionados)

@Controller
public class ProdutoFieldResolver {

    private final CategoriaService categoriaService;
    private final AvaliacaoService avaliacaoService;
    private final FornecedorService fornecedorService;

    @Autowired
    public ProdutoFieldResolver(
        CategoriaService categoriaService,
        AvaliacaoService avaliacaoService,
        FornecedorService fornecedorService
    ) {
        this.categoriaService = categoriaService;
        this.avaliacaoService = avaliacaoService;
        this.fornecedorService = fornecedorService;
    }

    // Resolve campo 'categoria' do tipo Produto
    @SchemaMapping(typeName = "Produto", field = "categoria")
    public Categoria categoria(Produto produto) {
        System.out.println("üîó Resolvendo categoria para produto: " + produto.getId());

        return categoriaService.buscarPorId(produto.getCategoriaId())
            .orElse(null);
    }

    // Resolve campo 'avaliacoes' do tipo Produto
    @SchemaMapping(typeName = "Produto", field = "avaliacoes")
    public List<Avaliacao> avaliacoes(Produto produto) {
        System.out.println("üîó Resolvendo avalia√ß√µes para produto: " + produto.getId());

        return avaliacaoService.buscarPorProduto(produto.getId());
    }

    // Resolve campo 'fornecedor' do tipo Produto
    @SchemaMapping(typeName = "Produto", field = "fornecedor")
    public Fornecedor fornecedor(Produto produto) {
        System.out.println("üîó Resolvendo fornecedor para produto: " + produto.getId());

        if (produto.getFornecedorId() == null) return null;

        return fornecedorService.buscarPorId(produto.getFornecedorId())
            .orElse(null);
    }

    // Campo computado
    @SchemaMapping(typeName = "Produto", field = "precoComDesconto")
    public BigDecimal precoComDesconto(Produto produto, @Argument Float percentual) {
        System.out.println("üîó Calculando pre√ßo com desconto: " + percentual + "%");

        BigDecimal desconto = produto.getPreco()
            .multiply(BigDecimal.valueOf(percentual / 100));

        return produto.getPreco().subtract(desconto);
    }

    @SchemaMapping(typeName = "Produto", field = "mediaAvaliacoes")
    public Double mediaAvaliacoes(Produto produto) {
        List<Avaliacao> avaliacoes = avaliacaoService.buscarPorProduto(produto.getId());

        if (avaliacoes.isEmpty()) return null;

        return avaliacoes.stream()
            .mapToInt(Avaliacao::getNota)
            .average()
            .orElse(0.0);
    }
}
```

### 3. DataLoader (Evitar N+1 Problem)

```java
// DataLoader para carregar dados em batch

@Configuration
public class DataLoaderConfig {

    @Bean
    public BatchLoaderRegistry batchLoaderRegistry(
        CategoriaService categoriaService,
        AvaliacaoService avaliacaoService
    ) {
        BatchLoaderRegistry registry = new DefaultBatchLoaderRegistry();

        // Batch loader para categorias
        registry.forTypePair(Long.class, Categoria.class)
            .registerBatchLoader((ids, env) -> {
                System.out.println("üì¶ [DataLoader] Carregando categorias em batch: " + ids);

                return Mono.just(categoriaService.buscarPorIds(ids));
            });

        // Batch loader para avalia√ß√µes
        registry.forTypePair(Long.class, List.class)
            .registerBatchLoader((produtoIds, env) -> {
                System.out.println("üì¶ [DataLoader] Carregando avalia√ß√µes em batch: " + produtoIds);

                Map<Long, List<Avaliacao>> avaliacoesPorProduto =
                    avaliacaoService.buscarPorProdutos(produtoIds);

                return Mono.just(
                    produtoIds.stream()
                        .map(id -> avaliacoesPorProduto.getOrDefault(id, List.of()))
                        .collect(Collectors.toList())
                );
            });

        return registry;
    }
}

// Usar DataLoader no resolver
@Controller
public class ProdutoFieldResolverWithDataLoader {

    @SchemaMapping(typeName = "Produto", field = "categoria")
    public CompletableFuture<Categoria> categoria(
        Produto produto,
        DataLoader<Long, Categoria> categoriaLoader
    ) {
        // DataLoader agrupa chamadas e faz uma query batch ‚úÖ
        return categoriaLoader.load(produto.getCategoriaId());
    }
}
```

### 4. Subscriptions (Real-time)

```java
// WebSocket configuration para subscriptions

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/graphql-websocket")
            .setAllowedOrigins("*")
            .withSockJS();
    }
}

// Subscription resolver
@Controller
public class ProdutoSubscriptionResolver {

    @SubscriptionMapping
    public Flux<Produto> produtoCriado() {
        System.out.println("üîî [GraphQL Subscription] produtoCriado");

        // Retorna stream de produtos criados
        return Flux.create(emitter -> {
            // Registrar listener para novos produtos
            // Quando produto criado, emitter.next(produto)
        });
    }

    @SubscriptionMapping
    public Flux<Produto> produtoAtualizado(@Argument Long id) {
        System.out.println("üîî [GraphQL Subscription] produtoAtualizado(id: " + id + ")");

        return Flux.create(emitter -> {
            // Stream de atualiza√ß√µes do produto espec√≠fico
        });
    }
}
```

### 5. Cliente GraphQL

```java
// Cliente para consumir API GraphQL

@Service
public class ProdutoGraphQLClient {

    private final WebClient webClient;

    public ProdutoGraphQLClient(@Value("${graphql.url}") String graphqlUrl) {
        this.webClient = WebClient.builder()
            .baseUrl(graphqlUrl)
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }

    public Produto buscarProduto(Long id) {
        String query = """
            query BuscarProduto($id: ID!) {
              produto(id: $id) {
                id
                nome
                preco
                categoria {
                  nome
                }
              }
            }
            """;

        Map<String, Object> variables = Map.of("id", id);

        GraphQLRequest request = new GraphQLRequest(query, variables);

        GraphQLResponse response = webClient.post()
            .bodyValue(request)
            .retrieve()
            .bodyToMono(GraphQLResponse.class)
            .block();

        return response.getData().getProduto();
    }

    public Produto criarProduto(CriarProdutoInput input) {
        String mutation = """
            mutation CriarProduto($input: CriarProdutoInput!) {
              criarProduto(input: $input) {
                id
                nome
                preco
              }
            }
            """;

        Map<String, Object> variables = Map.of("input", input);

        GraphQLRequest request = new GraphQLRequest(mutation, variables);

        GraphQLResponse response = webClient.post()
            .bodyValue(request)
            .retrieve()
            .bodyToMono(GraphQLResponse.class)
            .block();

        return response.getData().getCriarProduto();
    }
}

record GraphQLRequest(String query, Map<String, Object> variables) {}
record GraphQLResponse(GraphQLData data, List<GraphQLError> errors) {}
record GraphQLData(Produto produto, Produto criarProduto) {}
record GraphQLError(String message, List<String> path) {}
```

---

## üß™ Como Testar

### 1. Teste de Query

```java
@GraphQlTest(ProdutoQueryResolver.class)
class ProdutoQueryTest {

    @Autowired
    private GraphQlTester graphQlTester;

    @MockBean
    private ProdutoService service;

    @Test
    void deveRetornarProduto() {
        // Arrange
        Produto produto = new Produto();
        produto.setId(1L);
        produto.setNome("Notebook");
        produto.setPreco(new BigDecimal("3000"));

        when(service.buscarPorId(1L)).thenReturn(Optional.of(produto));

        // Act & Assert
        graphQlTester.documentName("buscar-produto")
            .variable("id", 1L)
            .execute()
            .path("produto.id").entity(Long.class).isEqualTo(1L)
            .path("produto.nome").entity(String.class).isEqualTo("Notebook")
            .path("produto.preco").entity(BigDecimal.class).isEqualTo(new BigDecimal("3000"));
    }
}
```

### 2. Teste de Mutation

```java
@Test
void deveCriarProduto() {
    // Arrange
    CriarProdutoInput input = new CriarProdutoInput(
        "Notebook",
        "Notebook Dell",
        new BigDecimal("3000"),
        10,
        1L
    );

    Produto produtoCriado = new Produto();
    produtoCriado.setId(1L);
    produtoCriado.setNome(input.nome());

    when(service.criar(any())).thenReturn(produtoCriado);

    // Act & Assert
    graphQlTester.documentName("criar-produto")
        .variable("input", input)
        .execute()
        .path("criarProduto.id").entity(Long.class).isEqualTo(1L)
        .path("criarProduto.nome").entity(String.class).isEqualTo("Notebook");
}
```

### 3. Teste de Subscription

```java
@Test
void deveReceberProdutoCriado() {
    // Arrange
    Flux<Produto> produtoFlux = Flux.just(new Produto("Notebook", new BigDecimal("3000")));

    // Act
    graphQlTester.documentName("subscription-produto-criado")
        .executeSubscription()
        .toFlux("produtoCriado", Produto.class)
        .as(StepVerifier::create)
        .expectNextMatches(p -> p.getNome().equals("Notebook"))
        .thenCancel()
        .verify();
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Schema First**: Definir schema antes de implementar
- ‚úÖ **DataLoader**: Usar para evitar N+1 problem
- ‚úÖ **Pagina√ß√£o**: Sempre paginar listas grandes
- ‚úÖ **Nullable**: Marcar campos opcionais corretamente
- ‚úÖ **Depth Limiting**: Limitar profundidade de queries
- ‚úÖ **Query Complexity**: Calcular e limitar complexidade
- ‚úÖ **Caching**: Cache em Field Resolvers

---

## üîó GraphQL vs REST

| Caracter√≠stica     | GraphQL          | REST             |
| ------------------ | ---------------- | ---------------- |
| **Endpoints**      | 1 √∫nico          | M√∫ltiplos        |
| **Over-fetching**  | N√£o              | Sim              |
| **Under-fetching** | N√£o              | Sim              |
| **Versionamento**  | Schema evolution | /v1, /v2         |
| **Documenta√ß√£o**   | Auto (schema)    | Manual (OpenAPI) |
| **Cache**          | Complexo         | Simples (HTTP)   |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens             | ‚ö†Ô∏è Desvantagens                 |
| ------------------------ | ------------------------------- |
| Sem over/under-fetching  | Complexidade inicial            |
| Schema fortemente tipado | Cache HTTP dif√≠cil              |
| Uma requisi√ß√£o           | Pode expor demais               |
| Introspection            | Performance (queries complexas) |
| Documenta√ß√£o autom√°tica  | Curva de aprendizado            |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use GraphQL quando:

- Frontend precisa flexibilidade
- M√∫ltiplos clientes (web/mobile)
- Dados relacionados complexos
- Necessidade de otimiza√ß√£o mobile

### ‚ùå Evite GraphQL quando:

- API simples CRUD
- Cache HTTP importante
- Time sem experi√™ncia
- File uploads complexos

---

**GraphQL permite clientes solicitarem exatamente os dados necess√°rios, eliminando over-fetching/under-fetching!** üé®‚ú®
