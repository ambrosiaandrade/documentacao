# 04.47 SOAP Architecture [AVAN√áADO] üßº

## üéØ Objetivo

Criar Web Services **enterprise-grade** usando SOAP (Simple Object Access Protocol) com **WSDL contracts**, **WS-Security**, **transa√ß√µes distribu√≠das** e **interoperabilidade** entre plataformas.

---

## üìö O Que √â?

**SOAP (Simple Object Access Protocol)** √© um protocolo XML para troca de mensagens estruturadas entre sistemas, com suporte a transa√ß√µes, seguran√ßa (WS-Security) e contratos formais (WSDL).

### Analogia

Como **correio registrado**:

- **REST**: Email simples (r√°pido, informal)
- **SOAP**: Correio registrado (formal, rastre√°vel, seguro)
- **Vantagem**: Garantias, seguran√ßa e padr√µes enterprise

---

## ‚ùå Problema que Resolve

### Antes (REST sem Contrato Formal)

```java
// ‚ùå PROBLEMA: REST sem contrato formal

@RestController
@RequestMapping("/api/pagamento")
class PagamentoController {

    @PostMapping
    PagamentoResponse processar(@RequestBody PagamentoRequest request) {
        // Sem contrato formal ‚ùå
        // Sem valida√ß√£o autom√°tica ‚ùå
        // Sem seguran√ßa WS-* ‚ùå
        // Sem transa√ß√µes distribu√≠das ‚ùå

        return new PagamentoResponse(
            request.getId(),
            "APROVADO",
            LocalDateTime.now()
        );
    }
}

// Cliente n√£o sabe a estrutura exata ‚ùå
{
  "id": "123",
  "valor": 100.00,
  "cartao": "1234567890123456"
}

// Problemas:
// - Sem contrato WSDL (cliente n√£o sabe estrutura) ‚ùå
// - Sem valida√ß√£o autom√°tica de tipos ‚ùå
// - Sem WS-Security (encryption, signatures) ‚ùå
// - Sem WS-Transaction (transa√ß√µes distribu√≠das) ‚ùå
// - Sem WS-ReliableMessaging (garantia de entrega) ‚ùå
// - Interoperabilidade limitada (.NET, Java) ‚ùå
```

**Problemas**:

- üìù Sem contrato formal (WSDL)
- üîí Sem WS-Security enterprise
- üí≥ Sem transa√ß√µes distribu√≠das
- üîÑ Interoperabilidade limitada

### Depois (SOAP com WSDL e WS-\*)

```xml
<!-- ‚úÖ SOLU√á√ÉO: SOAP com contrato WSDL formal -->

<!-- pagamento.wsdl - Contrato formal e tipado -->
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://schemas.xmlsoap.org/wsdl/"
             xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
             xmlns:tns="http://example.com/pagamento"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             targetNamespace="http://example.com/pagamento">

    <!-- Tipos de dados (tipados e validados) -->
    <types>
        <xsd:schema targetNamespace="http://example.com/pagamento">

            <xsd:element name="ProcessarPagamentoRequest">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="transacaoId" type="xsd:string"/>
                        <xsd:element name="valor" type="xsd:decimal"/>
                        <xsd:element name="numeroCartao" type="xsd:string"/>
                        <xsd:element name="cvv" type="xsd:string"/>
                        <xsd:element name="nomeCliente" type="xsd:string"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>

            <xsd:element name="ProcessarPagamentoResponse">
                <xsd:complexType>
                    <xsd:sequence>
                        <xsd:element name="transacaoId" type="xsd:string"/>
                        <xsd:element name="status" type="tns:StatusPagamento"/>
                        <xsd:element name="mensagem" type="xsd:string"/>
                        <xsd:element name="codigoAutorizacao" type="xsd:string"/>
                        <xsd:element name="dataHora" type="xsd:dateTime"/>
                    </xsd:sequence>
                </xsd:complexType>
            </xsd:element>

            <xsd:simpleType name="StatusPagamento">
                <xsd:restriction base="xsd:string">
                    <xsd:enumeration value="APROVADO"/>
                    <xsd:enumeration value="NEGADO"/>
                    <xsd:enumeration value="ERRO"/>
                </xsd:restriction>
            </xsd:simpleType>

        </xsd:schema>
    </types>

    <!-- Mensagens -->
    <message name="ProcessarPagamentoRequestMsg">
        <part name="parameters" element="tns:ProcessarPagamentoRequest"/>
    </message>
    <message name="ProcessarPagamentoResponseMsg">
        <part name="parameters" element="tns:ProcessarPagamentoResponse"/>
    </message>

    <!-- Port Type (opera√ß√µes) -->
    <portType name="PagamentoPortType">
        <operation name="ProcessarPagamento">
            <input message="tns:ProcessarPagamentoRequestMsg"/>
            <output message="tns:ProcessarPagamentoResponseMsg"/>
        </operation>
    </portType>

    <!-- Binding (protocolo SOAP) -->
    <binding name="PagamentoBinding" type="tns:PagamentoPortType">
        <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
        <operation name="ProcessarPagamento">
            <soap:operation soapAction="http://example.com/pagamento/ProcessarPagamento"/>
            <input>
                <soap:body use="literal"/>
            </input>
            <output>
                <soap:body use="literal"/>
            </output>
        </operation>
    </binding>

    <!-- Service (endpoint) -->
    <service name="PagamentoService">
        <port name="PagamentoPort" binding="tns:PagamentoBinding">
            <soap:address location="http://localhost:8080/ws/pagamento"/>
        </port>
    </service>

</definitions>
```

```java
// Implementa√ß√£o SOAP com JAX-WS

@WebService(
    serviceName = "PagamentoService",
    portName = "PagamentoPort",
    targetNamespace = "http://example.com/pagamento",
    endpointInterface = "com.example.pagamento.PagamentoPortType"
)
@SOAPBinding(style = SOAPBinding.Style.DOCUMENT)
public class PagamentoWebService implements PagamentoPortType {

    private final PagamentoService pagamentoService;

    @Autowired
    public PagamentoWebService(PagamentoService pagamentoService) {
        this.pagamentoService = pagamentoService;
    }

    @Override
    @WebMethod(operationName = "ProcessarPagamento")
    @WebResult(name = "ProcessarPagamentoResponse")
    public ProcessarPagamentoResponse processarPagamento(
        @WebParam(name = "ProcessarPagamentoRequest") ProcessarPagamentoRequest request
    ) throws PagamentoFault {

        System.out.println("üßº [SOAP] Processando pagamento: " + request.getTransacaoId());

        try {
            // Valida√ß√µes autom√°ticas pelo schema XSD ‚úÖ
            // Tipos fortemente tipados ‚úÖ

            Pagamento pagamento = pagamentoService.processar(
                request.getTransacaoId(),
                request.getValor(),
                request.getNumeroCartao(),
                request.getCvv(),
                request.getNomeCliente()
            );

            // Response tipada
            ProcessarPagamentoResponse response = new ProcessarPagamentoResponse();
            response.setTransacaoId(pagamento.getTransacaoId());
            response.setStatus(StatusPagamento.fromValue(pagamento.getStatus().name()));
            response.setMensagem("Pagamento processado com sucesso");
            response.setCodigoAutorizacao(pagamento.getCodigoAutorizacao());
            response.setDataHora(pagamento.getDataHora());

            return response;

        } catch (PagamentoNegadoException e) {
            // SOAP Fault (erro estruturado) ‚úÖ
            throw new PagamentoFault("Pagamento negado",
                buildFaultInfo("PAGAMENTO_NEGADO", e.getMessage()));
        }
    }
}

// SOAP Request/Response (XML) ‚úÖ
<!-- Request -->
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:pag="http://example.com/pagamento">
   <soapenv:Header>
      <!-- WS-Security header -->
      <wsse:Security xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/...">
         <wsse:UsernameToken>
            <wsse:Username>usuario</wsse:Username>
            <wsse:Password Type="...#PasswordDigest">...</wsse:Password>
         </wsse:UsernameToken>
      </wsse:Security>
   </soapenv:Header>
   <soapenv:Body>
      <pag:ProcessarPagamentoRequest>
         <pag:transacaoId>TXN-12345</pag:transacaoId>
         <pag:valor>150.00</pag:valor>
         <pag:numeroCartao>4111111111111111</pag:numeroCartao>
         <pag:cvv>123</pag:cvv>
         <pag:nomeCliente>Jo√£o Silva</pag:nomeCliente>
      </pag:ProcessarPagamentoRequest>
   </soapenv:Body>
</soapenv:Envelope>

<!-- Response -->
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
   <soapenv:Body>
      <pag:ProcessarPagamentoResponse xmlns:pag="http://example.com/pagamento">
         <pag:transacaoId>TXN-12345</pag:transacaoId>
         <pag:status>APROVADO</pag:status>
         <pag:mensagem>Pagamento processado com sucesso</pag:mensagem>
         <pag:codigoAutorizacao>AUTH-98765</pag:codigoAutorizacao>
         <pag:dataHora>2024-01-15T10:30:00</pag:dataHora>
      </pag:ProcessarPagamentoResponse>
   </soapenv:Body>
</soapenv:Envelope>

// ‚úÖ Vantagens:
// - Contrato WSDL formal (cliente gera c√≥digo automaticamente) ‚úÖ
// - Valida√ß√£o autom√°tica pelo schema XSD ‚úÖ
// - WS-Security (encryption, signatures, tokens) ‚úÖ
// - WS-Transaction (transa√ß√µes distribu√≠das) ‚úÖ
// - SOAP Fault (erros estruturados) ‚úÖ
// - Interoperabilidade (.NET, Java, PHP) ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Configura√ß√£o do Projeto

```xml
<!-- pom.xml -->
<dependencies>
    <!-- JAX-WS (SOAP) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web-services</artifactId>
    </dependency>

    <!-- WSDL -->
    <dependency>
        <groupId>wsdl4j</groupId>
        <artifactId>wsdl4j</artifactId>
    </dependency>

    <!-- WS-Security -->
    <dependency>
        <groupId>org.apache.wss4j</groupId>
        <artifactId>wss4j-ws-security-dom</artifactId>
        <version>2.4.1</version>
    </dependency>

    <!-- JAXB (XML binding) -->
    <dependency>
        <groupId>javax.xml.bind</groupId>
        <artifactId>jaxb-api</artifactId>
        <version>2.3.1</version>
    </dependency>
</dependencies>

<build>
    <plugins>
        <!-- JAXB plugin para gerar classes do XSD -->
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>jaxb2-maven-plugin</artifactId>
            <version>2.5.0</version>
            <executions>
                <execution>
                    <goals>
                        <goal>xjc</goal>
                    </goals>
                </execution>
            </executions>
            <configuration>
                <sources>
                    <source>src/main/resources/xsd</source>
                </sources>
            </configuration>
        </plugin>
    </plugins>
</build>
```

### 2. Schema XSD

```xml
<!-- src/main/resources/xsd/produto.xsd -->
<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:tns="http://example.com/produto"
           targetNamespace="http://example.com/produto"
           elementFormDefault="qualified">

    <!-- Request: Buscar Produto -->
    <xs:element name="BuscarProdutoRequest">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="id" type="xs:long"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Response: Buscar Produto -->
    <xs:element name="BuscarProdutoResponse">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="produto" type="tns:Produto"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Request: Criar Produto -->
    <xs:element name="CriarProdutoRequest">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="nome" type="xs:string"/>
                <xs:element name="descricao" type="xs:string" minOccurs="0"/>
                <xs:element name="preco" type="xs:decimal"/>
                <xs:element name="estoque" type="xs:int"/>
                <xs:element name="categoriaId" type="xs:long"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Response: Criar Produto -->
    <xs:element name="CriarProdutoResponse">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="produto" type="tns:Produto"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Request: Listar Produtos -->
    <xs:element name="ListarProdutosRequest">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="page" type="xs:int" minOccurs="0"/>
                <xs:element name="size" type="xs:int" minOccurs="0"/>
                <xs:element name="filtroNome" type="xs:string" minOccurs="0"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Response: Listar Produtos -->
    <xs:element name="ListarProdutosResponse">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="produtos" type="tns:Produto" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="totalElementos" type="xs:int"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- Tipo Complexo: Produto -->
    <xs:complexType name="Produto">
        <xs:sequence>
            <xs:element name="id" type="xs:long"/>
            <xs:element name="nome" type="xs:string"/>
            <xs:element name="descricao" type="xs:string" minOccurs="0"/>
            <xs:element name="preco" type="xs:decimal"/>
            <xs:element name="estoque" type="xs:int"/>
            <xs:element name="disponivel" type="xs:boolean"/>
            <xs:element name="dataCriacao" type="xs:dateTime"/>
            <xs:element name="categoria" type="tns:Categoria" minOccurs="0"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Tipo Complexo: Categoria -->
    <xs:complexType name="Categoria">
        <xs:sequence>
            <xs:element name="id" type="xs:long"/>
            <xs:element name="nome" type="xs:string"/>
        </xs:sequence>
    </xs:complexType>

    <!-- SOAP Fault -->
    <xs:element name="ProdutoFault">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="codigo" type="xs:string"/>
                <xs:element name="mensagem" type="xs:string"/>
                <xs:element name="detalhes" type="xs:string" minOccurs="0"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

</xs:schema>
```

### 3. Configura√ß√£o Spring WS

```java
// Configura√ß√£o do SOAP endpoint

@Configuration
@EnableWs
public class WebServiceConfig extends WsConfigurerAdapter {

    @Bean
    public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(
        ApplicationContext applicationContext
    ) {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        servlet.setApplicationContext(applicationContext);
        servlet.setTransformWsdlLocations(true);
        return new ServletRegistrationBean<>(servlet, "/ws/*");
    }

    @Bean(name = "produtos")
    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema produtosSchema) {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName("ProdutosPort");
        wsdl11Definition.setLocationUri("/ws/produtos");
        wsdl11Definition.setTargetNamespace("http://example.com/produto");
        wsdl11Definition.setSchema(produtosSchema);
        return wsdl11Definition;
    }

    @Bean
    public XsdSchema produtosSchema() {
        return new SimpleXsdSchema(new ClassPathResource("xsd/produto.xsd"));
    }

    // Interceptors
    @Override
    public void addInterceptors(List<EndpointInterceptor> interceptors) {
        interceptors.add(new PayloadLoggingInterceptor());
        interceptors.add(new SoapHeaderInterceptor());
    }
}

// Logging Interceptor

public class PayloadLoggingInterceptor extends PayloadLoggingInterceptor {

    private static final Logger log = LoggerFactory.getLogger(PayloadLoggingInterceptor.class);

    @Override
    protected void logMessageSource(String message, MessageSource messageSource) {
        try {
            Transformer transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");

            StringWriter writer = new StringWriter();
            transformer.transform(messageSource.getPayload(), new StreamResult(writer));

            log.info("\n" + message + ":\n" + writer);

        } catch (Exception e) {
            log.error("Erro ao logar mensagem", e);
        }
    }
}
```

### 4. Endpoint SOAP

```java
// Endpoint do Web Service

@Endpoint
public class ProdutoSoapEndpoint {

    private static final String NAMESPACE_URI = "http://example.com/produto";

    private final ProdutoService produtoService;

    @Autowired
    public ProdutoSoapEndpoint(ProdutoService produtoService) {
        this.produtoService = produtoService;
    }

    // Buscar produto por ID
    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "BuscarProdutoRequest")
    @ResponsePayload
    public BuscarProdutoResponse buscarProduto(
        @RequestPayload BuscarProdutoRequest request
    ) throws ProdutoNaoEncontradoFault {

        System.out.println("üßº [SOAP] BuscarProduto: " + request.getId());

        Produto produto = produtoService.buscar(request.getId())
            .orElseThrow(() -> {
                ProdutoFault fault = new ProdutoFault();
                fault.setCodigo("PRODUTO_NAO_ENCONTRADO");
                fault.setMensagem("Produto n√£o encontrado: " + request.getId());
                return new ProdutoNaoEncontradoFault("Produto n√£o encontrado", fault);
            });

        BuscarProdutoResponse response = new BuscarProdutoResponse();
        response.setProduto(converterParaSoap(produto));

        return response;
    }

    // Criar produto
    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "CriarProdutoRequest")
    @ResponsePayload
    public CriarProdutoResponse criarProduto(
        @RequestPayload CriarProdutoRequest request,
        @SoapHeader("{http://example.com/security}Authentication")
        SoapHeaderElement authHeader
    ) throws ValidationFault {

        System.out.println("üßº [SOAP] CriarProduto: " + request.getNome());

        // Validar autentica√ß√£o
        validarAutenticacao(authHeader);

        // Valida√ß√µes de neg√≥cio
        if (request.getPreco().compareTo(BigDecimal.ZERO) <= 0) {
            ProdutoFault fault = new ProdutoFault();
            fault.setCodigo("PRECO_INVALIDO");
            fault.setMensagem("Pre√ßo deve ser maior que zero");
            throw new ValidationFault("Valida√ß√£o falhou", fault);
        }

        Produto produto = new Produto();
        produto.setNome(request.getNome());
        produto.setDescricao(request.getDescricao());
        produto.setPreco(request.getPreco());
        produto.setEstoque(request.getEstoque());

        if (request.getCategoriaId() != null) {
            Categoria categoria = categoriaService.buscar(request.getCategoriaId())
                .orElseThrow(() -> {
                    ProdutoFault fault = new ProdutoFault();
                    fault.setCodigo("CATEGORIA_NAO_ENCONTRADA");
                    fault.setMensagem("Categoria n√£o encontrada");
                    return new ValidationFault("Categoria inv√°lida", fault);
                });
            produto.setCategoria(categoria);
        }

        Produto salvo = produtoService.salvar(produto);

        CriarProdutoResponse response = new CriarProdutoResponse();
        response.setProduto(converterParaSoap(salvo));

        return response;
    }

    // Listar produtos
    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "ListarProdutosRequest")
    @ResponsePayload
    public ListarProdutosResponse listarProdutos(
        @RequestPayload ListarProdutosRequest request
    ) {
        System.out.println("üßº [SOAP] ListarProdutos");

        int page = request.getPage() != null ? request.getPage() : 0;
        int size = request.getSize() != null ? request.getSize() : 20;

        Page<Produto> produtos;
        if (request.getFiltroNome() != null && !request.getFiltroNome().isBlank()) {
            produtos = produtoService.buscarPorNome(
                request.getFiltroNome(),
                PageRequest.of(page, size)
            );
        } else {
            produtos = produtoService.listar(PageRequest.of(page, size));
        }

        ListarProdutosResponse response = new ListarProdutosResponse();
        response.setTotalElementos((int) produtos.getTotalElements());

        produtos.getContent().forEach(produto ->
            response.getProdutos().add(converterParaSoap(produto))
        );

        return response;
    }

    // Converter entidade para tipo SOAP
    private com.example.produto.Produto converterParaSoap(Produto produto) {
        com.example.produto.Produto soapProduto = new com.example.produto.Produto();
        soapProduto.setId(produto.getId());
        soapProduto.setNome(produto.getNome());
        soapProduto.setDescricao(produto.getDescricao());
        soapProduto.setPreco(produto.getPreco());
        soapProduto.setEstoque(produto.getEstoque());
        soapProduto.setDisponivel(produto.getEstoque() > 0);

        XMLGregorianCalendar dataCriacao = DatatypeFactory.newInstance()
            .newXMLGregorianCalendar(produto.getDataCriacao().toString());
        soapProduto.setDataCriacao(dataCriacao);

        if (produto.getCategoria() != null) {
            com.example.produto.Categoria soapCategoria = new com.example.produto.Categoria();
            soapCategoria.setId(produto.getCategoria().getId());
            soapCategoria.setNome(produto.getCategoria().getNome());
            soapProduto.setCategoria(soapCategoria);
        }

        return soapProduto;
    }

    private void validarAutenticacao(SoapHeaderElement authHeader) throws ValidationFault {
        if (authHeader == null) {
            ProdutoFault fault = new ProdutoFault();
            fault.setCodigo("NAO_AUTORIZADO");
            fault.setMensagem("Header de autentica√ß√£o ausente");
            throw new ValidationFault("N√£o autorizado", fault);
        }

        // Validar token/credenciais
        // ...
    }
}

// Exception personalizada com SOAP Fault

@WebFault(name = "ProdutoFault", targetNamespace = "http://example.com/produto")
public class ProdutoNaoEncontradoFault extends Exception {

    private final ProdutoFault faultInfo;

    public ProdutoNaoEncontradoFault(String message, ProdutoFault faultInfo) {
        super(message);
        this.faultInfo = faultInfo;
    }

    public ProdutoFault getFaultInfo() {
        return faultInfo;
    }
}
```

### 5. Cliente SOAP

```java
// Cliente para consumir SOAP Web Service

@Service
public class ProdutoSoapClient {

    private final Jaxb2Marshaller marshaller;
    private final WebServiceTemplate webServiceTemplate;

    @Autowired
    public ProdutoSoapClient(Jaxb2Marshaller marshaller) {
        this.marshaller = marshaller;
        this.webServiceTemplate = new WebServiceTemplate();
        this.webServiceTemplate.setMarshaller(marshaller);
        this.webServiceTemplate.setUnmarshaller(marshaller);
        this.webServiceTemplate.setDefaultUri("http://localhost:8080/ws/produtos");
    }

    // Buscar produto
    public com.example.produto.Produto buscarProduto(Long id) {
        System.out.println("üì§ [SOAP Client] Buscando produto: " + id);

        BuscarProdutoRequest request = new BuscarProdutoRequest();
        request.setId(id);

        BuscarProdutoResponse response = (BuscarProdutoResponse) webServiceTemplate
            .marshalSendAndReceive(request);

        return response.getProduto();
    }

    // Criar produto
    public com.example.produto.Produto criarProduto(
        String nome,
        BigDecimal preco,
        int estoque
    ) {
        System.out.println("üì§ [SOAP Client] Criando produto: " + nome);

        CriarProdutoRequest request = new CriarProdutoRequest();
        request.setNome(nome);
        request.setPreco(preco);
        request.setEstoque(estoque);

        // Adicionar SOAP header de autentica√ß√£o
        webServiceTemplate.marshalSendAndReceive(
            request,
            new WebServiceMessageCallback() {
                @Override
                public void doWithMessage(WebServiceMessage message) throws IOException {
                    SoapMessage soapMessage = (SoapMessage) message;
                    SoapHeader header = soapMessage.getSoapHeader();

                    // Adicionar header customizado
                    QName qName = new QName("http://example.com/security", "Authentication");
                    SoapHeaderElement authHeader = header.addHeaderElement(qName);
                    authHeader.setText("Bearer token-aqui");
                }
            }
        );

        CriarProdutoResponse response = (CriarProdutoResponse) webServiceTemplate
            .marshalSendAndReceive(request);

        return response.getProduto();
    }

    // Listar produtos
    public List<com.example.produto.Produto> listarProdutos(int page, int size) {
        System.out.println("üì§ [SOAP Client] Listando produtos");

        ListarProdutosRequest request = new ListarProdutosRequest();
        request.setPage(page);
        request.setSize(size);

        ListarProdutosResponse response = (ListarProdutosResponse) webServiceTemplate
            .marshalSendAndReceive(request);

        return response.getProdutos();
    }
}

// Configura√ß√£o do cliente

@Configuration
public class SoapClientConfig {

    @Bean
    public Jaxb2Marshaller marshaller() {
        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
        marshaller.setContextPath("com.example.produto");
        return marshaller;
    }
}
```

### 6. WS-Security (Autentica√ß√£o e Criptografia)

```java
// Configura√ß√£o WS-Security

@Configuration
public class WebServiceSecurityConfig extends WsConfigurerAdapter {

    @Override
    public void addInterceptors(List<EndpointInterceptor> interceptors) {
        // Interceptor de seguran√ßa
        interceptors.add(wsSecurityInterceptor());
    }

    @Bean
    public XwsSecurityInterceptor wsSecurityInterceptor() {
        XwsSecurityInterceptor interceptor = new XwsSecurityInterceptor();
        interceptor.setPolicyConfiguration(new ClassPathResource("securityPolicy.xml"));
        interceptor.setCallbackHandler(callbackHandler());
        return interceptor;
    }

    @Bean
    public CallbackHandler callbackHandler() {
        return new SpringPlainTextPasswordValidationCallbackHandler() {
            @Override
            protected void validateUserInternal(String username, String password)
                throws Exception {

                // Validar credenciais
                if (!"admin".equals(username) || !"secret".equals(password)) {
                    throw new Exception("Credenciais inv√°lidas");
                }
            }
        };
    }
}
```

```xml
<!-- securityPolicy.xml -->
<xwss:SecurityConfiguration xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
    <xwss:RequireUsernameToken
        passwordDigestRequired="true"
        nonceRequired="true"/>

    <xwss:RequireTimestamp
        maxClockSkew="60"
        timestampFreshnessLimit="300"/>

    <xwss:RequireSignature/>

    <xwss:RequireEncryption/>
</xwss:SecurityConfiguration>
```

---

## üß™ Como Testar

### 1. Teste com SoapUI/Postman

```xml
<!-- Request manual -->
POST http://localhost:8080/ws/produtos
Content-Type: text/xml

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:prod="http://example.com/produto">
   <soapenv:Header/>
   <soapenv:Body>
      <prod:BuscarProdutoRequest>
         <prod:id>1</prod:id>
      </prod:BuscarProdutoRequest>
   </soapenv:Body>
</soapenv:Envelope>
```

### 2. Teste de Integra√ß√£o

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ProdutoSoapEndpointTest {

    @Autowired
    private WebServiceTemplate webServiceTemplate;

    @LocalServerPort
    private int port;

    @BeforeEach
    void setUp() {
        webServiceTemplate.setDefaultUri("http://localhost:" + port + "/ws/produtos");
    }

    @Test
    void deveBuscarProdutoComSucesso() {
        // Arrange
        BuscarProdutoRequest request = new BuscarProdutoRequest();
        request.setId(1L);

        // Act
        BuscarProdutoResponse response = (BuscarProdutoResponse) webServiceTemplate
            .marshalSendAndReceive(request);

        // Assert
        assertNotNull(response);
        assertNotNull(response.getProduto());
        assertEquals(1L, response.getProduto().getId());
    }

    @Test
    void deveRetornarFaultQuandoProdutoNaoExiste() {
        // Arrange
        BuscarProdutoRequest request = new BuscarProdutoRequest();
        request.setId(999L);

        // Act & Assert
        assertThrows(SoapFaultClientException.class, () ->
            webServiceTemplate.marshalSendAndReceive(request)
        );
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Contrato WSDL**: Sempre defina contrato formal
- ‚úÖ **WS-Security**: Use para autentica√ß√£o/criptografia
- ‚úÖ **SOAP Fault**: Erros estruturados e tipados
- ‚úÖ **Versionamento**: Namespace para vers√µes
- ‚úÖ **Valida√ß√£o XSD**: Valida√ß√£o autom√°tica de tipos
- ‚úÖ **Logging**: Logar todas as mensagens SOAP
- ‚úÖ **Timeout**: Configurar timeout adequado

---

## üîó SOAP vs REST vs GraphQL

| Caracter√≠stica  | SOAP              | REST                | GraphQL     |
| --------------- | ----------------- | ------------------- | ----------- |
| **Protocolo**   | XML/HTTP          | JSON/HTTP           | JSON/HTTP   |
| **Contrato**    | ‚úÖ WSDL formal    | ‚ö†Ô∏è OpenAPI opcional | ‚úÖ Schema   |
| **Seguran√ßa**   | ‚ö° WS-Security    | JWT/OAuth           | JWT/OAuth   |
| **Transa√ß√µes**  | ‚úÖ WS-Transaction | ‚ùå N√£o              | ‚ùå N√£o      |
| **Performance** | üêå Pesado (XML)   | ‚ö° R√°pido (JSON)    | ‚ö° R√°pido   |
| **Enterprise**  | ‚úÖ Ideal          | ‚ö†Ô∏è Limitado         | ‚ö†Ô∏è Limitado |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                   | ‚ö†Ô∏è Desvantagens      |
| ------------------------------ | -------------------- |
| Contrato WSDL formal           | XML pesado e verboso |
| WS-Security enterprise         | Complexidade alta    |
| Transa√ß√µes distribu√≠das        | Performance inferior |
| SOAP Fault estruturado         | Curva de aprendizado |
| Interoperabilidade (.NET/Java) | Tooling limitado     |
| Valida√ß√£o XSD autom√°tica       | N√£o human-readable   |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use SOAP quando:

- Integra√ß√£o enterprise (.NET, Java)
- WS-Security necess√°rio
- Transa√ß√µes distribu√≠das
- Contrato formal obrigat√≥rio
- Banking/finance systems

### ‚ùå Evite SOAP quando:

- API p√∫blica moderna
- Performance cr√≠tica
- Mobile/Web apps
- REST/GraphQL suficiente
- Simplicidade priorit√°ria

---

**SOAP oferece Web Services enterprise-grade com WS-Security e contratos formais WSDL!** üßº‚ú®
