# 04.25 State Pattern [M√âDIO] üîÑ

## üéØ Objetivo

Permitir que um objeto **altere seu comportamento** quando seu estado interno muda, eliminando condicionais complexas e facilitando **testes de cada estado isoladamente**.

---

## üìö O Que √â?

**State** √© um padr√£o comportamental GoF que permite um objeto alterar seu comportamento quando seu estado interno muda, aparentando mudar de classe. Encapsula estados em classes separadas e delega comportamento ao estado atual.

### Analogia

Como um **sem√°foro**:

- **Verde**: Permite passar (comportamento: acelerar)
- **Amarelo**: Aten√ß√£o (comportamento: desacelerar)
- **Vermelho**: Pare (comportamento: frear)
- **Vantagem**: Cada cor tem l√≥gica isolada, f√°cil adicionar estados

---

## ‚ùå Problema que Resolve

### Antes (Condicionais Gigantes)

```java
// ‚ùå PROBLEMA: if/switch gigante para cada opera√ß√£o
class Pedido {
    private StatusPedido status = StatusPedido.PENDENTE;

    void aprovar() {
        if (status == StatusPedido.PENDENTE) {
            status = StatusPedido.APROVADO;
            reservarEstoque();
            notificarCliente("Aprovado");
        } else if (status == StatusPedido.APROVADO) {
            throw new IllegalStateException("J√° aprovado");
        } else if (status == StatusPedido.ENVIADO) {
            throw new IllegalStateException("J√° enviado");
        } else if (status == StatusPedido.CANCELADO) {
            throw new IllegalStateException("Cancelado");
        }
    }

    void enviar() {
        if (status == StatusPedido.PENDENTE) {
            throw new IllegalStateException("Precisa aprovar primeiro");
        } else if (status == StatusPedido.APROVADO) {
            status = StatusPedido.ENVIADO;
            gerarEtiqueta();
            notificarCliente("Enviado");
        } else if (status == StatusPedido.ENVIADO) {
            throw new IllegalStateException("J√° enviado");
        } else if (status == StatusPedido.CANCELADO) {
            throw new IllegalStateException("Cancelado");
        }
    }

    void cancelar() {
        // Mais if/else... ‚ùå
    }

    // Cada m√©todo tem if/else gigante! ‚ùå
    // Adicionar novo estado = modificar TODOS os m√©todos! ‚ùå
}
```

**Problemas**:

- üîÄ Condicionais complexas em cada m√©todo
- üîß Adicionar estado = modificar m√∫ltiplos m√©todos
- üß™ Dif√≠cil testar l√≥gica de cada estado
- üìö L√≥gica de estado espalhada
- üêõ Alto risco de bugs (esquecer casos)

### Depois (State Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Cada estado √© uma classe
interface PedidoState {
    void aprovar(PedidoContext context);
    void enviar(PedidoContext context);
    void cancelar(PedidoContext context);
    String getNome();
}

class PedidoPendenteState implements PedidoState {
    public void aprovar(PedidoContext context) {
        context.reservarEstoque();
        context.notificar("Aprovado");
        context.setState(new PedidoAprovadoState());
    }

    public void enviar(PedidoContext context) {
        throw new IllegalStateException("Precisa aprovar primeiro");
    }

    public void cancelar(PedidoContext context) {
        context.setState(new PedidoCanceladoState());
    }

    public String getNome() { return "PENDENTE"; }
}

class PedidoAprovadoState implements PedidoState {
    public void aprovar(PedidoContext context) {
        throw new IllegalStateException("J√° aprovado");
    }

    public void enviar(PedidoContext context) {
        context.gerarEtiqueta();
        context.notificar("Enviado");
        context.setState(new PedidoEnviadoState());
    }

    public void cancelar(PedidoContext context) {
        context.liberarEstoque();
        context.setState(new PedidoCanceladoState());
    }

    public String getNome() { return "APROVADO"; }
}

// Context
class PedidoContext {
    private PedidoState state = new PedidoPendenteState();

    void aprovar() { state.aprovar(this); }
    void enviar() { state.enviar(this); }
    void cancelar() { state.cancelar(this); }

    void setState(PedidoState newState) {
        this.state = newState;
    }
}

// Teste isolado de estado
@Test
void pendenteStateDeveAprovar() {
    PedidoContext contextMock = mock(PedidoContext.class);
    PedidoState state = new PedidoPendenteState();

    state.aprovar(contextMock);

    verify(contextMock).reservarEstoque();
    verify(contextMock).setState(any(PedidoAprovadoState.class));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface State

```java
interface PedidoState {
    void aprovar(Pedido context);
    void enviar(Pedido context);
    void entregar(Pedido context);
    void cancelar(Pedido context);
    String getNome();
    List<String> getAcoesPermitidas();
}
```

### 2. Context (Pedido)

```java
final class Pedido {
    private final String id;
    private final String cliente;
    private final BigDecimal valor;
    private PedidoState state;
    private final List<String> historico = new ArrayList<>();

    Pedido(String id, String cliente, BigDecimal valor) {
        this.id = id;
        this.cliente = cliente;
        this.valor = valor;
        this.state = new PendingState();
        registrarHistorico("Pedido criado");
    }

    // Delega√ß√£o para o state
    public void aprovar() {
        state.aprovar(this);
    }

    public void enviar() {
        state.enviar(this);
    }

    public void entregar() {
        state.entregar(this);
    }

    public void cancelar() {
        state.cancelar(this);
    }

    // Transi√ß√£o de estado
    void setState(PedidoState newState) {
        System.out.println("üîÑ Transi√ß√£o: " + state.getNome() + " ‚Üí " + newState.getNome());
        this.state = newState;
        registrarHistorico("Estado alterado para " + newState.getNome());
    }

    // A√ß√µes executadas pelos states
    void reservarEstoque() {
        System.out.println("üì¶ Estoque reservado");
        registrarHistorico("Estoque reservado");
    }

    void liberarEstoque() {
        System.out.println("üì§ Estoque liberado");
        registrarHistorico("Estoque liberado");
    }

    void gerarEtiqueta() {
        System.out.println("üè∑Ô∏è Etiqueta gerada");
        registrarHistorico("Etiqueta de envio gerada");
    }

    void notificarCliente(String mensagem) {
        System.out.println("üìß Notifica√ß√£o enviada: " + mensagem);
        registrarHistorico("Cliente notificado: " + mensagem);
    }

    void processarPagamento() {
        System.out.println("üí≥ Pagamento processado");
        registrarHistorico("Pagamento processado");
    }

    void reembolsar() {
        System.out.println("üí∞ Reembolso processado");
        registrarHistorico("Reembolso realizado");
    }

    private void registrarHistorico(String evento) {
        historico.add(LocalDateTime.now() + " - " + evento);
    }

    // Getters
    public String getId() { return id; }
    public String getCliente() { return cliente; }
    public BigDecimal getValor() { return valor; }
    public String getEstadoAtual() { return state.getNome(); }
    public List<String> getAcoesPermitidas() { return state.getAcoesPermitidas(); }
    public List<String> getHistorico() { return List.copyOf(historico); }
}
```

### 3. States Concretos

```java
// State: Pendente
final class PendingState implements PedidoState {

    @Override
    public void aprovar(Pedido context) {
        System.out.println("‚úÖ Aprovando pedido...");
        context.processarPagamento();
        context.reservarEstoque();
        context.notificarCliente("Seu pedido foi aprovado!");
        context.setState(new ApprovedState());
    }

    @Override
    public void enviar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel enviar pedido pendente. Aprove primeiro.");
    }

    @Override
    public void entregar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel entregar pedido pendente.");
    }

    @Override
    public void cancelar(Pedido context) {
        System.out.println("‚ùå Cancelando pedido pendente...");
        context.notificarCliente("Seu pedido foi cancelado.");
        context.setState(new CancelledState());
    }

    @Override
    public String getNome() {
        return "PENDENTE";
    }

    @Override
    public List<String> getAcoesPermitidas() {
        return List.of("aprovar", "cancelar");
    }
}

// State: Aprovado
final class ApprovedState implements PedidoState {

    @Override
    public void aprovar(Pedido context) {
        throw new IllegalStateException("Pedido j√° est√° aprovado.");
    }

    @Override
    public void enviar(Pedido context) {
        System.out.println("üì¶ Enviando pedido...");
        context.gerarEtiqueta();
        context.notificarCliente("Seu pedido foi enviado!");
        context.setState(new ShippedState());
    }

    @Override
    public void entregar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel entregar. Envie primeiro.");
    }

    @Override
    public void cancelar(Pedido context) {
        System.out.println("‚ùå Cancelando pedido aprovado...");
        context.liberarEstoque();
        context.reembolsar();
        context.notificarCliente("Seu pedido foi cancelado e o reembolso ser√° processado.");
        context.setState(new CancelledState());
    }

    @Override
    public String getNome() {
        return "APROVADO";
    }

    @Override
    public List<String> getAcoesPermitidas() {
        return List.of("enviar", "cancelar");
    }
}

// State: Enviado
final class ShippedState implements PedidoState {

    @Override
    public void aprovar(Pedido context) {
        throw new IllegalStateException("Pedido j√° foi enviado.");
    }

    @Override
    public void enviar(Pedido context) {
        throw new IllegalStateException("Pedido j√° foi enviado.");
    }

    @Override
    public void entregar(Pedido context) {
        System.out.println("‚úÖ Entregando pedido...");
        context.notificarCliente("Seu pedido foi entregue!");
        context.setState(new DeliveredState());
    }

    @Override
    public void cancelar(Pedido context) {
        // Cancelamento ap√≥s envio √© mais complexo
        System.out.println("‚ö†Ô∏è Cancelando pedido enviado (devolu√ß√£o)...");
        context.reembolsar();
        context.notificarCliente("Devolu√ß√£o solicitada. Reembolso ser√° processado ap√≥s recebimento.");
        context.setState(new CancelledState());
    }

    @Override
    public String getNome() {
        return "ENVIADO";
    }

    @Override
    public List<String> getAcoesPermitidas() {
        return List.of("entregar", "cancelar");
    }
}

// State: Entregue
final class DeliveredState implements PedidoState {

    @Override
    public void aprovar(Pedido context) {
        throw new IllegalStateException("Pedido j√° foi entregue.");
    }

    @Override
    public void enviar(Pedido context) {
        throw new IllegalStateException("Pedido j√° foi entregue.");
    }

    @Override
    public void entregar(Pedido context) {
        throw new IllegalStateException("Pedido j√° foi entregue.");
    }

    @Override
    public void cancelar(Pedido context) {
        System.out.println("üîÑ Solicitando devolu√ß√£o de pedido entregue...");
        context.reembolsar();
        context.notificarCliente("Devolu√ß√£o solicitada ap√≥s entrega.");
        context.setState(new CancelledState());
    }

    @Override
    public String getNome() {
        return "ENTREGUE";
    }

    @Override
    public List<String> getAcoesPermitidas() {
        return List.of("cancelar"); // Apenas devolu√ß√£o
    }
}

// State: Cancelado (Final)
final class CancelledState implements PedidoState {

    @Override
    public void aprovar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel aprovar pedido cancelado.");
    }

    @Override
    public void enviar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel enviar pedido cancelado.");
    }

    @Override
    public void entregar(Pedido context) {
        throw new IllegalStateException("N√£o √© poss√≠vel entregar pedido cancelado.");
    }

    @Override
    public void cancelar(Pedido context) {
        System.out.println("‚ö†Ô∏è Pedido j√° est√° cancelado.");
    }

    @Override
    public String getNome() {
        return "CANCELADO";
    }

    @Override
    public List<String> getAcoesPermitidas() {
        return List.of(); // Nenhuma a√ß√£o permitida (estado final)
    }
}
```

### 4. State com M√©tricas

```java
abstract class MetricsState implements PedidoState {
    private static final AtomicInteger transicoes = new AtomicInteger(0);
    private static final Map<String, AtomicInteger> contagemPorEstado = new ConcurrentHashMap<>();

    protected void registrarTransicao(String deEstado, String paraEstado) {
        transicoes.incrementAndGet();
        contagemPorEstado.computeIfAbsent(paraEstado, k -> new AtomicInteger()).incrementAndGet();

        System.out.println("üìä M√©tricas - Total de transi√ß√µes: " + transicoes.get());
    }

    static Map<String, Integer> getMetricas() {
        return contagemPorEstado.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().get()
            ));
    }

    static int getTotalTransicoes() {
        return transicoes.get();
    }
}
```

### 5. State Machine (Valida√ß√£o de Transi√ß√µes)

```java
final class PedidoStateMachine {
    private static final Map<String, Set<String>> TRANSICOES_PERMITIDAS = Map.of(
        "PENDENTE", Set.of("APROVADO", "CANCELADO"),
        "APROVADO", Set.of("ENVIADO", "CANCELADO"),
        "ENVIADO", Set.of("ENTREGUE", "CANCELADO"),
        "ENTREGUE", Set.of("CANCELADO"),
        "CANCELADO", Set.of() // Estado final
    );

    static boolean isTransicaoValida(String estadoAtual, String novoEstado) {
        Set<String> permitidos = TRANSICOES_PERMITIDAS.get(estadoAtual);
        return permitidos != null && permitidos.contains(novoEstado);
    }

    static void validarTransicao(String estadoAtual, String novoEstado) {
        if (!isTransicaoValida(estadoAtual, novoEstado)) {
            throw new IllegalStateException(
                "Transi√ß√£o inv√°lida: " + estadoAtual + " ‚Üí " + novoEstado
            );
        }
    }

    static Set<String> getEstadosPermitidos(String estadoAtual) {
        return TRANSICOES_PERMITIDAS.getOrDefault(estadoAtual, Set.of());
    }

    static String gerarDiagrama() {
        StringBuilder sb = new StringBuilder();
        sb.append("State Machine Diagram:\n");

        TRANSICOES_PERMITIDAS.forEach((de, para) -> {
            para.forEach(p -> {
                sb.append("  ").append(de).append(" ‚Üí ").append(p).append("\n");
            });
        });

        return sb.toString();
    }
}
```

### 6. State Factory

```java
final class PedidoStateFactory {

    static PedidoState criar(String nomeEstado) {
        return switch (nomeEstado.toUpperCase()) {
            case "PENDENTE" -> new PendingState();
            case "APROVADO" -> new ApprovedState();
            case "ENVIADO" -> new ShippedState();
            case "ENTREGUE" -> new DeliveredState();
            case "CANCELADO" -> new CancelledState();
            default -> throw new IllegalArgumentException("Estado desconhecido: " + nomeEstado);
        };
    }

    static List<String> getTodosEstados() {
        return List.of("PENDENTE", "APROVADO", "ENVIADO", "ENTREGUE", "CANCELADO");
    }
}
```

### 7. State com Template Method

```java
abstract class BaseState implements PedidoState {

    @Override
    public final void aprovar(Pedido context) {
        validarTransicao("aprovar");
        executarAprovar(context);
    }

    @Override
    public final void enviar(Pedido context) {
        validarTransicao("enviar");
        executarEnviar(context);
    }

    protected abstract void executarAprovar(Pedido context);
    protected abstract void executarEnviar(Pedido context);

    protected void validarTransicao(String acao) {
        if (!getAcoesPermitidas().contains(acao)) {
            throw new IllegalStateException(
                "A√ß√£o '" + acao + "' n√£o permitida no estado " + getNome()
            );
        }
    }
}
```

---

## üß™ Como Testar

### 1. Testar Transi√ß√£o de Estado

```java
@Test
void deveTransicionarDePendenteParaAprovado() {
    // Arrange
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"));

    // Assert - Estado inicial
    assertEquals("PENDENTE", pedido.getEstadoAtual());

    // Act
    pedido.aprovar();

    // Assert - Novo estado
    assertEquals("APROVADO", pedido.getEstadoAtual());
}
```

### 2. Testar Fluxo Completo

```java
@Test
void devePercorrerFluxoCompletoDeEstados() {
    // Arrange
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"));

    // Act & Assert
    assertEquals("PENDENTE", pedido.getEstadoAtual());

    pedido.aprovar();
    assertEquals("APROVADO", pedido.getEstadoAtual());

    pedido.enviar();
    assertEquals("ENVIADO", pedido.getEstadoAtual());

    pedido.entregar();
    assertEquals("ENTREGUE", pedido.getEstadoAtual());
}
```

### 3. Testar Transi√ß√£o Inv√°lida

```java
@Test
void naoDevePermitirEnviarPedidoPendente() {
    // Arrange
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"));

    // Act & Assert
    IllegalStateException ex = assertThrows(
        IllegalStateException.class,
        () -> pedido.enviar()
    );

    assertTrue(ex.getMessage().contains("Aprove primeiro"));
}
```

### 4. Testar Cancelamento em Diferentes Estados

```java
@Test
void deveCancelarEmQualquerEstadoExcetoFinal() {
    // Pendente ‚Üí Cancelado
    Pedido pedido1 = new Pedido("PED-001", "Cliente", new BigDecimal("100"));
    pedido1.cancelar();
    assertEquals("CANCELADO", pedido1.getEstadoAtual());

    // Aprovado ‚Üí Cancelado
    Pedido pedido2 = new Pedido("PED-002", "Cliente", new BigDecimal("100"));
    pedido2.aprovar();
    pedido2.cancelar();
    assertEquals("CANCELADO", pedido2.getEstadoAtual());

    // Enviado ‚Üí Cancelado
    Pedido pedido3 = new Pedido("PED-003", "Cliente", new BigDecimal("100"));
    pedido3.aprovar();
    pedido3.enviar();
    pedido3.cancelar();
    assertEquals("CANCELADO", pedido3.getEstadoAtual());
}
```

### 5. Testar A√ß√µes Permitidas por Estado

```java
@Test
void deveRetornarAcoesPermitidas() {
    // Arrange
    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"));

    // Pendente permite aprovar e cancelar
    assertTrue(pedido.getAcoesPermitidas().contains("aprovar"));
    assertTrue(pedido.getAcoesPermitidas().contains("cancelar"));

    // Aprovado permite enviar e cancelar
    pedido.aprovar();
    assertTrue(pedido.getAcoesPermitidas().contains("enviar"));
    assertTrue(pedido.getAcoesPermitidas().contains("cancelar"));

    // Cancelado n√£o permite nenhuma a√ß√£o
    pedido.cancelar();
    assertTrue(pedido.getAcoesPermitidas().isEmpty());
}
```

### 6. Testar Hist√≥rico de Transi√ß√µes

```java
@Test
void deveRegistrarHistoricoDeTransicoes() {
    // Arrange
    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"));

    // Act
    pedido.aprovar();
    pedido.enviar();

    List<String> historico = pedido.getHistorico();

    // Assert
    assertTrue(historico.size() >= 3);
    assertTrue(historico.stream().anyMatch(h -> h.contains("criado")));
    assertTrue(historico.stream().anyMatch(h -> h.contains("APROVADO")));
    assertTrue(historico.stream().anyMatch(h -> h.contains("ENVIADO")));
}
```

### 7. Testar State Machine Validation

```java
@Test
void stateMachineDeveValidarTransicoes() {
    // Transi√ß√µes v√°lidas
    assertTrue(PedidoStateMachine.isTransicaoValida("PENDENTE", "APROVADO"));
    assertTrue(PedidoStateMachine.isTransicaoValida("APROVADO", "ENVIADO"));

    // Transi√ß√µes inv√°lidas
    assertFalse(PedidoStateMachine.isTransicaoValida("PENDENTE", "ENVIADO"));
    assertFalse(PedidoStateMachine.isTransicaoValida("CANCELADO", "APROVADO"));

    // Valida√ß√£o deve lan√ßar exce√ß√£o
    assertThrows(
        IllegalStateException.class,
        () -> PedidoStateMachine.validarTransicao("PENDENTE", "ENTREGUE")
    );
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå State com l√≥gica de neg√≥cio pesada
class BadState implements PedidoState {
    public void aprovar(Pedido context) {
        // L√≥gica complexa no state ‚ùå
        BigDecimal desconto = calcularDescontoComplexo(context);
        processarPagamentoComGateway(context, desconto);
        // State deve ser leve!
    }
}

// ‚ùå State compartilhando inst√¢ncias com estado mut√°vel
class StatefulBadState implements PedidoState {
    private int contador = 0; // Estado compartilhado ‚ùå

    public void aprovar(Pedido context) {
        contador++; // Race condition!
    }
}

// ‚ùå Context expondo setState publicamente
class BadPedido {
    public void setState(PedidoState state) { // ‚ùå p√∫blico
        this.state = state;
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ State leve delegando para context
class GoodState implements PedidoState {
    public void aprovar(Pedido context) {
        // State coordena, context executa
        context.processarPagamento();
        context.reservarEstoque();
        context.setState(new ApprovedState());
    }
}

// ‚úÖ States stateless ou imut√°veis
class StatelessGoodState implements PedidoState {
    // Sem estado interno
    public void aprovar(Pedido context) {
        context.setState(new ApprovedState());
    }
}

// ‚úÖ setState protegido
class GoodPedido {
    void setState(PedidoState state) { // package-private
        this.state = state;
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Estados leves**: L√≥gica complexa no context, coordena√ß√£o no state
- ‚úÖ **Stateless**: States sem estado mut√°vel interno
- ‚úÖ **Encapsular transi√ß√µes**: setState package-private ou protected
- ‚úÖ **Valida√ß√£o**: Verificar transi√ß√µes permitidas
- ‚úÖ **Null Object**: Estado inicial sempre definido
- ‚úÖ **Hist√≥rico**: Registrar transi√ß√µes para auditoria
- ‚úÖ **Testes isolados**: Testar cada state independentemente

---

## üîó Integra√ß√£o com Frameworks

### Spring State Machine

```java
@Configuration
@EnableStateMachine
public class PedidoStateMachineConfig
    extends StateMachineConfigurerAdapter<States, Events> {

    @Override
    public void configure(StateMachineStateConfigurer<States, Events> states) {
        states
            .withStates()
            .initial(States.PENDENTE)
            .states(EnumSet.allOf(States.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<States, Events> transitions) {
        transitions
            .withExternal()
            .source(States.PENDENTE).target(States.APROVADO).event(Events.APROVAR)
            .and()
            .withExternal()
            .source(States.APROVADO).target(States.ENVIADO).event(Events.ENVIAR);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                              | ‚ö†Ô∏è Desvantagens                         |
| ----------------------------------------- | --------------------------------------- |
| Elimina condicionais complexas            | Muitas classes (um por estado)          |
| Testa cada estado isoladamente            | Transi√ß√µes distribu√≠das entre states    |
| Adicionar estado sem modificar existentes | Debug pode ser complexo                 |
| L√≥gica de estado encapsulada              | Overhead para poucos estados simples    |
| Transi√ß√µes expl√≠citas e claras            | Pode ser overkill para m√°quinas simples |

---

## üîç Compara√ß√£o

| Padr√£o                      | Prop√≥sito                     | Quando Usar                            |
| --------------------------- | ----------------------------- | -------------------------------------- |
| **State**                   | Comportamento muda com estado | M√∫ltiplos estados com l√≥gica diferente |
| **Strategy**                | Trocar algoritmo              | Diferentes formas de fazer mesma coisa |
| **Command**                 | Encapsular a√ß√£o               | Undo/redo, filas, macros               |
| **Chain of Responsibility** | Encadear handlers             | M√∫ltiplos handlers poss√≠veis           |

---

## üß† Exerc√≠cios Pr√°ticos

1. **State com timeout** (transi√ß√£o autom√°tica ap√≥s tempo)
2. **State com rollback** (desfazer √∫ltima transi√ß√£o)
3. **State hier√°rquico** (substates dentro de states)
4. **State com guard conditions** (valida√ß√µes antes de transi√ß√£o)
5. **State persistente** (salvar/restaurar estado em banco)

---

## üìö Relacionado

- **Strategy**: Encapsula algoritmos intercambi√°veis
- **Template Method**: Define esqueleto de algoritmo
- **Flyweight**: Compartilha states imut√°veis
- **Memento**: Salva/restaura estado

---

**State Pattern elimina condicionais complexas e permite testar cada estado isoladamente!** üîÑ‚ú®
