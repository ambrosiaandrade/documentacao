# 04.38 Gateway Padr√£o de Integra√ß√£o [EXPERT] üîå

## üéØ Objetivo

Dominar o **Gateway Pattern de Integra√ß√£o** para **simplificar intera√ß√µes** com **sistemas externos**, **APIs legadas** e **servi√ßos de terceiros** atrav√©s de uma **camada de abstra√ß√£o** que encapsula complexidade.

---

## üìñ Defini√ß√£o

**Gateway de Integra√ß√£o** √© um padr√£o que fornece uma **interface simplificada** para acessar **sistemas externos complexos**, encapsulando l√≥gica de comunica√ß√£o, transforma√ß√£o de dados e tratamento de erros.

**Analogia:** √â como um **tradutor simult√¢neo** que permite comunica√ß√£o entre pessoas que falam idiomas diferentes, abstraindo a complexidade da tradu√ß√£o.

---

## üé® Problema

Ao integrar com APIs externas:

```java
// Cliente acessa diretamente API externa
PaymentResponse response = externalPaymentApi.createPayment(
    apiKey,
    merchantId,
    complexPaymentRequest
);

// Problemas:
// - Cliente acoplado √† API externa
// - Mudan√ßas na API afetam todos os clientes
// - L√≥gica de retry/timeout espalhada
// - Transforma√ß√£o de dados repetida
// - M√∫ltiplos pontos de falha
```

**Problemas:**

- ‚ùå **Alto acoplamento** com API externa
- ‚ùå **L√≥gica duplicada** (retry, timeout, auth)
- ‚ùå **Mudan√ßas custosas** quando API externa muda
- ‚ùå **Dif√≠cil de testar** (depend√™ncia externa)
- ‚ùå **Sem ponto central** para monitoramento

---

## ‚úÖ Solu√ß√£o

**Gateway de Integra√ß√£o** encapsula acesso ao sistema externo:

```java
// Cliente usa Gateway simplificado
PaymentResult result = paymentGateway.processPayment(order);

// Gateway abstrai complexidade:
// - Autentica√ß√£o
// - Retry logic
// - Transforma√ß√£o de dados
// - Circuit breaker
// - Logging/monitoring
```

**Vantagens:**

- ‚úÖ **Desacoplamento**: Cliente n√£o conhece API externa
- ‚úÖ **Simplifica√ß√£o**: Interface limpa e intuitiva
- ‚úÖ **Centraliza√ß√£o**: L√≥gica de integra√ß√£o em um lugar
- ‚úÖ **Testabilidade**: F√°cil mockar o Gateway
- ‚úÖ **Manutenibilidade**: Mudan√ßas na API afetam s√≥ o Gateway

---

## üèóÔ∏è Implementa√ß√£o: Payment Gateway

### Interface do Gateway

```java
public interface PaymentGateway {

    /**
     * Processa pagamento (interface simplificada)
     */
    PaymentResult processPayment(PaymentRequest request);

    /**
     * Verifica status de pagamento
     */
    PaymentStatus checkPaymentStatus(String transactionId);

    /**
     * Cancela pagamento
     */
    CancellationResult cancelPayment(String transactionId);

    /**
     * Solicita reembolso
     */
    RefundResult refundPayment(String transactionId, BigDecimal amount);
}
```

### DTOs Simplificados (Dom√≠nio da Aplica√ß√£o)

```java
@Data
@AllArgsConstructor
public class PaymentRequest {
    private String orderId;
    private BigDecimal amount;
    private String currency;
    private String customerEmail;
    private CreditCard creditCard;
}

@Data
public class PaymentResult {
    private String transactionId;
    private PaymentStatus status;
    private String message;
    private LocalDateTime processedAt;
}

public enum PaymentStatus {
    APPROVED,
    PENDING,
    DECLINED,
    PROCESSING,
    FAILED
}
```

### Implementa√ß√£o: Stripe Gateway

```java
@Service
@Slf4j
public class StripePaymentGateway implements PaymentGateway {

    private final StripeClient stripeClient;
    private final PaymentTransformer transformer;
    private final CircuitBreaker circuitBreaker;

    public StripePaymentGateway(
        StripeClient stripeClient,
        PaymentTransformer transformer,
        CircuitBreakerRegistry circuitBreakerRegistry
    ) {
        this.stripeClient = stripeClient;
        this.transformer = transformer;
        this.circuitBreaker = circuitBreakerRegistry.circuitBreaker("stripe-payment");
    }

    @Override
    @Retry(name = "stripe-payment")
    @TimeLimiter(name = "stripe-payment")
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment via Stripe: orderId={}, amount={}",
            request.getOrderId(), request.getAmount());

        try {
            // 1. Transformar request do dom√≠nio para Stripe API
            StripeChargeRequest stripeRequest = transformer.toStripeRequest(request);

            // 2. Chamar API Stripe com Circuit Breaker
            StripeChargeResponse stripeResponse = circuitBreaker.executeSupplier(() -> {
                return stripeClient.createCharge(stripeRequest);
            });

            // 3. Transformar response da Stripe para dom√≠nio
            PaymentResult result = transformer.fromStripeResponse(stripeResponse);

            log.info("Payment processed successfully: transactionId={}, status={}",
                result.getTransactionId(), result.getStatus());

            return result;

        } catch (StripeException e) {
            log.error("Stripe API error: {}", e.getMessage(), e);
            return PaymentResult.builder()
                .status(PaymentStatus.FAILED)
                .message("Payment processing failed: " + e.getMessage())
                .processedAt(LocalDateTime.now())
                .build();
        } catch (CallNotPermittedException e) {
            log.error("Circuit breaker open for Stripe");
            return PaymentResult.builder()
                .status(PaymentStatus.FAILED)
                .message("Payment service temporarily unavailable")
                .processedAt(LocalDateTime.now())
                .build();
        }
    }

    @Override
    public PaymentStatus checkPaymentStatus(String transactionId) {
        try {
            StripeCharge charge = stripeClient.retrieveCharge(transactionId);
            return transformer.toPaymentStatus(charge.getStatus());
        } catch (StripeException e) {
            log.error("Error checking payment status: {}", e.getMessage());
            return PaymentStatus.FAILED;
        }
    }

    @Override
    public CancellationResult cancelPayment(String transactionId) {
        try {
            StripeRefund refund = stripeClient.createRefund(transactionId);
            return new CancellationResult(true, refund.getId());
        } catch (StripeException e) {
            log.error("Error canceling payment: {}", e.getMessage());
            return new CancellationResult(false, null);
        }
    }

    @Override
    public RefundResult refundPayment(String transactionId, BigDecimal amount) {
        try {
            StripeRefund refund = stripeClient.createRefund(
                transactionId,
                amount.multiply(BigDecimal.valueOf(100)).intValue()  // Stripe usa centavos
            );

            return RefundResult.builder()
                .refundId(refund.getId())
                .status(RefundStatus.COMPLETED)
                .amount(amount)
                .processedAt(LocalDateTime.now())
                .build();

        } catch (StripeException e) {
            log.error("Error refunding payment: {}", e.getMessage());
            return RefundResult.builder()
                .status(RefundStatus.FAILED)
                .message(e.getMessage())
                .build();
        }
    }
}
```

### Transformer (Tradu√ß√£o de DTOs)

```java
@Component
public class PaymentTransformer {

    /**
     * Converte PaymentRequest (dom√≠nio) para StripeChargeRequest (API externa)
     */
    public StripeChargeRequest toStripeRequest(PaymentRequest request) {
        return StripeChargeRequest.builder()
            .amount(request.getAmount().multiply(BigDecimal.valueOf(100)).intValue())  // Centavos
            .currency(request.getCurrency().toLowerCase())
            .source(toStripeCardToken(request.getCreditCard()))
            .description("Order: " + request.getOrderId())
            .receiptEmail(request.getCustomerEmail())
            .metadata(Map.of("order_id", request.getOrderId()))
            .build();
    }

    /**
     * Converte StripeChargeResponse (API externa) para PaymentResult (dom√≠nio)
     */
    public PaymentResult fromStripeResponse(StripeChargeResponse response) {
        return PaymentResult.builder()
            .transactionId(response.getId())
            .status(toPaymentStatus(response.getStatus()))
            .message(response.getOutcome().getSellerMessage())
            .processedAt(LocalDateTime.ofEpochSecond(response.getCreated(), 0, ZoneOffset.UTC))
            .build();
    }

    public PaymentStatus toPaymentStatus(String stripeStatus) {
        return switch (stripeStatus) {
            case "succeeded" -> PaymentStatus.APPROVED;
            case "pending" -> PaymentStatus.PENDING;
            case "failed" -> PaymentStatus.DECLINED;
            default -> PaymentStatus.FAILED;
        };
    }

    private String toStripeCardToken(CreditCard card) {
        // Usar Stripe.js no frontend para tokenizar cart√£o
        // Aqui apenas para demonstra√ß√£o
        return "tok_" + card.getNumber().substring(card.getNumber().length() - 4);
    }
}
```

---

## üîÑ M√∫ltiplos Gateways (Strategy Pattern)

### Implementa√ß√£o: PayPal Gateway

```java
@Service
@Slf4j
public class PayPalPaymentGateway implements PaymentGateway {

    private final PayPalClient paypalClient;
    private final PaymentTransformer transformer;

    @Override
    @Retry(name = "paypal-payment")
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("Processing payment via PayPal: orderId={}", request.getOrderId());

        try {
            // 1. Criar order no PayPal
            PayPalOrderRequest orderRequest = transformer.toPayPalRequest(request);
            PayPalOrder order = paypalClient.createOrder(orderRequest);

            // 2. Capturar pagamento
            PayPalCapture capture = paypalClient.captureOrder(order.getId());

            // 3. Transformar para dom√≠nio
            return transformer.fromPayPalCapture(capture);

        } catch (PayPalException e) {
            log.error("PayPal API error: {}", e.getMessage());
            return PaymentResult.failed("PayPal error: " + e.getMessage());
        }
    }

    // Implementar outros m√©todos...
}
```

### Gateway Factory (Sele√ß√£o de Gateway)

```java
@Service
public class PaymentGatewayFactory {

    private final Map<PaymentProvider, PaymentGateway> gateways;

    public PaymentGatewayFactory(
        StripePaymentGateway stripeGateway,
        PayPalPaymentGateway paypalGateway
    ) {
        this.gateways = Map.of(
            PaymentProvider.STRIPE, stripeGateway,
            PaymentProvider.PAYPAL, paypalGateway
        );
    }

    public PaymentGateway getGateway(PaymentProvider provider) {
        PaymentGateway gateway = gateways.get(provider);
        if (gateway == null) {
            throw new IllegalArgumentException("Unsupported payment provider: " + provider);
        }
        return gateway;
    }
}
```

### Service Layer

```java
@Service
@Slf4j
public class PaymentService {

    private final PaymentGatewayFactory gatewayFactory;
    private final PaymentRepository paymentRepository;

    public PaymentResult processPayment(Order order, PaymentProvider provider) {
        log.info("Processing payment for order: {}, provider: {}", order.getId(), provider);

        // 1. Selecionar Gateway
        PaymentGateway gateway = gatewayFactory.getGateway(provider);

        // 2. Criar request
        PaymentRequest request = PaymentRequest.builder()
            .orderId(order.getId())
            .amount(order.getTotalAmount())
            .currency("USD")
            .customerEmail(order.getCustomerEmail())
            .creditCard(order.getCreditCard())
            .build();

        // 3. Processar pagamento via Gateway
        PaymentResult result = gateway.processPayment(request);

        // 4. Persistir resultado
        Payment payment = Payment.builder()
            .orderId(order.getId())
            .transactionId(result.getTransactionId())
            .status(result.getStatus())
            .provider(provider)
            .amount(order.getTotalAmount())
            .processedAt(result.getProcessedAt())
            .build();

        paymentRepository.save(payment);

        return result;
    }
}
```

---

## üîê Gateway para Sistema Legado SOAP

### Interface Simplificada

```java
public interface CustomerGateway {

    /**
     * Busca cliente por CPF (interface REST-like)
     */
    Optional<Customer> findByCpf(String cpf);

    /**
     * Atualiza endere√ßo do cliente
     */
    void updateAddress(String customerId, Address address);
}
```

### Implementa√ß√£o SOAP

```java
@Service
@Slf4j
public class LegacyCustomerGateway implements CustomerGateway {

    private final CustomerSoapClient soapClient;
    private final CustomerTransformer transformer;

    @Override
    @Cacheable(value = "customers", key = "#cpf")
    public Optional<Customer> findByCpf(String cpf) {
        log.info("Fetching customer from legacy system: cpf={}", cpf);

        try {
            // 1. Chamar SOAP service
            GetCustomerRequest soapRequest = new GetCustomerRequest();
            soapRequest.setCpf(cpf);

            GetCustomerResponse soapResponse = soapClient.getCustomer(soapRequest);

            // 2. Validar resposta
            if (soapResponse == null || soapResponse.getCustomer() == null) {
                return Optional.empty();
            }

            // 3. Transformar SOAP DTO para dom√≠nio
            Customer customer = transformer.fromSoap(soapResponse.getCustomer());

            return Optional.of(customer);

        } catch (SOAPFaultException e) {
            log.error("SOAP fault: {}", e.getMessage());
            return Optional.empty();
        } catch (Exception e) {
            log.error("Error calling legacy system", e);
            throw new GatewayException("Failed to fetch customer from legacy system", e);
        }
    }

    @Override
    @CacheEvict(value = "customers", key = "#customerId")
    public void updateAddress(String customerId, Address address) {
        log.info("Updating address in legacy system: customerId={}", customerId);

        try {
            UpdateAddressRequest soapRequest = new UpdateAddressRequest();
            soapRequest.setCustomerId(customerId);
            soapRequest.setAddress(transformer.toSoapAddress(address));

            UpdateAddressResponse response = soapClient.updateAddress(soapRequest);

            if (!response.isSuccess()) {
                throw new GatewayException("Failed to update address: " + response.getErrorMessage());
            }

        } catch (Exception e) {
            log.error("Error updating address in legacy system", e);
            throw new GatewayException("Failed to update address", e);
        }
    }
}
```

---

## üß™ Testando Gateway

### Mock do Gateway

```java
@ExtendWith(MockitoExtension.class)
class PaymentServiceTest {

    @Mock
    private PaymentGateway paymentGateway;

    @Mock
    private PaymentRepository paymentRepository;

    @InjectMocks
    private PaymentService paymentService;

    @Test
    @DisplayName("Deve processar pagamento com sucesso via Gateway")
    void deveProcessarPagamentoComSucesso() {
        // Given
        Order order = Order.builder()
            .id("ORDER-123")
            .totalAmount(new BigDecimal("100.00"))
            .customerEmail("joao@mail.com")
            .build();

        PaymentResult expectedResult = PaymentResult.builder()
            .transactionId("TXN-456")
            .status(PaymentStatus.APPROVED)
            .processedAt(LocalDateTime.now())
            .build();

        when(paymentGateway.processPayment(any())).thenReturn(expectedResult);

        // When
        PaymentResult result = paymentService.processPayment(order, PaymentProvider.STRIPE);

        // Then
        assertEquals(PaymentStatus.APPROVED, result.getStatus());
        assertEquals("TXN-456", result.getTransactionId());

        verify(paymentGateway).processPayment(any());
        verify(paymentRepository).save(any());
    }
}
```

### Teste de Integra√ß√£o com WireMock

```java
@SpringBootTest
@AutoConfigureWireMock(port = 8089)
class StripePaymentGatewayIntegrationTest {

    @Autowired
    private StripePaymentGateway gateway;

    @Test
    @DisplayName("Deve processar pagamento via Stripe API mockada")
    void deveProcessarPagamentoViaStripeMockada() {
        // Given - Mock Stripe API
        stubFor(post(urlEqualTo("/v1/charges"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "application/json")
                .withBody("""
                    {
                        "id": "ch_123456",
                        "status": "succeeded",
                        "amount": 10000,
                        "created": 1234567890,
                        "outcome": {
                            "seller_message": "Payment complete"
                        }
                    }
                    """)));

        PaymentRequest request = PaymentRequest.builder()
            .orderId("ORDER-123")
            .amount(new BigDecimal("100.00"))
            .currency("USD")
            .customerEmail("joao@mail.com")
            .build();

        // When
        PaymentResult result = gateway.processPayment(request);

        // Then
        assertEquals(PaymentStatus.APPROVED, result.getStatus());
        assertEquals("ch_123456", result.getTransactionId());

        verify(postRequestedFor(urlEqualTo("/v1/charges")));
    }
}
```

---

## üìã Compara√ß√£o: Gateway vs Adapter vs Facade

| Padr√£o      | Prop√≥sito                            | Escopo          | Transforma√ß√£o      |
| ----------- | ------------------------------------ | --------------- | ------------------ |
| **Gateway** | Simplificar acesso a sistema externo | Sistema externo | Sim (bidirecional) |
| **Adapter** | Adaptar interface incompat√≠vel       | Local           | Sim (interface)    |
| **Facade**  | Simplificar subsistema complexo      | Local           | N√£o necess√°ria     |

**Gateway** = **Adapter** para **sistemas externos** + **l√≥gica de integra√ß√£o** (retry, circuit breaker, caching)

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Interface simplificada
public interface PaymentGateway {
    PaymentResult processPayment(PaymentRequest request);
}

// ‚úÖ Encapsule transforma√ß√£o de dados
PaymentTransformer.toStripeRequest(request)

// ‚úÖ Circuit Breaker para resili√™ncia
@CircuitBreaker(name = "payment-gateway")

// ‚úÖ Retry com backoff
@Retry(name = "payment-gateway", fallbackMethod = "fallbackPayment")

// ‚úÖ Timeout para chamadas externas
@TimeLimiter(name = "payment-gateway")

// ‚úÖ Cache quando apropriado
@Cacheable(value = "customers", key = "#cpf")

// ‚úÖ Logs estruturados
log.info("Processing payment: orderId={}, amount={}", orderId, amount);

// ‚úÖ M√©tricas de integra√ß√£o
meterRegistry.counter("payment.gateway.calls", "provider", "stripe").increment();

// ‚úÖ Testes com mocks/WireMock
@AutoConfigureWireMock
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Expor DTOs da API externa
public StripeChargeResponse processPayment(...)  // ‚ùå

// ‚úÖ Usar DTOs do dom√≠nio
public PaymentResult processPayment(...)

// ‚ùå L√≥gica de neg√≥cio no Gateway
if (amount > 1000) {
    // valida√ß√£o de neg√≥cio  // ‚ùå
}

// ‚úÖ Gateway apenas integra
// L√≥gica de neg√≥cio no Service

// ‚ùå Gateway sem tratamento de erro
throw exception;  // ‚ùå Vaza exce√ß√£o externa

// ‚úÖ Transformar exce√ß√µes
catch (StripeException e) {
    throw new GatewayException("Payment failed", e);
}

// ‚ùå Sem retry/circuit breaker
// Falha tempor√°ria derruba o sistema

// ‚úÖ Resili√™ncia
@Retry @CircuitBreaker @TimeLimiter

// ‚ùå Hardcoded credentials
stripeClient.setApiKey("sk_test_...");  // ‚ùå

// ‚úÖ Configura√ß√£o externa
@Value("${stripe.api.key}")
```

---

## üéØ Quando Usar?

### ‚úÖ Use Gateway de Integra√ß√£o quando:

- Integrar com **APIs externas complexas**
- M√∫ltiplos **pontos de integra√ß√£o** com mesmo sistema
- Precisa **abstrair complexidade** (SOAP, XML, protocolos legados)
- Requer **resili√™ncia** (retry, circuit breaker, timeout)
- **Transforma√ß√£o de dados** entre dom√≠nios diferentes
- Facilitar **testes** (mockar Gateway vs mockar API externa)

### ‚ùå N√£o use quando:

- API externa j√° √© **simples** (REST limpo)
- **√önico ponto** de integra√ß√£o
- **Performance cr√≠tica** (lat√™ncia adicional)
- Overhead de manuten√ß√£o n√£o justifica

---

## üìù Resumo

**Gateway de Integra√ß√£o** fornece:

- ‚úÖ **Abstra√ß√£o**: Interface simplificada para sistema externo
- ‚úÖ **Desacoplamento**: Cliente n√£o conhece API externa
- ‚úÖ **Transforma√ß√£o**: Traduz entre dom√≠nio interno e externo
- ‚úÖ **Resili√™ncia**: Circuit breaker, retry, timeout
- ‚úÖ **Centraliza√ß√£o**: L√≥gica de integra√ß√£o em um lugar
- ‚úÖ **Testabilidade**: F√°cil mockar Gateway
- ‚úÖ **Monitoramento**: M√©tricas e logs centralizados
- ‚úÖ **Manutenibilidade**: Mudan√ßas na API externa isoladas

**Diferen√ßa para Gateway Arquitetural:**

- **Arquitetural**: Ponto de entrada para **m√∫ltiplos microservices** (roteamento, autentica√ß√£o)
- **Integra√ß√£o**: Abstra√ß√£o para **sistema externo** espec√≠fico (Stripe, PayPal, SOAP legado)

**Regra de ouro:** Use **Gateway de Integra√ß√£o** para encapsular **complexidade de APIs externas**, fornecendo interface **simplificada** e **resiliente** para o dom√≠nio da aplica√ß√£o.

---

**√öltima Atualiza√ß√£o:** 2025-11-15  
**N√≠vel:** EXPERT  
**Tempo Estimado:** 40 minutos
