# 04.9 Publisher/Subscriber Pattern [M√âDIO] üì¢

## üéØ Objetivo

Desacoplar **produtores (publishers)** de **consumidores (subscribers)** atrav√©s de um canal de eventos, permitindo que m√∫ltiplos componentes reajam ao mesmo evento **sem conhecimento m√∫tuo**.

---

## üìö O Que √â?

**Publisher/Subscriber (Pub/Sub)** √© um padr√£o de mensageria onde publishers enviam eventos para um canal/t√≥pico sem conhecer quem ir√° consumi-los, e subscribers se inscrevem nesses canais para receber os eventos de interesse.

### Analogia

Como um **jornal**: o editor (publisher) publica not√≠cias sem saber quem vai ler. Os leitores (subscribers) assinam o jornal e recebem todas as edi√ß√µes. Novos leitores podem assinar sem que o editor precise mudar nada.

### Diferen√ßa Fundamental

- **Chamada direta**: `emailService.enviar()` ‚Üí `auditoriaService.registrar()` (acoplamento)
- **Pub/Sub**: `eventBus.publish(UsuarioCriado)` ‚Üí M√∫ltiplos subscribers reagem independentemente

---

## ‚ùå Problema que Resolve

### Antes (Acoplamento Direto)

```java
// ‚ùå PROBLEMA: Acoplamento forte, dif√≠cil extens√£o
public class UsuarioService {
    private final EmailService emailService;
    private final AuditoriaService auditoriaService;
    private final NotificacaoService notificacaoService;
    private final AnalyticsService analyticsService;

    public void criar(Usuario usuario) {
        repository.save(usuario);

        // Acoplamento direto com todos os servi√ßos
        emailService.enviarBoasVindas(usuario);
        auditoriaService.registrar("Usuario criado: " + usuario.getId());
        notificacaoService.enviarPush(usuario);
        analyticsService.track("user_created", usuario.getId());

        // Adicionar novo servi√ßo = modificar aqui!
    }
}
```

**Problemas**:

- üîó Alto acoplamento (UsuarioService conhece 4+ servi√ßos)
- üêå Opera√ß√£o s√≠ncrona (espera todos os servi√ßos)
- üîß Dif√≠cil extens√£o (novo servi√ßo = modificar c√≥digo)
- üß™ Testes dif√≠ceis (precisa mockar todos)

### Depois (Publisher/Subscriber)

```java
// ‚úÖ SOLU√á√ÉO: Desacoplamento via eventos
public class UsuarioService {
    private final EventBus eventBus;

    public void criar(Usuario usuario) {
        repository.save(usuario);

        // Publica evento - n√£o sabe quem consome
        eventBus.publish(new UsuarioCriadoEvent(
            usuario.getId(),
            usuario.getEmail(),
            Instant.now()
        ));
    }
}

// Subscribers se inscrevem independentemente
@Component
public class EmailSubscriber implements EventSubscriber {
    public void onEvent(UsuarioCriadoEvent event) {
        emailService.enviarBoasVindas(event.email());
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Definir Hierarquia de Eventos

```java
// Eventos imut√°veis com sealed interface
sealed interface DomainEvent permits
    UsuarioCriadoEvent,
    UsuarioBloqueadoEvent,
    EmailAlteradoEvent {

    Instant timestamp();
}

record UsuarioCriadoEvent(
    String usuarioId,
    String email,
    String nome,
    Instant timestamp
) implements DomainEvent {}

record UsuarioBloqueadoEvent(
    String usuarioId,
    String motivo,
    Instant timestamp
) implements DomainEvent {}

record EmailAlteradoEvent(
    String usuarioId,
    String emailAntigo,
    String emailNovo,
    Instant timestamp
) implements DomainEvent {}
```

### 2. Event Bus Thread-Safe

```java
@FunctionalInterface
interface EventSubscriber<T extends DomainEvent> {
    void onEvent(T event);
}

final class InMemoryEventBus {
    private final Map<Class<? extends DomainEvent>, List<EventSubscriber<?>>>
        subscribers = new ConcurrentHashMap<>();

    public <T extends DomainEvent> void subscribe(
        Class<T> eventType,
        EventSubscriber<T> subscriber
    ) {
        subscribers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                   .add(subscriber);
    }

    public void publish(DomainEvent event) {
        List<EventSubscriber<?>> subs = subscribers.get(event.getClass());
        if (subs != null) {
            subs.forEach(sub -> {
                try {
                    @SuppressWarnings("unchecked")
                    EventSubscriber<DomainEvent> typedSub =
                        (EventSubscriber<DomainEvent>) sub;
                    typedSub.onEvent(event);
                } catch (Exception e) {
                    System.err.println("Erro ao notificar subscriber: " + e.getMessage());
                    // Em produ√ß√£o: enviar para DLQ, alertar, etc
                }
            });
        }
    }

    public int countSubscribers(Class<? extends DomainEvent> eventType) {
        List<EventSubscriber<?>> subs = subscribers.get(eventType);
        return subs != null ? subs.size() : 0;
    }
}
```

### 3. Implementa√ß√£o com Executor Ass√≠ncrono

```java
final class AsyncEventBus {
    private final Map<Class<? extends DomainEvent>, List<EventSubscriber<?>>>
        subscribers = new ConcurrentHashMap<>();
    private final ExecutorService executor;

    public AsyncEventBus(int threads) {
        this.executor = Executors.newFixedThreadPool(threads);
    }

    public <T extends DomainEvent> void subscribe(
        Class<T> eventType,
        EventSubscriber<T> subscriber
    ) {
        subscribers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                   .add(subscriber);
    }

    public CompletableFuture<Void> publishAsync(DomainEvent event) {
        List<EventSubscriber<?>> subs = subscribers.get(event.getClass());
        if (subs == null || subs.isEmpty()) {
            return CompletableFuture.completedFuture(null);
        }

        List<CompletableFuture<Void>> futures = subs.stream()
            .map(sub -> CompletableFuture.runAsync(() -> {
                @SuppressWarnings("unchecked")
                EventSubscriber<DomainEvent> typedSub =
                    (EventSubscriber<DomainEvent>) sub;
                typedSub.onEvent(event);
            }, executor))
            .toList();

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
    }

    public void shutdown() {
        executor.shutdown();
    }
}
```

### 4. Publishers (Servi√ßos de Dom√≠nio)

```java
final class UsuarioService {
    private final UsuarioRepository repository;
    private final InMemoryEventBus eventBus;

    public UsuarioService(UsuarioRepository repo, InMemoryEventBus bus) {
        this.repository = repo;
        this.eventBus = bus;
    }

    public void criar(String id, String email, String nome) {
        Usuario usuario = new Usuario(id, email, nome);
        repository.save(usuario);

        // Publicar evento ap√≥s persist√™ncia
        eventBus.publish(new UsuarioCriadoEvent(
            id, email, nome, Instant.now()
        ));
    }

    public void bloquear(String id, String motivo) {
        Usuario usuario = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Usu√°rio n√£o encontrado"));

        usuario.bloquear();
        repository.save(usuario);

        eventBus.publish(new UsuarioBloqueadoEvent(
            id, motivo, Instant.now()
        ));
    }
}
```

### 5. Subscribers Especializados

```java
// Subscriber para envio de emails
final class EmailSubscriber implements EventSubscriber<UsuarioCriadoEvent> {
    private final EmailService emailService;

    public EmailSubscriber(EmailService emailService) {
        this.emailService = emailService;
    }

    @Override
    public void onEvent(UsuarioCriadoEvent event) {
        System.out.println("üìß Enviando email de boas-vindas para: " + event.email());
        emailService.enviarBoasVindas(event.email(), event.nome());
    }
}

// Subscriber para auditoria
final class AuditoriaSubscriber implements EventSubscriber<DomainEvent> {
    private final AuditoriaRepository auditoriaRepo;

    public AuditoriaSubscriber(AuditoriaRepository repo) {
        this.auditoriaRepo = repo;
    }

    @Override
    public void onEvent(DomainEvent event) {
        String logMsg = switch (event) {
            case UsuarioCriadoEvent e ->
                "Usuario criado: " + e.usuarioId() + " (" + e.email() + ")";
            case UsuarioBloqueadoEvent e ->
                "Usuario bloqueado: " + e.usuarioId() + " - Motivo: " + e.motivo();
            case EmailAlteradoEvent e ->
                "Email alterado: " + e.usuarioId() + " (" + e.emailAntigo() + " ‚Üí " + e.emailNovo() + ")";
        };

        auditoriaRepo.salvar(new AuditoriaLog(logMsg, event.timestamp()));
    }
}

// Subscriber para analytics
final class AnalyticsSubscriber implements EventSubscriber<UsuarioCriadoEvent> {
    private final AnalyticsService analytics;

    public AnalyticsSubscriber(AnalyticsService analytics) {
        this.analytics = analytics;
    }

    @Override
    public void onEvent(UsuarioCriadoEvent event) {
        System.out.println("üìä Tracking analytics: user_created");
        analytics.track("user_created", Map.of(
            "user_id", event.usuarioId(),
            "email_domain", event.email().split("@")[1],
            "timestamp", event.timestamp().toString()
        ));
    }
}
```

### 6. Configura√ß√£o e Wiring

```java
public class Application {
    public static void main(String[] args) {
        // Setup
        InMemoryEventBus eventBus = new InMemoryEventBus();

        // Registrar subscribers
        eventBus.subscribe(UsuarioCriadoEvent.class,
            new EmailSubscriber(new EmailService()));
        eventBus.subscribe(UsuarioCriadoEvent.class,
            new AnalyticsSubscriber(new AnalyticsService()));
        eventBus.subscribe(DomainEvent.class,
            new AuditoriaSubscriber(new AuditoriaRepository()));

        // Usar servi√ßo
        UsuarioService service = new UsuarioService(
            new UsuarioRepository(),
            eventBus
        );

        service.criar("user1", "joao@test.com", "Jo√£o Silva");
        // Automaticamente dispara: Email, Analytics, Auditoria
    }
}
```

---

## üß™ Como Testar

### 1. Testar Notifica√ß√£o de Subscriber

```java
@Test
void deveNotificarSubscriberQuandoEventoPublicado() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();
    List<UsuarioCriadoEvent> eventosRecebidos = new CopyOnWriteArrayList<>();

    bus.subscribe(UsuarioCriadoEvent.class, eventosRecebidos::add);

    // Act
    bus.publish(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));

    // Assert
    assertEquals(1, eventosRecebidos.size());
    assertEquals("user1", eventosRecebidos.get(0).usuarioId());
}
```

### 2. Testar M√∫ltiplos Subscribers

```java
@Test
void deveNotificarTodosSubscribers() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();

    AtomicInteger contador1 = new AtomicInteger(0);
    AtomicInteger contador2 = new AtomicInteger(0);

    bus.subscribe(UsuarioCriadoEvent.class, e -> contador1.incrementAndGet());
    bus.subscribe(UsuarioCriadoEvent.class, e -> contador2.incrementAndGet());

    // Act
    bus.publish(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));

    // Assert
    assertEquals(1, contador1.get());
    assertEquals(1, contador2.get());
}
```

### 3. Testar Isolamento de Falhas

```java
@Test
void falhaEmUmSubscriberNaoDeveAfetarOutros() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();

    List<UsuarioCriadoEvent> sucessos = new CopyOnWriteArrayList<>();

    bus.subscribe(UsuarioCriadoEvent.class, e -> {
        throw new RuntimeException("Falha proposital");
    });
    bus.subscribe(UsuarioCriadoEvent.class, sucessos::add);

    // Act
    bus.publish(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));

    // Assert - segundo subscriber recebeu apesar da falha do primeiro
    assertEquals(1, sucessos.size());
}
```

### 4. Testar Filtragem por Tipo de Evento

```java
@Test
void deveReceberApenasEventosDoTipoInscrito() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();

    List<DomainEvent> recebidos = new CopyOnWriteArrayList<>();

    bus.subscribe(UsuarioCriadoEvent.class, recebidos::add);

    // Act - publicar eventos de tipos diferentes
    bus.publish(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));
    bus.publish(new UsuarioBloqueadoEvent("user2", "Suspeito", Instant.now()));

    // Assert - s√≥ recebeu UsuarioCriadoEvent
    assertEquals(1, recebidos.size());
    assertInstanceOf(UsuarioCriadoEvent.class, recebidos.get(0));
}
```

### 5. Testar Publica√ß√£o Ass√≠ncrona

```java
@Test
void devePublicarAssincronamente() throws Exception {
    // Arrange
    AsyncEventBus bus = new AsyncEventBus(2);
    CountDownLatch latch = new CountDownLatch(2);

    bus.subscribe(UsuarioCriadoEvent.class, e -> {
        try {
            Thread.sleep(100); // Simula processamento
            latch.countDown();
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    });

    bus.subscribe(UsuarioCriadoEvent.class, e -> {
        try {
            Thread.sleep(100);
            latch.countDown();
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    });

    // Act
    long inicio = System.currentTimeMillis();
    bus.publishAsync(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));

    boolean completed = latch.await(500, TimeUnit.MILLISECONDS);
    long duracao = System.currentTimeMillis() - inicio;

    // Assert - executou em paralelo (n√£o levou 200ms)
    assertTrue(completed);
    assertTrue(duracao < 200, "Deve executar em paralelo: " + duracao + "ms");

    bus.shutdown();
}
```

### 6. Testar com Mock de Subscriber

```java
@Test
void deveInvocarMetodoDoSubscriber() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();
    EmailService emailService = mock(EmailService.class);

    bus.subscribe(UsuarioCriadoEvent.class,
        new EmailSubscriber(emailService));

    // Act
    bus.publish(new UsuarioCriadoEvent("user1", "joao@test.com", "Jo√£o", Instant.now()));

    // Assert
    verify(emailService).enviarBoasVindas("joao@test.com", "Jo√£o");
}
```

### 7. Testar Ordem de Notifica√ß√£o (N√£o Garantida)

```java
@Test
void ordemDeNotificacaoNaoDeveSerGarantida() {
    // Arrange
    InMemoryEventBus bus = new InMemoryEventBus();
    List<String> ordem = new CopyOnWriteArrayList<>();

    bus.subscribe(UsuarioCriadoEvent.class, e -> ordem.add("A"));
    bus.subscribe(UsuarioCriadoEvent.class, e -> ordem.add("B"));
    bus.subscribe(UsuarioCriadoEvent.class, e -> ordem.add("C"));

    // Act
    bus.publish(new UsuarioCriadoEvent("user1", "test@mail.com", "Test", Instant.now()));

    // Assert - todos receberam, mas ordem pode variar
    assertEquals(3, ordem.size());
    assertTrue(ordem.contains("A"));
    assertTrue(ordem.contains("B"));
    assertTrue(ordem.contains("C"));
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Eventos mut√°veis
class UsuarioCriadoEvent {
    private String email; // Permite setEmail() - NUNCA!
}

// ‚ùå L√≥gica pesada no subscriber
bus.subscribe(UsuarioCriadoEvent.class, e -> {
    Thread.sleep(5000); // Bloqueia outros subscribers!
});

// ‚ùå Subscriber alterando estado compartilhado sem sincroniza√ß√£o
static int contador = 0; // Race condition!
bus.subscribe(event -> contador++);
```

### ‚úÖ Fazer

```java
// ‚úÖ Eventos imut√°veis (records)
record UsuarioCriadoEvent(String usuarioId, String email, Instant timestamp)
    implements DomainEvent {}

// ‚úÖ Subscriber ass√≠ncrono para l√≥gica pesada
asyncEventBus.publishAsync(event);

// ‚úÖ Estado thread-safe
AtomicInteger contador = new AtomicInteger(0);
bus.subscribe(event -> contador.incrementAndGet());
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Eventos imut√°veis**: Use records para garantir imutabilidade
- ‚úÖ **Isolamento de falhas**: Falha em um subscriber n√£o afeta outros
- ‚úÖ **Async para I/O**: Subscribers com I/O (DB, HTTP) devem ser ass√≠ncronos
- ‚úÖ **Idempot√™ncia**: Subscribers devem tolerar recebimento duplicado
- ‚úÖ **Dead Letter Queue**: Eventos com falha persistente v√£o para DLQ
- ‚úÖ **Monitoramento**: Rastrear lat√™ncia e falhas de subscribers
- ‚úÖ **Tipo espec√≠fico**: Subscriber se inscreve no tipo exato necess√°rio

---

## üîó Integra√ß√£o com Frameworks

### Spring ApplicationEventPublisher

```java
@Service
public class UsuarioService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void criar(Usuario usuario) {
        repository.save(usuario);
        eventPublisher.publishEvent(new UsuarioCriadoEvent(usuario.getId()));
    }
}

@Component
public class EmailListener {
    @EventListener
    public void handleUsuarioCriado(UsuarioCriadoEvent event) {
        // Enviar email
    }
}
```

### Guava EventBus

```java
EventBus eventBus = new EventBus();

eventBus.register(new Object() {
    @Subscribe
    public void handleUsuarioCriado(UsuarioCriadoEvent event) {
        // Processar evento
    }
});

eventBus.post(new UsuarioCriadoEvent("user1", "test@mail.com"));
```

### Apache Kafka (Distribu√≠do)

```java
@KafkaListener(topics = "usuario.criado")
public void handleUsuarioCriado(UsuarioCriadoEvent event) {
    // Processar evento de t√≥pico Kafka
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                                               | ‚ö†Ô∏è Desvantagens                         |
| ---------------------------------------------------------- | --------------------------------------- |
| Baixo acoplamento (publisher n√£o conhece subscribers)      | Ordem de entrega n√£o garantida          |
| F√°cil extens√£o (adicionar subscriber sem modificar c√≥digo) | Debugging dif√≠cil (fluxo indireto)      |
| Escalabilidade horizontal (m√∫ltiplos consumers)            | Sem resposta s√≠ncrona (fire-and-forget) |
| Paraleliza√ß√£o natural                                      | Risco de event storm sem controle       |
| Testabilidade (subscribers isolados)                       | Complexidade em falhas (retry, DLQ)     |

---

## üîç Compara√ß√£o com Outras Abordagens

| Aspecto              | Pub/Sub               | Observer           | Message Queue  | Event Sourcing |
| -------------------- | --------------------- | ------------------ | -------------- | -------------- |
| **Distribui√ß√£o**     | Local ou distribu√≠da  | Local (in-process) | Distribu√≠da    | Distribu√≠da    |
| **Garantia entrega** | Depende implementa√ß√£o | Imediata           | Garantida      | Garantida      |
| **Ordem**            | N√£o garantida         | Garantida          | Depende config | Por stream     |
| **Persist√™ncia**     | Opcional              | N√£o                | Sim            | Sim (imut√°vel) |
| **Complexidade**     | M√©dia                 | Baixa              | Alta           | Muito Alta     |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar retry** em subscriber que falha temporariamente
2. **Criar filtro de eventos** (subscriber s√≥ recebe eventos com condi√ß√£o espec√≠fica)
3. **Adicionar DLQ** para eventos com falhas persistentes
4. **Implementar prioriza√ß√£o** de eventos (cr√≠tico vs normal)
5. **Testar backpressure** quando subscribers est√£o lentos

---

## üìö Relacionado

- **Dead Letter Queue**: Destino para eventos com falha persistente
- **Saga Pattern**: Orquestra√ß√£o via eventos pub/sub
- **Event Sourcing**: Eventos como fonte de verdade
- **CQRS**: Eventos sincronizam write e read models

---

**Publisher/Subscriber desacopla componentes atrav√©s de eventos, permitindo extens√£o f√°cil mas exigindo disciplina em tratamento de falhas!** üì¢‚ú®
