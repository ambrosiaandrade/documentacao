# 04.12 Cache Aside (Lazy Loading) [M√âDIO] üíæ

## üéØ Objetivo

Reduzir **lat√™ncia de leituras** e **carga no banco de dados** atrav√©s de um cache controlado pela aplica√ß√£o, onde os dados s√£o carregados sob demanda (lazy) e armazenados para reutiliza√ß√£o.

---

## üìö O Que √â?

**Cache Aside** (tamb√©m conhecido como **Lazy Loading**) √© um padr√£o onde a aplica√ß√£o gerencia explicitamente o cache: verifica se o dado est√° em cache, se n√£o estiver, busca da fonte prim√°ria (banco de dados) e popula o cache para futuras consultas.

### Analogia

Como uma **agenda telef√¥nica pessoal**: quando voc√™ precisa de um n√∫mero, primeiro verifica sua agenda (cache). Se n√£o encontrar, procura na lista telef√¥nica geral (banco de dados), anota na sua agenda (popula cache) e usa. Da pr√≥xima vez, j√° est√° anotado e √© muito mais r√°pido.

### Fluxo B√°sico

1. **READ**: Verifica cache ‚Üí Se HIT: retorna / Se MISS: busca DB ‚Üí popula cache ‚Üí retorna
2. **WRITE**: Atualiza DB ‚Üí Invalida cache (ou atualiza)

---

## ‚ùå Problema que Resolve

### Antes (Sem Cache)

```java
// ‚ùå PROBLEMA: Cada leitura bate no banco
@Service
public class PerfilService {
    private final PerfilRepository repository;

    public Perfil buscar(String userId) {
        // SEMPRE vai ao banco - lat√™ncia alta
        return repository.findById(userId)
            .orElseThrow(() -> new NotFoundException("Usu√°rio n√£o encontrado"));
    }
}

// M√©tricas:
// - Lat√™ncia p95: 250ms
// - DB Queries/s: 5000
// - CPU DB: 85%
```

**Problemas**:

- üêå Lat√™ncia alta (250ms por consulta)
- üí∏ Custo elevado de DB (RDS, queries)
- üî• Gargalo no banco (CPU 85%)
- üìä Escalabilidade limitada

### Depois (Cache Aside)

```java
// ‚úÖ SOLU√á√ÉO: Cache gerenciado pela aplica√ß√£o
@Service
public class PerfilService {
    private final PerfilRepository repository;
    private final CacheManager cacheManager;

    public Perfil buscar(String userId) {
        // 1. Verifica cache
        Perfil cached = cacheManager.get("perfil:" + userId);
        if (cached != null) {
            return cached; // Cache HIT - 2ms
        }

        // 2. Cache MISS - busca do banco
        Perfil perfil = repository.findById(userId)
            .orElseThrow(() -> new NotFoundException("Usu√°rio n√£o encontrado"));

        // 3. Popula cache
        cacheManager.put("perfil:" + userId, perfil, Duration.ofMinutes(15));

        return perfil;
    }
}

// M√©tricas:
// - Lat√™ncia p95: 5ms (95% cache hit)
// - DB Queries/s: 250 (redu√ß√£o de 95%)
// - CPU DB: 15%
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface de Cache

```java
interface Cache<K, V> {
    Optional<V> get(K key);
    void put(K key, V value);
    void put(K key, V value, Duration ttl);
    void evict(K key);
    void clear();
    boolean contains(K key);
    int size();
}

final class InMemoryCache<K, V> implements Cache<K, V> {
    private final Map<K, CacheEntry<V>> store = new ConcurrentHashMap<>();

    record CacheEntry<V>(V value, Instant expiration) {
        boolean isExpired() {
            return Instant.now().isAfter(expiration);
        }
    }

    @Override
    public Optional<V> get(K key) {
        CacheEntry<V> entry = store.get(key);

        if (entry == null) {
            return Optional.empty();
        }

        if (entry.isExpired()) {
            store.remove(key);
            return Optional.empty();
        }

        return Optional.of(entry.value());
    }

    @Override
    public void put(K key, V value) {
        put(key, value, Duration.ofHours(1)); // Default TTL
    }

    @Override
    public void put(K key, V value, Duration ttl) {
        Instant expiration = Instant.now().plus(ttl);
        store.put(key, new CacheEntry<>(value, expiration));
    }

    @Override
    public void evict(K key) {
        store.remove(key);
    }

    @Override
    public void clear() {
        store.clear();
    }

    @Override
    public boolean contains(K key) {
        return get(key).isPresent();
    }

    @Override
    public int size() {
        // Remove expirados antes de contar
        store.entrySet().removeIf(e -> e.getValue().isExpired());
        return store.size();
    }
}
```

### 2. Modelo de Dom√≠nio

```java
record Perfil(
    String id,
    String nome,
    String email,
    String telefone,
    LocalDate dataNascimento
) {}

interface PerfilRepository {
    Optional<Perfil> findById(String id);
    void save(Perfil perfil);
    void deleteById(String id);
}

// Simula√ß√£o de reposit√≥rio
final class PerfilRepositoryImpl implements PerfilRepository {
    private final Map<String, Perfil> database = new ConcurrentHashMap<>();
    private final AtomicInteger queriesCount = new AtomicInteger(0);

    @Override
    public Optional<Perfil> findById(String id) {
        queriesCount.incrementAndGet();

        // Simula lat√™ncia de banco
        try {
            Thread.sleep(50);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        return Optional.ofNullable(database.get(id));
    }

    @Override
    public void save(Perfil perfil) {
        queriesCount.incrementAndGet();
        database.put(perfil.id(), perfil);
    }

    @Override
    public void deleteById(String id) {
        queriesCount.incrementAndGet();
        database.remove(id);
    }

    public int getQueriesCount() {
        return queriesCount.get();
    }

    public void resetQueriesCount() {
        queriesCount.set(0);
    }
}
```

### 3. Service com Cache Aside

```java
final class PerfilService {
    private final PerfilRepository repository;
    private final Cache<String, Perfil> cache;
    private final Duration cacheTTL;

    // M√©tricas
    private final AtomicInteger cacheHits = new AtomicInteger(0);
    private final AtomicInteger cacheMisses = new AtomicInteger(0);

    PerfilService(PerfilRepository repository, Cache<String, Perfil> cache, Duration ttl) {
        this.repository = repository;
        this.cache = cache;
        this.cacheTTL = ttl;
    }

    public Perfil buscar(String id) {
        // 1. Tentativa de busca no cache
        Optional<Perfil> cached = cache.get(id);

        if (cached.isPresent()) {
            cacheHits.incrementAndGet();
            System.out.println("‚úÖ Cache HIT: " + id);
            return cached.get();
        }

        // 2. Cache MISS - buscar do reposit√≥rio
        cacheMisses.incrementAndGet();
        System.out.println("‚ùå Cache MISS: " + id);

        Perfil perfil = repository.findById(id)
            .orElseThrow(() -> new IllegalArgumentException("Perfil n√£o encontrado: " + id));

        // 3. Popular cache para pr√≥ximas consultas
        cache.put(id, perfil, cacheTTL);

        return perfil;
    }

    public void atualizar(Perfil perfil) {
        // 1. Atualizar no banco
        repository.save(perfil);

        // 2. Invalidar cache (Cache Aside t√≠pico)
        // Alternativa: atualizar cache diretamente
        cache.evict(perfil.id());

        System.out.println("üîÑ Cache invalidado: " + perfil.id());
    }

    public void deletar(String id) {
        repository.deleteById(id);
        cache.evict(id);

        System.out.println("üóë Perfil deletado e cache invalidado: " + id);
    }

    // Estrat√©gia alternativa: Write-Through (atualizar cache)
    public void atualizarComWriteThrough(Perfil perfil) {
        repository.save(perfil);
        cache.put(perfil.id(), perfil, cacheTTL);

        System.out.println("üìù Cache atualizado: " + perfil.id());
    }

    public CacheMetrics getMetrics() {
        int total = cacheHits.get() + cacheMisses.get();
        double hitRate = total > 0 ? (cacheHits.get() * 100.0) / total : 0;

        return new CacheMetrics(
            cacheHits.get(),
            cacheMisses.get(),
            hitRate,
            cache.size()
        );
    }

    public void resetMetrics() {
        cacheHits.set(0);
        cacheMisses.set(0);
    }
}

record CacheMetrics(
    int hits,
    int misses,
    double hitRate,
    int cacheSize
) {
    @Override
    public String toString() {
        return String.format(
            "Cache Metrics: Hits=%d, Misses=%d, HitRate=%.2f%%, Size=%d",
            hits, misses, hitRate, cacheSize
        );
    }
}
```

### 4. Exemplo de Uso

```java
public class Application {
    public static void main(String[] args) {
        // Setup
        PerfilRepository repository = new PerfilRepositoryImpl();
        Cache<String, Perfil> cache = new InMemoryCache<>();
        PerfilService service = new PerfilService(
            repository,
            cache,
            Duration.ofMinutes(5)
        );

        // Dados de teste
        Perfil joao = new Perfil(
            "user1",
            "Jo√£o Silva",
            "joao@test.com",
            "11999999999",
            LocalDate.of(1990, 5, 15)
        );
        repository.save(joao);

        // Primeira busca - Cache MISS
        Perfil p1 = service.buscar("user1"); // Vai ao banco

        // Segunda busca - Cache HIT
        Perfil p2 = service.buscar("user1"); // Retorna do cache

        // Atualiza√ß√£o - Invalida cache
        Perfil joaoAtualizado = new Perfil(
            "user1",
            "Jo√£o Pedro Silva",
            "joao.pedro@test.com",
            "11988888888",
            LocalDate.of(1990, 5, 15)
        );
        service.atualizar(joaoAtualizado);

        // Pr√≥xima busca - Cache MISS novamente
        Perfil p3 = service.buscar("user1"); // Vai ao banco

        // M√©tricas
        System.out.println(service.getMetrics());
        // Output: Cache Metrics: Hits=1, Misses=2, HitRate=33.33%, Size=1
    }
}
```

---

## üß™ Como Testar

### 1. Testar Cache HIT

```java
@Test
void deveBuscarDoCacheAposPopular() {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfil = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    when(repo.findById("user1")).thenReturn(Optional.of(perfil));

    // Act - primeira busca (cache miss)
    service.buscar("user1");

    // Segunda busca (cache hit)
    Perfil resultado = service.buscar("user1");

    // Assert
    assertEquals("Ana", resultado.nome());
    verify(repo, times(1)).findById("user1"); // S√≥ 1 chamada ao repo

    CacheMetrics metrics = service.getMetrics();
    assertEquals(1, metrics.hits());
    assertEquals(1, metrics.misses());
    assertEquals(50.0, metrics.hitRate(), 0.01);
}
```

### 2. Testar Cache MISS

```java
@Test
void deveBuscarDoRepositorioEmCacheMiss() {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfil = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    when(repo.findById("user1")).thenReturn(Optional.of(perfil));

    // Act
    Perfil resultado = service.buscar("user1");

    // Assert
    assertEquals("Ana", resultado.nome());
    verify(repo).findById("user1");
    assertTrue(cache.contains("user1")); // Cache foi populado

    CacheMetrics metrics = service.getMetrics();
    assertEquals(0, metrics.hits());
    assertEquals(1, metrics.misses());
}
```

### 3. Testar Invalida√ß√£o de Cache

```java
@Test
void deveInvalidarCacheAposAtualizacao() {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfilOriginal = new Perfil("user1", "Ana", "ana@test.com",
        "11999999999", LocalDate.of(1995, 3, 10));
    Perfil perfilAtualizado = new Perfil("user1", "Ana Silva", "ana.silva@test.com",
        "11988888888", LocalDate.of(1995, 3, 10));

    when(repo.findById("user1"))
        .thenReturn(Optional.of(perfilOriginal))
        .thenReturn(Optional.of(perfilAtualizado));

    // Act
    service.buscar("user1"); // Popula cache
    assertTrue(cache.contains("user1"));

    service.atualizar(perfilAtualizado); // Invalida cache

    // Assert
    assertFalse(cache.contains("user1")); // Cache foi invalidado

    Perfil recarregado = service.buscar("user1"); // Busca do repo novamente
    assertEquals("Ana Silva", recarregado.nome());
    verify(repo, times(2)).findById("user1");
}
```

### 4. Testar Expira√ß√£o de Cache (TTL)

```java
@Test
void deveBuscarDoRepositorioAposExpiracao() throws InterruptedException {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    Duration ttl = Duration.ofMillis(100); // TTL curto para teste
    PerfilService service = new PerfilService(repo, cache, ttl);

    Perfil perfil = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    when(repo.findById("user1")).thenReturn(Optional.of(perfil));

    // Act
    service.buscar("user1"); // Popula cache
    assertEquals(1, cache.size());

    Thread.sleep(150); // Aguarda expira√ß√£o

    service.buscar("user1"); // Cache expirado - busca do repo

    // Assert
    verify(repo, times(2)).findById("user1"); // 2 chamadas (inicial + p√≥s-expira√ß√£o)

    CacheMetrics metrics = service.getMetrics();
    assertEquals(0, metrics.hits());
    assertEquals(2, metrics.misses());
}
```

### 5. Testar Performance (Cache vs Sem Cache)

```java
@Test
void cacheDeverMelhorarPerformance() {
    // Arrange
    PerfilRepositoryImpl repo = new PerfilRepositoryImpl();
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfil = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    repo.save(perfil);

    // Act - primeira busca sem cache
    long inicio1 = System.currentTimeMillis();
    service.buscar("user1");
    long duracao1 = System.currentTimeMillis() - inicio1;

    // Segunda busca com cache
    long inicio2 = System.currentTimeMillis();
    service.buscar("user1");
    long duracao2 = System.currentTimeMillis() - inicio2;

    // Assert
    assertTrue(duracao2 < duracao1,
        String.format("Cache deveria ser mais r√°pido: sem cache=%dms, com cache=%dms",
            duracao1, duracao2));

    // Cache HIT deve ser pelo menos 10x mais r√°pido
    assertTrue(duracao1 / duracao2 >= 10);
}
```

### 6. Testar Concorr√™ncia (Thread Safety)

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfil = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    when(repo.findById("user1")).thenReturn(Optional.of(perfil));

    int threads = 10;
    CountDownLatch latch = new CountDownLatch(threads);

    // Act - 10 threads buscando simultaneamente
    for (int i = 0; i < threads; i++) {
        new Thread(() -> {
            service.buscar("user1");
            latch.countDown();
        }).start();
    }

    latch.await(2, TimeUnit.SECONDS);

    // Assert - repo deve ser chamado apenas 1x (primeira thread)
    // Outras threads esperam ou pegam do cache
    verify(repo, atMost(threads)).findById("user1");
    assertTrue(cache.contains("user1"));
}
```

### 7. Testar Taxa de Cache Hit

```java
@Test
void deveMedirTaxaDeCacheHit() {
    // Arrange
    PerfilRepository repo = mock(PerfilRepository.class);
    Cache<String, Perfil> cache = new InMemoryCache<>();
    PerfilService service = new PerfilService(repo, cache, Duration.ofMinutes(5));

    Perfil perfil1 = new Perfil("user1", "Ana", "ana@test.com", "11999999999",
        LocalDate.of(1995, 3, 10));
    Perfil perfil2 = new Perfil("user2", "Bob", "bob@test.com", "11988888888",
        LocalDate.of(1992, 7, 20));

    when(repo.findById("user1")).thenReturn(Optional.of(perfil1));
    when(repo.findById("user2")).thenReturn(Optional.of(perfil2));

    // Act - simular padr√£o de acesso real
    service.buscar("user1"); // Miss
    service.buscar("user1"); // Hit
    service.buscar("user1"); // Hit
    service.buscar("user2"); // Miss
    service.buscar("user1"); // Hit
    service.buscar("user2"); // Hit

    // Assert
    CacheMetrics metrics = service.getMetrics();
    assertEquals(4, metrics.hits());
    assertEquals(2, metrics.misses());
    assertEquals(66.67, metrics.hitRate(), 0.01); // 4/6 = 66.67%
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå N√£o invalidar cache em atualiza√ß√µes
public void atualizar(Perfil perfil) {
    repository.save(perfil);
    // PROBLEMA: Cache continua com dados antigos!
}

// ‚ùå Cache sem TTL (cresce infinitamente)
cache.put(key, value); // Sem expira√ß√£o!

// ‚ùå Chave de cache inconsistente
cache.put("user:" + id, perfil);
cache.get("perfil:" + id); // Chave diferente!

// ‚ùå Cache de dados sens√≠veis sem criptografia
cache.put(userId, senhaEmTextoPlano); // NUNCA!
```

### ‚úÖ Fazer

```java
// ‚úÖ Sempre invalidar ou atualizar cache
public void atualizar(Perfil perfil) {
    repository.save(perfil);
    cache.evict(perfil.id()); // Invalida
    // OU
    cache.put(perfil.id(), perfil, ttl); // Atualiza
}

// ‚úÖ Sempre definir TTL
cache.put(key, value, Duration.ofMinutes(15));

// ‚úÖ Chave de cache consistente e prefixada
private String cacheKey(String id) {
    return "perfil:" + id;
}

// ‚úÖ N√£o cachear dados sens√≠veis
// Se necess√°rio, criptografar antes de cachear
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **TTL apropriado**: 5-15 min para dados semi-est√°ticos
- ‚úÖ **Invalida√ß√£o consistente**: Sempre invalide em writes
- ‚úÖ **Chaves prefixadas**: `perfil:123`, `produto:456`
- ‚úÖ **Monitorar hit rate**: Alvo: >80% para dados frequentes
- ‚úÖ **Limite de tamanho**: Evict por LRU se atingir limite
- ‚úÖ **M√©tricas**: Rastrear hits/misses, lat√™ncia, tamanho
- ‚úÖ **N√£o cachear dados mut√°veis**: Apenas read-heavy

---

## üîó Integra√ß√£o com Frameworks

### Spring Cache com Redis

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(15))
            .serializeValuesWith(SerializationPair.fromSerializer(
                new GenericJackson2JsonRedisSerializer()
            ));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}

@Service
public class PerfilService {

    @Cacheable(value = "perfis", key = "#id")
    public Perfil buscar(String id) {
        return repository.findById(id).orElseThrow();
    }

    @CachePut(value = "perfis", key = "#perfil.id")
    public Perfil atualizar(Perfil perfil) {
        return repository.save(perfil);
    }

    @CacheEvict(value = "perfis", key = "#id")
    public void deletar(String id) {
        repository.deleteById(id);
    }
}
```

### Caffeine (Cache Local)

```java
Cache<String, Perfil> cache = Caffeine.newBuilder()
    .expireAfterWrite(15, TimeUnit.MINUTES)
    .maximumSize(10_000)
    .recordStats()
    .build();

// Uso
Perfil perfil = cache.get(userId, id -> repository.findById(id).orElse(null));
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                                | ‚ö†Ô∏è Desvantagens                          |
| ------------------------------------------- | ---------------------------------------- |
| Reduz lat√™ncia drasticamente (2ms vs 250ms) | Risco de dados desatualizados (stale)    |
| Diminui carga no banco (95% redu√ß√£o)        | Overhead de invalida√ß√£o                  |
| Escalabilidade (cache horizontal)           | Complexidade adicional                   |
| Controle expl√≠cito (flex√≠vel)               | C√≥digo de gerenciamento manual           |
| F√°cil implementar e testar                  | Poss√≠vel inconsist√™ncia se invalidar mal |

---

## üîç Compara√ß√£o com Outros Patterns

| Aspecto           | Cache Aside | Read-Through   | Write-Through  |
| ----------------- | ----------- | -------------- | -------------- |
| **Controle**      | Aplica√ß√£o   | Cache Provider | Cache Provider |
| **C√≥digo**        | Manual      | Transparente   | Transparente   |
| **Invalida√ß√£o**   | Manual      | Autom√°tica     | Autom√°tica     |
| **Flexibilidade** | Alta        | M√©dia          | M√©dia          |
| **Complexidade**  | M√©dia       | Baixa          | Alta           |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar LRU eviction** quando cache atingir tamanho m√°ximo
2. **Adicionar m√©tricas Prometheus** (cache_hits, cache_misses, cache_size)
3. **Criar warmup de cache** ao inicializar aplica√ß√£o
4. **Implementar cache em 2 n√≠veis** (L1: local, L2: Redis)
5. **Testar comportamento** com thundering herd (m√∫ltiplas threads miss simult√¢neo)

---

## üìö Relacionado

- **Read-Through**: Cache carrega automaticamente em miss
- **Write-Through**: Cache atualiza DB automaticamente
- **Write-Behind**: Cache acumula writes e persiste em batch
- **Circuit Breaker**: Proteger cache de falhas do DB
- **Bulkhead**: Isolar thread pool de acesso ao cache

---

**Cache Aside √© o padr√£o mais simples e flex√≠vel, ideal para read-heavy workloads, mas requer disciplina na invalida√ß√£o!** üíæ‚ú®
