# 04.15 Rate Limiting [ALTO] ‚è±Ô∏è

## üéØ Objetivo

Restringir o n√∫mero de requisi√ß√µes/a√ß√µes por **chave** (usu√°rio, IP, clientId) em uma **janela de tempo**, protegendo recursos contra abuso, DoS e uso excessivo.

---

## üìö O Que √â?

**Rate Limiting** √© um padr√£o que controla a taxa de requisi√ß√µes permitidas por cliente/recurso, rejeitando requisi√ß√µes que excedem o limite configurado.

### Analogia

Como uma **catraca de metr√¥**:

- **Fixed Window**: M√°ximo 50 pessoas por minuto. No minuto seguinte, contador zera
- **Token Bucket**: Cada pessoa precisa de 1 ficha. Fichas se regeneram (5/segundo). Sem fichas? Espere
- **Sliding Window**: Considera √∫ltimas 60 segundas independente do minuto exato

---

## ‚ùå Problema que Resolve

### Antes (Sem Rate Limiting)

```java
// ‚ùå PROBLEMA: Endpoint desprotegido
@PostMapping("/login")
public ResponseEntity<?> login(@RequestBody LoginRequest request) {
    User user = authService.authenticate(request.username(), request.password());
    String token = tokenService.generate(user);
    return ResponseEntity.ok(new TokenResponse(token));
}

// Problemas:
// - Brute force ilimitado (1000 tentativas/segundo)
// - DoS simples (flooding)
// - Uso desproporcional por cliente malicioso
// - Custos de infra explodem
```

**Problemas**:

- üîì Brute force attacks (login, API keys)
- üí• DoS/DDoS (flooding)
- üí∏ Abuso de recursos pagos
- üêõ Clientes bugados (loops infinitos)

### Depois (Com Rate Limiting)

```java
// ‚úÖ SOLU√á√ÉO: Rate limiter protege endpoint
@PostMapping("/login")
public ResponseEntity<?> login(
    @RequestBody LoginRequest request,
    @RequestHeader("X-Forwarded-For") String ip
) {
    LimitOutcome outcome = rateLimiter.check(ip);

    if (outcome instanceof Blocked blocked) {
        return ResponseEntity
            .status(429) // Too Many Requests
            .header("Retry-After", String.valueOf(blocked.retryAfterMs() / 1000))
            .body(Map.of("error", "RATE_LIMIT_EXCEEDED"));
    }

    User user = authService.authenticate(request.username(), request.password());
    String token = tokenService.generate(user);

    return ResponseEntity.ok(new TokenResponse(token));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Dom√≠nio

```java
sealed interface LimitOutcome permits Allowed, Blocked {}

record Allowed(long remaining) implements LimitOutcome {}

record Blocked(String reason, long retryAfterMs) implements LimitOutcome {
    static Blocked rateLimit(long retryAfterMs) {
        return new Blocked("RATE_LIMIT_EXCEEDED", retryAfterMs);
    }
}

record RateLimitConfig(int maxRequests, long windowMs) {
    static RateLimitConfig perMinute(int max) {
        return new RateLimitConfig(max, 60_000);
    }

    static RateLimitConfig perSecond(int max) {
        return new RateLimitConfig(max, 1_000);
    }
}
```

### 2. Fixed Window Rate Limiter

```java
final class FixedWindowRateLimiter {
    private final int maxRequests;
    private final long windowMs;

    private long windowStart;
    private final Map<String, Integer> counters = new ConcurrentHashMap<>();

    // M√©tricas
    private final AtomicInteger allowedCount = new AtomicInteger(0);
    private final AtomicInteger blockedCount = new AtomicInteger(0);

    FixedWindowRateLimiter(RateLimitConfig config) {
        this.maxRequests = config.maxRequests();
        this.windowMs = config.windowMs();
        this.windowStart = System.currentTimeMillis();
    }

    synchronized LimitOutcome check(String key) {
        long now = System.currentTimeMillis();

        // Reset janela se expirou
        if (now - windowStart >= windowMs) {
            counters.clear();
            windowStart = now;
            System.out.println("üîÑ Janela resetada");
        }

        int currentCount = counters.getOrDefault(key, 0);

        if (currentCount >= maxRequests) {
            blockedCount.incrementAndGet();
            long retryAfter = windowMs - (now - windowStart);
            System.out.println("üö´ BLOQUEADO: " + key + " (" + currentCount + "/" + maxRequests + ")");
            return Blocked.rateLimit(retryAfter);
        }

        counters.put(key, currentCount + 1);
        allowedCount.incrementAndGet();
        long remaining = maxRequests - (currentCount + 1);
        System.out.println("‚úÖ PERMITIDO: " + key + " (" + (currentCount + 1) + "/" + maxRequests + ")");

        return new Allowed(remaining);
    }

    RateLimitMetrics getMetrics() {
        return new RateLimitMetrics(
            allowedCount.get(),
            blockedCount.get(),
            counters.size()
        );
    }
}

record RateLimitMetrics(int allowed, int blocked, int activeKeys) {
    double blockRate() {
        int total = allowed + blocked;
        return total > 0 ? (blocked * 100.0) / total : 0;
    }
}
```

### 3. Token Bucket Rate Limiter

```java
final class TokenBucketRateLimiter {
    private final int capacity;
    private final double refillRate; // tokens por ms

    private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();

    record Bucket(double tokens, long lastRefill) {}

    TokenBucketRateLimiter(int capacity, double refillPerSecond) {
        this.capacity = capacity;
        this.refillRate = refillPerSecond / 1000.0; // Converte para por ms
    }

    synchronized LimitOutcome check(String key) {
        long now = System.currentTimeMillis();

        Bucket bucket = buckets.computeIfAbsent(key,
            k -> new Bucket(capacity, now)
        );

        // Calcula tokens reabastecidos
        long elapsed = now - bucket.lastRefill();
        double refilled = elapsed * refillRate;
        double currentTokens = Math.min(capacity, bucket.tokens() + refilled);

        if (currentTokens < 1) {
            // Sem tokens dispon√≠veis
            long timeToRefill = (long) ((1 - currentTokens) / refillRate);
            System.out.println("ü™£ SEM TOKENS: " + key + " (retry: " + timeToRefill + "ms)");
            return Blocked.rateLimit(timeToRefill);
        }

        // Consome 1 token
        buckets.put(key, new Bucket(currentTokens - 1, now));
        System.out.println("ü™ô TOKEN CONSUMIDO: " + key + " (" + (currentTokens - 1) + " restantes)");

        return new Allowed((long) (currentTokens - 1));
    }
}
```

### 4. Sliding Window Rate Limiter

```java
final class SlidingWindowRateLimiter {
    private final int maxRequests;
    private final long windowMs;

    private final Map<String, Queue<Long>> timestamps = new ConcurrentHashMap<>();

    SlidingWindowRateLimiter(RateLimitConfig config) {
        this.maxRequests = config.maxRequests();
        this.windowMs = config.windowMs();
    }

    synchronized LimitOutcome check(String key) {
        long now = System.currentTimeMillis();
        long windowStart = now - windowMs;

        // Remove timestamps fora da janela
        Queue<Long> queue = timestamps.computeIfAbsent(key,
            k -> new LinkedList<>()
        );

        queue.removeIf(ts -> ts < windowStart);

        if (queue.size() >= maxRequests) {
            // Calcula quando o timestamp mais antigo sair√° da janela
            Long oldest = queue.peek();
            long retryAfter = oldest != null ? (oldest + windowMs) - now : windowMs;

            System.out.println("üìä LIMITE EXCEDIDO: " + key + " (" + queue.size() + "/" + maxRequests + ")");
            return Blocked.rateLimit(retryAfter);
        }

        queue.offer(now);
        long remaining = maxRequests - queue.size();

        System.out.println("‚úÖ PERMITIDO: " + key + " (" + queue.size() + "/" + maxRequests + ")");
        return new Allowed(remaining);
    }
}
```

### 5. Rate Limiter Adapter (Interface Unificada)

```java
interface RateLimiter {
    LimitOutcome check(String key);
}

final class RateLimiters {
    static RateLimiter fixedWindow(RateLimitConfig config) {
        return new FixedWindowRateLimiter(config)::check;
    }

    static RateLimiter tokenBucket(int capacity, double refillPerSecond) {
        return new TokenBucketRateLimiter(capacity, refillPerSecond)::check;
    }

    static RateLimiter slidingWindow(RateLimitConfig config) {
        return new SlidingWindowRateLimiter(config)::check;
    }
}
```

### 6. Service com Rate Limiting

```java
final class LoginService {
    private final RateLimiter loginLimiter;
    private final RateLimiter tokenLimiter;
    private final AuthService authService;

    LoginService(AuthService authService) {
        this.authService = authService;

        // 5 tentativas de login por minuto por IP
        this.loginLimiter = RateLimiters.fixedWindow(
            RateLimitConfig.perMinute(5)
        );

        // 100 requisi√ß√µes de token por segundo (global)
        this.tokenLimiter = RateLimiters.tokenBucket(100, 100.0);
    }

    LoginOutcome login(String ip, String username, String password) {
        LimitOutcome limit = loginLimiter.check(ip);

        if (limit instanceof Blocked blocked) {
            return new LoginRateLimited(blocked.retryAfterMs());
        }

        try {
            User user = authService.authenticate(username, password);
            String token = generateToken(user);
            return new LoginSuccess(token, user);

        } catch (AuthException e) {
            return new LoginFailed(e.getMessage());
        }
    }

    private String generateToken(User user) {
        LimitOutcome limit = tokenLimiter.check("global");

        if (limit instanceof Blocked) {
            throw new RuntimeException("Sistema sobrecarregado");
        }

        return "token-" + user.id();
    }
}

sealed interface LoginOutcome permits LoginSuccess, LoginFailed, LoginRateLimited {}
record LoginSuccess(String token, User user) implements LoginOutcome {}
record LoginFailed(String reason) implements LoginOutcome {}
record LoginRateLimited(long retryAfterMs) implements LoginOutcome {}

record User(String id, String username) {}
```

---

## üß™ Como Testar

### 1. Testar Fixed Window - Dentro do Limite

```java
@Test
void fixedWindowDevePermitirDentroDoLimite() {
    // Arrange
    RateLimiter limiter = RateLimiters.fixedWindow(
        new RateLimitConfig(3, 1000) // 3 req/segundo
    );

    // Act & Assert
    assertInstanceOf(Allowed.class, limiter.check("user1"));
    assertInstanceOf(Allowed.class, limiter.check("user1"));

    LimitOutcome third = limiter.check("user1");
    assertInstanceOf(Allowed.class, third);
    assertEquals(0, ((Allowed) third).remaining());
}
```

### 2. Testar Fixed Window - Bloqueio

```java
@Test
void fixedWindowDeveBLoquearAoExceder() {
    // Arrange
    RateLimiter limiter = RateLimiters.fixedWindow(
        new RateLimitConfig(2, 500) // 2 req/500ms
    );

    // Act
    limiter.check("ip1");
    limiter.check("ip1");
    LimitOutcome blocked = limiter.check("ip1"); // 3¬™ requisi√ß√£o

    // Assert
    assertInstanceOf(Blocked.class, blocked);
    Blocked b = (Blocked) blocked;
    assertTrue(b.retryAfterMs() <= 500);
    assertEquals("RATE_LIMIT_EXCEEDED", b.reason());
}
```

### 3. Testar Fixed Window - Reset de Janela

```java
@Test
void fixedWindowDeveResetarAposJanela() throws InterruptedException {
    // Arrange
    RateLimiter limiter = RateLimiters.fixedWindow(
        new RateLimitConfig(1, 100) // 1 req/100ms
    );

    // Act
    assertInstanceOf(Allowed.class, limiter.check("client"));
    assertInstanceOf(Blocked.class, limiter.check("client"));

    Thread.sleep(120); // Aguarda reset

    LimitOutcome afterReset = limiter.check("client");

    // Assert
    assertInstanceOf(Allowed.class, afterReset);
}
```

### 4. Testar Token Bucket - Refill Gradual

```java
@Test
void tokenBucketDeveReabastecerGradualmente() throws InterruptedException {
    // Arrange
    // Capacidade: 2 tokens, refill: 10 tokens/segundo
    RateLimiter limiter = RateLimiters.tokenBucket(2, 10.0);

    // Act - Consome todos tokens
    assertInstanceOf(Allowed.class, limiter.check("api-key"));
    assertInstanceOf(Allowed.class, limiter.check("api-key"));
    assertInstanceOf(Blocked.class, limiter.check("api-key")); // Sem tokens

    Thread.sleep(150); // Aguarda ~1.5 tokens reabastecidos

    // Assert - 1 token reabastecido
    assertInstanceOf(Allowed.class, limiter.check("api-key"));
    assertInstanceOf(Blocked.class, limiter.check("api-key")); // Ainda sem 2¬∫ token
}
```

### 5. Testar Sliding Window - Janela M√≥vel

```java
@Test
void slidingWindowDeveConsiderarJanelaMovel() throws InterruptedException {
    // Arrange
    RateLimiter limiter = RateLimiters.slidingWindow(
        new RateLimitConfig(2, 200) // 2 req/200ms
    );

    // Act
    long t0 = System.currentTimeMillis();
    assertInstanceOf(Allowed.class, limiter.check("user")); // t=0ms
    assertInstanceOf(Allowed.class, limiter.check("user")); // t=0ms
    assertInstanceOf(Blocked.class, limiter.check("user")); // t=0ms (bloqueado)

    Thread.sleep(120); // t=120ms (ainda dentro da janela de 200ms)

    assertInstanceOf(Blocked.class, limiter.check("user")); // Ainda bloqueado

    Thread.sleep(100); // t=220ms (primeira requisi√ß√£o saiu da janela)

    // Assert
    assertInstanceOf(Allowed.class, limiter.check("user")); // Liberado!
}
```

### 6. Testar Isolamento Entre Chaves

```java
@Test
void deveIsolarLimitesPorChave() {
    // Arrange
    RateLimiter limiter = RateLimiters.fixedWindow(
        new RateLimitConfig(1, 1000)
    );

    // Act
    assertInstanceOf(Allowed.class, limiter.check("userA"));
    assertInstanceOf(Allowed.class, limiter.check("userB")); // Chave diferente
    assertInstanceOf(Allowed.class, limiter.check("userC")); // Chave diferente

    // Assert - Cada chave tem seu pr√≥prio limite
    assertInstanceOf(Blocked.class, limiter.check("userA")); // Bloqueado
    assertInstanceOf(Blocked.class, limiter.check("userB")); // Bloqueado
    assertInstanceOf(Blocked.class, limiter.check("userC")); // Bloqueado
}
```

### 7. Testar Concorr√™ncia (Thread Safety)

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    // Arrange
    FixedWindowRateLimiter limiter = new FixedWindowRateLimiter(
        new RateLimitConfig(100, 1000)
    );

    int threads = 50;
    int requestsPerThread = 3; // Total: 150 requisi√ß√µes, limite: 100

    CountDownLatch latch = new CountDownLatch(threads);
    AtomicInteger allowed = new AtomicInteger(0);
    AtomicInteger blocked = new AtomicInteger(0);

    // Act - 50 threads fazendo 3 requisi√ß√µes cada
    for (int i = 0; i < threads; i++) {
        new Thread(() -> {
            for (int j = 0; j < requestsPerThread; j++) {
                LimitOutcome outcome = limiter.check("concurrent-key");
                if (outcome instanceof Allowed) {
                    allowed.incrementAndGet();
                } else {
                    blocked.incrementAndGet();
                }
            }
            latch.countDown();
        }).start();
    }

    latch.await();

    // Assert
    assertEquals(100, allowed.get()); // Exatamente 100 permitidas
    assertEquals(50, blocked.get()); // 50 bloqueadas

    RateLimitMetrics metrics = limiter.getMetrics();
    assertEquals(100, metrics.allowed());
    assertEquals(50, metrics.blocked());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Limite muito alto (n√£o protege)
RateLimitConfig.perMinute(10_000); // In√∫til

// ‚ùå Janela muito longa (burst no in√≠cio)
new RateLimitConfig(1000, 3600_000); // 1h

// ‚ùå Usar username como chave (bypass com IPs)
limiter.check(request.username()); // Atacante usa m√∫ltiplos usu√°rios

// ‚ùå N√£o informar Retry-After
if (blocked) {
    return ResponseEntity.status(429).build(); // Cliente n√£o sabe quando tentar
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Limites razo√°veis por caso de uso
RateLimitConfig.perMinute(10); // Login
RateLimitConfig.perSecond(100); // API leitura
RateLimitConfig.perSecond(10); // API escrita

// ‚úÖ Janela curta (suaviza bursts)
new RateLimitConfig(100, 1000); // 100/segundo

// ‚úÖ Usar IP + User (defesa em profundidade)
String key = ip + ":" + username;
limiter.check(key);

// ‚úÖ Sempre informar Retry-After
return ResponseEntity
    .status(429)
    .header("Retry-After", String.valueOf(blocked.retryAfterMs() / 1000))
    .body(error);
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Limites por contexto**: Login (5/min), Leitura (100/s), Escrita (10/s)
- ‚úÖ **Chave composta**: IP + User (defesa em camadas)
- ‚úÖ **Retry-After header**: Informar cliente quando retry
- ‚úÖ **M√©tricas**: Rastrear allowed/blocked/block-rate
- ‚úÖ **Graceful degradation**: Aumentar limites em hor√°rio fora de pico
- ‚úÖ **Whitelist**: IPs confi√°veis sem limite
- ‚úÖ **Distributed**: Usar Redis para clusters

---

## üîó Integra√ß√£o com Frameworks

### Spring Boot + Bucket4j

```java
@Configuration
public class RateLimitConfig {

    @Bean
    public Bucket loginBucket() {
        Bandwidth limit = Bandwidth.classic(5, Refill.intervally(5, Duration.ofMinutes(1)));
        return Bucket.builder()
            .addLimit(limit)
            .build();
    }
}

@RestController
public class LoginController {

    @Autowired
    private Bucket loginBucket;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest request) {
        if (!loginBucket.tryConsume(1)) {
            return ResponseEntity
                .status(429)
                .body(Map.of("error", "Too many requests"));
        }

        // ... l√≥gica de login
    }
}
```

### Redis Distributed Rate Limiter

```java
@Component
public class RedisRateLimiter {

    @Autowired
    private StringRedisTemplate redis;

    public LimitOutcome check(String key, int max, long windowSeconds) {
        String redisKey = "rate_limit:" + key;
        Long current = redis.opsForValue().increment(redisKey);

        if (current == 1) {
            redis.expire(redisKey, windowSeconds, TimeUnit.SECONDS);
        }

        if (current > max) {
            Long ttl = redis.getExpire(redisKey, TimeUnit.MILLISECONDS);
            return Blocked.rateLimit(ttl);
        }

        return new Allowed(max - current);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                    | ‚ö†Ô∏è Desvantagens                        |
| ------------------------------- | -------------------------------------- |
| Prote√ß√£o contra abuso/DoS       | Pode bloquear usu√°rios leg√≠timos       |
| Controle de custos (APIs pagas) | Complexidade de distribui√ß√£o (cluster) |
| Justi√ßa entre clientes          | Fixed Window tem burst no boundary     |
| Previsibilidade de carga        | Requer storage (mem√≥ria ou Redis)      |

---

## üîç Compara√ß√£o

| Algoritmo          | Precis√£o | Mem√≥ria | Burst      | Complexidade |
| ------------------ | -------- | ------- | ---------- | ------------ |
| **Fixed Window**   | Baixa    | Baixa   | Alto       | Simples      |
| **Sliding Window** | Alta     | Alta    | M√©dio      | M√©dia        |
| **Token Bucket**   | Alta     | M√©dia   | Controlado | M√©dia        |
| **Leaky Bucket**   | Alta     | M√©dia   | Nenhum     | Alta         |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar Leaky Bucket** (vaz√£o constante)
2. **Chave composta** (IP + User + Endpoint)
3. **Rate limit hier√°rquico** (global 1000/s, por-user 10/s)
4. **Adaptive rate limiting** (reduzir limite ap√≥s detec√ß√£o de ataque)
5. **Distributed com Redis** (cluster de servidores)

---

## üìö Relacionado

- **Circuit Breaker**: Proteger rate limiter de falhas
- **Token Refresh**: Rate limit no endpoint de refresh
- **Bulkhead**: Isolar pools de threads por cliente
- **Retry with Backoff**: Cliente deve respeitar Retry-After

---

**Rate Limiting protege recursos e garante justi√ßa, mas requer configura√ß√£o adequada por caso de uso!** ‚è±Ô∏è‚ú®
