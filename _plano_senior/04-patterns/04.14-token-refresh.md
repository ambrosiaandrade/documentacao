# 04.14 Token Refresh [ALTO] üîê

## üéØ Objetivo

Renovar **access tokens** curtos usando **refresh tokens** de longa dura√ß√£o com rota√ß√£o autom√°tica, minimizando janela de comprometimento sem exigir re-autentica√ß√£o completa.

---

## üìö O Que √â?

**Token Refresh** √© um padr√£o OAuth 2.0 (RFC 6749 ¬ß6) que usa tokens de dois tipos:

- **Access Token**: Curta dura√ß√£o (5-15 min), usado para acessar recursos
- **Refresh Token**: Longa dura√ß√£o (dias/semanas), usado apenas para obter novos access tokens

### Analogia

Como um **cart√£o de acesso corporativo**:

- **Access token**: Crach√° tempor√°rio (expira todo dia √†s 18h)
- **Refresh token**: Cart√£o permanente que permite retirar novo crach√° sem falar com RH
- **Rota√ß√£o**: Cada vez que retira crach√° novo, o cart√£o tamb√©m √© trocado (previne fraude)

---

## ‚ùå Problema que Resolve

### Antes (Access Token Longo)

```java
// ‚ùå PROBLEMA: Access token longo demais
@Service
public class AuthService {
    public String login(String username, String password) {
        if (!validar(username, password)) {
            throw new UnauthorizedException();
        }

        // Token v√°lido por 24 horas ‚ùå
        return jwtService.generateToken(username, Duration.ofHours(24));
    }
}

// Problemas:
// - Token roubado v√°lido por 1 dia inteiro
// - Imposs√≠vel revogar sem blacklist complexa
// - Usu√°rio removido continua acessando at√© expira√ß√£o
```

**Problemas**:

- üîì Janela de comprometimento longa (24h)
- üö´ Revoga√ß√£o complexa (precisa blacklist)
- üîÑ Re-autentica√ß√£o excessiva se token curto
- üêõ Usu√°rio desabilitado continua acessando

### Depois (Token Refresh)

```java
// ‚úÖ SOLU√á√ÉO: Access curto + Refresh longo com rota√ß√£o
@Service
public class AuthService {
    public TokenPair login(String username, String password) {
        if (!validar(username, password)) {
            throw new UnauthorizedException();
        }

        String accessToken = jwtService.generateAccessToken(
            username,
            Duration.ofMinutes(15) // Curto ‚úÖ
        );

        RefreshToken refreshToken = refreshService.createRefreshToken(
            username,
            Duration.ofDays(30) // Longo ‚úÖ
        );

        return new TokenPair(accessToken, refreshToken.id());
    }

    public TokenPair refresh(String refreshTokenId) {
        // Valida e rota automaticamente
        RefreshOutcome outcome = refreshService.refresh(refreshTokenId);

        return switch (outcome) {
            case RefreshSuccess s -> new TokenPair(s.newAccessToken(), s.newRefreshToken());
            case RefreshRejected r -> throw new UnauthorizedException(r.reason());
        };
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Dom√≠nio

```java
record TokenPair(String accessToken, String refreshToken) {}

sealed interface RefreshOutcome permits RefreshSuccess, RefreshRejected {}

record RefreshSuccess(
    String newAccessToken,
    String newRefreshToken,
    long expiresAt
) implements RefreshOutcome {}

record RefreshRejected(String reason) implements RefreshOutcome {
    static RefreshRejected notFound() { return new RefreshRejected("NOT_FOUND"); }
    static RefreshRejected expired() { return new RefreshRejected("EXPIRED"); }
    static RefreshRejected revoked() { return new RefreshRejected("REVOKED"); }
    static RefreshRejected replayDetected() { return new RefreshRejected("REPLAY_DETECTED"); }
}

record RefreshToken(
    String id,
    String subject,
    long expiresAt,
    boolean revoked,
    long createdAt
) {
    boolean isExpired() {
        return System.currentTimeMillis() > expiresAt;
    }
}
```

### 2. Token Store (Persist√™ncia)

```java
interface RefreshTokenStore {
    Optional<RefreshToken> find(String id);
    void save(RefreshToken token);
    void revoke(String id);
    boolean isUsed(String id);
    void markUsed(String id);
    void revokeAllBySubject(String subject);
}

final class InMemoryRefreshTokenStore implements RefreshTokenStore {
    private final Map<String, RefreshToken> tokens = new ConcurrentHashMap<>();
    private final Set<String> usedTokens = ConcurrentHashMap.newKeySet();
    private final Map<String, Set<String>> subjectIndex = new ConcurrentHashMap<>();

    @Override
    public Optional<RefreshToken> find(String id) {
        return Optional.ofNullable(tokens.get(id));
    }

    @Override
    public void save(RefreshToken token) {
        tokens.put(token.id(), token);

        // Indexa por subject para revoga√ß√£o em massa
        subjectIndex
            .computeIfAbsent(token.subject(), k -> ConcurrentHashMap.newKeySet())
            .add(token.id());

        System.out.println("üíæ Refresh token salvo: " + token.id());
    }

    @Override
    public void revoke(String id) {
        RefreshToken token = tokens.get(id);
        if (token != null) {
            RefreshToken revoked = new RefreshToken(
                token.id(),
                token.subject(),
                token.expiresAt(),
                true, // revoked
                token.createdAt()
            );
            tokens.put(id, revoked);
            System.out.println("üö´ Refresh token revogado: " + id);
        }
    }

    @Override
    public boolean isUsed(String id) {
        return usedTokens.contains(id);
    }

    @Override
    public void markUsed(String id) {
        usedTokens.add(id);
        System.out.println("‚úÖ Refresh token marcado como usado: " + id);
    }

    @Override
    public void revokeAllBySubject(String subject) {
        Set<String> tokenIds = subjectIndex.get(subject);
        if (tokenIds != null) {
            tokenIds.forEach(this::revoke);
            System.out.println("üö´ Todos tokens do usu√°rio " + subject + " revogados");
        }
    }
}
```

### 3. Token Generator

```java
final class TokenGenerator {
    private final String secretKey;

    TokenGenerator(String secretKey) {
        this.secretKey = secretKey;
    }

    String generateAccessToken(String subject, long ttlMillis) {
        long now = System.currentTimeMillis();
        long exp = now + ttlMillis;

        // Simplificado - em produ√ß√£o usar JWT library (jjwt, nimbus-jose-jwt)
        String payload = subject + ":" + exp;
        String signature = sign(payload);

        return Base64.getEncoder().encodeToString(
            (payload + ":" + signature).getBytes()
        );
    }

    String generateRefreshToken() {
        return UUID.randomUUID().toString();
    }

    private String sign(String data) {
        // Simplificado - usar HMAC-SHA256 em produ√ß√£o
        return Integer.toHexString((data + secretKey).hashCode());
    }
}
```

### 4. Refresh Service (Core)

```java
final class RefreshService {
    private final RefreshTokenStore store;
    private final TokenGenerator generator;
    private final long accessTtlMs;
    private final long refreshTtlMs;

    // M√©tricas
    private final AtomicInteger successCount = new AtomicInteger(0);
    private final AtomicInteger rejectCount = new AtomicInteger(0);
    private final AtomicInteger replayCount = new AtomicInteger(0);

    RefreshService(
        RefreshTokenStore store,
        TokenGenerator generator,
        long accessTtlMs,
        long refreshTtlMs
    ) {
        this.store = store;
        this.generator = generator;
        this.accessTtlMs = accessTtlMs;
        this.refreshTtlMs = refreshTtlMs;
    }

    RefreshToken createRefreshToken(String subject, long ttlMs) {
        long now = System.currentTimeMillis();
        String tokenId = generator.generateRefreshToken();

        RefreshToken token = new RefreshToken(
            tokenId,
            subject,
            now + ttlMs,
            false,
            now
        );

        store.save(token);
        return token;
    }

    RefreshOutcome refresh(String refreshTokenId) {
        // 1. Buscar token
        Optional<RefreshToken> maybeToken = store.find(refreshTokenId);
        if (maybeToken.isEmpty()) {
            rejectCount.incrementAndGet();
            System.out.println("‚ùå Token n√£o encontrado: " + refreshTokenId);
            return RefreshRejected.notFound();
        }

        RefreshToken token = maybeToken.get();

        // 2. Validar se n√£o foi revogado
        if (token.revoked()) {
            rejectCount.incrementAndGet();
            System.out.println("‚ùå Token revogado: " + refreshTokenId);
            return RefreshRejected.revoked();
        }

        // 3. Validar expira√ß√£o
        if (token.isExpired()) {
            rejectCount.incrementAndGet();
            System.out.println("‚ùå Token expirado: " + refreshTokenId);
            return RefreshRejected.expired();
        }

        // 4. Detectar replay (token usado 2x)
        if (store.isUsed(refreshTokenId)) {
            replayCount.incrementAndGet();
            store.revoke(refreshTokenId); // Revoga por seguran√ßa
            System.out.println("üö® REPLAY DETECTADO: " + refreshTokenId);
            return RefreshRejected.replayDetected();
        }

        // 5. Marcar token como usado (rota√ß√£o)
        store.markUsed(refreshTokenId);

        // 6. Gerar novo par de tokens
        String newAccessToken = generator.generateAccessToken(
            token.subject(),
            accessTtlMs
        );

        RefreshToken newRefreshToken = createRefreshToken(
            token.subject(),
            refreshTtlMs
        );

        successCount.incrementAndGet();
        System.out.println("‚úÖ Refresh bem-sucedido: " + token.subject());

        return new RefreshSuccess(
            newAccessToken,
            newRefreshToken.id(),
            newRefreshToken.expiresAt()
        );
    }

    void revokeAllTokens(String subject) {
        store.revokeAllBySubject(subject);
    }

    RefreshMetrics getMetrics() {
        return new RefreshMetrics(
            successCount.get(),
            rejectCount.get(),
            replayCount.get()
        );
    }
}

record RefreshMetrics(int successes, int rejections, int replays) {}
```

### 5. Controller (API)

```java
@RestController
@RequestMapping("/auth")
final class AuthController {
    private final RefreshService refreshService;

    @PostMapping("/refresh")
    ResponseEntity<?> refresh(@RequestBody RefreshRequest request) {
        RefreshOutcome outcome = refreshService.refresh(request.refreshToken());

        return switch (outcome) {
            case RefreshSuccess s -> ResponseEntity.ok(new TokenResponse(
                s.newAccessToken(),
                s.newRefreshToken(),
                s.expiresAt()
            ));

            case RefreshRejected r -> ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(Map.of("error", r.reason()));
        };
    }

    @PostMapping("/logout")
    ResponseEntity<?> logout(@RequestHeader("X-User-Id") String userId) {
        refreshService.revokeAllTokens(userId);
        return ResponseEntity.ok(Map.of("message", "Logout realizado"));
    }
}

record RefreshRequest(String refreshToken) {}
record TokenResponse(String accessToken, String refreshToken, long expiresAt) {}
```

---

## üß™ Como Testar

### 1. Testar Refresh Bem-Sucedido com Rota√ß√£o

```java
@Test
void deveRotacionarRefreshTokenComSucesso() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret-key");
    RefreshService service = new RefreshService(
        store,
        generator,
        15 * 60 * 1000L, // 15 min
        30 * 24 * 60 * 60 * 1000L // 30 dias
    );

    RefreshToken originalToken = service.createRefreshToken(
        "user123",
        30 * 24 * 60 * 60 * 1000L
    );
    String originalTokenId = originalToken.id();

    // Act
    RefreshOutcome outcome = service.refresh(originalTokenId);

    // Assert
    assertInstanceOf(RefreshSuccess.class, outcome);
    RefreshSuccess success = (RefreshSuccess) outcome;

    assertNotNull(success.newAccessToken());
    assertNotNull(success.newRefreshToken());
    assertNotEquals(originalTokenId, success.newRefreshToken()); // Rotacionou!

    assertTrue(success.expiresAt() > System.currentTimeMillis());

    // Verifica que novo token existe
    assertTrue(store.find(success.newRefreshToken()).isPresent());

    // Verifica que token antigo foi marcado como usado
    assertTrue(store.isUsed(originalTokenId));
}
```

### 2. Testar Rejei√ß√£o de Token Expirado

```java
@Test
void deveRejeitarTokenExpirado() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 2000);

    long past = System.currentTimeMillis() - 5000; // 5 segundos no passado
    RefreshToken expiredToken = new RefreshToken(
        "expired-token",
        "user1",
        past, // expiresAt no passado
        false,
        past - 10000
    );
    store.save(expiredToken);

    // Act
    RefreshOutcome outcome = service.refresh("expired-token");

    // Assert
    assertInstanceOf(RefreshRejected.class, outcome);
    assertEquals("EXPIRED", ((RefreshRejected) outcome).reason());

    RefreshMetrics metrics = service.getMetrics();
    assertEquals(0, metrics.successes());
    assertEquals(1, metrics.rejections());
}
```

### 3. Testar Detec√ß√£o de Replay Attack

```java
@Test
void deveDetectarReplayAttack() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 60000);

    RefreshToken token = service.createRefreshToken("user1", 60000);
    String tokenId = token.id();

    // Act
    RefreshOutcome first = service.refresh(tokenId); // Usa pela 1¬™ vez
    assertInstanceOf(RefreshSuccess.class, first);

    RefreshOutcome second = service.refresh(tokenId); // REPLAY!

    // Assert
    assertInstanceOf(RefreshRejected.class, second);
    assertEquals("REPLAY_DETECTED", ((RefreshRejected) second).reason());

    // Verifica que token foi revogado por seguran√ßa
    RefreshToken revokedToken = store.find(tokenId).orElseThrow();
    assertTrue(revokedToken.revoked());

    RefreshMetrics metrics = service.getMetrics();
    assertEquals(1, metrics.successes());
    assertEquals(1, metrics.replays());
}
```

### 4. Testar Rejei√ß√£o de Token Revogado

```java
@Test
void deveRejeitarTokenRevogado() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 60000);

    RefreshToken token = service.createRefreshToken("user1", 60000);
    String tokenId = token.id();

    // Revoga manualmente (ex: logout)
    store.revoke(tokenId);

    // Act
    RefreshOutcome outcome = service.refresh(tokenId);

    // Assert
    assertInstanceOf(RefreshRejected.class, outcome);
    assertEquals("REVOKED", ((RefreshRejected) outcome).reason());
}
```

### 5. Testar Revoga√ß√£o em Massa (Logout)

```java
@Test
void deveRevogarTodosTokensDoUsuario() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 60000);

    // Cria 3 tokens para mesmo usu√°rio (m√∫ltiplos dispositivos)
    RefreshToken token1 = service.createRefreshToken("user1", 60000);
    RefreshToken token2 = service.createRefreshToken("user1", 60000);
    RefreshToken token3 = service.createRefreshToken("user1", 60000);

    // Act
    service.revokeAllTokens("user1");

    // Assert
    assertTrue(store.find(token1.id()).orElseThrow().revoked());
    assertTrue(store.find(token2.id()).orElseThrow().revoked());
    assertTrue(store.find(token3.id()).orElseThrow().revoked());
}
```

### 6. Testar Token N√£o Encontrado

```java
@Test
void deveRejeitarTokenInexistente() {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 60000);

    // Act
    RefreshOutcome outcome = service.refresh("token-inexistente");

    // Assert
    assertInstanceOf(RefreshRejected.class, outcome);
    assertEquals("NOT_FOUND", ((RefreshRejected) outcome).reason());
}
```

### 7. Testar Concorr√™ncia (M√∫ltiplos Refreshes Simult√¢neos)

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    // Arrange
    RefreshTokenStore store = new InMemoryRefreshTokenStore();
    TokenGenerator generator = new TokenGenerator("secret");
    RefreshService service = new RefreshService(store, generator, 1000, 60000);

    RefreshToken token = service.createRefreshToken("user1", 60000);
    String tokenId = token.id();

    int threads = 10;
    CountDownLatch latch = new CountDownLatch(threads);
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger rejectCount = new AtomicInteger(0);

    // Act - 10 threads tentam usar mesmo token
    for (int i = 0; i < threads; i++) {
        new Thread(() -> {
            RefreshOutcome outcome = service.refresh(tokenId);
            if (outcome instanceof RefreshSuccess) {
                successCount.incrementAndGet();
            } else {
                rejectCount.incrementAndGet();
            }
            latch.countDown();
        }).start();
    }

    latch.await();

    // Assert - Apenas 1 deve ter sucesso, 9 devem falhar
    assertEquals(1, successCount.get());
    assertEquals(9, rejectCount.get());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Refresh token sem expira√ß√£o
RefreshToken infinito = new RefreshToken(
    "token",
    "user",
    Long.MAX_VALUE, // Nunca expira!
    false,
    now
);

// ‚ùå N√£o rotacionar (reutilizar mesmo token)
public RefreshOutcome refresh(String tokenId) {
    // ...valida√ß√µes...
    return new RefreshSuccess(newAccess, tokenId, exp); // MESMO token!
}

// ‚ùå N√£o detectar replay
if (store.isUsed(tokenId)) {
    return RefreshRejected.replayDetected(); // Mas n√£o revoga!
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Refresh token com TTL razo√°vel
RefreshToken token = new RefreshToken(
    id,
    subject,
    now + Duration.ofDays(30).toMillis(), // 30 dias
    false,
    now
);

// ‚úÖ Sempre rotacionar
store.markUsed(oldTokenId);
RefreshToken newToken = createRefreshToken(subject, ttl);
return new RefreshSuccess(newAccess, newToken.id(), newToken.expiresAt());

// ‚úÖ Revogar em replay
if (store.isUsed(tokenId)) {
    store.revoke(tokenId); // Revoga por seguran√ßa
    return RefreshRejected.replayDetected();
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Access curto**: 5-15 minutos (minimiza janela de ataque)
- ‚úÖ **Refresh longo**: 7-30 dias (balan√ßo UX vs seguran√ßa)
- ‚úÖ **Rota√ß√£o obrigat√≥ria**: Novo refresh a cada uso
- ‚úÖ **Detec√ß√£o de replay**: Marcar como usado + revogar
- ‚úÖ **Revoga√ß√£o em massa**: Logout invalida todos tokens do usu√°rio
- ‚úÖ **Indexa√ß√£o por subject**: Facilita revoga√ß√£o
- ‚úÖ **M√©tricas**: Rastrear successes/rejections/replays

---

## üîó Integra√ß√£o com Frameworks

### Spring Security + JWT

```java
@Configuration
public class SecurityConfig {

    @Bean
    public JwtDecoder jwtDecoder() {
        return NimbusJwtDecoder.withSecretKey(secretKey).build();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.decoder(jwtDecoder()))
            )
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint((req, res, authEx) -> {
                    res.setStatus(401);
                    res.getWriter().write("{\"error\":\"TOKEN_EXPIRED\"}");
                })
            );

        return http.build();
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                             | ‚ö†Ô∏è Desvantagens                      |
| ---------------------------------------- | ------------------------------------ |
| Janela de comprometimento curta (15 min) | Precisa armazenamento de estado (DB) |
| Revoga√ß√£o granular (logout efetivo)      | Rota√ß√£o aumenta complexidade         |
| UX melhor (sem re-login frequente)       | Replay detection requer controle     |
| Detec√ß√£o de replay attack                | Performance de consulta ao store     |

---

## üîç Compara√ß√£o

| Aspecto          | Access Longo | Session-Based | Token Refresh |
| ---------------- | ------------ | ------------- | ------------- |
| **Seguran√ßa**    | Baixa        | Alta          | Alta          |
| **Stateless**    | Sim          | N√£o           | Parcial       |
| **Revoga√ß√£o**    | Dif√≠cil      | F√°cil         | Moderada      |
| **UX**           | Boa          | Boa           | Excelente     |
| **Complexidade** | Baixa        | M√©dia         | Alta          |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar refresh com Redis** (store distribu√≠do)
2. **Adicionar rate limiting** ao endpoint de refresh (3 tentativas/min)
3. **Sliding window** para refresh (renovar se < 7 dias de expira√ß√£o)
4. **Fingerprinting** (validar IP/User-Agent na renova√ß√£o)
5. **M√©tricas avan√ßadas** (lat√™ncia de refresh, distribui√ß√£o de TTL)

---

## üìö Relacionado

- **Rate Limiting**: Proteger endpoint de refresh
- **Circuit Breaker**: Falhas no token store
- **CQRS**: Separar comandos (revoke) de queries (find)
- **Event Sourcing**: Auditar hist√≥rico de refreshes

---

**Token Refresh equilibra seguran√ßa e usabilidade com rota√ß√£o autom√°tica e detec√ß√£o de replay!** üîê‚ú®
