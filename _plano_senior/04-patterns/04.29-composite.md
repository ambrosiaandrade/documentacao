# 04.29 Composite Pattern [M√âDIO] üå≥

## üéØ Objetivo

Compor objetos em **estruturas de √°rvore** para representar hierarquias parte-todo, permitindo tratar objetos individuais e composi√ß√µes uniformemente e facilitando **testes de hierarquias**.

---

## üìö O Que √â?

**Composite** √© um padr√£o estrutural GoF que permite compor objetos em estruturas de √°rvore e trabalhar com essas estruturas como se fossem objetos individuais. Essencial para representar hierarquias como menus, sistemas de arquivos, organiza√ß√µes.

### Analogia

Como uma **estrutura militar**:

- **Soldado**: Folha (leaf) - n√£o tem subordinados
- **Pelot√£o**: Composite - tem soldados
- **Companhia**: Composite - tem pelot√µes
- **Batalh√£o**: Composite - tem companhias
- **Vantagem**: Todos respondem a "executar miss√£o" uniformemente

---

## ‚ùå Problema que Resolve

### Antes (Tratamento Diferente para Leaf e Composite)

```java
// ‚ùå PROBLEMA: C√≥digo diferente para folhas e composi√ß√µes
class ArquivoSistema {
    void calcularTamanho(Object item) {
        if (item instanceof Arquivo) {
            // Tratamento para arquivo ‚ùå
            Arquivo arquivo = (Arquivo) item;
            return arquivo.getTamanho();

        } else if (item instanceof Pasta) {
            // Tratamento diferente para pasta ‚ùå
            Pasta pasta = (Pasta) item;
            int total = 0;
            for (Object filho : pasta.getFilhos()) {
                total += calcularTamanho(filho); // Recurs√£o manual
            }
            return total;
        }

        throw new IllegalArgumentException("Tipo desconhecido");
    }
}

// Problemas:
// - Tratamento diferente para leaf e composite ‚ùå
// - if/else para cada tipo ‚ùå
// - Cliente precisa conhecer hierarquia ‚ùå
// - Adicionar novo tipo = modificar c√≥digo ‚ùå
```

**Problemas**:

- üîÄ Tratamento diferente para folhas e composi√ß√µes
- üß© Cliente conhece estrutura interna
- üîß Adicionar tipo = modificar cliente
- üß™ Dif√≠cil testar hierarquias complexas
- üìö L√≥gica de travessia duplicada

### Depois (Composite Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Interface comum, tratamento uniforme
interface ComponenteSistemaArquivos {
    long getTamanho();
    void exibir(int nivel);
    String getNome();
}

// Leaf (Folha)
class Arquivo implements ComponenteSistemaArquivos {
    private final String nome;
    private final long tamanho;

    Arquivo(String nome, long tamanho) {
        this.nome = nome;
        this.tamanho = tamanho;
    }

    public long getTamanho() {
        return tamanho;
    }

    public void exibir(int nivel) {
        System.out.println("  ".repeat(nivel) + "üìÑ " + nome + " (" + tamanho + " bytes)");
    }

    public String getNome() {
        return nome;
    }
}

// Composite (Composto)
class Pasta implements ComponenteSistemaArquivos {
    private final String nome;
    private final List<ComponenteSistemaArquivos> filhos = new ArrayList<>();

    Pasta(String nome) {
        this.nome = nome;
    }

    void adicionar(ComponenteSistemaArquivos componente) {
        filhos.add(componente);
    }

    public long getTamanho() {
        // Soma recursiva autom√°tica
        return filhos.stream()
            .mapToLong(ComponenteSistemaArquivos::getTamanho)
            .sum();
    }

    public void exibir(int nivel) {
        System.out.println("  ".repeat(nivel) + "üìÅ " + nome);
        filhos.forEach(f -> f.exibir(nivel + 1));
    }

    public String getNome() {
        return nome;
    }
}

// Cliente simplificado - trata tudo uniformemente
Pasta raiz = new Pasta("root");
raiz.adicionar(new Arquivo("file1.txt", 100));
raiz.adicionar(new Arquivo("file2.txt", 200));

Pasta subpasta = new Pasta("docs");
subpasta.adicionar(new Arquivo("doc1.pdf", 1000));
raiz.adicionar(subpasta);

// Tratamento uniforme! ‚úÖ
System.out.println("Tamanho total: " + raiz.getTamanho()); // 1300
raiz.exibir(0);

// Teste simples
@Test
void deveSomarTamanhosRecursivamente() {
    Pasta pasta = new Pasta("test");
    pasta.adicionar(new Arquivo("a.txt", 100));
    pasta.adicionar(new Arquivo("b.txt", 200));

    assertEquals(300, pasta.getTamanho());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Component

```java
interface ComponenteOrganizacional {
    String getNome();
    double getSalario();
    int contarFuncionarios();
    void exibir(int nivel);
    void adicionarSubordinado(ComponenteOrganizacional subordinado);
    void removerSubordinado(ComponenteOrganizacional subordinado);
    List<ComponenteOrganizacional> getSubordinados();
}
```

### 2. Leaf (Folha)

```java
final class Funcionario implements ComponenteOrganizacional {
    private final String nome;
    private final String cargo;
    private final double salario;

    Funcionario(String nome, String cargo, double salario) {
        this.nome = nome;
        this.cargo = cargo;
        this.salario = salario;
    }

    @Override
    public String getNome() {
        return nome;
    }

    @Override
    public double getSalario() {
        return salario;
    }

    @Override
    public int contarFuncionarios() {
        return 1; // Apenas ele mesmo
    }

    @Override
    public void exibir(int nivel) {
        String indentacao = "  ".repeat(nivel);
        System.out.println(indentacao + "üë§ " + nome + " (" + cargo + ") - R$ " +
                         String.format("%.2f", salario));
    }

    @Override
    public void adicionarSubordinado(ComponenteOrganizacional subordinado) {
        throw new UnsupportedOperationException("Funcion√°rio n√£o pode ter subordinados");
    }

    @Override
    public void removerSubordinado(ComponenteOrganizacional subordinado) {
        throw new UnsupportedOperationException("Funcion√°rio n√£o pode ter subordinados");
    }

    @Override
    public List<ComponenteOrganizacional> getSubordinados() {
        return List.of(); // Vazio - leaf n√£o tem filhos
    }

    String getCargo() {
        return cargo;
    }
}
```

### 3. Composite (Composto)

```java
final class Departamento implements ComponenteOrganizacional {
    private final String nome;
    private final List<ComponenteOrganizacional> subordinados = new ArrayList<>();

    Departamento(String nome) {
        this.nome = nome;
    }

    @Override
    public String getNome() {
        return nome;
    }

    @Override
    public double getSalario() {
        // Soma sal√°rios de todos subordinados (recursivo)
        return subordinados.stream()
            .mapToDouble(ComponenteOrganizacional::getSalario)
            .sum();
    }

    @Override
    public int contarFuncionarios() {
        // Conta todos funcion√°rios (recursivo)
        return subordinados.stream()
            .mapToInt(ComponenteOrganizacional::contarFuncionarios)
            .sum();
    }

    @Override
    public void exibir(int nivel) {
        String indentacao = "  ".repeat(nivel);
        System.out.println(indentacao + "üè¢ " + nome + " (Funcion√°rios: " +
                         contarFuncionarios() + ", Folha: R$ " +
                         String.format("%.2f", getSalario()) + ")");

        // Exibe subordinados recursivamente
        subordinados.forEach(s -> s.exibir(nivel + 1));
    }

    @Override
    public void adicionarSubordinado(ComponenteOrganizacional subordinado) {
        subordinados.add(subordinado);
        System.out.println("‚ûï " + subordinado.getNome() + " adicionado ao " + nome);
    }

    @Override
    public void removerSubordinado(ComponenteOrganizacional subordinado) {
        subordinados.remove(subordinado);
        System.out.println("‚ûñ " + subordinado.getNome() + " removido do " + nome);
    }

    @Override
    public List<ComponenteOrganizacional> getSubordinados() {
        return List.copyOf(subordinados); // C√≥pia imut√°vel
    }
}
```

### 4. Composite com Busca

```java
final class DepartamentoComBusca extends Departamento {

    DepartamentoComBusca(String nome) {
        super(nome);
    }

    // Buscar por nome (recursivo)
    Optional<ComponenteOrganizacional> buscarPorNome(String nome) {
        if (getNome().equalsIgnoreCase(nome)) {
            return Optional.of(this);
        }

        return getSubordinados().stream()
            .map(sub -> {
                if (sub instanceof DepartamentoComBusca dept) {
                    return dept.buscarPorNome(nome);
                } else if (sub.getNome().equalsIgnoreCase(nome)) {
                    return Optional.of(sub);
                }
                return Optional.<ComponenteOrganizacional>empty();
            })
            .filter(Optional::isPresent)
            .map(Optional::get)
            .findFirst();
    }

    // Buscar por cargo
    List<Funcionario> buscarPorCargo(String cargo) {
        List<Funcionario> resultado = new ArrayList<>();

        getSubordinados().forEach(sub -> {
            if (sub instanceof Funcionario func && func.getCargo().equalsIgnoreCase(cargo)) {
                resultado.add(func);
            } else if (sub instanceof DepartamentoComBusca dept) {
                resultado.addAll(dept.buscarPorCargo(cargo));
            }
        });

        return resultado;
    }

    // Sal√°rio m√©dio
    double calcularSalarioMedio() {
        int total = contarFuncionarios();
        return total == 0 ? 0.0 : getSalario() / total;
    }
}
```

### 5. Composite com Visitor (Opera√ß√µes Externas)

```java
interface VisitorOrganizacional {
    void visitarFuncionario(Funcionario funcionario);
    void visitarDepartamento(Departamento departamento);
}

// Relat√≥rio de sal√°rios
class RelatorioSalariosVisitor implements VisitorOrganizacional {
    private final List<String> relatorio = new ArrayList<>();
    private double totalSalarios = 0;

    @Override
    public void visitarFuncionario(Funcionario funcionario) {
        relatorio.add(String.format("%s: R$ %.2f",
            funcionario.getNome(), funcionario.getSalario()));
        totalSalarios += funcionario.getSalario();
    }

    @Override
    public void visitarDepartamento(Departamento departamento) {
        relatorio.add(String.format("[%s] Total: R$ %.2f",
            departamento.getNome(), departamento.getSalario()));

        departamento.getSubordinados().forEach(sub -> {
            if (sub instanceof Funcionario f) {
                visitarFuncionario(f);
            } else if (sub instanceof Departamento d) {
                visitarDepartamento(d);
            }
        });
    }

    List<String> getRelatorio() {
        return List.copyOf(relatorio);
    }

    double getTotalSalarios() {
        return totalSalarios;
    }
}
```

### 6. Composite com Iterator

```java
final class DepartamentoIteravel extends Departamento implements Iterable<ComponenteOrganizacional> {

    DepartamentoIteravel(String nome) {
        super(nome);
    }

    @Override
    public Iterator<ComponenteOrganizacional> iterator() {
        return new CompositeIterator(this);
    }

    // Iterator que percorre √°rvore em profundidade (DFS)
    private static class CompositeIterator implements Iterator<ComponenteOrganizacional> {
        private final Deque<ComponenteOrganizacional> pilha = new ArrayDeque<>();

        CompositeIterator(ComponenteOrganizacional raiz) {
            pilha.push(raiz);
        }

        @Override
        public boolean hasNext() {
            return !pilha.isEmpty();
        }

        @Override
        public ComponenteOrganizacional next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            ComponenteOrganizacional atual = pilha.pop();

            // Adiciona filhos √† pilha (ordem reversa para DFS correto)
            List<ComponenteOrganizacional> filhos = atual.getSubordinados();
            for (int i = filhos.size() - 1; i >= 0; i--) {
                pilha.push(filhos.get(i));
            }

            return atual;
        }
    }
}
```

### 7. Composite com Filtro

```java
final class DepartamentoComFiltro extends Departamento {

    DepartamentoComFiltro(String nome) {
        super(nome);
    }

    List<Funcionario> filtrarFuncionarios(Predicate<Funcionario> filtro) {
        List<Funcionario> resultado = new ArrayList<>();

        getSubordinados().forEach(sub -> {
            if (sub instanceof Funcionario func && filtro.test(func)) {
                resultado.add(func);
            } else if (sub instanceof DepartamentoComFiltro dept) {
                resultado.addAll(dept.filtrarFuncionarios(filtro));
            }
        });

        return resultado;
    }

    // Funcion√°rios com sal√°rio acima de X
    List<Funcionario> salarioAcimaDe(double valor) {
        return filtrarFuncionarios(f -> f.getSalario() > valor);
    }

    // Funcion√°rios por cargo
    List<Funcionario> porCargo(String cargo) {
        return filtrarFuncionarios(f -> f.getCargo().equalsIgnoreCase(cargo));
    }
}
```

### 8. Composite Builder

```java
final class OrganizacaoBuilder {
    private final Departamento raiz;
    private final Deque<Departamento> pilha = new ArrayDeque<>();

    OrganizacaoBuilder(String nomeEmpresa) {
        this.raiz = new Departamento(nomeEmpresa);
        this.pilha.push(raiz);
    }

    OrganizacaoBuilder departamento(String nome) {
        Departamento novo = new Departamento(nome);
        pilha.peek().adicionarSubordinado(novo);
        pilha.push(novo);
        return this;
    }

    OrganizacaoBuilder funcionario(String nome, String cargo, double salario) {
        Funcionario func = new Funcionario(nome, cargo, salario);
        pilha.peek().adicionarSubordinado(func);
        return this;
    }

    OrganizacaoBuilder fim() {
        if (pilha.size() > 1) {
            pilha.pop();
        }
        return this;
    }

    Departamento build() {
        return raiz;
    }

    static OrganizacaoBuilder criar(String nomeEmpresa) {
        return new OrganizacaoBuilder(nomeEmpresa);
    }
}

// Uso fluente
Departamento empresa = OrganizacaoBuilder.criar("TechCorp")
    .departamento("TI")
        .funcionario("Alice", "Dev Senior", 8000)
        .funcionario("Bob", "Dev Junior", 4000)
        .fim()
    .departamento("RH")
        .funcionario("Carol", "Gerente RH", 7000)
        .fim()
    .build();
```

---

## üß™ Como Testar

### 1. Testar Opera√ß√£o Recursiva

```java
@Test
void deveSomarSalariosRecursivamente() {
    // Arrange
    Departamento ti = new Departamento("TI");
    ti.adicionarSubordinado(new Funcionario("Alice", "Dev", 5000));
    ti.adicionarSubordinado(new Funcionario("Bob", "Dev", 4000));

    Departamento empresa = new Departamento("Empresa");
    empresa.adicionarSubordinado(ti);
    empresa.adicionarSubordinado(new Funcionario("CEO", "CEO", 20000));

    // Act
    double total = empresa.getSalario();

    // Assert
    assertEquals(29000, total, 0.01);
}
```

### 2. Testar Contagem Recursiva

```java
@Test
void deveContarTodosFuncionarios() {
    // Arrange
    Departamento ti = new Departamento("TI");
    ti.adicionarSubordinado(new Funcionario("Alice", "Dev", 5000));
    ti.adicionarSubordinado(new Funcionario("Bob", "Dev", 4000));

    Departamento rh = new Departamento("RH");
    rh.adicionarSubordinado(new Funcionario("Carol", "RH", 3000));

    Departamento empresa = new Departamento("Empresa");
    empresa.adicionarSubordinado(ti);
    empresa.adicionarSubordinado(rh);

    // Act
    int total = empresa.contarFuncionarios();

    // Assert
    assertEquals(3, total);
}
```

### 3. Testar Hierarquia Aninhada

```java
@Test
void deveSuportarHierarquiaProfunda() {
    // Arrange
    Departamento nivel3 = new Departamento("Equipe Alpha");
    nivel3.adicionarSubordinado(new Funcionario("Dev1", "Dev", 4000));

    Departamento nivel2 = new Departamento("TI");
    nivel2.adicionarSubordinado(nivel3);

    Departamento nivel1 = new Departamento("Diretoria");
    nivel1.adicionarSubordinado(nivel2);

    Departamento raiz = new Departamento("Empresa");
    raiz.adicionarSubordinado(nivel1);

    // Act & Assert
    assertEquals(4000, raiz.getSalario(), 0.01);
    assertEquals(1, raiz.contarFuncionarios());
}
```

### 4. Testar Busca

```java
@Test
void deveBuscarPorNome() {
    // Arrange
    DepartamentoComBusca raiz = new DepartamentoComBusca("Empresa");
    raiz.adicionarSubordinado(new Funcionario("Alice", "Dev", 5000));

    DepartamentoComBusca ti = new DepartamentoComBusca("TI");
    ti.adicionarSubordinado(new Funcionario("Bob", "Dev", 4000));
    raiz.adicionarSubordinado(ti);

    // Act
    Optional<ComponenteOrganizacional> resultado = raiz.buscarPorNome("Bob");

    // Assert
    assertTrue(resultado.isPresent());
    assertEquals("Bob", resultado.get().getNome());
}
```

### 5. Testar Iterator

```java
@Test
void iteratorDevePercorrerArvoreCompleta() {
    // Arrange
    DepartamentoIteravel raiz = new DepartamentoIteravel("Empresa");
    raiz.adicionarSubordinado(new Funcionario("Alice", "Dev", 5000));
    raiz.adicionarSubordinado(new Funcionario("Bob", "Dev", 4000));

    // Act
    List<String> nomes = new ArrayList<>();
    for (ComponenteOrganizacional comp : raiz) {
        nomes.add(comp.getNome());
    }

    // Assert
    assertEquals(3, nomes.size()); // Raiz + 2 funcion√°rios
    assertTrue(nomes.contains("Empresa"));
    assertTrue(nomes.contains("Alice"));
    assertTrue(nomes.contains("Bob"));
}
```

### 6. Testar Visitor

```java
@Test
void visitorDeveGerarRelatorio() {
    // Arrange
    Departamento ti = new Departamento("TI");
    ti.adicionarSubordinado(new Funcionario("Alice", "Dev", 5000));
    ti.adicionarSubordinado(new Funcionario("Bob", "Dev", 4000));

    RelatorioSalariosVisitor visitor = new RelatorioSalariosVisitor();

    // Act
    visitor.visitarDepartamento(ti);

    // Assert
    assertEquals(9000, visitor.getTotalSalarios(), 0.01);
    assertFalse(visitor.getRelatorio().isEmpty());
}
```

### 7. Testar Builder

```java
@Test
void builderDeveCriarHierarquia() {
    // Act
    Departamento empresa = OrganizacaoBuilder.criar("TechCorp")
        .departamento("TI")
            .funcionario("Alice", "Dev", 5000)
            .funcionario("Bob", "Dev", 4000)
            .fim()
        .build();

    // Assert
    assertEquals("TechCorp", empresa.getNome());
    assertEquals(2, empresa.contarFuncionarios());
    assertEquals(9000, empresa.getSalario(), 0.01);
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Leaf com opera√ß√µes de composite
class BadLeaf implements Component {
    public void adicionar(Component c) {
        // Retorna silenciosamente ‚ùå
        // Ou lan√ßa exce√ß√£o gen√©rica ‚ùå
    }
}

// ‚ùå Composite sem tratamento de ciclos
class BadComposite {
    void adicionar(Component c) {
        children.add(c); // ‚ùå Permite ciclos!
        // Pode causar StackOverflowError
    }
}

// ‚ùå Opera√ß√µes n√£o uniformes
interface BadComponent {
    // Leaf n√£o tem essas opera√ß√µes ‚ùå
    void adicionar(Component c);
    void remover(Component c);
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Leaf com exce√ß√£o clara
class GoodLeaf implements Component {
    public void adicionar(Component c) {
        throw new UnsupportedOperationException(
            "Leaf n√£o pode ter filhos"
        );
    }
}

// ‚úÖ Verificar ciclos
class SafeComposite {
    void adicionar(Component c) {
        if (c == this) {
            throw new IllegalArgumentException("N√£o pode adicionar a si mesmo");
        }
        if (c instanceof SafeComposite && contains(c, this)) {
            throw new IllegalArgumentException("Criaria ciclo");
        }
        children.add(c);
    }
}

// ‚úÖ Interface m√≠nima ou separada
interface Component {
    String getNome();
    double calcular();
}

interface CompositeOperations {
    void adicionar(Component c);
    void remover(Component c);
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Interface comum**: Leaf e Composite implementam mesma interface
- ‚úÖ **Opera√ß√µes recursivas**: M√©todos delegam para filhos
- ‚úÖ **Verificar ciclos**: Evitar adicionar ancestrais como filhos
- ‚úÖ **Immutability**: Considerar composites imut√°veis
- ‚úÖ **Visitor para opera√ß√µes**: Adicionar funcionalidade sem modificar hierarquia
- ‚úÖ **Iterator**: Facilitar travessia da √°rvore
- ‚úÖ **Null Object**: Usar em vez de null para filhos vazios

---

## üîó Integra√ß√£o com Frameworks

### Spring Bean Hierarchy

```java
@Component
public class ServiceComposite {

    @Autowired
    private List<Service> services; // Spring injeta todos

    public void executarTodos() {
        services.forEach(Service::executar);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                         | ‚ö†Ô∏è Desvantagens                            |
| ------------------------------------ | ------------------------------------------ |
| Trata hierarquias uniformemente      | Dif√≠cil restringir tipos de filhos         |
| Facilita adicionar novos componentes | Opera√ß√µes leaf/composite podem confundir   |
| Simplifica c√≥digo cliente            | Pode ser overkill para hierarquias simples |
| Opera√ß√µes recursivas naturais        | Risco de ciclos se n√£o verificar           |

---

## üîç Compara√ß√£o

| Padr√£o                      | Prop√≥sito               | Quando Usar                           |
| --------------------------- | ----------------------- | ------------------------------------- |
| **Composite**               | Hierarquia parte-todo   | √Årvores, menus, organogramas          |
| **Decorator**               | Adicionar comportamento | Enriquecer objeto dinamicamente       |
| **Chain of Responsibility** | Encadear handlers       | Pipeline linear                       |
| **Flyweight**               | Compartilhar objetos    | Economizar mem√≥ria com muitos objetos |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Composite com cache** (cachear opera√ß√µes recursivas)
2. **Composite com valida√ß√£o** (validar estrutura da √°rvore)
3. **Composite thread-safe** (opera√ß√µes concorrentes)
4. **Composite com serializa√ß√£o** (salvar/carregar √°rvore)
5. **Composite com diff** (comparar duas √°rvores)

---

## üìö Relacionado

- **Iterator**: Percorrer elementos de cole√ß√£o
- **Visitor**: Opera√ß√µes externas sobre estrutura
- **Flyweight**: Compartilhar objetos leaf
- **Decorator**: Adicionar comportamento (similar mas diferente prop√≥sito)

---

**Composite Pattern representa hierarquias parte-todo e permite testes uniformes de estruturas complexas!** üå≥‚ú®
