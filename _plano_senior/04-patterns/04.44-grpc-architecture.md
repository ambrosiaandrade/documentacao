# 04.44 gRPC Architecture [AVAN√áADO] ‚ö°

## üéØ Objetivo

Criar APIs de **alta performance** usando Protocol Buffers e HTTP/2, com suporte a **streaming bidirecional**, permitindo **testes de contrato** e comunica√ß√£o eficiente entre microservices.

---

## üìö O Que √â?

**gRPC (gRPC Remote Procedure Call)** √© um framework RPC moderno que usa Protocol Buffers para serializa√ß√£o e HTTP/2 para transporte, oferecendo streaming bidirecional e alta performance.

### Analogia

Como **linha de produ√ß√£o industrial**:

- **Protocolo (Protobuf)**: Especifica√ß√£o precisa de pe√ßas
- **Esteira (HTTP/2)**: Transporte cont√≠nuo e bidirecional
- **M√°quinas (Services)**: Processam rapidamente
- **Vantagem**: Comunica√ß√£o extremamente r√°pida e eficiente

---

## ‚ùå Problema que Resolve

### Antes (REST com JSON - Overhead)

```java
// ‚ùå PROBLEMA: REST com JSON tem overhead

@RestController
@RequestMapping("/api/produtos")
class ProdutoRestController {

    @GetMapping("/{id}")
    ProdutoDTO buscar(@PathVariable Long id) {
        // Retorna JSON (texto) ‚ùå
        return new ProdutoDTO(
            id,
            "Notebook Dell Inspiron 15 3000 Intel Core i5 8GB RAM",
            "Notebook com processador Intel Core i5 de 11¬™ gera√ß√£o...",
            new BigDecimal("3299.99"),
            15
        );
    }
}

// JSON Response (verboso) ‚ùå
{
  "id": 1,
  "nome": "Notebook Dell Inspiron 15 3000 Intel Core i5 8GB RAM",
  "descricao": "Notebook com processador Intel Core i5 de 11¬™ gera√ß√£o com 8GB de RAM DDR4 e SSD de 256GB, tela Full HD de 15.6 polegadas",
  "preco": 3299.99,
  "estoque": 15
}

// Problemas:
// - JSON √© texto (parsing lento) ‚ùå
// - Sem tipagem forte (erros em runtime) ‚ùå
// - HTTP/1.1 (uma requisi√ß√£o por vez) ‚ùå
// - Sem streaming nativo ‚ùå
// - Overhead de texto (tamanho) ‚ùå
// - Sem gera√ß√£o autom√°tica de cliente ‚ùå

// Listagem (N requisi√ß√µes sequenciais) ‚ùå
void listarProdutos() {
    for (int i = 1; i <= 100; i++) {
        ProdutoDTO produto = rest.get("/produtos/" + i); // 100 requests
    }
}
```

**Problemas**:

- üêå JSON parsing lento
- üìù Sem tipagem forte
- üîÑ HTTP/1.1 (sem multiplexing)
- üìä Overhead de tamanho
- üåä Sem streaming nativo

### Depois (gRPC com Protobuf - Bin√°rio)

```protobuf
// ‚úÖ SOLU√á√ÉO: gRPC com Protocol Buffers (bin√°rio e tipado)

// produto.proto
syntax = "proto3";

package com.example.produto;

option java_multiple_files = true;
option java_package = "com.example.produto.grpc";

// Defini√ß√£o do servi√ßo (contrato)
service ProdutoService {
  // Unary RPC - uma request, uma response
  rpc BuscarProduto(ProdutoRequest) returns (ProdutoResponse);

  // Server streaming - uma request, stream de responses
  rpc ListarProdutos(ListarProdutosRequest) returns (stream ProdutoResponse);

  // Client streaming - stream de requests, uma response
  rpc CriarProdutosEmLote(stream CriarProdutoRequest) returns (CriarProdutosResponse);

  // Bidirectional streaming - streams em ambas dire√ß√µes
  rpc SincronizarProdutos(stream ProdutoSync) returns (stream ProdutoSyncResponse);
}

// Mensagens (tipadas e compactas)
message ProdutoRequest {
  int64 id = 1;
}

message ProdutoResponse {
  int64 id = 1;
  string nome = 2;
  string descricao = 3;
  double preco = 4;
  int32 estoque = 5;
}

message ListarProdutosRequest {
  int32 page = 1;
  int32 size = 2;
  string filtro_nome = 3;
}

message CriarProdutoRequest {
  string nome = 1;
  string descricao = 2;
  double preco = 3;
  int32 estoque = 4;
}

message CriarProdutosResponse {
  int32 total_criados = 1;
  repeated int64 ids = 2;
}

message ProdutoSync {
  int64 id = 1;
  int64 timestamp = 2;
  string operacao = 3; // CREATE, UPDATE, DELETE
}

message ProdutoSyncResponse {
  bool sucesso = 1;
  string mensagem = 2;
}
```

```java
// Implementa√ß√£o do Servidor gRPC

@GrpcService
public class ProdutoGrpcService extends ProdutoServiceGrpc.ProdutoServiceImplBase {

    private final ProdutoRepository repository;

    @Autowired
    public ProdutoGrpcService(ProdutoRepository repository) {
        this.repository = repository;
    }

    // 1. UNARY RPC - Request/Response simples
    @Override
    public void buscarProduto(
        ProdutoRequest request,
        StreamObserver<ProdutoResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Unary] BuscarProduto: " + request.getId());

        Produto produto = repository.findById(request.getId())
            .orElseThrow(() -> new StatusRuntimeException(Status.NOT_FOUND));

        ProdutoResponse response = ProdutoResponse.newBuilder()
            .setId(produto.getId())
            .setNome(produto.getNome())
            .setDescricao(produto.getDescricao())
            .setPreco(produto.getPreco().doubleValue())
            .setEstoque(produto.getEstoque())
            .build();

        // Enviar response e completar
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    // 2. SERVER STREAMING - Envia m√∫ltiplas responses
    @Override
    public void listarProdutos(
        ListarProdutosRequest request,
        StreamObserver<ProdutoResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Server Streaming] ListarProdutos");

        List<Produto> produtos = repository.findAll();

        // Envia produtos em stream ‚úÖ
        for (Produto produto : produtos) {
            ProdutoResponse response = ProdutoResponse.newBuilder()
                .setId(produto.getId())
                .setNome(produto.getNome())
                .setPreco(produto.getPreco().doubleValue())
                .build();

            responseObserver.onNext(response); // Stream!

            // Simula processamento incremental
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        responseObserver.onCompleted();
    }

    // 3. CLIENT STREAMING - Recebe m√∫ltiplas requests
    @Override
    public StreamObserver<CriarProdutoRequest> criarProdutosEmLote(
        StreamObserver<CriarProdutosResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Client Streaming] CriarProdutosEmLote");

        return new StreamObserver<CriarProdutoRequest>() {
            private final List<Long> idsCriados = new ArrayList<>();

            @Override
            public void onNext(CriarProdutoRequest request) {
                // Recebe cada produto do stream
                System.out.println("üì• Recebendo: " + request.getNome());

                Produto produto = new Produto();
                produto.setNome(request.getNome());
                produto.setDescricao(request.getDescricao());
                produto.setPreco(BigDecimal.valueOf(request.getPreco()));
                produto.setEstoque(request.getEstoque());

                Produto salvo = repository.save(produto);
                idsCriados.add(salvo.getId());
            }

            @Override
            public void onError(Throwable t) {
                System.err.println("‚ùå Erro no stream: " + t.getMessage());
            }

            @Override
            public void onCompleted() {
                // Quando cliente termina, envia resposta √∫nica
                CriarProdutosResponse response = CriarProdutosResponse.newBuilder()
                    .setTotalCriados(idsCriados.size())
                    .addAllIds(idsCriados)
                    .build();

                responseObserver.onNext(response);
                responseObserver.onCompleted();

                System.out.println("‚úÖ Criados " + idsCriados.size() + " produtos");
            }
        };
    }

    // 4. BIDIRECTIONAL STREAMING - Stream em ambas dire√ß√µes
    @Override
    public StreamObserver<ProdutoSync> sincronizarProdutos(
        StreamObserver<ProdutoSyncResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Bidirectional] SincronizarProdutos");

        return new StreamObserver<ProdutoSync>() {
            @Override
            public void onNext(ProdutoSync sync) {
                System.out.println("üîÑ Sincronizando: " + sync.getOperacao() + " - " + sync.getId());

                try {
                    // Processa opera√ß√£o
                    switch (sync.getOperacao()) {
                        case "CREATE" -> criarProduto(sync);
                        case "UPDATE" -> atualizarProduto(sync);
                        case "DELETE" -> deletarProduto(sync);
                    }

                    // Responde imediatamente para cada opera√ß√£o
                    ProdutoSyncResponse response = ProdutoSyncResponse.newBuilder()
                        .setSucesso(true)
                        .setMensagem("Opera√ß√£o " + sync.getOperacao() + " conclu√≠da")
                        .build();

                    responseObserver.onNext(response);

                } catch (Exception e) {
                    ProdutoSyncResponse response = ProdutoSyncResponse.newBuilder()
                        .setSucesso(false)
                        .setMensagem("Erro: " + e.getMessage())
                        .build();

                    responseObserver.onNext(response);
                }
            }

            @Override
            public void onError(Throwable t) {
                System.err.println("‚ùå Erro na sincroniza√ß√£o: " + t.getMessage());
            }

            @Override
            public void onCompleted() {
                responseObserver.onCompleted();
                System.out.println("‚úÖ Sincroniza√ß√£o conclu√≠da");
            }
        };
    }
}

// ‚úÖ Vantagens:
// - Protocol Buffers: bin√°rio, compacto, r√°pido ‚úÖ
// - HTTP/2: multiplexing, streaming, compress√£o ‚úÖ
// - Tipagem forte: erros em compile time ‚úÖ
// - Gera√ß√£o autom√°tica de cliente ‚úÖ
// - Streaming bidirecional ‚úÖ
// - 10x mais r√°pido que REST/JSON ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Configura√ß√£o do Projeto

```xml
<!-- pom.xml -->
<dependencies>
    <!-- gRPC -->
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-netty-shaded</artifactId>
        <version>1.58.0</version>
    </dependency>
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-protobuf</artifactId>
        <version>1.58.0</version>
    </dependency>
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-stub</artifactId>
        <version>1.58.0</version>
    </dependency>

    <!-- Spring Boot gRPC -->
    <dependency>
        <groupId>net.devh</groupId>
        <artifactId>grpc-spring-boot-starter</artifactId>
        <version>2.15.0.RELEASE</version>
    </dependency>
</dependencies>

<build>
    <extensions>
        <extension>
            <groupId>kr.motd.maven</groupId>
            <artifactId>os-maven-plugin</artifactId>
            <version>1.7.1</version>
        </extension>
    </extensions>

    <plugins>
        <!-- Protobuf compiler -->
        <plugin>
            <groupId>org.xolstice.maven.plugins</groupId>
            <artifactId>protobuf-maven-plugin</artifactId>
            <version>0.6.1</version>
            <configuration>
                <protocArtifact>
                    com.google.protobuf:protoc:3.24.0:exe:${os.detected.classifier}
                </protocArtifact>
                <pluginId>grpc-java</pluginId>
                <pluginArtifact>
                    io.grpc:protoc-gen-grpc-java:1.58.0:exe:${os.detected.classifier}
                </pluginArtifact>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>compile</goal>
                        <goal>compile-custom</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

```properties
# application.properties

# gRPC Server
grpc.server.port=9090
grpc.server.address=0.0.0.0

# Security
grpc.server.security.enabled=true
grpc.server.security.certificate-chain=classpath:cert.pem
grpc.server.security.private-key=classpath:key.pem

# Reflection (para ferramentas como grpcurl)
grpc.server.reflection-service-enabled=true
```

### 2. Proto File Completo

```protobuf
// src/main/proto/produto.proto

syntax = "proto3";

package com.example.produto;

option java_multiple_files = true;
option java_package = "com.example.produto.grpc";
option java_outer_classname = "ProdutoProto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

// ===== SERVICO =====
service ProdutoService {
  // CRUD b√°sico
  rpc CriarProduto(CriarProdutoRequest) returns (ProdutoResponse);
  rpc BuscarProduto(ProdutoRequest) returns (ProdutoResponse);
  rpc AtualizarProduto(AtualizarProdutoRequest) returns (ProdutoResponse);
  rpc DeletarProduto(ProdutoRequest) returns (google.protobuf.Empty);

  // Listagem
  rpc ListarProdutos(ListarProdutosRequest) returns (ListarProdutosResponse);

  // Streaming
  rpc ListarProdutosStream(ListarProdutosRequest) returns (stream ProdutoResponse);
  rpc CriarProdutosLote(stream CriarProdutoRequest) returns (CriarLoteResponse);
  rpc SincronizarProdutos(stream ProdutoSync) returns (stream ProdutoSyncResponse);

  // Busca
  rpc BuscarPorNome(BuscarRequest) returns (stream ProdutoResponse);

  // Estat√≠sticas
  rpc ObterEstatisticas(google.protobuf.Empty) returns (EstatisticasResponse);
}

// ===== MENSAGENS =====

message ProdutoRequest {
  int64 id = 1;
}

message CriarProdutoRequest {
  string nome = 1;
  string descricao = 2;
  double preco = 3;
  int32 estoque = 4;
  int64 categoria_id = 5;
  repeated string tags = 6;
}

message AtualizarProdutoRequest {
  int64 id = 1;
  optional string nome = 2;
  optional string descricao = 3;
  optional double preco = 4;
  optional int32 estoque = 5;
}

message ProdutoResponse {
  int64 id = 1;
  string nome = 2;
  string descricao = 3;
  double preco = 4;
  int32 estoque = 5;
  bool disponivel = 6;
  google.protobuf.Timestamp data_criacao = 7;
  CategoriaInfo categoria = 8;
  repeated string tags = 9;
}

message CategoriaInfo {
  int64 id = 1;
  string nome = 2;
}

message ListarProdutosRequest {
  int32 page = 1;
  int32 size = 2;
  optional string filtro_nome = 3;
  optional double preco_min = 4;
  optional double preco_max = 5;
  optional bool apenas_disponiveis = 6;
  OrdenacaoProduto ordenacao = 7;
}

enum OrdenacaoProduto {
  NOME_ASC = 0;
  NOME_DESC = 1;
  PRECO_ASC = 2;
  PRECO_DESC = 3;
  DATA_ASC = 4;
  DATA_DESC = 5;
}

message ListarProdutosResponse {
  repeated ProdutoResponse produtos = 1;
  int32 total_elementos = 2;
  int32 total_paginas = 3;
  int32 pagina_atual = 4;
}

message CriarLoteResponse {
  int32 total_criados = 1;
  int32 total_erros = 2;
  repeated int64 ids_criados = 3;
}

message ProdutoSync {
  int64 id = 1;
  string operacao = 2; // CREATE, UPDATE, DELETE
  optional CriarProdutoRequest dados = 3;
  int64 timestamp = 4;
}

message ProdutoSyncResponse {
  bool sucesso = 1;
  string mensagem = 2;
  int64 id = 3;
}

message BuscarRequest {
  string termo = 1;
  int32 limite = 2;
}

message EstatisticasResponse {
  int32 total_produtos = 1;
  double valor_total_estoque = 2;
  int32 produtos_disponiveis = 3;
  int32 produtos_esgotados = 4;
  double preco_medio = 5;
}

// ===== ERROS =====
message ErroResponse {
  int32 codigo = 1;
  string mensagem = 2;
  repeated string detalhes = 3;
}
```

### 3. Servidor gRPC Completo

```java
// Implementa√ß√£o completa do servidor

@GrpcService
public class ProdutoGrpcServiceImpl extends ProdutoServiceGrpc.ProdutoServiceImplBase {

    private final ProdutoRepository repository;
    private final CategoriaRepository categoriaRepository;

    @Autowired
    public ProdutoGrpcServiceImpl(
        ProdutoRepository repository,
        CategoriaRepository categoriaRepository
    ) {
        this.repository = repository;
        this.categoriaRepository = categoriaRepository;
    }

    @Override
    public void criarProduto(
        CriarProdutoRequest request,
        StreamObserver<ProdutoResponse> responseObserver
    ) {
        try {
            System.out.println("‚ö° [gRPC] CriarProduto: " + request.getNome());

            // Valida√ß√µes
            if (request.getNome().isBlank()) {
                responseObserver.onError(Status.INVALID_ARGUMENT
                    .withDescription("Nome √© obrigat√≥rio")
                    .asRuntimeException());
                return;
            }

            // Criar produto
            Produto produto = new Produto();
            produto.setNome(request.getNome());
            produto.setDescricao(request.getDescricao());
            produto.setPreco(BigDecimal.valueOf(request.getPreco()));
            produto.setEstoque(request.getEstoque());

            if (request.getCategoriaId() > 0) {
                Categoria categoria = categoriaRepository.findById(request.getCategoriaId())
                    .orElseThrow(() -> Status.NOT_FOUND
                        .withDescription("Categoria n√£o encontrada")
                        .asRuntimeException());
                produto.setCategoria(categoria);
            }

            Produto salvo = repository.save(produto);

            // Construir response
            ProdutoResponse response = buildProdutoResponse(salvo);

            responseObserver.onNext(response);
            responseObserver.onCompleted();

        } catch (StatusRuntimeException e) {
            responseObserver.onError(e);
        } catch (Exception e) {
            responseObserver.onError(Status.INTERNAL
                .withDescription("Erro ao criar produto: " + e.getMessage())
                .asRuntimeException());
        }
    }

    @Override
    public void buscarProduto(
        ProdutoRequest request,
        StreamObserver<ProdutoResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC] BuscarProduto: " + request.getId());

        Produto produto = repository.findById(request.getId())
            .orElseThrow(() -> Status.NOT_FOUND
                .withDescription("Produto n√£o encontrado: " + request.getId())
                .asRuntimeException());

        ProdutoResponse response = buildProdutoResponse(produto);

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void listarProdutos(
        ListarProdutosRequest request,
        StreamObserver<ListarProdutosResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC] ListarProdutos");

        Pageable pageable = PageRequest.of(
            request.getPage(),
            request.getSize() > 0 ? request.getSize() : 20
        );

        Page<Produto> page = repository.findAll(pageable);

        ListarProdutosResponse.Builder responseBuilder = ListarProdutosResponse.newBuilder()
            .setTotalElementos((int) page.getTotalElements())
            .setTotalPaginas(page.getTotalPages())
            .setPaginaAtual(page.getNumber());

        page.getContent().forEach(produto ->
            responseBuilder.addProdutos(buildProdutoResponse(produto))
        );

        responseObserver.onNext(responseBuilder.build());
        responseObserver.onCompleted();
    }

    @Override
    public void listarProdutosStream(
        ListarProdutosRequest request,
        StreamObserver<ProdutoResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Server Streaming] ListarProdutosStream");

        List<Produto> produtos = repository.findAll();

        // Envia produtos em stream
        produtos.forEach(produto -> {
            ProdutoResponse response = buildProdutoResponse(produto);
            responseObserver.onNext(response);

            // Simula processamento incremental
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        responseObserver.onCompleted();
    }

    @Override
    public StreamObserver<CriarProdutoRequest> criarProdutosLote(
        StreamObserver<CriarLoteResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC Client Streaming] CriarProdutosLote");

        return new StreamObserver<CriarProdutoRequest>() {
            private final List<Long> idsCriados = new ArrayList<>();
            private int erros = 0;

            @Override
            public void onNext(CriarProdutoRequest request) {
                try {
                    Produto produto = new Produto();
                    produto.setNome(request.getNome());
                    produto.setDescricao(request.getDescricao());
                    produto.setPreco(BigDecimal.valueOf(request.getPreco()));
                    produto.setEstoque(request.getEstoque());

                    Produto salvo = repository.save(produto);
                    idsCriados.add(salvo.getId());

                    System.out.println("‚úÖ Criado: " + salvo.getNome());

                } catch (Exception e) {
                    erros++;
                    System.err.println("‚ùå Erro ao criar: " + e.getMessage());
                }
            }

            @Override
            public void onError(Throwable t) {
                System.err.println("‚ùå Erro no stream: " + t.getMessage());
            }

            @Override
            public void onCompleted() {
                CriarLoteResponse response = CriarLoteResponse.newBuilder()
                    .setTotalCriados(idsCriados.size())
                    .setTotalErros(erros)
                    .addAllIdsCriados(idsCriados)
                    .build();

                responseObserver.onNext(response);
                responseObserver.onCompleted();

                System.out.println("‚úÖ Lote criado: " + idsCriados.size() + " produtos");
            }
        };
    }

    @Override
    public void obterEstatisticas(
        Empty request,
        StreamObserver<EstatisticasResponse> responseObserver
    ) {
        System.out.println("‚ö° [gRPC] ObterEstatisticas");

        long total = repository.count();
        long disponiveis = repository.countByEstoqueGreaterThan(0);

        EstatisticasResponse response = EstatisticasResponse.newBuilder()
            .setTotalProdutos((int) total)
            .setProdutosDisponiveis((int) disponiveis)
            .setProdutosEsgotados((int) (total - disponiveis))
            .build();

        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    // Helper method
    private ProdutoResponse buildProdutoResponse(Produto produto) {
        ProdutoResponse.Builder builder = ProdutoResponse.newBuilder()
            .setId(produto.getId())
            .setNome(produto.getNome())
            .setDescricao(produto.getDescricao() != null ? produto.getDescricao() : "")
            .setPreco(produto.getPreco().doubleValue())
            .setEstoque(produto.getEstoque())
            .setDisponivel(produto.getEstoque() > 0);

        if (produto.getCategoria() != null) {
            CategoriaInfo categoriaInfo = CategoriaInfo.newBuilder()
                .setId(produto.getCategoria().getId())
                .setNome(produto.getCategoria().getNome())
                .build();
            builder.setCategoria(categoriaInfo);
        }

        if (produto.getDataCriacao() != null) {
            Timestamp timestamp = Timestamp.newBuilder()
                .setSeconds(produto.getDataCriacao().toEpochSecond(ZoneOffset.UTC))
                .build();
            builder.setDataCriacao(timestamp);
        }

        return builder.build();
    }
}
```

### 4. Cliente gRPC

```java
// Cliente para consumir servi√ßo gRPC

@Service
public class ProdutoGrpcClient {

    private final ProdutoServiceGrpc.ProdutoServiceBlockingStub blockingStub;
    private final ProdutoServiceGrpc.ProdutoServiceStub asyncStub;

    @Autowired
    public ProdutoGrpcClient(
        @GrpcClient("produto-service") Channel channel
    ) {
        this.blockingStub = ProdutoServiceGrpc.newBlockingStub(channel);
        this.asyncStub = ProdutoServiceGrpc.newStub(channel);
    }

    // Chamada s√≠ncrona (blocking)
    public ProdutoResponse buscarProduto(Long id) {
        System.out.println("üì§ [gRPC Client] Buscando produto: " + id);

        ProdutoRequest request = ProdutoRequest.newBuilder()
            .setId(id)
            .build();

        try {
            return blockingStub.buscarProduto(request);

        } catch (StatusRuntimeException e) {
            System.err.println("‚ùå Erro: " + e.getStatus());
            throw e;
        }
    }

    // Chamada ass√≠ncrona
    public CompletableFuture<ProdutoResponse> criarProdutoAsync(CriarProdutoRequest request) {
        System.out.println("üì§ [gRPC Client Async] Criando produto");

        CompletableFuture<ProdutoResponse> future = new CompletableFuture<>();

        asyncStub.criarProduto(request, new StreamObserver<ProdutoResponse>() {
            @Override
            public void onNext(ProdutoResponse response) {
                future.complete(response);
            }

            @Override
            public void onError(Throwable t) {
                future.completeExceptionally(t);
            }

            @Override
            public void onCompleted() {
                // J√° completou no onNext
            }
        });

        return future;
    }

    // Server streaming
    public void listarProdutosStream(Consumer<ProdutoResponse> callback) {
        System.out.println("üì§ [gRPC Client] Listando produtos (stream)");

        ListarProdutosRequest request = ListarProdutosRequest.newBuilder()
            .setPage(0)
            .setSize(100)
            .build();

        Iterator<ProdutoResponse> iterator = blockingStub.listarProdutosStream(request);

        while (iterator.hasNext()) {
            ProdutoResponse produto = iterator.next();
            callback.accept(produto);
        }
    }

    // Client streaming
    public CriarLoteResponse criarProdutosLote(List<CriarProdutoRequest> produtos) {
        System.out.println("üì§ [gRPC Client] Criando lote de " + produtos.size() + " produtos");

        CompletableFuture<CriarLoteResponse> future = new CompletableFuture<>();

        StreamObserver<CriarLoteResponse> responseObserver = new StreamObserver<>() {
            @Override
            public void onNext(CriarLoteResponse response) {
                future.complete(response);
            }

            @Override
            public void onError(Throwable t) {
                future.completeExceptionally(t);
            }

            @Override
            public void onCompleted() {
                // J√° completou no onNext
            }
        };

        StreamObserver<CriarProdutoRequest> requestObserver =
            asyncStub.criarProdutosLote(responseObserver);

        try {
            // Envia produtos em stream
            for (CriarProdutoRequest produto : produtos) {
                requestObserver.onNext(produto);
                Thread.sleep(10); // Throttle
            }

            requestObserver.onCompleted();

            return future.get(30, TimeUnit.SECONDS);

        } catch (Exception e) {
            requestObserver.onError(e);
            throw new RuntimeException("Erro ao criar lote", e);
        }
    }
}

// Configura√ß√£o do cliente
@Configuration
public class GrpcClientConfig {

    @Bean
    public ManagedChannel produtoChannel() {
        return ManagedChannelBuilder
            .forAddress("localhost", 9090)
            .usePlaintext() // Usar TLS em produ√ß√£o
            .build();
    }
}
```

### 5. Interceptors (Logging, Auth, Metrics)

```java
// Server interceptor

@GrpcGlobalServerInterceptor
public class LoggingInterceptor implements ServerInterceptor {

    @Override
    public <ReqT, RespT> ServerCall.Listener<ReqT> interceptCall(
        ServerCall<ReqT, RespT> call,
        Metadata headers,
        ServerCallHandler<ReqT, RespT> next
    ) {
        String methodName = call.getMethodDescriptor().getFullMethodName();
        System.out.println("üîç [gRPC Interceptor] Chamada: " + methodName);

        long startTime = System.currentTimeMillis();

        ServerCall.Listener<ReqT> listener = next.startCall(call, headers);

        return new ForwardingServerCallListener.SimpleForwardingServerCallListener<>(listener) {
            @Override
            public void onComplete() {
                long duration = System.currentTimeMillis() - startTime;
                System.out.println("‚úÖ [gRPC] Conclu√≠do em " + duration + "ms");
                super.onComplete();
            }

            @Override
            public void onCancel() {
                System.out.println("‚ö†Ô∏è [gRPC] Chamada cancelada");
                super.onCancel();
            }
        };
    }
}

// Client interceptor

public class AuthInterceptor implements ClientInterceptor {

    private final String token;

    public AuthInterceptor(String token) {
        this.token = token;
    }

    @Override
    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(
        MethodDescriptor<ReqT, RespT> method,
        CallOptions callOptions,
        Channel next
    ) {
        return new ForwardingClientCall.SimpleForwardingClientCall<>(
            next.newCall(method, callOptions)
        ) {
            @Override
            public void start(Listener<RespT> responseListener, Metadata headers) {
                // Adicionar token de autentica√ß√£o
                headers.put(
                    Metadata.Key.of("Authorization", Metadata.ASCII_STRING_MARSHALLER),
                    "Bearer " + token
                );
                super.start(responseListener, headers);
            }
        };
    }
}
```

---

## üß™ Como Testar

### 1. Teste Unit√°rio de Servi√ßo gRPC

```java
@ExtendWith(MockitoExtension.class)
class ProdutoGrpcServiceTest {

    @Mock
    private ProdutoRepository repository;

    @InjectMocks
    private ProdutoGrpcServiceImpl service;

    @Captor
    private ArgumentCaptor<ProdutoResponse> responseCaptor;

    @Test
    void deveBuscarProdutoComSucesso() {
        // Arrange
        Produto produto = new Produto();
        produto.setId(1L);
        produto.setNome("Notebook");
        produto.setPreco(BigDecimal.valueOf(3000));

        when(repository.findById(1L)).thenReturn(Optional.of(produto));

        ProdutoRequest request = ProdutoRequest.newBuilder()
            .setId(1L)
            .build();

        StreamObserver<ProdutoResponse> responseObserver = mock(StreamObserver.class);

        // Act
        service.buscarProduto(request, responseObserver);

        // Assert
        verify(responseObserver).onNext(responseCaptor.capture());
        verify(responseObserver).onCompleted();

        ProdutoResponse response = responseCaptor.getValue();
        assertEquals(1L, response.getId());
        assertEquals("Notebook", response.getNome());
    }

    @Test
    void deveRetornarErroQuandoProdutoNaoExiste() {
        // Arrange
        when(repository.findById(999L)).thenReturn(Optional.empty());

        ProdutoRequest request = ProdutoRequest.newBuilder()
            .setId(999L)
            .build();

        StreamObserver<ProdutoResponse> responseObserver = mock(StreamObserver.class);

        // Act
        service.buscarProduto(request, responseObserver);

        // Assert
        verify(responseObserver).onError(any(StatusRuntimeException.class));
    }
}
```

### 2. Teste de Integra√ß√£o gRPC

```java
@SpringBootTest(properties = {
    "grpc.server.port=0" // Porta aleat√≥ria
})
class ProdutoGrpcIntegrationTest {

    @LocalServerPort
    private int grpcPort;

    @Autowired
    private ProdutoRepository repository;

    private ProdutoServiceGrpc.ProdutoServiceBlockingStub stub;
    private ManagedChannel channel;

    @BeforeEach
    void setUp() {
        channel = ManagedChannelBuilder
            .forAddress("localhost", grpcPort)
            .usePlaintext()
            .build();

        stub = ProdutoServiceGrpc.newBlockingStub(channel);

        repository.deleteAll();
    }

    @AfterEach
    void tearDown() {
        channel.shutdown();
    }

    @Test
    void deveCriarBuscarAtualizarDeletarProduto() {
        // 1. CREATE
        CriarProdutoRequest createRequest = CriarProdutoRequest.newBuilder()
            .setNome("Notebook")
            .setDescricao("Notebook Dell")
            .setPreco(3000.0)
            .setEstoque(10)
            .build();

        ProdutoResponse createResponse = stub.criarProduto(createRequest);
        assertNotNull(createResponse);
        assertEquals("Notebook", createResponse.getNome());
        Long produtoId = createResponse.getId();

        // 2. READ
        ProdutoRequest readRequest = ProdutoRequest.newBuilder()
            .setId(produtoId)
            .build();

        ProdutoResponse readResponse = stub.buscarProduto(readRequest);
        assertEquals("Notebook", readResponse.getNome());

        // 3. UPDATE
        AtualizarProdutoRequest updateRequest = AtualizarProdutoRequest.newBuilder()
            .setId(produtoId)
            .setNome("Notebook Atualizado")
            .build();

        ProdutoResponse updateResponse = stub.atualizarProduto(updateRequest);
        assertEquals("Notebook Atualizado", updateResponse.getNome());

        // 4. DELETE
        stub.deletarProduto(readRequest);

        // Verificar que foi deletado
        assertThrows(StatusRuntimeException.class, () ->
            stub.buscarProduto(readRequest)
        );
    }

    @Test
    void deveListarProdutosEmStream() {
        // Arrange - criar produtos
        for (int i = 1; i <= 5; i++) {
            CriarProdutoRequest request = CriarProdutoRequest.newBuilder()
                .setNome("Produto " + i)
                .setPreco(100.0 * i)
                .setEstoque(i)
                .build();
            stub.criarProduto(request);
        }

        // Act
        ListarProdutosRequest request = ListarProdutosRequest.newBuilder()
            .setPage(0)
            .setSize(10)
            .build();

        Iterator<ProdutoResponse> iterator = stub.listarProdutosStream(request);

        // Assert
        List<ProdutoResponse> produtos = new ArrayList<>();
        iterator.forEachRemaining(produtos::add);

        assertEquals(5, produtos.size());
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Protocol Buffers**: Sempre use proto3
- ‚úÖ **Streaming**: Use para grandes volumes de dados
- ‚úÖ **Interceptors**: Logging, auth, metrics
- ‚úÖ **Deadline**: Defina timeout para chamadas
- ‚úÖ **Retry**: Configure retry policy
- ‚úÖ **Load Balancing**: Use client-side ou proxy
- ‚úÖ **Health Check**: Implemente health service
- ‚úÖ **Reflection**: Habilite para ferramentas (grpcurl)

---

## üîó gRPC vs REST vs GraphQL

| Caracter√≠stica  | gRPC              | REST            | GraphQL          |
| --------------- | ----------------- | --------------- | ---------------- |
| **Protocolo**   | HTTP/2 + Protobuf | HTTP/1.1 + JSON | HTTP + JSON      |
| **Performance** | ‚ö° Excelente      | Boa             | Boa              |
| **Streaming**   | ‚úÖ Nativo         | ‚ùå N√£o          | ‚ö†Ô∏è Subscriptions |
| **Tipagem**     | ‚úÖ Forte          | ‚ùå N√£o          | ‚úÖ Schema        |
| **Browser**     | ‚ö†Ô∏è Limitado       | ‚úÖ Nativo       | ‚úÖ Nativo        |
| **Tamanho**     | Pequeno (bin√°rio) | M√©dio (texto)   | M√©dio (texto)    |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                 | ‚ö†Ô∏è Desvantagens          |
| ---------------------------- | ------------------------ |
| 10x mais r√°pido que REST     | Suporte browser limitado |
| Streaming bidirecional       | Curva de aprendizado     |
| Tipagem forte                | Debugging complexo       |
| Gera√ß√£o autom√°tica de c√≥digo | N√£o human-readable       |
| HTTP/2 multiplexing          | Requer infraestrutura    |
| Compacto (bin√°rio)           | Ferramentas limitadas    |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use gRPC quando:

- Microservices internos (backend-to-backend)
- Performance cr√≠tica
- Streaming de dados necess√°rio
- Baixa lat√™ncia obrigat√≥ria
- Comunica√ß√£o servidor-servidor

### ‚ùå Evite gRPC quando:

- API p√∫blica (browser)
- REST suficiente
- Time sem experi√™ncia
- Debugging frequente necess√°rio
- Simplicidade priorit√°ria

---

**gRPC oferece comunica√ß√£o de alta performance com streaming bidirecional usando Protocol Buffers e HTTP/2!** ‚ö°‚ú®
