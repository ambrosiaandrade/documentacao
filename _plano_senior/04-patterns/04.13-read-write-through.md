# 04.13 Read-Through & Write-Through Cache [ALTO] üîÑ

## üéØ Objetivo

Delegar ao **cache provider** a responsabilidade de carregar dados (Read-Through) e persistir escritas (Write-Through), eliminando c√≥digo duplicado de gerenciamento de cache na aplica√ß√£o.

---

## üìö O Que √â?

**Read-Through** e **Write-Through** s√£o padr√µes onde o cache gerencia automaticamente a sincroniza√ß√£o com a fonte de dados:

- **Read-Through**: Cache carrega dados do DB automaticamente em caso de miss
- **Write-Through**: Cache persiste dados no DB automaticamente ao escrever

### Analogia

Como um **bibliotec√°rio pessoal**:

- **Read-Through**: Voc√™ pede um livro. Se ele n√£o tem, busca no acervo principal e te entrega (voc√™ n√£o precisa ir ao acervo)
- **Write-Through**: Voc√™ devolve um livro anotado. Ele atualiza o original no acervo e mant√©m c√≥pia na mesa dele

---

## ‚ùå Problema que Resolve

### Antes (Cache Aside Manual)

```java
// ‚ùå PROBLEMA: C√≥digo repetido em v√°rios servi√ßos
@Service
public class ProdutoService {
    public Produto buscar(String id) {
        // L√≥gica duplicada em 10 servi√ßos
        Produto cached = cache.get(id);
        if (cached != null) return cached;

        Produto produto = repository.findById(id);
        cache.put(id, produto);
        return produto;
    }

    public void atualizar(Produto produto) {
        repository.save(produto);
        cache.evict(produto.getId()); // F√°cil esquecer!
    }
}

@Service
public class CategoriaService {
    public Categoria buscar(String id) {
        // MESMA l√≥gica duplicada ‚ùå
        Categoria cached = cache.get(id);
        if (cached != null) return cached;

        Categoria categoria = repository.findById(id);
        cache.put(id, categoria);
        return categoria;
    }
}
```

**Problemas**:

- üìã C√≥digo duplicado (get/populate pattern)
- üêõ Bugs de esquecimento (n√£o popular cache)
- üîÑ Invalida√ß√£o inconsistente
- üß™ Testes repetitivos

### Depois (Read/Write-Through)

```java
// ‚úÖ SOLU√á√ÉO: Cache gerencia tudo automaticamente
@Service
public class ProdutoService {
    private final ReadThroughCache<String, Produto> cache;

    public Produto buscar(String id) {
        return cache.get(id); // Cache carrega automaticamente se miss
    }

    public void atualizar(Produto produto) {
        cache.put(produto.getId(), produto); // Cache persiste automaticamente
    }
}

@Service
public class CategoriaService {
    private final ReadThroughCache<String, Categoria> cache;

    public Categoria buscar(String id) {
        return cache.get(id); // Mesma interface, zero duplica√ß√£o!
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Read-Through Cache

```java
@FunctionalInterface
interface CacheLoader<K, V> {
    V load(K key);
}

final class ReadThroughCache<K, V> {
    private final Map<K, CacheEntry<V>> store = new ConcurrentHashMap<>();
    private final CacheLoader<K, V> loader;
    private final Duration ttl;

    // M√©tricas
    private final AtomicInteger hits = new AtomicInteger(0);
    private final AtomicInteger misses = new AtomicInteger(0);
    private final AtomicInteger loads = new AtomicInteger(0);

    record CacheEntry<V>(V value, Instant expiration) {
        boolean isExpired() {
            return Instant.now().isAfter(expiration);
        }
    }

    ReadThroughCache(CacheLoader<K, V> loader, Duration ttl) {
        this.loader = loader;
        this.ttl = ttl;
    }

    public V get(K key) {
        CacheEntry<V> entry = store.get(key);

        // Verifica se existe e n√£o expirou
        if (entry != null && !entry.isExpired()) {
            hits.incrementAndGet();
            System.out.println("‚úÖ Read-Through HIT: " + key);
            return entry.value();
        }

        // Cache MISS - carrega automaticamente
        misses.incrementAndGet();
        loads.incrementAndGet();
        System.out.println("üì• Read-Through LOADING: " + key);

        V value = loader.load(key);

        if (value != null) {
            Instant expiration = Instant.now().plus(ttl);
            store.put(key, new CacheEntry<>(value, expiration));
        }

        return value;
    }

    public void evict(K key) {
        store.remove(key);
        System.out.println("üóë Evicted: " + key);
    }

    public void clear() {
        store.clear();
    }

    public CacheStats getStats() {
        int total = hits.get() + misses.get();
        double hitRate = total > 0 ? (hits.get() * 100.0) / total : 0;

        return new CacheStats(
            hits.get(),
            misses.get(),
            loads.get(),
            hitRate,
            store.size()
        );
    }
}

record CacheStats(
    int hits,
    int misses,
    int loads,
    double hitRate,
    int size
) {}
```

### 2. Write-Through Cache

```java
@FunctionalInterface
interface CacheWriter<K, V> {
    void write(K key, V value);
}

final class WriteThroughCache<K, V> {
    private final Map<K, V> store = new ConcurrentHashMap<>();
    private final CacheWriter<K, V> writer;

    // M√©tricas
    private final AtomicInteger writes = new AtomicInteger(0);
    private final AtomicInteger writesSucceeded = new AtomicInteger(0);
    private final AtomicInteger writesFailed = new AtomicInteger(0);

    WriteThroughCache(CacheWriter<K, V> writer) {
        this.writer = writer;
    }

    public V get(K key) {
        return store.get(key);
    }

    public void put(K key, V value) {
        writes.incrementAndGet();

        try {
            // 1. Persiste no storage primeiro (write-through)
            writer.write(key, value);
            writesSucceeded.incrementAndGet();
            System.out.println("üíæ Write-Through PERSISTED: " + key);

            // 2. Atualiza cache ap√≥s persist√™ncia
            store.put(key, value);
            System.out.println("‚úÖ Write-Through CACHED: " + key);

        } catch (Exception e) {
            writesFailed.incrementAndGet();
            System.err.println("‚ùå Write-Through FAILED: " + key + " - " + e.getMessage());
            throw new RuntimeException("Falha ao persistir via write-through", e);
        }
    }

    public void remove(K key) {
        store.remove(key);
    }

    public WriteStats getStats() {
        return new WriteStats(
            writes.get(),
            writesSucceeded.get(),
            writesFailed.get(),
            store.size()
        );
    }
}

record WriteStats(
    int totalWrites,
    int succeeded,
    int failed,
    int cacheSize
) {}
```

### 3. Cache Combinado (Read + Write-Through)

```java
final class ReadWriteThroughCache<K, V> {
    private final Map<K, CacheEntry<V>> store = new ConcurrentHashMap<>();
    private final CacheLoader<K, V> loader;
    private final CacheWriter<K, V> writer;
    private final Duration ttl;

    record CacheEntry<V>(V value, Instant expiration) {
        boolean isExpired() {
            return Instant.now().isAfter(expiration);
        }
    }

    ReadWriteThroughCache(CacheLoader<K, V> loader, CacheWriter<K, V> writer, Duration ttl) {
        this.loader = loader;
        this.writer = writer;
        this.ttl = ttl;
    }

    public V get(K key) {
        CacheEntry<V> entry = store.get(key);

        if (entry != null && !entry.isExpired()) {
            return entry.value();
        }

        // Read-Through
        V value = loader.load(key);
        if (value != null) {
            Instant expiration = Instant.now().plus(ttl);
            store.put(key, new CacheEntry<>(value, expiration));
        }

        return value;
    }

    public void put(K key, V value) {
        // Write-Through
        writer.write(key, value);

        Instant expiration = Instant.now().plus(ttl);
        store.put(key, new CacheEntry<>(value, expiration));
    }

    public void remove(K key) {
        store.remove(key);
    }
}
```

### 4. Exemplo de Uso - Produto Service

```java
record Produto(String id, String nome, BigDecimal preco, String categoria) {}

interface ProdutoRepository {
    Optional<Produto> findById(String id);
    void save(Produto produto);
}

final class ProdutoService {
    private final ReadWriteThroughCache<String, Produto> cache;
    private final ProdutoRepository repository;

    ProdutoService(ProdutoRepository repository) {
        this.repository = repository;

        // Configura cache com loader e writer
        CacheLoader<String, Produto> loader = id ->
            repository.findById(id).orElse(null);

        CacheWriter<String, Produto> writer = (id, produto) ->
            repository.save(produto);

        this.cache = new ReadWriteThroughCache<>(
            loader,
            writer,
            Duration.ofMinutes(10)
        );
    }

    public Produto buscar(String id) {
        // Simplesmente chama cache - ele gerencia tudo
        return cache.get(id);
    }

    public void atualizar(Produto produto) {
        // Cache persiste e atualiza automaticamente
        cache.put(produto.id(), produto);
    }

    public void remover(String id) {
        cache.remove(id);
        // Em produ√ß√£o: tamb√©m deletar do DB
    }
}
```

### 5. Exemplo de Uso - Config Service

```java
record ConfigEntry(String key, String value, String descricao) {}

final class ConfigService {
    private final ReadWriteThroughCache<String, ConfigEntry> cache;

    ConfigService(ConfigRepository repository) {
        this.cache = new ReadWriteThroughCache<>(
            repository::load,      // Read-Through loader
            repository::persist,   // Write-Through writer
            Duration.ofHours(1)
        );
    }

    public String getConfig(String key) {
        ConfigEntry entry = cache.get(key);
        return entry != null ? entry.value() : null;
    }

    public void setConfig(String key, String value, String descricao) {
        ConfigEntry entry = new ConfigEntry(key, value, descricao);
        cache.put(key, entry);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Read-Through (Cache Miss Carrega Automaticamente)

```java
@Test
void readThroughDeveCarregarAutomaticamente() {
    // Arrange
    CacheLoader<String, Produto> loader = mock(CacheLoader.class);
    Produto produto = new Produto("P1", "Teclado", new BigDecimal("150"), "Perif√©ricos");
    when(loader.load("P1")).thenReturn(produto);

    ReadThroughCache<String, Produto> cache = new ReadThroughCache<>(
        loader,
        Duration.ofMinutes(5)
    );

    // Act
    Produto resultado = cache.get("P1");

    // Assert
    assertNotNull(resultado);
    assertEquals("Teclado", resultado.nome());
    verify(loader, times(1)).load("P1"); // Carregou do loader

    CacheStats stats = cache.getStats();
    assertEquals(0, stats.hits());
    assertEquals(1, stats.misses());
    assertEquals(1, stats.loads());
}
```

### 2. Testar Read-Through (Cache Hit N√£o Carrega)

```java
@Test
void readThroughHitNaoDeveCarregar() {
    // Arrange
    CacheLoader<String, Produto> loader = mock(CacheLoader.class);
    Produto produto = new Produto("P1", "Teclado", new BigDecimal("150"), "Perif√©ricos");
    when(loader.load("P1")).thenReturn(produto);

    ReadThroughCache<String, Produto> cache = new ReadThroughCache<>(
        loader,
        Duration.ofMinutes(5)
    );

    // Act
    cache.get("P1"); // Primeira busca - carrega
    Produto resultado = cache.get("P1"); // Segunda busca - cache hit

    // Assert
    assertEquals("Teclado", resultado.nome());
    verify(loader, times(1)).load("P1"); // S√≥ carregou 1x

    CacheStats stats = cache.getStats();
    assertEquals(1, stats.hits());
    assertEquals(1, stats.misses());
    assertEquals(1, stats.loads());
}
```

### 3. Testar Write-Through (Persiste Antes de Cachear)

```java
@Test
void writeThroughDevePeristirAntesDeCachear() {
    // Arrange
    CacheWriter<String, Produto> writer = mock(CacheWriter.class);
    WriteThroughCache<String, Produto> cache = new WriteThroughCache<>(writer);

    Produto produto = new Produto("P1", "Mouse", new BigDecimal("80"), "Perif√©ricos");

    // Act
    cache.put("P1", produto);

    // Assert
    verify(writer).write("P1", produto); // Persistiu
    assertEquals(produto, cache.get("P1")); // E est√° no cache

    WriteStats stats = cache.getStats();
    assertEquals(1, stats.totalWrites());
    assertEquals(1, stats.succeeded());
    assertEquals(0, stats.failed());
}
```

### 4. Testar Write-Through com Falha de Persist√™ncia

```java
@Test
void writeThroughDeveFalharSePersistenciaFalhar() {
    // Arrange
    CacheWriter<String, Produto> writer = mock(CacheWriter.class);
    doThrow(new RuntimeException("DB indispon√≠vel"))
        .when(writer).write(anyString(), any());

    WriteThroughCache<String, Produto> cache = new WriteThroughCache<>(writer);
    Produto produto = new Produto("P1", "Mouse", new BigDecimal("80"), "Perif√©ricos");

    // Act & Assert
    assertThrows(RuntimeException.class, () -> cache.put("P1", produto));

    // Cache N√ÉO deve conter o item se persist√™ncia falhou
    assertNull(cache.get("P1"));

    WriteStats stats = cache.getStats();
    assertEquals(1, stats.totalWrites());
    assertEquals(0, stats.succeeded());
    assertEquals(1, stats.failed());
}
```

### 5. Testar Cache Combinado (Read + Write-Through)

```java
@Test
void cacheCombinadoDeveCarregarEPersistir() {
    // Arrange
    ProdutoRepository repository = mock(ProdutoRepository.class);
    Produto original = new Produto("P1", "Teclado", new BigDecimal("150"), "Perif√©ricos");
    Produto atualizado = new Produto("P1", "Teclado Mec√¢nico", new BigDecimal("200"), "Perif√©ricos");

    when(repository.findById("P1")).thenReturn(Optional.of(original));

    ProdutoService service = new ProdutoService(repository);

    // Act - Read-Through
    Produto lido = service.buscar("P1");
    assertEquals("Teclado", lido.nome());
    verify(repository).findById("P1");

    // Act - Write-Through
    service.atualizar(atualizado);
    verify(repository).save(atualizado);

    // Cache agora tem vers√£o atualizada
    Produto relido = service.buscar("P1");
    assertEquals("Teclado Mec√¢nico", relido.nome());
    verify(repository, times(1)).findById("P1"); // N√£o recarregou
}
```

### 6. Testar Expira√ß√£o em Read-Through

```java
@Test
void readThroughDeveRecarregarAposExpiracao() throws InterruptedException {
    // Arrange
    CacheLoader<String, Produto> loader = mock(CacheLoader.class);
    Produto produto1 = new Produto("P1", "Vers√£o 1", new BigDecimal("100"), "Cat");
    Produto produto2 = new Produto("P1", "Vers√£o 2", new BigDecimal("120"), "Cat");

    when(loader.load("P1"))
        .thenReturn(produto1)
        .thenReturn(produto2);

    ReadThroughCache<String, Produto> cache = new ReadThroughCache<>(
        loader,
        Duration.ofMillis(100) // TTL curto para teste
    );

    // Act
    Produto v1 = cache.get("P1");
    assertEquals("Vers√£o 1", v1.nome());

    Thread.sleep(150); // Aguarda expira√ß√£o

    Produto v2 = cache.get("P1");
    assertEquals("Vers√£o 2", v2.nome());

    // Assert
    verify(loader, times(2)).load("P1"); // Carregou 2x

    CacheStats stats = cache.getStats();
    assertEquals(0, stats.hits()); // Ambas foram misses (expirado)
    assertEquals(2, stats.misses());
    assertEquals(2, stats.loads());
}
```

### 7. Testar Evict em Read-Through

```java
@Test
void evictDeveForcarReload() {
    // Arrange
    CacheLoader<String, Produto> loader = mock(CacheLoader.class);
    Produto original = new Produto("P1", "Original", new BigDecimal("100"), "Cat");
    Produto atualizado = new Produto("P1", "Atualizado", new BigDecimal("120"), "Cat");

    when(loader.load("P1"))
        .thenReturn(original)
        .thenReturn(atualizado);

    ReadThroughCache<String, Produto> cache = new ReadThroughCache<>(
        loader,
        Duration.ofMinutes(10)
    );

    // Act
    cache.get("P1"); // Carrega original
    cache.evict("P1"); // Remove do cache
    Produto recarregado = cache.get("P1"); // Recarrega

    // Assert
    assertEquals("Atualizado", recarregado.nome());
    verify(loader, times(2)).load("P1");
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Loader com l√≥gica complexa
CacheLoader<String, Produto> loader = id -> {
    // L√≥gica pesada, m√∫ltiplas queries, joins complexos
    // Cache loader deve ser simples!
};

// ‚ùå Writer sem tratamento de erro
CacheWriter<String, Produto> writer = (id, produto) -> {
    repository.save(produto); // Se falhar, cache fica inconsistente!
};

// ‚ùå Cache sem TTL
new ReadThroughCache<>(loader, Duration.ZERO); // Nunca expira!
```

### ‚úÖ Fazer

```java
// ‚úÖ Loader simples e direto
CacheLoader<String, Produto> loader = id ->
    repository.findById(id).orElse(null);

// ‚úÖ Writer com tratamento de erro
CacheWriter<String, Produto> writer = (id, produto) -> {
    try {
        repository.save(produto);
    } catch (Exception e) {
        log.error("Falha ao persistir: {}", id, e);
        throw e; // Propaga para n√£o cachear
    }
};

// ‚úÖ TTL apropriado
new ReadThroughCache<>(loader, Duration.ofMinutes(15));
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Loader simples**: Apenas busca do DB, sem l√≥gica complexa
- ‚úÖ **Writer transacional**: Garantir atomicidade
- ‚úÖ **TTL definido**: Sempre configurar expira√ß√£o
- ‚úÖ **Tratamento de erro**: Falha no writer n√£o deve cachear
- ‚úÖ **M√©tricas**: Rastrear hit rate, loads, writes
- ‚úÖ **Evict strategy**: Oferecer maneira de invalidar manualmente
- ‚úÖ **Thread-safe**: ConcurrentHashMap ou sincroniza√ß√£o

---

## üîó Integra√ß√£o com Frameworks

### Caffeine (Java Cache API)

```java
LoadingCache<String, Produto> cache = Caffeine.newBuilder()
    .expireAfterWrite(15, TimeUnit.MINUTES)
    .maximumSize(10_000)
    .build(key -> repository.findById(key).orElse(null)); // Read-Through

// Uso
Produto produto = cache.get("P1"); // Carrega automaticamente
```

### Guava Cache

```java
LoadingCache<String, Produto> cache = CacheBuilder.newBuilder()
    .expireAfterWrite(15, TimeUnit.MINUTES)
    .maximumSize(10_000)
    .build(new CacheLoader<String, Produto>() {
        public Produto load(String key) {
            return repository.findById(key).orElse(null);
        }
    });
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                         | ‚ö†Ô∏è Desvantagens                  |
| ------------------------------------ | -------------------------------- |
| Elimina c√≥digo duplicado             | Menos controle fino por opera√ß√£o |
| Reduz bugs de esquecimento           | Loader/Writer devem ser simples  |
| Interface uniforme                   | Falha no writer afeta cache      |
| Facilita testes (mock loader/writer) | Debugging menos expl√≠cito        |
| Consist√™ncia autom√°tica              | Performance do loader cr√≠tica    |

---

## üîç Compara√ß√£o

| Aspecto           | Cache Aside     | Read-Through | Write-Through      |
| ----------------- | --------------- | ------------ | ------------------ |
| **Controle**      | Aplica√ß√£o       | Cache        | Cache              |
| **C√≥digo**        | Manual (if/put) | Transparente | Transparente       |
| **Flexibilidade** | Alta            | M√©dia        | Baixa              |
| **Consist√™ncia**  | Eventual        | Eventual     | Imediata           |
| **Uso ideal**     | Controle fino   | Leituras     | Escritas moderadas |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar Write-Behind** (batch writes ass√≠ncronos)
2. **Adicionar refresh-ahead** (recarregar proativamente antes de expirar)
3. **Criar cache em 2 n√≠veis** (L1: local read-through, L2: Redis write-through)
4. **Testar thundering herd** com m√∫ltiplas threads miss simult√¢neo
5. **Implementar cache warming** ao inicializar

---

## üìö Relacionado

- **Cache Aside**: Controle manual, mais flex√≠vel
- **Write-Behind**: Batch writes ass√≠ncronos
- **Circuit Breaker**: Proteger loader de falhas
- **Bulkhead**: Isolar threads de carregamento

---

**Read/Write-Through simplifica gerenciamento de cache mas requer loader/writer bem projetados e tratamento de erro robusto!** üîÑ‚ú®
