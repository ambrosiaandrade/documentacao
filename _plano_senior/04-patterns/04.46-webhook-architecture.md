# 04.46 Webhook Architecture [AVAN√áADO] ü™ù

## üéØ Objetivo

Criar integra√ß√µes **event-driven** usando HTTP callbacks, permitindo que sistemas externos sejam **notificados automaticamente** quando eventos ocorrem, com **retry**, **signatures** e **idempot√™ncia**.

---

## üìö O Que √â?

**Webhook** √© um padr√£o onde o sistema **envia HTTP POST** para URLs registradas quando eventos ocorrem, permitindo integra√ß√µes ass√≠ncronas e notifica√ß√µes em tempo real sem polling.

### Analogia

Como **campainha da casa**:

- **Polling**: Voc√™ verifica a porta a cada minuto
- **Webhook**: Campainha toca quando algu√©m chega
- **Vantagem**: Notifica√ß√£o instant√¢nea sem verifica√ß√£o constante

---

## ‚ùå Problema que Resolve

### Antes (Polling - Verifica Constantemente)

```java
// ‚ùå PROBLEMA: Cliente precisa fazer polling

@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    @GetMapping("/{id}")
    PedidoDTO buscarPedido(@PathVariable Long id) {
        return pedidoService.buscar(id);
    }
}

// Cliente externo (polling a cada 30s) ‚ùå
@Scheduled(fixedDelay = 30000)
public void verificarPedidos() {
    List<Pedido> pedidos = rest.get("/api/pedidos?status=PENDENTE");

    for (Pedido pedido : pedidos) {
        // Processar pedido
        if (pedido.getStatus() == Status.PAGO) {
            processar(pedido);
        }
    }
}

// Problemas:
// - Cliente faz 2880 requests/dia (maioria vazia) ‚ùå
// - Atraso de at√© 30s ‚ùå
// - Sobrecarga no servidor ‚ùå
// - Desperd√≠cio de banda ‚ùå
// - N√£o escal√°vel ‚ùå
```

**Problemas**:

- üîÑ Polling desperdi√ßa recursos (2880 requests/dia)
- ‚è±Ô∏è Atraso (at√© 30s de lat√™ncia)
- üì° Banda desperdi√ßada
- üö´ N√£o √© evento-driven

### Depois (Webhook - Push Instant√¢neo)

```java
// ‚úÖ SOLU√á√ÉO: Webhook notifica automaticamente

@Entity
@Data
public class WebhookSubscription {
    @Id
    @GeneratedValue
    private Long id;

    private String nome;
    private String url;
    private String secret; // Para HMAC signature

    @ElementCollection
    private Set<String> eventos; // PEDIDO_CRIADO, PEDIDO_PAGO, etc.

    private boolean ativo;
    private int tentativas;
    private LocalDateTime ultimaFalha;
}

@Service
public class WebhookService {

    private final WebhookSubscriptionRepository repository;
    private final RestTemplate restTemplate;

    // Registrar webhook
    public WebhookSubscription registrar(WebhookRequest request) {
        System.out.println("ü™ù Registrando webhook: " + request.getUrl());

        WebhookSubscription subscription = new WebhookSubscription();
        subscription.setNome(request.getNome());
        subscription.setUrl(request.getUrl());
        subscription.setSecret(gerarSecret());
        subscription.setEventos(request.getEventos());
        subscription.setAtivo(true);

        return repository.save(subscription);
    }

    // Disparar webhook quando evento ocorre
    public void disparar(String evento, Object payload) {
        System.out.println("üîî Evento disparado: " + evento);

        // Buscar webhooks interessados neste evento
        List<WebhookSubscription> subscriptions =
            repository.findByAtivoTrueAndEventosContaining(evento);

        for (WebhookSubscription subscription : subscriptions) {
            enviarWebhook(subscription, evento, payload);
        }
    }

    private void enviarWebhook(WebhookSubscription subscription, String evento, Object payload) {
        try {
            System.out.println("üì§ Enviando webhook para: " + subscription.getUrl());

            // Construir payload
            WebhookPayload webhookPayload = new WebhookPayload(
                UUID.randomUUID().toString(),
                evento,
                LocalDateTime.now(),
                payload
            );

            // Gerar signature HMAC
            String signature = gerarSignature(webhookPayload, subscription.getSecret());

            // Enviar POST
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("X-Webhook-Signature", signature);
            headers.set("X-Webhook-Event", evento);
            headers.set("X-Webhook-Id", webhookPayload.getId());

            HttpEntity<WebhookPayload> request = new HttpEntity<>(webhookPayload, headers);

            ResponseEntity<String> response = restTemplate.postForEntity(
                subscription.getUrl(),
                request,
                String.class
            );

            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println("‚úÖ Webhook entregue com sucesso");
                subscription.setTentativas(0);
            } else {
                throw new WebhookException("Status n√£o-sucesso: " + response.getStatusCode());
            }

        } catch (Exception e) {
            System.err.println("‚ùå Erro ao enviar webhook: " + e.getMessage());
            tratarFalha(subscription);
        }
    }

    private void tratarFalha(WebhookSubscription subscription) {
        subscription.setTentativas(subscription.getTentativas() + 1);
        subscription.setUltimaFalha(LocalDateTime.now());

        // Desativar ap√≥s 5 falhas
        if (subscription.getTentativas() >= 5) {
            subscription.setAtivo(false);
            System.err.println("‚ö†Ô∏è Webhook desativado ap√≥s 5 falhas: " + subscription.getUrl());
        }

        repository.save(subscription);
    }

    private String gerarSignature(WebhookPayload payload, String secret) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(), "HmacSHA256");
            mac.init(secretKey);

            String json = objectMapper.writeValueAsString(payload);
            byte[] hash = mac.doFinal(json.getBytes());

            return "sha256=" + Hex.encodeHexString(hash);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao gerar signature", e);
        }
    }
}

// Disparar webhook quando evento acontece

@Service
public class PedidoService {

    private final WebhookService webhookService;

    @Transactional
    public Pedido criar(CriarPedidoRequest request) {
        Pedido pedido = new Pedido();
        // ... criar pedido

        pedido = repository.save(pedido);

        // Disparar webhook instantaneamente ‚úÖ
        webhookService.disparar("PEDIDO_CRIADO", pedido);

        return pedido;
    }

    @Transactional
    public Pedido pagar(Long id) {
        Pedido pedido = buscar(id);
        pedido.setStatus(Status.PAGO);

        pedido = repository.save(pedido);

        // Webhook de pagamento ‚úÖ
        webhookService.disparar("PEDIDO_PAGO", pedido);

        return pedido;
    }
}

// ‚úÖ Vantagens:
// - Push instant√¢neo (0s de lat√™ncia) ‚úÖ
// - Sem polling (0 requests desnecess√°rias) ‚úÖ
// - Event-driven (reage a eventos) ‚úÖ
// - Escal√°vel (desacopla sistemas) ‚úÖ
// - Seguro (HMAC signature) ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo e Repository

```java
// Entidade de Webhook Subscription

@Entity
@Table(name = "webhook_subscriptions")
@Data
@NoArgsConstructor
public class WebhookSubscription {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String nome;

    @Column(nullable = false)
    private String url;

    @Column(nullable = false)
    private String secret;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "webhook_eventos")
    private Set<String> eventos = new HashSet<>();

    private boolean ativo = true;

    private int tentativas = 0;

    @Column(name = "max_tentativas")
    private int maxTentativas = 5;

    @Column(name = "ultima_falha")
    private LocalDateTime ultimaFalha;

    @Column(name = "data_criacao")
    private LocalDateTime dataCriacao;

    @Column(name = "usuario_id")
    private String usuarioId;
}

// Hist√≥rico de Webhooks Enviados

@Entity
@Table(name = "webhook_deliveries")
@Data
@NoArgsConstructor
public class WebhookDelivery {

    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "webhook_id")
    private String webhookId; // UUID √∫nico

    @ManyToOne
    @JoinColumn(name = "subscription_id")
    private WebhookSubscription subscription;

    private String evento;

    @Column(columnDefinition = "TEXT")
    private String payload;

    @Column(name = "status_code")
    private Integer statusCode;

    @Column(columnDefinition = "TEXT")
    private String response;

    private boolean sucesso;

    private int tentativa;

    @Column(name = "data_envio")
    private LocalDateTime dataEnvio;

    @Column(name = "duracao_ms")
    private Long duracaoMs;
}

@Repository
public interface WebhookSubscriptionRepository extends JpaRepository<WebhookSubscription, Long> {

    List<WebhookSubscription> findByAtivoTrueAndEventosContaining(String evento);

    List<WebhookSubscription> findByUsuarioId(String usuarioId);

    Optional<WebhookSubscription> findByIdAndUsuarioId(Long id, String usuarioId);
}

@Repository
public interface WebhookDeliveryRepository extends JpaRepository<WebhookDelivery, Long> {

    List<WebhookDelivery> findBySubscriptionIdOrderByDataEnvioDesc(Long subscriptionId);

    List<WebhookDelivery> findByWebhookId(String webhookId);
}
```

### 2. WebhookService Completo

```java
// Servi√ßo completo de Webhooks

@Service
@Slf4j
public class WebhookService {

    private final WebhookSubscriptionRepository subscriptionRepository;
    private final WebhookDeliveryRepository deliveryRepository;
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final TaskExecutor taskExecutor;

    @Autowired
    public WebhookService(
        WebhookSubscriptionRepository subscriptionRepository,
        WebhookDeliveryRepository deliveryRepository,
        RestTemplate restTemplate,
        ObjectMapper objectMapper,
        @Qualifier("webhookTaskExecutor") TaskExecutor taskExecutor
    ) {
        this.subscriptionRepository = subscriptionRepository;
        this.deliveryRepository = deliveryRepository;
        this.restTemplate = restTemplate;
        this.objectMapper = objectMapper;
        this.taskExecutor = taskExecutor;
    }

    // Registrar novo webhook
    @Transactional
    public WebhookSubscription registrar(WebhookRegistrationRequest request, String usuarioId) {
        log.info("ü™ù Registrando webhook para usu√°rio: {}", usuarioId);

        // Validar URL
        if (!isUrlValida(request.getUrl())) {
            throw new IllegalArgumentException("URL inv√°lida: " + request.getUrl());
        }

        WebhookSubscription subscription = new WebhookSubscription();
        subscription.setNome(request.getNome());
        subscription.setUrl(request.getUrl());
        subscription.setSecret(gerarSecret());
        subscription.setEventos(request.getEventos());
        subscription.setUsuarioId(usuarioId);
        subscription.setDataCriacao(LocalDateTime.now());
        subscription.setMaxTentativas(request.getMaxTentativas() != null ?
            request.getMaxTentativas() : 5);

        return subscriptionRepository.save(subscription);
    }

    // Atualizar webhook
    @Transactional
    public WebhookSubscription atualizar(Long id, WebhookUpdateRequest request, String usuarioId) {
        WebhookSubscription subscription = subscriptionRepository
            .findByIdAndUsuarioId(id, usuarioId)
            .orElseThrow(() -> new ResourceNotFoundException("Webhook n√£o encontrado"));

        if (request.getNome() != null) {
            subscription.setNome(request.getNome());
        }
        if (request.getUrl() != null && isUrlValida(request.getUrl())) {
            subscription.setUrl(request.getUrl());
        }
        if (request.getEventos() != null) {
            subscription.setEventos(request.getEventos());
        }
        if (request.getAtivo() != null) {
            subscription.setAtivo(request.getAtivo());
        }

        return subscriptionRepository.save(subscription);
    }

    // Disparar webhooks para um evento
    @Async("webhookTaskExecutor")
    public void disparar(String evento, Object payload) {
        log.info("üîî Evento disparado: {}", evento);

        List<WebhookSubscription> subscriptions =
            subscriptionRepository.findByAtivoTrueAndEventosContaining(evento);

        log.info("üì§ Enviando para {} webhooks", subscriptions.size());

        for (WebhookSubscription subscription : subscriptions) {
            taskExecutor.execute(() -> enviarWebhook(subscription, evento, payload, 1));
        }
    }

    // Enviar webhook individual
    private void enviarWebhook(
        WebhookSubscription subscription,
        String evento,
        Object payload,
        int tentativa
    ) {
        String webhookId = UUID.randomUUID().toString();
        long startTime = System.currentTimeMillis();

        WebhookDelivery delivery = new WebhookDelivery();
        delivery.setWebhookId(webhookId);
        delivery.setSubscription(subscription);
        delivery.setEvento(evento);
        delivery.setTentativa(tentativa);
        delivery.setDataEnvio(LocalDateTime.now());

        try {
            log.info("üì§ Tentativa {}/{} - Enviando webhook {} para: {}",
                tentativa, subscription.getMaxTentativas(), webhookId, subscription.getUrl());

            // Construir payload
            WebhookPayload webhookPayload = new WebhookPayload(
                webhookId,
                evento,
                LocalDateTime.now(),
                payload
            );

            String payloadJson = objectMapper.writeValueAsString(webhookPayload);
            delivery.setPayload(payloadJson);

            // Gerar signature
            String signature = gerarSignature(payloadJson, subscription.getSecret());

            // Preparar headers
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            headers.set("X-Webhook-Signature", signature);
            headers.set("X-Webhook-Event", evento);
            headers.set("X-Webhook-Id", webhookId);
            headers.set("X-Webhook-Timestamp", String.valueOf(System.currentTimeMillis() / 1000));
            headers.set("User-Agent", "MyApp-Webhook/1.0");

            // Enviar POST com timeout
            HttpEntity<String> request = new HttpEntity<>(payloadJson, headers);

            ResponseEntity<String> response = restTemplate.exchange(
                subscription.getUrl(),
                HttpMethod.POST,
                request,
                String.class
            );

            // Processar resposta
            delivery.setStatusCode(response.getStatusCode().value());
            delivery.setResponse(response.getBody());
            delivery.setSucesso(response.getStatusCode().is2xxSuccessful());
            delivery.setDuracaoMs(System.currentTimeMillis() - startTime);

            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("‚úÖ Webhook {} entregue com sucesso em {}ms",
                    webhookId, delivery.getDuracaoMs());

                // Resetar contadores de falha
                subscription.setTentativas(0);
                subscription.setUltimaFalha(null);
                subscriptionRepository.save(subscription);

            } else {
                throw new WebhookException("Status n√£o-sucesso: " + response.getStatusCode());
            }

        } catch (Exception e) {
            log.error("‚ùå Erro ao enviar webhook {}: {}", webhookId, e.getMessage());

            delivery.setSucesso(false);
            delivery.setResponse("Erro: " + e.getMessage());
            delivery.setDuracaoMs(System.currentTimeMillis() - startTime);

            // Retry com exponential backoff
            if (tentativa < subscription.getMaxTentativas()) {
                long delayMs = calcularDelay(tentativa);
                log.warn("‚è≥ Reintentando webhook {} em {}ms", webhookId, delayMs);

                CompletableFuture.delayedExecutor(delayMs, TimeUnit.MILLISECONDS)
                    .execute(() -> enviarWebhook(subscription, evento, payload, tentativa + 1));
            } else {
                // Falhou ap√≥s todas as tentativas
                tratarFalhaDefinitiva(subscription);
            }
        } finally {
            deliveryRepository.save(delivery);
        }
    }

    // Calcular delay para exponential backoff
    private long calcularDelay(int tentativa) {
        // 1s, 2s, 4s, 8s, 16s
        return (long) Math.pow(2, tentativa - 1) * 1000;
    }

    // Tratar falha definitiva
    @Transactional
    private void tratarFalhaDefinitiva(WebhookSubscription subscription) {
        log.error("‚ö†Ô∏è Webhook {} falhou ap√≥s {} tentativas",
            subscription.getId(), subscription.getMaxTentativas());

        subscription.setTentativas(subscription.getTentativas() + 1);
        subscription.setUltimaFalha(LocalDateTime.now());

        // Desativar ap√≥s muitas falhas
        if (subscription.getTentativas() >= 10) {
            subscription.setAtivo(false);
            log.error("üö´ Webhook {} desativado automaticamente", subscription.getId());
        }

        subscriptionRepository.save(subscription);
    }

    // Gerar signature HMAC SHA-256
    private String gerarSignature(String payload, String secret) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(secretKey);

            byte[] hash = mac.doFinal(payload.getBytes(StandardCharsets.UTF_8));
            return "sha256=" + Hex.encodeHexString(hash);

        } catch (Exception e) {
            throw new RuntimeException("Erro ao gerar signature", e);
        }
    }

    // Gerar secret aleat√≥rio
    private String gerarSecret() {
        byte[] bytes = new byte[32];
        new SecureRandom().nextBytes(bytes);
        return Hex.encodeHexString(bytes);
    }

    // Validar URL
    private boolean isUrlValida(String url) {
        try {
            URI uri = new URI(url);
            return uri.getScheme() != null &&
                   (uri.getScheme().equals("http") || uri.getScheme().equals("https"));
        } catch (Exception e) {
            return false;
        }
    }

    // Reenviar webhook manualmente
    @Transactional
    public void reenviar(Long deliveryId) {
        WebhookDelivery delivery = deliveryRepository.findById(deliveryId)
            .orElseThrow(() -> new ResourceNotFoundException("Delivery n√£o encontrado"));

        log.info("üîÑ Reenviando webhook: {}", delivery.getWebhookId());

        try {
            Object payload = objectMapper.readValue(delivery.getPayload(), Object.class);
            enviarWebhook(delivery.getSubscription(), delivery.getEvento(), payload, 1);
        } catch (Exception e) {
            throw new RuntimeException("Erro ao reenviar webhook", e);
        }
    }
}

// Configura√ß√£o do TaskExecutor

@Configuration
public class WebhookConfig {

    @Bean(name = "webhookTaskExecutor")
    public TaskExecutor webhookTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("webhook-");
        executor.initialize();
        return executor;
    }

    @Bean
    public RestTemplate webhookRestTemplate() {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(5000);  // 5s
        factory.setReadTimeout(10000);     // 10s

        return new RestTemplate(factory);
    }
}
```

### 3. API Controllers

```java
// Controller para gerenciar webhooks

@RestController
@RequestMapping("/api/webhooks")
public class WebhookController {

    private final WebhookService webhookService;
    private final WebhookSubscriptionRepository subscriptionRepository;
    private final WebhookDeliveryRepository deliveryRepository;

    @Autowired
    public WebhookController(
        WebhookService webhookService,
        WebhookSubscriptionRepository subscriptionRepository,
        WebhookDeliveryRepository deliveryRepository
    ) {
        this.webhookService = webhookService;
        this.subscriptionRepository = subscriptionRepository;
        this.deliveryRepository = deliveryRepository;
    }

    // Registrar novo webhook
    @PostMapping
    public ResponseEntity<WebhookSubscription> registrar(
        @Valid @RequestBody WebhookRegistrationRequest request,
        Principal principal
    ) {
        WebhookSubscription subscription = webhookService.registrar(
            request,
            principal.getName()
        );

        return ResponseEntity.status(HttpStatus.CREATED).body(subscription);
    }

    // Listar webhooks do usu√°rio
    @GetMapping
    public List<WebhookSubscription> listar(Principal principal) {
        return subscriptionRepository.findByUsuarioId(principal.getName());
    }

    // Buscar webhook espec√≠fico
    @GetMapping("/{id}")
    public WebhookSubscription buscar(
        @PathVariable Long id,
        Principal principal
    ) {
        return subscriptionRepository.findByIdAndUsuarioId(id, principal.getName())
            .orElseThrow(() -> new ResourceNotFoundException("Webhook n√£o encontrado"));
    }

    // Atualizar webhook
    @PutMapping("/{id}")
    public WebhookSubscription atualizar(
        @PathVariable Long id,
        @Valid @RequestBody WebhookUpdateRequest request,
        Principal principal
    ) {
        return webhookService.atualizar(id, request, principal.getName());
    }

    // Deletar webhook
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletar(
        @PathVariable Long id,
        Principal principal
    ) {
        WebhookSubscription subscription = subscriptionRepository
            .findByIdAndUsuarioId(id, principal.getName())
            .orElseThrow(() -> new ResourceNotFoundException("Webhook n√£o encontrado"));

        subscriptionRepository.delete(subscription);
        return ResponseEntity.noContent().build();
    }

    // Hist√≥rico de deliveries
    @GetMapping("/{id}/deliveries")
    public List<WebhookDelivery> historico(@PathVariable Long id) {
        return deliveryRepository.findBySubscriptionIdOrderByDataEnvioDesc(id);
    }

    // Reenviar webhook
    @PostMapping("/deliveries/{deliveryId}/retry")
    public ResponseEntity<Void> reenviar(@PathVariable Long deliveryId) {
        webhookService.reenviar(deliveryId);
        return ResponseEntity.accepted().build();
    }
}

// DTOs

@Data
@NoArgsConstructor
@AllArgsConstructor
public class WebhookRegistrationRequest {

    @NotBlank(message = "Nome √© obrigat√≥rio")
    private String nome;

    @NotBlank(message = "URL √© obrigat√≥ria")
    @Pattern(regexp = "^https?://.*", message = "URL deve come√ßar com http:// ou https://")
    private String url;

    @NotEmpty(message = "Pelo menos um evento √© obrigat√≥rio")
    private Set<String> eventos;

    private Integer maxTentativas;
}

@Data
public class WebhookUpdateRequest {
    private String nome;
    private String url;
    private Set<String> eventos;
    private Boolean ativo;
}

@Data
@AllArgsConstructor
@NoArgsConstructor
public class WebhookPayload {
    private String id;
    private String evento;
    private LocalDateTime timestamp;
    private Object data;
}
```

### 4. Verifica√ß√£o de Signature (Cliente)

```java
// Cliente que recebe webhooks

@RestController
@RequestMapping("/webhooks")
@Slf4j
public class WebhookReceiverController {

    private static final String WEBHOOK_SECRET = "seu-secret-aqui";

    // Receber webhook
    @PostMapping("/pedido")
    public ResponseEntity<String> receberWebhookPedido(
        @RequestBody String payload,
        @RequestHeader("X-Webhook-Signature") String signature,
        @RequestHeader("X-Webhook-Event") String evento,
        @RequestHeader("X-Webhook-Id") String webhookId
    ) {
        log.info("ü™ù Webhook recebido: {} (ID: {})", evento, webhookId);

        // 1. Verificar signature
        if (!verificarSignature(payload, signature)) {
            log.error("‚ùå Signature inv√°lida para webhook: {}", webhookId);
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Signature inv√°lida");
        }

        // 2. Verificar idempot√™ncia (evitar processar duplicatas)
        if (jaProcessado(webhookId)) {
            log.warn("‚ö†Ô∏è Webhook j√° processado: {}", webhookId);
            return ResponseEntity.ok("J√° processado");
        }

        try {
            // 3. Parsear payload
            WebhookPayload webhookPayload = objectMapper.readValue(payload, WebhookPayload.class);

            // 4. Processar baseado no evento
            switch (evento) {
                case "PEDIDO_CRIADO" -> processarPedidoCriado(webhookPayload);
                case "PEDIDO_PAGO" -> processarPedidoPago(webhookPayload);
                case "PEDIDO_CANCELADO" -> processarPedidoCancelado(webhookPayload);
                default -> log.warn("Evento desconhecido: {}", evento);
            }

            // 5. Marcar como processado
            marcarComoProcessado(webhookId);

            log.info("‚úÖ Webhook processado com sucesso: {}", webhookId);
            return ResponseEntity.ok("Processado com sucesso");

        } catch (Exception e) {
            log.error("‚ùå Erro ao processar webhook: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Erro ao processar: " + e.getMessage());
        }
    }

    // Verificar signature HMAC
    private boolean verificarSignature(String payload, String receivedSignature) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKey = new SecretKeySpec(
                WEBHOOK_SECRET.getBytes(StandardCharsets.UTF_8),
                "HmacSHA256"
            );
            mac.init(secretKey);

            byte[] hash = mac.doFinal(payload.getBytes(StandardCharsets.UTF_8));
            String expectedSignature = "sha256=" + Hex.encodeHexString(hash);

            return MessageDigest.isEqual(
                expectedSignature.getBytes(),
                receivedSignature.getBytes()
            );

        } catch (Exception e) {
            log.error("Erro ao verificar signature", e);
            return false;
        }
    }

    // Verificar se j√° foi processado (idempot√™ncia)
    private boolean jaProcessado(String webhookId) {
        return webhookProcessadoRepository.existsByWebhookId(webhookId);
    }

    // Marcar como processado
    private void marcarComoProcessado(String webhookId) {
        WebhookProcessado processado = new WebhookProcessado();
        processado.setWebhookId(webhookId);
        processado.setDataProcessamento(LocalDateTime.now());
        webhookProcessadoRepository.save(processado);
    }
}
```

---

## üß™ Como Testar

### 1. Teste de Webhook Service

```java
@ExtendWith(MockitoExtension.class)
class WebhookServiceTest {

    @Mock
    private WebhookSubscriptionRepository subscriptionRepository;

    @Mock
    private RestTemplate restTemplate;

    @InjectMocks
    private WebhookService service;

    @Test
    void deveRegistrarWebhookComSucesso() {
        // Arrange
        WebhookRegistrationRequest request = new WebhookRegistrationRequest(
            "Meu Webhook",
            "https://example.com/webhook",
            Set.of("PEDIDO_CRIADO"),
            5
        );

        // Act
        WebhookSubscription subscription = service.registrar(request, "usuario123");

        // Assert
        assertNotNull(subscription);
        assertEquals("Meu Webhook", subscription.getNome());
        assertNotNull(subscription.getSecret());
        verify(subscriptionRepository).save(any());
    }

    @Test
    void deveDispararWebhookParaSubscricoesAtivas() {
        // Arrange
        WebhookSubscription subscription = new WebhookSubscription();
        subscription.setUrl("https://example.com/webhook");
        subscription.setSecret("secret123");
        subscription.setEventos(Set.of("PEDIDO_CRIADO"));

        when(subscriptionRepository.findByAtivoTrueAndEventosContaining("PEDIDO_CRIADO"))
            .thenReturn(List.of(subscription));

        when(restTemplate.exchange(anyString(), any(), any(), eq(String.class)))
            .thenReturn(ResponseEntity.ok("OK"));

        // Act
        service.disparar("PEDIDO_CRIADO", Map.of("pedidoId", 123));

        // Assert - aguardar async
        await().atMost(Duration.ofSeconds(2))
            .untilAsserted(() ->
                verify(restTemplate).exchange(anyString(), any(), any(), eq(String.class))
            );
    }
}
```

### 2. Teste de Signature

```java
@Test
void deveVerificarSignatureCorretamente() {
    // Arrange
    String payload = "{\"evento\":\"TESTE\"}";
    String secret = "meu-secret";

    String signature = gerarSignature(payload, secret);

    // Act
    boolean valido = verificarSignature(payload, signature, secret);

    // Assert
    assertTrue(valido);
}

@Test
void deveRejeitarSignatureInvalida() {
    // Arrange
    String payload = "{\"evento\":\"TESTE\"}";
    String secret = "meu-secret";
    String signatureInvalida = "sha256=invalido";

    // Act
    boolean valido = verificarSignature(payload, signatureInvalida, secret);

    // Assert
    assertFalse(valido);
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **HMAC Signature**: Sempre validar autenticidade
- ‚úÖ **Idempot√™ncia**: Evitar processar duplicatas
- ‚úÖ **Retry com Backoff**: Exponential backoff para retries
- ‚úÖ **Timeout**: Definir timeout razo√°vel (5-10s)
- ‚úÖ **HTTPS**: Usar HTTPS para seguran√ßa
- ‚úÖ **Logging**: Registrar todas as tentativas
- ‚úÖ **Dead Letter Queue**: Para webhooks que sempre falham

---

## üîó Webhook vs Polling vs WebSocket

| Caracter√≠stica   | Webhook              | Polling              | WebSocket    |
| ---------------- | -------------------- | -------------------- | ------------ |
| **Dire√ß√£o**      | Push (server‚Üíclient) | Pull (client‚Üíserver) | Bidirecional |
| **Lat√™ncia**     | ‚ö° Instant√¢neo       | üêå 1-30s             | ‚ö° ~0ms      |
| **Overhead**     | Baixo                | ‚ùå Alto              | Baixo        |
| **Conex√£o**      | Por evento           | Constante            | Persistente  |
| **Complexidade** | M√©dia                | Baixa                | Alta         |
| **Use Case**     | Integra√ß√µes          | Simples              | Real-time    |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens   | ‚ö†Ô∏è Desvantagens                |
| -------------- | ------------------------------ |
| Event-driven   | Cliente precisa expor endpoint |
| Sem polling    | Retry complexo                 |
| Instant√¢neo    | Debugging dif√≠cil              |
| Escal√°vel      | Idempot√™ncia necess√°ria        |
| Desacoplado    | Seguran√ßa (HMAC)               |
| Baixo overhead | Firewall issues                |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Webhook quando:

- Integra√ß√µes entre sistemas
- Notifica√ß√µes de eventos
- Payment gateways
- CI/CD pipelines
- GitHub/GitLab events

### ‚ùå Evite Webhook quando:

- Cliente n√£o pode expor endpoint
- Tempo real bidirecional (use WebSocket)
- Dados sens√≠veis sem HTTPS
- Simplicidade priorit√°ria

---

**Webhooks permitem integra√ß√µes event-driven com notifica√ß√µes push instant√¢neas!** ü™ù‚ö°
