# 4.1 Circuit Breaker Pattern [EXPERT]

ğŸ¯ **Objetivo:** Implementar e testar o padrÃ£o Circuit Breaker para proteger sistemas contra falhas em cascata, bloqueando chamadas a serviÃ§os degradados.

---

## ğŸ”Œ O Que Ã‰ Circuit Breaker?

PadrÃ£o que **monitora falhas** e **interrompe chamadas** temporariamente quando um serviÃ§o externo estÃ¡ degradado, permitindo recuperaÃ§Ã£o sem sobrecarregar o sistema.

### Analogia FÃ­sica

Como um disjuntor elÃ©trico: detecta sobrecarga e **abre o circuito** automaticamente para evitar danos maiores.

---

## ğŸ¯ Problema que Resolve

### CenÃ¡rio Sem Circuit Breaker

```
Cliente â†’ [Timeout 30s] â†’ ServiÃ§o Lento (down)
  â†“
100 threads bloqueadas aguardando timeout
  â†“
Sistema satura e para de responder
  â†“
CASCATA DE FALHAS
```

### Com Circuit Breaker

```
Cliente â†’ Circuit Breaker (OPEN) â†’ âŒ Falha rÃ¡pida ou Fallback
  â†“
Threads nÃ£o bloqueiam
  â†“
Sistema continua operacional
  â†“
ISOLAMENTO DE FALHA
```

---

## ğŸ”„ Estados do Circuit Breaker

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   CLOSED    â”‚ â† Estado normal: chamadas passam
        â”‚  (Normal)   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
        Falhas >= Limiar
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚    OPEN     â”‚ â† Circuito aberto: chamadas bloqueadas
        â”‚  (Aberto)   â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
        Cooldown expirou
               â”‚
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  HALF-OPEN  â”‚ â† Teste: permite 1 chamada
        â”‚  (Teste)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       Sucesso â”‚  â”‚ Falha
               â–¼  â–¼
          CLOSED  OPEN
```

### CLOSED (Fechado)

- âœ… OperaÃ§Ã£o normal
- âœ… Chamadas passam normalmente
- ğŸ“Š Contador de falhas zerado ou baixo

### OPEN (Aberto)

- âŒ Circuito aberto, chamadas bloqueadas
- âš¡ Retorna **falha imediata** ou executa fallback
- â± Aguarda perÃ­odo de **cooldown**

### HALF-OPEN (Meio Aberto)

- ğŸ§ª PerÃ­odo de **teste**
- âœ… Permite **1 chamada** para verificar recuperaÃ§Ã£o
- Se sucesso â†’ CLOSED
- Se falha â†’ OPEN novamente

---

## ğŸ’» ImplementaÃ§Ã£o com Java 17

### Estrutura Base

```java
enum Estado { CLOSED, OPEN, HALF_OPEN }

@FunctionalInterface
interface Acao<T> {
    T executar() throws Exception;
}

final class CircuitBreaker {
    private Estado estado = Estado.CLOSED;
    private int falhas = 0;
    private final int limiteFalhas;
    private long abertoAte;
    private final long cooldownMs;

    CircuitBreaker(int limiteFalhas, long cooldownMs) {
        this.limiteFalhas = limiteFalhas;
        this.cooldownMs = cooldownMs;
    }

    synchronized <T> T executar(Acao<T> acao, Acao<T> fallback) throws Exception {
        long agora = System.currentTimeMillis();

        // Se OPEN, verificar se cooldown expirou
        if (estado == Estado.OPEN) {
            if (agora >= abertoAte) {
                estado = Estado.HALF_OPEN;
            } else {
                // Ainda em cooldown â†’ fallback
                return fallback.executar();
            }
        }

        try {
            T resultado = acao.executar();

            // Sucesso em HALF_OPEN â†’ fechar circuito
            if (estado == Estado.HALF_OPEN) {
                resetar();
            }

            return resultado;

        } catch (Exception e) {
            registrarFalha(agora);

            if (estado == Estado.OPEN) {
                return fallback.executar();
            }

            throw e;
        }
    }

    private void registrarFalha(long agora) {
        falhas++;
        if (estado == Estado.HALF_OPEN || falhas >= limiteFalhas) {
            abrir(agora);
        }
    }

    private void abrir(long agora) {
        estado = Estado.OPEN;
        abertoAte = agora + cooldownMs;
    }

    private void resetar() {
        estado = Estado.CLOSED;
        falhas = 0;
    }

    public Estado getEstado() {
        return estado;
    }
}
```

---

## ğŸ§ª Como Testar o Pattern

### Teste 1: Circuito Fechado em Sucesso

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CircuitBreakerTest {

    @Test
    void deveManterCircuitoFechadoQuandoSucesso() throws Exception {
        CircuitBreaker cb = new CircuitBreaker(2, 100);

        Acao<String> acao = () -> "OK";
        Acao<String> fallback = () -> "FALLBACK";

        String resultado = cb.executar(acao, fallback);

        assertEquals("OK", resultado);
        assertEquals(Estado.CLOSED, cb.getEstado());
    }
}
```

### Teste 2: Abertura ApÃ³s Limiar de Falhas

```java
@Test
void deveAbrirCircuitoAposLimiteDeFalhas() {
    CircuitBreaker cb = new CircuitBreaker(2, 200);

    Acao<String> acaoComFalha = () -> {
        throw new RuntimeException("ServiÃ§o indisponÃ­vel");
    };
    Acao<String> fallback = () -> "FALLBACK";

    // 1Âª falha - circuito ainda fechado
    assertThrows(RuntimeException.class,
        () -> cb.executar(acaoComFalha, fallback));
    assertEquals(Estado.CLOSED, cb.getEstado());

    // 2Âª falha - atinge limiar, abre circuito
    assertThrows(RuntimeException.class,
        () -> cb.executar(acaoComFalha, fallback));
    assertEquals(Estado.OPEN, cb.getEstado());

    // 3Âª tentativa - circuito OPEN, retorna fallback sem executar aÃ§Ã£o
    String resultado = assertDoesNotThrow(
        () -> cb.executar(acaoComFalha, fallback));
    assertEquals("FALLBACK", resultado);
}
```

### Teste 3: TransiÃ§Ã£o HALF-OPEN apÃ³s Cooldown

```java
@Test
void deveTransitarParaHalfOpenAposCooldown() throws Exception {
    CircuitBreaker cb = new CircuitBreaker(1, 50);

    Acao<String> falha = () -> {
        throw new IllegalStateException("down");
    };
    Acao<String> fallback = () -> "CACHE";

    // Abrir circuito
    assertThrows(IllegalStateException.class,
        () -> cb.executar(falha, fallback));
    assertEquals(Estado.OPEN, cb.getEstado());

    // Aguardar cooldown
    Thread.sleep(70);

    // PrÃ³xima chamada entra em HALF_OPEN e testa recuperaÃ§Ã£o
    Acao<String> sucesso = () -> "RECUPERADO";
    String resultado = cb.executar(sucesso, fallback);

    assertEquals("RECUPERADO", resultado);
    assertEquals(Estado.CLOSED, cb.getEstado());
}
```

### Teste 4: Falha em HALF-OPEN Reabre Circuito

```java
@Test
void deveFalharEmHalfOpenEReabrirCircuito() throws Exception {
    CircuitBreaker cb = new CircuitBreaker(1, 50);

    Acao<String> falha = () -> {
        throw new RuntimeException("Ainda indisponÃ­vel");
    };
    Acao<String> fallback = () -> "FALLBACK";

    // Abrir circuito
    assertThrows(RuntimeException.class,
        () -> cb.executar(falha, fallback));

    // Aguardar cooldown
    Thread.sleep(70);

    // Tentativa em HALF_OPEN falha â†’ volta para OPEN
    String resultado = cb.executar(falha, fallback);

    assertEquals("FALLBACK", resultado);
    assertEquals(Estado.OPEN, cb.getEstado());
}
```

### Teste 5: Chamadas Concorrentes

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    CircuitBreaker cb = new CircuitBreaker(5, 100);
    AtomicInteger sucessos = new AtomicInteger(0);
    AtomicInteger fallbacks = new AtomicInteger(0);

    int threads = 10;
    CountDownLatch latch = new CountDownLatch(threads);

    for (int i = 0; i < threads; i++) {
        int index = i;
        new Thread(() -> {
            try {
                Acao<String> acao = () -> {
                    if (index < 5) throw new RuntimeException();
                    return "OK";
                };

                String resultado = cb.executar(acao, () -> "FB");

                if ("OK".equals(resultado)) sucessos.incrementAndGet();
                if ("FB".equals(resultado)) fallbacks.incrementAndGet();

            } catch (Exception ignored) {
            } finally {
                latch.countDown();
            }
        }).start();
    }

    assertTrue(latch.await(5, TimeUnit.SECONDS));
    assertTrue(sucessos.get() + fallbacks.get() <= threads);
}
```

---

## ğŸ“Š Boas PrÃ¡ticas de Teste

### âœ… O Que Testar

- [ ] Estado inicial Ã© **CLOSED**
- [ ] TransiÃ§Ã£o **CLOSED â†’ OPEN** apÃ³s limiar
- [ ] Fallback executado quando **OPEN**
- [ ] TransiÃ§Ã£o **OPEN â†’ HALF_OPEN** apÃ³s cooldown
- [ ] **HALF_OPEN â†’ CLOSED** em sucesso
- [ ] **HALF_OPEN â†’ OPEN** em falha
- [ ] Thread safety (synchronized/locks)
- [ ] MÃ©tricas exportadas corretamente

### âš  Evitar

- âŒ Sleeps longos (usar valores mÃ­nimos para testes)
- âŒ Depender de tempo real (usar Clock injetÃ¡vel em produÃ§Ã£o)
- âŒ Testar implementaÃ§Ã£o interna (focar em comportamento)

---

## âš™ Frameworks de ProduÃ§Ã£o

### Resilience4j

```java
CircuitBreakerConfig config = CircuitBreakerConfig.custom()
    .failureRateThreshold(50)
    .waitDurationInOpenState(Duration.ofSeconds(10))
    .permittedNumberOfCallsInHalfOpenState(3)
    .slidingWindowSize(10)
    .build();

CircuitBreaker cb = CircuitBreaker.of("backend", config);

String result = cb.executeSupplier(() -> remoteService.call());
```

### Spring Cloud Circuit Breaker

```java
@CircuitBreaker(name = "backendA", fallbackMethod = "fallbackMethod")
public String serviceCall() {
    return restTemplate.getForObject("/api/data", String.class);
}

private String fallbackMethod(Exception e) {
    return "Resposta alternativa";
}
```

---

## ğŸ“ Vantagens vs Desvantagens

### âœ… Vantagens

- **ProteÃ§Ã£o contra cascata**: Isola falhas
- **RecuperaÃ§Ã£o automÃ¡tica**: Detecta quando serviÃ§o volta
- **LatÃªncia reduzida**: Falha rÃ¡pida em vez de timeout
- **Conserva recursos**: NÃ£o desperdiÃ§a threads

### âš  Desvantagens

- **ConfiguraÃ§Ã£o crÃ­tica**: Limiar/cooldown errados prejudicam
- **Complexidade**: 3 estados, transiÃ§Ãµes, thread safety
- **Falsos positivos**: Pode bloquear serviÃ§o saudÃ¡vel
- **Sobrecarga**: SincronizaÃ§Ã£o e contadores

---

## ğŸ” ComparaÃ§Ã£o com Outros Patterns

| Pattern             | Comportamento                           | Quando Usar                    |
| ------------------- | --------------------------------------- | ------------------------------ |
| **Circuit Breaker** | Bloqueia chamadas apÃ³s padrÃ£o de falhas | Proteger de serviÃ§os instÃ¡veis |
| **Retry**           | Reexecuta tentativas com backoff        | Falhas transientes/temporÃ¡rias |
| **Timeout**         | Limita tempo de execuÃ§Ã£o                | Evitar bloqueios indefinidos   |
| **Fallback**        | Retorna resposta alternativa            | DegradaÃ§Ã£o graciosa            |
| **Bulkhead**        | Isola pools de recursos                 | Evitar que falha consuma tudo  |

### CombinaÃ§Ãµes Comuns

```java
// Circuit Breaker + Fallback + Timeout
CircuitBreaker
    .decorateSupplier(cb,
        Timeout.decorateSupplier(timeout,
            () -> remoteService.call()
        )
    )
    .recover(Exception.class, fallbackValue);
```

---

## ğŸ§  ExercÃ­cios PrÃ¡ticos

### 1. Implementar Janela Deslizante

Modificar Circuit Breaker para usar **sliding window** (Ãºltimas N chamadas) em vez de contador simples.

### 2. Adicionar MÃ©tricas

Instrumentar com contadores:

- Total de chamadas bloqueadas
- DuraÃ§Ã£o em cada estado
- Taxa de sucesso em HALF_OPEN

### 3. ConfiguraÃ§Ã£o DinÃ¢mica

Permitir alterar limiar/cooldown em runtime via JMX ou endpoint HTTP.

### 4. Circuit Breaker HierÃ¡rquico

Implementar CB pai que controla mÃºltiplos CBs filhos (diferentes endpoints).

---

## ğŸ“š ReferÃªncias

- **Livros:**

  - "Release It!" (Michael Nygard) - origem do pattern
  - "Building Microservices" (Sam Newman)

- **Frameworks:**

  - [Resilience4j](https://resilience4j.readme.io/docs/circuitbreaker)
  - [Spring Cloud Circuit Breaker](https://spring.io/projects/spring-cloud-circuitbreaker)
  - [Netflix Hystrix](https://github.com/Netflix/Hystrix) (legacy, referÃªncia histÃ³rica)

- **Artigos:**
  - [Martin Fowler - Circuit Breaker](https://martinfowler.com/bliki/CircuitBreaker.html)

---

## ğŸ“š PrÃ³ximos Passos

- [4.2 Retry Pattern](04.2-retry.md) - Tentativas com backoff
- [4.3 Fallback Pattern](04.3-fallback.md) - Respostas alternativas
- [4.4 Timeout Pattern](04.4-timeout.md) - Limites de tempo
- [4.5 Bulkhead Pattern](04.5-bulkhead.md) - Isolamento de recursos
- [Voltar ao Ãndice](../../README.md)

---

**Ãšltima AtualizaÃ§Ã£o:** 2025-11-14  
**NÃ­vel:** [EXPERT]  
**Tempo Estimado:** 3 horas  
**Frameworks:** Resilience4j, Spring Cloud, MicroProfile Fault Tolerance
