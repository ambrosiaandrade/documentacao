# 04.26 Chain of Responsibility [M√âDIO] ‚õìÔ∏è

## üéØ Objetivo

Permitir que **m√∫ltiplos objetos** processem uma requisi√ß√£o, encadeando handlers e permitindo que cada um decida se processa ou passa adiante, facilitando **testes de cada handler isoladamente**.

---

## üìö O Que √â?

**Chain of Responsibility** √© um padr√£o comportamental GoF que evita acoplar o remetente de uma requisi√ß√£o ao seu receptor, dando a m√∫ltiplos objetos a chance de processar a requisi√ß√£o. Encadeia os objetos receptores e passa a requisi√ß√£o pela cadeia at√© que algum objeto a processe.

### Analogia

Como um **atendimento ao cliente**:

- **N√≠vel 1**: Atendente (problemas simples)
- **N√≠vel 2**: Supervisor (problemas m√©dios)
- **N√≠vel 3**: Gerente (problemas complexos)
- **Vantagem**: Cada n√≠vel tenta resolver, se n√£o consegue, escala para pr√≥ximo

---

## ‚ùå Problema que Resolve

### Antes (if/else Acoplado)

```java
// ‚ùå PROBLEMA: L√≥gica centralizada com m√∫ltiplas responsabilidades
class PedidoValidator {
    void validar(Pedido pedido) {
        // Valida√ß√£o de campos obrigat√≥rios
        if (pedido.getCliente() == null) {
            throw new ValidationException("Cliente obrigat√≥rio");
        }

        // Valida√ß√£o de valor
        if (pedido.getValor().compareTo(BigDecimal.ZERO) <= 0) {
            throw new ValidationException("Valor inv√°lido");
        }

        // Valida√ß√£o de estoque
        if (!estoqueService.temDisponivel(pedido.getProdutos())) {
            throw new ValidationException("Estoque insuficiente");
        }

        // Valida√ß√£o de limite de cr√©dito
        if (!creditoService.temLimite(pedido.getCliente(), pedido.getValor())) {
            throw new ValidationException("Limite de cr√©dito excedido");
        }

        // Adicionar nova valida√ß√£o = modificar este m√©todo ‚ùå
        // Dif√≠cil testar valida√ß√µes isoladamente ‚ùå
    }
}
```

**Problemas**:

- üîó Valida√ß√µes acopladas em um m√©todo gigante
- üîß Adicionar valida√ß√£o = modificar classe existente
- üß™ Dif√≠cil testar valida√ß√µes isoladamente
- üîÑ Imposs√≠vel reordenar ou desabilitar valida√ß√µes
- üìö M√∫ltiplas responsabilidades em um lugar

### Depois (Chain of Responsibility)

```java
// ‚úÖ SOLU√á√ÉO: Cadeia de handlers independentes
interface ValidationHandler {
    void validar(Pedido pedido);
    void setNext(ValidationHandler next);
}

abstract class BaseValidationHandler implements ValidationHandler {
    private ValidationHandler next;

    public void setNext(ValidationHandler next) {
        this.next = next;
    }

    protected void validarProximo(Pedido pedido) {
        if (next != null) {
            next.validar(pedido);
        }
    }
}

class CamposObrigatoriosHandler extends BaseValidationHandler {
    public void validar(Pedido pedido) {
        if (pedido.getCliente() == null) {
            throw new ValidationException("Cliente obrigat√≥rio");
        }
        validarProximo(pedido); // Passa para pr√≥ximo
    }
}

class ValorMinimoHandler extends BaseValidationHandler {
    public void validar(Pedido pedido) {
        if (pedido.getValor().compareTo(BigDecimal.ZERO) <= 0) {
            throw new ValidationException("Valor inv√°lido");
        }
        validarProximo(pedido);
    }
}

// Compor cadeia
ValidationHandler cadeia = new CamposObrigatoriosHandler();
cadeia.setNext(new ValorMinimoHandler());
cadeia.setNext(new EstoqueHandler());
cadeia.setNext(new CreditoHandler());

// Testar handler isoladamente
@Test
void camposObrigatoriosDeveValidar() {
    ValidationHandler handler = new CamposObrigatoriosHandler();
    // Sem pr√≥ximo handler - teste isolado

    Pedido invalido = new Pedido(null, valor);
    assertThrows(ValidationException.class, () -> handler.validar(invalido));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Handler

```java
interface PedidoHandler {
    ResultadoProcessamento processar(Pedido pedido);
    void setProximo(PedidoHandler proximo);
}

record ResultadoProcessamento(
    boolean processado,
    String mensagem,
    boolean continuarCadeia
) {
    static ResultadoProcessamento processado(String mensagem) {
        return new ResultadoProcessamento(true, mensagem, false);
    }

    static ResultadoProcessamento naoProcessado() {
        return new ResultadoProcessamento(false, "N√£o processado", true);
    }

    static ResultadoProcessamento processadoContinuar(String mensagem) {
        return new ResultadoProcessamento(true, mensagem, true);
    }
}
```

### 2. Handler Base Abstrato

```java
abstract class BasePedidoHandler implements PedidoHandler {
    private PedidoHandler proximo;

    @Override
    public void setProximo(PedidoHandler proximo) {
        this.proximo = proximo;
    }

    @Override
    public final ResultadoProcessamento processar(Pedido pedido) {
        System.out.println("üîç [" + getNome() + "] Processando pedido " + pedido.id());

        ResultadoProcessamento resultado = processarInterno(pedido);

        if (resultado.processado()) {
            System.out.println("‚úÖ [" + getNome() + "] " + resultado.mensagem());
        } else {
            System.out.println("‚è≠Ô∏è  [" + getNome() + "] N√£o processado, passando adiante");
        }

        // Continua cadeia se necess√°rio
        if (resultado.continuarCadeia() && proximo != null) {
            return proximo.processar(pedido);
        }

        return resultado;
    }

    protected abstract ResultadoProcessamento processarInterno(Pedido pedido);
    protected abstract String getNome();
}
```

### 3. Handlers Concretos

```java
// Handler: Valida√ß√£o de Campos
final class ValidacaoCamposHandler extends BasePedidoHandler {

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        List<String> erros = new ArrayList<>();

        if (pedido.id() == null || pedido.id().isBlank()) {
            erros.add("ID obrigat√≥rio");
        }

        if (pedido.cliente() == null || pedido.cliente().isBlank()) {
            erros.add("Cliente obrigat√≥rio");
        }

        if (pedido.valor() == null || pedido.valor().compareTo(BigDecimal.ZERO) <= 0) {
            erros.add("Valor deve ser positivo");
        }

        if (!erros.isEmpty()) {
            throw new ValidationException("Valida√ß√£o falhou: " + String.join(", ", erros));
        }

        return ResultadoProcessamento.processadoContinuar("Campos v√°lidos");
    }

    @Override
    protected String getNome() {
        return "ValidacaoCampos";
    }
}

// Handler: Desconto por Valor
final class DescontoHandler extends BasePedidoHandler {
    private final BigDecimal limiteDesconto;
    private final BigDecimal percentualDesconto;

    DescontoHandler(BigDecimal limiteDesconto, BigDecimal percentualDesconto) {
        this.limiteDesconto = limiteDesconto;
        this.percentualDesconto = percentualDesconto;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        if (pedido.valor().compareTo(limiteDesconto) >= 0) {
            BigDecimal desconto = pedido.valor()
                .multiply(percentualDesconto)
                .divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP);

            System.out.println("  üí∞ Desconto aplicado: " + percentualDesconto + "% (R$ " + desconto + ")");

            return ResultadoProcessamento.processadoContinuar(
                "Desconto de " + percentualDesconto + "% aplicado"
            );
        }

        return ResultadoProcessamento.naoProcessado();
    }

    @Override
    protected String getNome() {
        return "Desconto";
    }
}

// Handler: Aprova√ß√£o por Valor
final class AprovacaoHandler extends BasePedidoHandler {
    private final BigDecimal limiteAutomatico;

    AprovacaoHandler(BigDecimal limiteAutomatico) {
        this.limiteAutomatico = limiteAutomatico;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        if (pedido.valor().compareTo(limiteAutomatico) <= 0) {
            System.out.println("  ‚úÖ Aprova√ß√£o autom√°tica (valor abaixo de R$ " + limiteAutomatico + ")");
            return ResultadoProcessamento.processado("Aprovado automaticamente");
        }

        // Valor alto - passa para pr√≥ximo handler (aprova√ß√£o manual)
        return ResultadoProcessamento.naoProcessado();
    }

    @Override
    protected String getNome() {
        return "AprovacaoAutomatica";
    }
}

// Handler: Aprova√ß√£o Manual
final class AprovacaoManualHandler extends BasePedidoHandler {

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        System.out.println("  üìã Pedido enviado para aprova√ß√£o manual");
        System.out.println("  ‚è≥ Aguardando revis√£o do gerente...");

        return ResultadoProcessamento.processado("Enviado para aprova√ß√£o manual");
    }

    @Override
    protected String getNome() {
        return "AprovacaoManual";
    }
}

// Handler: Notifica√ß√£o
final class NotificacaoHandler extends BasePedidoHandler {
    private final NotificacaoService notificacaoService;

    NotificacaoHandler(NotificacaoService notificacaoService) {
        this.notificacaoService = notificacaoService;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        notificacaoService.notificar(
            pedido.cliente(),
            "Pedido " + pedido.id() + " recebido"
        );

        return ResultadoProcessamento.processadoContinuar("Cliente notificado");
    }

    @Override
    protected String getNome() {
        return "Notificacao";
    }
}

// Handler: Logging
final class LoggingHandler extends BasePedidoHandler {
    private final AtomicInteger contador = new AtomicInteger(0);

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        int count = contador.incrementAndGet();
        System.out.println("  üìù Log registrado (#" + count + "): " + pedido.id());

        return ResultadoProcessamento.processadoContinuar("Pedido logado");
    }

    @Override
    protected String getNome() {
        return "Logging";
    }

    int getTotalProcessados() {
        return contador.get();
    }
}
```

### 4. Chain Builder (Fluent Interface)

```java
final class PedidoHandlerChainBuilder {
    private PedidoHandler primeiro;
    private PedidoHandler ultimo;

    PedidoHandlerChainBuilder addHandler(PedidoHandler handler) {
        if (primeiro == null) {
            primeiro = handler;
            ultimo = handler;
        } else {
            ultimo.setProximo(handler);
            ultimo = handler;
        }

        return this;
    }

    PedidoHandlerChainBuilder validacao() {
        return addHandler(new ValidacaoCamposHandler());
    }

    PedidoHandlerChainBuilder desconto(BigDecimal limite, BigDecimal percentual) {
        return addHandler(new DescontoHandler(limite, percentual));
    }

    PedidoHandlerChainBuilder aprovacaoAutomatica(BigDecimal limite) {
        return addHandler(new AprovacaoHandler(limite));
    }

    PedidoHandlerChainBuilder aprovacaoManual() {
        return addHandler(new AprovacaoManualHandler());
    }

    PedidoHandlerChainBuilder notificacao(NotificacaoService service) {
        return addHandler(new NotificacaoHandler(service));
    }

    PedidoHandlerChainBuilder logging() {
        return addHandler(new LoggingHandler());
    }

    PedidoHandler build() {
        if (primeiro == null) {
            throw new IllegalStateException("Cadeia vazia - adicione pelo menos um handler");
        }
        return primeiro;
    }

    static PedidoHandlerChainBuilder criar() {
        return new PedidoHandlerChainBuilder();
    }
}
```

### 5. Chain com Prioridade

```java
final class PriorityHandler extends BasePedidoHandler {
    private final List<PedidoHandler> handlers;

    PriorityHandler(List<PedidoHandler> handlers) {
        this.handlers = new ArrayList<>(handlers);
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        for (PedidoHandler handler : handlers) {
            ResultadoProcessamento resultado = handler.processar(pedido);

            if (resultado.processado() && !resultado.continuarCadeia()) {
                return resultado; // Para na primeira que processar completamente
            }
        }

        return ResultadoProcessamento.naoProcessado();
    }

    @Override
    protected String getNome() {
        return "PriorityChain";
    }
}
```

### 6. Chain com Filtro (Conditional)

```java
final class ConditionalHandler extends BasePedidoHandler {
    private final PedidoHandler handler;
    private final Predicate<Pedido> condicao;
    private final String nomeCondicao;

    ConditionalHandler(String nomeCondicao, Predicate<Pedido> condicao, PedidoHandler handler) {
        this.nomeCondicao = nomeCondicao;
        this.condicao = condicao;
        this.handler = handler;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        if (condicao.test(pedido)) {
            System.out.println("  ‚úÖ Condi√ß√£o '" + nomeCondicao + "' satisfeita");
            return handler.processar(pedido);
        }

        System.out.println("  ‚è≠Ô∏è  Condi√ß√£o '" + nomeCondicao + "' n√£o satisfeita");
        return ResultadoProcessamento.naoProcessado();
    }

    @Override
    protected String getNome() {
        return "Conditional[" + nomeCondicao + "]";
    }
}
```

### 7. Chain com Circuit Breaker

```java
final class CircuitBreakerHandler extends BasePedidoHandler {
    private final PedidoHandler handler;
    private final AtomicInteger falhas = new AtomicInteger(0);
    private final int limiteFalhas;
    private volatile boolean circuitoAberto = false;

    CircuitBreakerHandler(PedidoHandler handler, int limiteFalhas) {
        this.handler = handler;
        this.limiteFalhas = limiteFalhas;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        if (circuitoAberto) {
            System.err.println("  üö® Circuito aberto - handler desabilitado");
            return ResultadoProcessamento.naoProcessado();
        }

        try {
            ResultadoProcessamento resultado = handler.processar(pedido);
            falhas.set(0); // Reset em caso de sucesso
            return resultado;

        } catch (Exception e) {
            int totalFalhas = falhas.incrementAndGet();
            System.err.println("  ‚ùå Falha #" + totalFalhas + " detectada");

            if (totalFalhas >= limiteFalhas) {
                circuitoAberto = true;
                System.err.println("  üö® CIRCUITO ABERTO - limite de " + limiteFalhas + " falhas atingido");
            }

            throw e;
        }
    }

    @Override
    protected String getNome() {
        return "CircuitBreaker";
    }

    void resetarCircuito() {
        circuitoAberto = false;
        falhas.set(0);
        System.out.println("  üîÑ Circuito resetado");
    }

    boolean isCircuitoAberto() {
        return circuitoAberto;
    }
}
```

### 8. M√©tricas da Chain

```java
final class MetricsHandler extends BasePedidoHandler {
    private final PedidoHandler handler;
    private final AtomicInteger processados = new AtomicInteger(0);
    private final AtomicInteger falhas = new AtomicInteger(0);
    private final AtomicLong tempoTotal = new AtomicLong(0);

    MetricsHandler(PedidoHandler handler) {
        this.handler = handler;
    }

    @Override
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        long inicio = System.nanoTime();

        try {
            ResultadoProcessamento resultado = handler.processar(pedido);
            processados.incrementAndGet();
            return resultado;

        } catch (Exception e) {
            falhas.incrementAndGet();
            throw e;

        } finally {
            long duracao = System.nanoTime() - inicio;
            tempoTotal.addAndGet(duracao);
        }
    }

    @Override
    protected String getNome() {
        return "Metrics";
    }

    HandlerMetrics getMetrics() {
        int total = processados.get();
        double tempoMedioMs = total == 0 ? 0.0 : (tempoTotal.get() / total) / 1_000_000.0;

        return new HandlerMetrics(
            processados.get(),
            falhas.get(),
            tempoMedioMs,
            calcularTaxaSucesso()
        );
    }

    private double calcularTaxaSucesso() {
        int total = processados.get() + falhas.get();
        if (total == 0) return 100.0;

        return (processados.get() * 100.0) / total;
    }
}

record HandlerMetrics(int processados, int falhas, double tempoMedioMs, double taxaSucesso) {}
```

---

## üß™ Como Testar

### 1. Testar Handler Isoladamente

```java
@Test
void validacaoCamposDeveRejeitarPedidoInvalido() {
    // Arrange
    PedidoHandler handler = new ValidacaoCamposHandler();
    Pedido pedidoInvalido = new Pedido("", "", BigDecimal.ZERO, Status.PENDENTE);

    // Act & Assert
    ValidationException ex = assertThrows(
        ValidationException.class,
        () -> handler.processar(pedidoInvalido)
    );

    assertTrue(ex.getMessage().contains("ID obrigat√≥rio"));
}
```

### 2. Testar Cadeia Completa

```java
@Test
void deveProcessarCadeiaCompleta() {
    // Arrange
    NotificacaoService serviceMock = mock(NotificacaoService.class);

    PedidoHandler cadeia = PedidoHandlerChainBuilder.criar()
        .validacao()
        .desconto(new BigDecimal("500"), new BigDecimal("10"))
        .aprovacaoAutomatica(new BigDecimal("1000"))
        .notificacao(serviceMock)
        .build();

    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("600"), Status.PENDENTE);

    // Act
    ResultadoProcessamento resultado = cadeia.processar(pedido);

    // Assert
    assertTrue(resultado.processado());
    verify(serviceMock).notificar("Cliente A", "Pedido PED-001 recebido");
}
```

### 3. Testar Handler Passa Adiante

```java
@Test
void descontoHandlerDevePassarAdianteSeValorBaixo() {
    // Arrange
    PedidoHandler proximoMock = mock(PedidoHandler.class);
    when(proximoMock.processar(any())).thenReturn(
        ResultadoProcessamento.processado("Pr√≥ximo processou")
    );

    DescontoHandler handler = new DescontoHandler(
        new BigDecimal("1000"), // Limite
        new BigDecimal("10")
    );
    handler.setProximo(proximoMock);

    Pedido pedidoBaixoValor = new Pedido("PED-001", "Cliente", new BigDecimal("500"), Status.PENDENTE);

    // Act
    handler.processar(pedidoBaixoValor);

    // Assert - Passou para pr√≥ximo
    verify(proximoMock).processar(pedidoBaixoValor);
}
```

### 4. Testar Interrup√ß√£o da Cadeia

```java
@Test
void aprovacaoAutomaticaDeveInterromperCadeia() {
    // Arrange
    PedidoHandler proximoMock = mock(PedidoHandler.class);

    AprovacaoHandler handler = new AprovacaoHandler(new BigDecimal("1000"));
    handler.setProximo(proximoMock);

    Pedido pedidoBaixoValor = new Pedido("PED-001", "Cliente", new BigDecimal("500"), Status.PENDENTE);

    // Act
    ResultadoProcessamento resultado = handler.processar(pedidoBaixoValor);

    // Assert - N√ÉO passou para pr√≥ximo (aprova√ß√£o autom√°tica interrompeu)
    assertTrue(resultado.processado());
    assertFalse(resultado.continuarCadeia());
    verify(proximoMock, never()).processar(any());
}
```

### 5. Testar Conditional Handler

```java
@Test
void conditionalHandlerDevePularSeCondicaoNaoSatisfeita() {
    // Arrange
    PedidoHandler handlerInterno = mock(PedidoHandler.class);

    ConditionalHandler handler = new ConditionalHandler(
        "Valor > 1000",
        p -> p.valor().compareTo(new BigDecimal("1000")) > 0,
        handlerInterno
    );

    Pedido pedidoBaixo = new Pedido("PED-001", "Cliente", new BigDecimal("500"), Status.PENDENTE);

    // Act
    ResultadoProcessamento resultado = handler.processar(pedidoBaixo);

    // Assert - N√£o processou (condi√ß√£o n√£o satisfeita)
    assertFalse(resultado.processado());
    verify(handlerInterno, never()).processar(any());
}
```

### 6. Testar Circuit Breaker

```java
@Test
void circuitBreakerDeveAbrirAposLimiteDeFalhas() {
    // Arrange
    PedidoHandler falhoMock = mock(PedidoHandler.class);
    when(falhoMock.processar(any())).thenThrow(new RuntimeException("Erro simulado"));

    CircuitBreakerHandler cb = new CircuitBreakerHandler(falhoMock, 3);

    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);

    // Act - Falha 3 vezes
    assertThrows(RuntimeException.class, () -> cb.processar(pedido));
    assertThrows(RuntimeException.class, () -> cb.processar(pedido));
    assertThrows(RuntimeException.class, () -> cb.processar(pedido));

    // Assert - Circuito aberto
    assertTrue(cb.isCircuitoAberto());

    // Pr√≥xima tentativa n√£o chama handler (circuito aberto)
    ResultadoProcessamento resultado = cb.processar(pedido);
    assertFalse(resultado.processado());

    verify(falhoMock, times(3)).processar(any()); // Apenas 3 chamadas
}
```

### 7. Testar M√©tricas

```java
@Test
void metricsHandlerDeveRastrearProcessamento() {
    // Arrange
    PedidoHandler handler = mock(PedidoHandler.class);
    when(handler.processar(any())).thenReturn(ResultadoProcessamento.processado("OK"));

    MetricsHandler metrics = new MetricsHandler(handler);

    Pedido pedido = new Pedido("PED-001", "Cliente", new BigDecimal("100"), Status.PENDENTE);

    // Act
    metrics.processar(pedido);
    metrics.processar(pedido);
    metrics.processar(pedido);

    HandlerMetrics stats = metrics.getMetrics();

    // Assert
    assertEquals(3, stats.processados());
    assertEquals(0, stats.falhas());
    assertEquals(100.0, stats.taxaSucesso());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Handler modificando pedido sem necessidade
class BadHandler extends BasePedidoHandler {
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        pedido.setValor(BigDecimal.ZERO); // Modifica estado ‚ùå
        return ResultadoProcessamento.processado("OK");
    }
}

// ‚ùå Handler com l√≥gica de neg√≥cio complexa
class OverloadedHandler extends BasePedidoHandler {
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        // Faz muitas coisas ‚ùå
        validar(pedido);
        calcularDesconto(pedido);
        processarPagamento(pedido);
        enviarEmail(pedido);
        // Handler deve ter responsabilidade √∫nica!
    }
}

// ‚ùå Cadeia circular
handler1.setProximo(handler2);
handler2.setProximo(handler1); // ‚ùå Loop infinito!
```

### ‚úÖ Fazer

```java
// ‚úÖ Handler com responsabilidade √∫nica
class GoodHandler extends BasePedidoHandler {
    protected ResultadoProcessamento processarInterno(Pedido pedido) {
        // Apenas uma responsabilidade
        if (isValido(pedido)) {
            return ResultadoProcessamento.processadoContinuar("V√°lido");
        }
        return ResultadoProcessamento.naoProcessado();
    }
}

// ‚úÖ Usar builder para evitar loops
PedidoHandler cadeia = PedidoHandlerChainBuilder.criar()
    .validacao()
    .desconto(limite, percentual)
    .aprovacaoAutomatica(limite)
    .build(); // Builder garante ordem correta

// ‚úÖ Handler imut√°vel (thread-safe)
class ImmutableHandler extends BasePedidoHandler {
    private final BigDecimal limite; // final

    ImmutableHandler(BigDecimal limite) {
        this.limite = limite;
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Responsabilidade √∫nica**: Cada handler uma preocupa√ß√£o
- ‚úÖ **Stateless prefer√≠vel**: Evitar estado mut√°vel compartilhado
- ‚úÖ **Builder pattern**: Facilitar constru√ß√£o da cadeia
- ‚úÖ **Logging**: Rastrear fluxo pela cadeia
- ‚úÖ **Null-safe**: Verificar se h√° pr√≥ximo antes de chamar
- ‚úÖ **Testes isolados**: Testar cada handler sem cadeia completa
- ‚úÖ **M√©tricas**: Instrumentar para observabilidade

---

## üîó Integra√ß√£o com Frameworks

### Spring Interceptors (Chain of Responsibility)

```java
@Component
public class AuthenticationInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler) {
        // Valida autentica√ß√£o
        if (!isAuthenticated(request)) {
            response.setStatus(401);
            return false; // Interrompe cadeia
        }
        return true; // Continua cadeia
    }
}

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new AuthenticationInterceptor())
                .addInterceptor(new LoggingInterceptor())
                .addInterceptor(new RateLimitInterceptor());
        // Chain of Responsibility!
    }
}
```

### Servlet Filters (Chain Cl√°ssico)

```java
public class AuthFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request,
                        ServletResponse response,
                        FilterChain chain) {
        // Processa
        authenticate(request);

        // Passa adiante
        chain.doFilter(request, response);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                        | ‚ö†Ô∏è Desvantagens                            |
| ----------------------------------- | ------------------------------------------ |
| Desacopla emissor de receptor       | Debug pode ser complexo (fluxo n√£o √≥bvio)  |
| Adiciona/remove handlers facilmente | N√£o garante que requisi√ß√£o ser√° processada |
| Testa handlers isoladamente         | Pode ter impacto de performance            |
| Flexibilidade em runtime            | Ordem dos handlers importa                 |
| Segue Open/Closed Principle         | Muitas classes pequenas                    |

---

## üîç Compara√ß√£o

| Padr√£o                      | Prop√≥sito               | Quando Usar                             |
| --------------------------- | ----------------------- | --------------------------------------- |
| **Chain of Responsibility** | Encadear handlers       | M√∫ltiplos handlers podem processar      |
| **Command**                 | Encapsular a√ß√£o         | Undo/redo, filas, macros                |
| **Strategy**                | Trocar algoritmo        | Uma estrat√©gia escolhida                |
| **Decorator**               | Adicionar comportamento | Enriquecer funcionalidade dinamicamente |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Chain com timeout** (limitar tempo de processamento)
2. **Chain com retry** (tentar novamente em caso de falha)
3. **Chain bidirecional** (resposta volta pela cadeia)
4. **Chain async** (processar handlers em paralelo)
5. **Chain com cache** (cachear resultado por handler)

---

## üìö Relacionado

- **Decorator**: Adiciona comportamento (similar mas foca em enriquecer)
- **Command**: Encapsula requisi√ß√µes como objetos
- **Composite**: Composi√ß√£o hier√°rquica (√°rvore)
- **Observer**: Notifica√ß√£o 1-to-N

---

**Chain of Responsibility encadeia handlers, permitindo processar requisi√ß√µes flexivelmente e testar isoladamente!** ‚õìÔ∏è‚ú®
