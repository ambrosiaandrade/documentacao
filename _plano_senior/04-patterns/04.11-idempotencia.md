# 04.11 Idempot√™ncia [M√âDIO] üîÅ

## üéØ Objetivo

Garantir que **m√∫ltiplas execu√ß√µes** da mesma opera√ß√£o produzam o **mesmo efeito √∫nico**, evitando duplica√ß√µes e inconsist√™ncias causadas por retries, reentregas de mensagens ou falhas de rede.

---

## üìö O Que √â?

**Idempot√™ncia** √© a propriedade onde executar uma opera√ß√£o N vezes produz o mesmo resultado que execut√°-la 1 vez. Em sistemas distribu√≠dos, √© essencial para lidar com duplica√ß√µes inevit√°veis.

### Analogia

Como um **interruptor de luz**: apertar o bot√£o "LIGAR" 10 vezes tem o mesmo efeito que apertar 1 vez - a luz fica ligada. N√£o importa quantas vezes voc√™ pressiona, o estado final √© o mesmo.

### Exemplos HTTP

- **Idempotente**: `PUT /users/123`, `DELETE /users/123`, `GET /users/123`
- **N√£o idempotente**: `POST /transactions` (cria nova transa√ß√£o a cada chamada)

---

## ‚ùå Problema que Resolve

### Antes (Sem Idempot√™ncia)

```java
// ‚ùå PROBLEMA: Duplica√ß√µes causam inconsist√™ncia
@KafkaListener(topics = "pagamentos")
public void processarPagamento(PagamentoEvent event) {
    // Sem verifica√ß√£o de idempot√™ncia
    contaRepository.debitar(event.getContaId(), event.getValor());
    faturaRepository.criar(event.getFaturaId(), event.getValor());
    emailService.enviar(event.getEmail(), "Pagamento confirmado");
}

// Cen√°rio: Kafka reenvia mensagem ap√≥s timeout
// Resultado:
// - Conta debitada 2x ‚ùå
// - 2 faturas criadas ‚ùå
// - 2 emails enviados ‚ùå
```

**Problemas**:

- üí∏ Cobran√ßa duplicada (d√©bito 2x)
- üóÇ Dados duplicados (2 faturas com mesmo ID)
- üìß Spam de notifica√ß√µes
- üêõ Dif√≠cil debugar ("foi chamado 1x ou 2x?")

### Depois (Com Idempot√™ncia)

```java
// ‚úÖ SOLU√á√ÉO: Verificar se j√° foi processado
@KafkaListener(topics = "pagamentos")
public void processarPagamento(PagamentoEvent event) {
    if (idempotencyStore.jaProcessado(event.getId())) {
        log.info("Evento {} j√° processado, ignorando duplicata", event.getId());
        return; // Ignora duplicata
    }

    // Processar apenas 1x
    contaRepository.debitar(event.getContaId(), event.getValor());
    faturaRepository.criar(event.getFaturaId(), event.getValor());
    emailService.enviar(event.getEmail(), "Pagamento confirmado");

    // Marcar como processado
    idempotencyStore.marcar(event.getId());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Store de Idempot√™ncia

```java
// Chave de idempot√™ncia
record IdempotencyKey(String key, Instant timestamp) {}

interface IdempotencyStore {
    boolean jaProcessado(String key);
    void marcar(String key);
    void marcar(String key, Duration ttl);
    void limparExpirados();
    int count();
}

final class InMemoryIdempotencyStore implements IdempotencyStore {
    private final Map<String, IdempotencyKey> processados = new ConcurrentHashMap<>();

    @Override
    public boolean jaProcessado(String key) {
        return processados.containsKey(key);
    }

    @Override
    public void marcar(String key) {
        processados.put(key, new IdempotencyKey(key, Instant.now()));
    }

    @Override
    public void marcar(String key, Duration ttl) {
        IdempotencyKey idempKey = new IdempotencyKey(key, Instant.now());
        processados.put(key, idempKey);

        // Agendar remo√ß√£o ap√≥s TTL
        scheduleRemoval(key, ttl);
    }

    @Override
    public void limparExpirados() {
        Instant now = Instant.now();
        processados.entrySet().removeIf(entry ->
            entry.getValue().timestamp().isBefore(now.minus(Duration.ofHours(24)))
        );
    }

    @Override
    public int count() {
        return processados.size();
    }

    private void scheduleRemoval(String key, Duration ttl) {
        // Simplificado - em produ√ß√£o usar ScheduledExecutorService
        new Thread(() -> {
            try {
                Thread.sleep(ttl.toMillis());
                processados.remove(key);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

### 2. Processor Idempotente

```java
@FunctionalInterface
interface EventHandler<T> {
    void handle(T event);
}

final class IdempotentProcessor<T> {
    private final IdempotencyStore store;
    private final EventHandler<T> handler;
    private final Function<T, String> keyExtractor;

    IdempotentProcessor(
        IdempotencyStore store,
        EventHandler<T> handler,
        Function<T, String> keyExtractor
    ) {
        this.store = store;
        this.handler = handler;
        this.keyExtractor = keyExtractor;
    }

    public boolean process(T event) {
        String key = keyExtractor.apply(event);

        // Verifica√ß√£o at√¥mica e marca√ß√£o
        if (store.jaProcessado(key)) {
            System.out.println("üîÅ Duplicata ignorada: " + key);
            return false; // N√£o processou (j√° existia)
        }

        // Processar evento
        handler.handle(event);

        // Marcar como processado
        store.marcar(key);
        System.out.println("‚úÖ Processado: " + key);
        return true; // Processou com sucesso
    }
}
```

### 3. Implementa√ß√£o com TTL (Time To Live)

```java
final class IdempotentProcessorWithTTL<T> {
    private final IdempotencyStore store;
    private final EventHandler<T> handler;
    private final Function<T, String> keyExtractor;
    private final Duration ttl;

    IdempotentProcessorWithTTL(
        IdempotencyStore store,
        EventHandler<T> handler,
        Function<T, String> keyExtractor,
        Duration ttl
    ) {
        this.store = store;
        this.handler = handler;
        this.keyExtractor = keyExtractor;
        this.ttl = ttl;
    }

    public boolean process(T event) {
        String key = keyExtractor.apply(event);

        if (store.jaProcessado(key)) {
            return false;
        }

        handler.handle(event);
        store.marcar(key, ttl); // Expira ap√≥s TTL
        return true;
    }
}
```

### 4. API REST com Idempotency-Key

```java
record TransacaoRequest(String idempotencyKey, BigDecimal valor, String conta) {}
record TransacaoResponse(String id, BigDecimal valor, String status) {}

@RestController
@RequestMapping("/transacoes")
public class TransacaoController {
    private final IdempotencyStore idempotencyStore;
    private final TransacaoService transacaoService;

    @PostMapping
    public ResponseEntity<TransacaoResponse> criar(
        @RequestBody TransacaoRequest request
    ) {
        String idempKey = request.idempotencyKey();

        if (idempKey == null || idempKey.isBlank()) {
            return ResponseEntity.badRequest().build();
        }

        // Verifica se j√° foi processado
        if (idempotencyStore.jaProcessado(idempKey)) {
            // Retorna resultado anterior (idealmente cache do response)
            TransacaoResponse cached = getCachedResponse(idempKey);
            return ResponseEntity.ok(cached);
        }

        // Processa transa√ß√£o
        TransacaoResponse response = transacaoService.criar(request);

        // Marca como processado e cacheia resposta
        idempotencyStore.marcar(idempKey);
        cacheResponse(idempKey, response);

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    private TransacaoResponse getCachedResponse(String key) {
        // Implementa√ß√£o simplificada
        return new TransacaoResponse("cached-id", BigDecimal.ZERO, "CACHED");
    }

    private void cacheResponse(String key, TransacaoResponse response) {
        // Armazenar response para retornar em duplicatas
    }
}
```

### 5. Idempot√™ncia em Mensageria

```java
record PagamentoEvent(
    String eventId,        // Chave de idempot√™ncia
    String contaId,
    BigDecimal valor,
    Instant timestamp
) {}

@Component
public class PagamentoListener {
    private final IdempotencyStore idempotencyStore;
    private final ContaRepository contaRepository;

    @KafkaListener(topics = "pagamentos")
    public void processar(PagamentoEvent event) {
        if (idempotencyStore.jaProcessado(event.eventId())) {
            log.info("Evento {} j√° processado, ignorando", event.eventId());
            return;
        }

        try {
            // Processar pagamento
            contaRepository.debitar(event.contaId(), event.valor());

            // Marcar como processado
            idempotencyStore.marcar(event.eventId());

        } catch (Exception e) {
            log.error("Erro ao processar pagamento: {}", event.eventId(), e);
            // N√£o marca como processado - permite retry
            throw e;
        }
    }
}
```

---

## üß™ Como Testar

### 1. Testar Primeira Execu√ß√£o Processa

```java
@Test
void devePro cessarPrimeiraVez() {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();
    EventHandler<String> handler = mock(EventHandler.class);
    IdempotentProcessor<String> processor = new IdempotentProcessor<>(
        store, handler, Function.identity()
    );

    // Act
    boolean processado = processor.process("evento-1");

    // Assert
    assertTrue(processado);
    verify(handler).handle("evento-1");
    assertTrue(store.jaProcessado("evento-1"));
}
```

### 2. Testar Duplicata √â Ignorada

```java
@Test
void deveIgnorarDuplicata() {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();
    EventHandler<String> handler = mock(EventHandler.class);
    IdempotentProcessor<String> processor = new IdempotentProcessor<>(
        store, handler, Function.identity()
    );

    // Act
    processor.process("evento-1"); // Primeira vez
    boolean segundaExecucao = processor.process("evento-1"); // Duplicata

    // Assert
    assertFalse(segundaExecucao);
    verify(handler, times(1)).handle("evento-1"); // S√≥ 1 vez
}
```

### 3. Testar Eventos Diferentes S√£o Processados

```java
@Test
void deveProcessarEventosDiferentes() {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();
    EventHandler<String> handler = mock(EventHandler.class);
    IdempotentProcessor<String> processor = new IdempotentProcessor<>(
        store, handler, Function.identity()
    );

    // Act
    boolean ev1 = processor.process("evento-1");
    boolean ev2 = processor.process("evento-2");
    boolean ev3 = processor.process("evento-3");

    // Assert
    assertTrue(ev1);
    assertTrue(ev2);
    assertTrue(ev3);
    verify(handler, times(3)).handle(anyString());
}
```

### 4. Testar Concorr√™ncia (Thread Safety)

```java
@Test
void deveSerThreadSafe() throws InterruptedException {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();
    AtomicInteger processamentos = new AtomicInteger(0);

    EventHandler<String> handler = event -> processamentos.incrementAndGet();
    IdempotentProcessor<String> processor = new IdempotentProcessor<>(
        store, handler, Function.identity()
    );

    int threads = 10;
    CountDownLatch latch = new CountDownLatch(threads);

    // Act - 10 threads tentando processar mesmo evento
    for (int i = 0; i < threads; i++) {
        new Thread(() -> {
            processor.process("evento-concorrente");
            latch.countDown();
        }).start();
    }

    latch.await(2, TimeUnit.SECONDS);

    // Assert - deve processar apenas 1x
    assertEquals(1, processamentos.get());
}
```

### 5. Testar TTL (Expira√ß√£o)

```java
@Test
void deveExpirarAposTTL() throws InterruptedException {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();
    EventHandler<String> handler = mock(EventHandler.class);

    Duration ttl = Duration.ofMillis(200);
    IdempotentProcessorWithTTL<String> processor = new IdempotentProcessorWithTTL<>(
        store, handler, Function.identity(), ttl
    );

    // Act
    processor.process("evento-1");
    assertTrue(store.jaProcessado("evento-1"));

    Thread.sleep(300); // Aguarda expira√ß√£o

    // Assert - deve permitir reprocessamento ap√≥s expira√ß√£o
    boolean reprocessado = processor.process("evento-1");
    assertTrue(reprocessado);
    verify(handler, times(2)).handle("evento-1");
}
```

### 6. Testar Limpeza de Expirados

```java
@Test
void deveLimparRegistrosExpirados() throws InterruptedException {
    // Arrange
    IdempotencyStore store = new InMemoryIdempotencyStore();

    store.marcar("evento-1");
    store.marcar("evento-2");
    store.marcar("evento-3");

    assertEquals(3, store.count());

    // Simular passagem de tempo (requer implementa√ß√£o com timestamp)
    Thread.sleep(100);

    // Act
    store.limparExpirados(); // Remove registros com mais de 24h

    // Assert - em teste real, configurar TTL menor
    // assertEquals(0, store.count());
}
```

### 7. Testar API REST com Idempotency-Key

```java
@Test
void deveRetornarMesmaRespostaParaMesmaIdempotencyKey() throws Exception {
    // Arrange
    String idempKey = UUID.randomUUID().toString();
    TransacaoRequest request = new TransacaoRequest(
        idempKey,
        new BigDecimal("100.00"),
        "conta-123"
    );

    // Act - primeira chamada
    mockMvc.perform(post("/transacoes")
        .contentType(MediaType.APPLICATION_JSON)
        .content(toJson(request)))
        .andExpect(status().isCreated());

    // Act - segunda chamada com mesma key
    mockMvc.perform(post("/transacoes")
        .contentType(MediaType.APPLICATION_JSON)
        .content(toJson(request)))
        .andExpect(status().isOk()); // Retorna cached response

    // Assert - transa√ß√£o criada apenas 1x
    verify(transacaoService, times(1)).criar(any());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Usar payload como chave (n√£o √© √∫nico)
String key = event.getPayload(); // M√∫ltiplos eventos com mesmo payload!

// ‚ùå N√£o limpar registros antigos
// Store cresce infinitamente em mem√≥ria

// ‚ùå Idempot√™ncia sem atomicidade
if (!store.contains(key)) {
    // Race condition aqui!
    handler.handle(event);
    store.add(key);
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Usar ID √∫nico e est√°vel
String key = event.getEventId(); // UUID, requestId, messageId

// ‚úÖ Implementar TTL
store.marcar(key, Duration.ofHours(24)); // Expira ap√≥s 24h

// ‚úÖ Opera√ß√£o at√¥mica
synchronized (store) {
    if (!store.contains(key)) {
        handler.handle(event);
        store.add(key);
    }
}

// Ou usar ConcurrentHashMap.computeIfAbsent()
store.computeIfAbsent(key, k -> {
    handler.handle(event);
    return true;
});
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Chave √∫nica**: Use UUID, requestId ou messageId
- ‚úÖ **TTL**: Expire registros antigos (24h~7 dias)
- ‚úÖ **Thread-safe**: ConcurrentHashMap ou sincroniza√ß√£o
- ‚úÖ **Persist√™ncia**: DB ou Redis para sobreviver a restarts
- ‚úÖ **M√©tricas**: Monitorar taxa de duplicatas
- ‚úÖ **Cache de resposta**: Armazene response para retornar em duplicatas
- ‚úÖ **Falha n√£o marca**: S√≥ marque como processado ap√≥s sucesso

---

## üîó Integra√ß√£o com Frameworks

### Spring com Redis

```java
@Configuration
public class IdempotencyConfig {

    @Bean
    public IdempotencyStore redisIdempotencyStore(RedisTemplate<String, String> redis) {
        return new IdempotencyStore() {
            @Override
            public boolean jaProcessado(String key) {
                return Boolean.TRUE.equals(redis.hasKey("idempotency:" + key));
            }

            @Override
            public void marcar(String key, Duration ttl) {
                redis.opsForValue().set("idempotency:" + key, "1", ttl);
            }
        };
    }
}
```

### Stripe-like Idempotency-Key Header

```java
@PostMapping
public ResponseEntity<Response> criar(
    @RequestHeader("Idempotency-Key") String idempKey,
    @RequestBody Request request
) {
    if (idempotencyStore.jaProcessado(idempKey)) {
        return ResponseEntity.ok(getCachedResponse(idempKey));
    }

    Response response = service.processar(request);
    idempotencyStore.marcar(idempKey);
    cacheResponse(idempKey, response);

    return ResponseEntity.created(uri).body(response);
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                   | ‚ö†Ô∏è Desvantagens                     |
| ------------------------------ | ----------------------------------- |
| Retry seguro (sem duplica√ß√µes) | Overhead de storage (chaves)        |
| Consist√™ncia garantida         | Requer chave √∫nica est√°vel          |
| Debugging facilitado           | TTL mal configurado causa problemas |
| APIs mais robustas             | Race condition se n√£o at√¥mico       |
| Mensageria confi√°vel           | Mem√≥ria/Redis necess√°rio            |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar store persistente** com PostgreSQL e √≠ndice √∫nico
2. **Criar limpeza autom√°tica** de registros expirados (cronjob)
3. **Testar race condition** com 100 threads tentando processar mesmo evento
4. **Implementar cache de resposta** para retornar em duplicatas
5. **Adicionar m√©tricas** (Prometheus) de taxa de duplicatas por endpoint

---

## üìö Relacionado

- **Retry Pattern**: Idempot√™ncia permite retries seguros
- **Dead Letter Queue**: Mensagens falham mesmo com idempot√™ncia
- **Event Sourcing**: Eventos devem ser idempotentes no replay
- **CQRS**: Commands devem ser idempotentes
- **Saga Pattern**: Compensa√ß√µes devem ser idempotentes

---

**Idempot√™ncia √© essencial para sistemas distribu√≠dos confi√°veis, mas requer chave √∫nica, storage apropriado e TTL bem configurado!** üîÅ‚ú®
