# 04.30 DAO (Data Access Object) Pattern [M√âDIO] üíæ

## üéØ Objetivo

Isolar a **l√≥gica de acesso a dados** da l√≥gica de neg√≥cio, facilitando **testes com mocks** e permitindo trocar implementa√ß√µes de persist√™ncia sem afetar o c√≥digo cliente.

---

## üìö O Que √â?

**DAO** √© um padr√£o estrutural que encapsula todo acesso a dados em objetos dedicados, isolando opera√ß√µes CRUD (Create, Read, Update, Delete) e consultas complexas da camada de neg√≥cio.

### Analogia

Como um **bibliotec√°rio**:

- **Voc√™ (Cliente)**: Pede um livro
- **Bibliotec√°rio (DAO)**: Sabe onde buscar (SQL, NoSQL, arquivo, API)
- **Estante (Database)**: Armazenamento f√≠sico
- **Vantagem**: Voc√™ n√£o precisa saber a organiza√ß√£o interna da biblioteca

---

## ‚ùå Problema que Resolve

### Antes (SQL Espalhado no C√≥digo de Neg√≥cio)

```java
// ‚ùå PROBLEMA: L√≥gica de neg√≥cio misturada com SQL
@Service
class PedidoService {

    @Autowired
    private DataSource dataSource;

    void processarPedido(Long pedidoId) {
        // SQL direto no servi√ßo ‚ùå
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "SELECT * FROM pedidos WHERE id = ?")) {

            stmt.setLong(1, pedidoId);
            ResultSet rs = stmt.executeQuery();

            if (rs.next()) {
                String status = rs.getString("status");

                // L√≥gica de neg√≥cio
                if ("PENDENTE".equals(status)) {
                    // Mais SQL ‚ùå
                    try (PreparedStatement update = conn.prepareStatement(
                        "UPDATE pedidos SET status = ? WHERE id = ?")) {
                        update.setString(1, "APROVADO");
                        update.setLong(2, pedidoId);
                        update.executeUpdate();
                    }
                }
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}

// Problemas:
// - SQL misturado com l√≥gica de neg√≥cio ‚ùå
// - Imposs√≠vel testar sem banco real ‚ùå
// - Trocar banco = refatorar tudo ‚ùå
// - Try-catch boilerplate ‚ùå
```

**Problemas**:

- üß© SQL espalhado no c√≥digo
- üß™ Dif√≠cil testar sem banco real
- üîß Trocar banco = refatorar tudo
- üìö Boilerplate JDBC repetido
- üîÄ L√≥gica de neg√≥cio polu√≠da

### Depois (DAO Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Interface DAO isolada
interface PedidoDAO {
    Optional<Pedido> buscarPorId(Long id);
    List<Pedido> buscarTodos();
    void salvar(Pedido pedido);
    void atualizar(Pedido pedido);
    void deletar(Long id);
    List<Pedido> buscarPorStatus(String status);
}

// Implementa√ß√£o JDBC (detalhes isolados)
@Repository
class PedidoDAOJdbc implements PedidoDAO {

    @Autowired
    private JdbcTemplate jdbc;

    @Override
    public Optional<Pedido> buscarPorId(Long id) {
        try {
            Pedido pedido = jdbc.queryForObject(
                "SELECT * FROM pedidos WHERE id = ?",
                this::mapearPedido,
                id
            );
            return Optional.ofNullable(pedido);
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }

    private Pedido mapearPedido(ResultSet rs, int row) throws SQLException {
        return new Pedido(
            rs.getLong("id"),
            rs.getString("cliente"),
            rs.getBigDecimal("valor_total"),
            rs.getString("status")
        );
    }
}

// Servi√ßo limpo - apenas l√≥gica de neg√≥cio
@Service
class PedidoService {

    @Autowired
    private PedidoDAO pedidoDAO; // Interface!

    void processarPedido(Long pedidoId) {
        pedidoDAO.buscarPorId(pedidoId).ifPresent(pedido -> {
            // Apenas l√≥gica de neg√≥cio
            if ("PENDENTE".equals(pedido.getStatus())) {
                pedido.setStatus("APROVADO");
                pedidoDAO.atualizar(pedido);
            }
        });
    }
}

// Teste simples com mock
@Test
void deveAprovarPedidoPendente() {
    // Mock do DAO
    PedidoDAO daoMock = mock(PedidoDAO.class);
    Pedido pedido = new Pedido(1L, "Jo√£o", BigDecimal.valueOf(100), "PENDENTE");
    when(daoMock.buscarPorId(1L)).thenReturn(Optional.of(pedido));

    PedidoService service = new PedidoService();
    service.pedidoDAO = daoMock;

    // Act
    service.processarPedido(1L);

    // Assert
    verify(daoMock).atualizar(argThat(p -> "APROVADO".equals(p.getStatus())));
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Entity (Modelo de Dom√≠nio)

```java
record Produto(
    Long id,
    String nome,
    BigDecimal preco,
    int estoque,
    LocalDateTime criadoEm
) {
    // Factory method para cria√ß√£o
    static Produto novo(String nome, BigDecimal preco, int estoque) {
        return new Produto(null, nome, preco, estoque, LocalDateTime.now());
    }

    // C√≥pia com ID (ap√≥s inser√ß√£o)
    Produto comId(Long novoId) {
        return new Produto(novoId, nome, preco, estoque, criadoEm);
    }

    // Atualizar estoque
    Produto atualizarEstoque(int novoEstoque) {
        return new Produto(id, nome, preco, novoEstoque, criadoEm);
    }
}
```

### 2. Interface DAO (Contrato)

```java
interface ProdutoDAO {
    // CRUD b√°sico
    Optional<Produto> buscarPorId(Long id);
    List<Produto> buscarTodos();
    Produto salvar(Produto produto);
    void atualizar(Produto produto);
    void deletar(Long id);

    // Consultas customizadas
    List<Produto> buscarPorNome(String nome);
    List<Produto> buscarComEstoqueBaixo(int limite);
    List<Produto> buscarPorFaixaPreco(BigDecimal min, BigDecimal max);

    // Opera√ß√µes especiais
    int contarTodos();
    boolean existe(Long id);
    void atualizarEstoque(Long id, int quantidade);
}
```

### 3. Implementa√ß√£o JDBC

```java
@Repository
class ProdutoDAOJdbc implements ProdutoDAO {

    private final JdbcTemplate jdbc;
    private final AtomicLong contadorConsultas = new AtomicLong();

    @Autowired
    ProdutoDAOJdbc(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    @Override
    public Optional<Produto> buscarPorId(Long id) {
        contadorConsultas.incrementAndGet();

        String sql = "SELECT * FROM produtos WHERE id = ?";
        try {
            Produto produto = jdbc.queryForObject(sql, this::mapRow, id);
            return Optional.ofNullable(produto);
        } catch (EmptyResultDataAccessException e) {
            return Optional.empty();
        }
    }

    @Override
    public List<Produto> buscarTodos() {
        contadorConsultas.incrementAndGet();
        return jdbc.query("SELECT * FROM produtos", this::mapRow);
    }

    @Override
    public Produto salvar(Produto produto) {
        String sql = "INSERT INTO produtos (nome, preco, estoque, criado_em) VALUES (?, ?, ?, ?)";

        KeyHolder keyHolder = new GeneratedKeyHolder();
        jdbc.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setString(1, produto.nome());
            ps.setBigDecimal(2, produto.preco());
            ps.setInt(3, produto.estoque());
            ps.setTimestamp(4, Timestamp.valueOf(produto.criadoEm()));
            return ps;
        }, keyHolder);

        Long novoId = keyHolder.getKey().longValue();
        return produto.comId(novoId);
    }

    @Override
    public void atualizar(Produto produto) {
        String sql = "UPDATE produtos SET nome = ?, preco = ?, estoque = ? WHERE id = ?";

        int rows = jdbc.update(sql,
            produto.nome(),
            produto.preco(),
            produto.estoque(),
            produto.id()
        );

        if (rows == 0) {
            throw new EntityNotFoundException("Produto n√£o encontrado: " + produto.id());
        }
    }

    @Override
    public void deletar(Long id) {
        int rows = jdbc.update("DELETE FROM produtos WHERE id = ?", id);
        if (rows == 0) {
            throw new EntityNotFoundException("Produto n√£o encontrado: " + id);
        }
    }

    @Override
    public List<Produto> buscarPorNome(String nome) {
        contadorConsultas.incrementAndGet();
        return jdbc.query(
            "SELECT * FROM produtos WHERE nome LIKE ?",
            this::mapRow,
            "%" + nome + "%"
        );
    }

    @Override
    public List<Produto> buscarComEstoqueBaixo(int limite) {
        return jdbc.query(
            "SELECT * FROM produtos WHERE estoque < ?",
            this::mapRow,
            limite
        );
    }

    @Override
    public List<Produto> buscarPorFaixaPreco(BigDecimal min, BigDecimal max) {
        return jdbc.query(
            "SELECT * FROM produtos WHERE preco BETWEEN ? AND ?",
            this::mapRow,
            min,
            max
        );
    }

    @Override
    public int contarTodos() {
        return jdbc.queryForObject("SELECT COUNT(*) FROM produtos", Integer.class);
    }

    @Override
    public boolean existe(Long id) {
        Integer count = jdbc.queryForObject(
            "SELECT COUNT(*) FROM produtos WHERE id = ?",
            Integer.class,
            id
        );
        return count != null && count > 0;
    }

    @Override
    public void atualizarEstoque(Long id, int quantidade) {
        jdbc.update("UPDATE produtos SET estoque = estoque + ? WHERE id = ?", quantidade, id);
    }

    // RowMapper
    private Produto mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Produto(
            rs.getLong("id"),
            rs.getString("nome"),
            rs.getBigDecimal("preco"),
            rs.getInt("estoque"),
            rs.getTimestamp("criado_em").toLocalDateTime()
        );
    }

    long getTotalConsultas() {
        return contadorConsultas.get();
    }
}
```

### 4. Implementa√ß√£o In-Memory (Testes)

```java
class ProdutoDAOInMemory implements ProdutoDAO {

    private final Map<Long, Produto> produtos = new ConcurrentHashMap<>();
    private final AtomicLong sequencia = new AtomicLong(1);

    @Override
    public Optional<Produto> buscarPorId(Long id) {
        return Optional.ofNullable(produtos.get(id));
    }

    @Override
    public List<Produto> buscarTodos() {
        return new ArrayList<>(produtos.values());
    }

    @Override
    public Produto salvar(Produto produto) {
        Long novoId = sequencia.getAndIncrement();
        Produto comId = produto.comId(novoId);
        produtos.put(novoId, comId);
        return comId;
    }

    @Override
    public void atualizar(Produto produto) {
        if (!produtos.containsKey(produto.id())) {
            throw new EntityNotFoundException("Produto n√£o encontrado: " + produto.id());
        }
        produtos.put(produto.id(), produto);
    }

    @Override
    public void deletar(Long id) {
        if (produtos.remove(id) == null) {
            throw new EntityNotFoundException("Produto n√£o encontrado: " + id);
        }
    }

    @Override
    public List<Produto> buscarPorNome(String nome) {
        return produtos.values().stream()
            .filter(p -> p.nome().toLowerCase().contains(nome.toLowerCase()))
            .toList();
    }

    @Override
    public List<Produto> buscarComEstoqueBaixo(int limite) {
        return produtos.values().stream()
            .filter(p -> p.estoque() < limite)
            .toList();
    }

    @Override
    public List<Produto> buscarPorFaixaPreco(BigDecimal min, BigDecimal max) {
        return produtos.values().stream()
            .filter(p -> p.preco().compareTo(min) >= 0 && p.preco().compareTo(max) <= 0)
            .toList();
    }

    @Override
    public int contarTodos() {
        return produtos.size();
    }

    @Override
    public boolean existe(Long id) {
        return produtos.containsKey(id);
    }

    @Override
    public void atualizarEstoque(Long id, int quantidade) {
        Produto produto = produtos.get(id);
        if (produto == null) {
            throw new EntityNotFoundException("Produto n√£o encontrado: " + id);
        }
        produtos.put(id, produto.atualizarEstoque(produto.estoque() + quantidade));
    }

    void limpar() {
        produtos.clear();
        sequencia.set(1);
    }
}
```

### 5. DAO com Cache

```java
class ProdutoDAOComCache implements ProdutoDAO {

    private final ProdutoDAO delegate;
    private final Map<Long, Produto> cache = new ConcurrentHashMap<>();
    private final AtomicLong hits = new AtomicLong();
    private final AtomicLong misses = new AtomicLong();

    ProdutoDAOComCache(ProdutoDAO delegate) {
        this.delegate = delegate;
    }

    @Override
    public Optional<Produto> buscarPorId(Long id) {
        Produto cached = cache.get(id);
        if (cached != null) {
            hits.incrementAndGet();
            return Optional.of(cached);
        }

        misses.incrementAndGet();
        Optional<Produto> resultado = delegate.buscarPorId(id);
        resultado.ifPresent(p -> cache.put(id, p));
        return resultado;
    }

    @Override
    public Produto salvar(Produto produto) {
        Produto salvo = delegate.salvar(produto);
        cache.put(salvo.id(), salvo);
        return salvo;
    }

    @Override
    public void atualizar(Produto produto) {
        delegate.atualizar(produto);
        cache.put(produto.id(), produto); // Atualiza cache
    }

    @Override
    public void deletar(Long id) {
        delegate.deletar(id);
        cache.remove(id); // Remove do cache
    }

    // Outros m√©todos delegam diretamente
    @Override
    public List<Produto> buscarTodos() {
        return delegate.buscarTodos();
    }

    @Override
    public List<Produto> buscarPorNome(String nome) {
        return delegate.buscarPorNome(nome);
    }

    @Override
    public List<Produto> buscarComEstoqueBaixo(int limite) {
        return delegate.buscarComEstoqueBaixo(limite);
    }

    @Override
    public List<Produto> buscarPorFaixaPreco(BigDecimal min, BigDecimal max) {
        return delegate.buscarPorFaixaPreco(min, max);
    }

    @Override
    public int contarTodos() {
        return delegate.contarTodos();
    }

    @Override
    public boolean existe(Long id) {
        return cache.containsKey(id) || delegate.existe(id);
    }

    @Override
    public void atualizarEstoque(Long id, int quantidade) {
        delegate.atualizarEstoque(id, quantidade);
        cache.remove(id); // Invalida cache
    }

    void limparCache() {
        cache.clear();
    }

    double getTaxaHit() {
        long totalAcessos = hits.get() + misses.get();
        return totalAcessos == 0 ? 0.0 : (double) hits.get() / totalAcessos;
    }
}
```

### 6. DAO com Retry

```java
class ProdutoDAOComRetry implements ProdutoDAO {

    private final ProdutoDAO delegate;
    private final int maxTentativas;
    private final Duration delayEntreRetries;

    ProdutoDAOComRetry(ProdutoDAO delegate, int maxTentativas, Duration delay) {
        this.delegate = delegate;
        this.maxTentativas = maxTentativas;
        this.delayEntreRetries = delay;
    }

    @Override
    public Optional<Produto> buscarPorId(Long id) {
        return executarComRetry(() -> delegate.buscarPorId(id));
    }

    @Override
    public List<Produto> buscarTodos() {
        return executarComRetry(delegate::buscarTodos);
    }

    @Override
    public Produto salvar(Produto produto) {
        return executarComRetry(() -> delegate.salvar(produto));
    }

    @Override
    public void atualizar(Produto produto) {
        executarComRetry(() -> {
            delegate.atualizar(produto);
            return null;
        });
    }

    @Override
    public void deletar(Long id) {
        executarComRetry(() -> {
            delegate.deletar(id);
            return null;
        });
    }

    @Override
    public List<Produto> buscarPorNome(String nome) {
        return executarComRetry(() -> delegate.buscarPorNome(nome));
    }

    @Override
    public List<Produto> buscarComEstoqueBaixo(int limite) {
        return executarComRetry(() -> delegate.buscarComEstoqueBaixo(limite));
    }

    @Override
    public List<Produto> buscarPorFaixaPreco(BigDecimal min, BigDecimal max) {
        return executarComRetry(() -> delegate.buscarPorFaixaPreco(min, max));
    }

    @Override
    public int contarTodos() {
        return executarComRetry(delegate::contarTodos);
    }

    @Override
    public boolean existe(Long id) {
        return executarComRetry(() -> delegate.existe(id));
    }

    @Override
    public void atualizarEstoque(Long id, int quantidade) {
        executarComRetry(() -> {
            delegate.atualizarEstoque(id, quantidade);
            return null;
        });
    }

    private <T> T executarComRetry(Supplier<T> operacao) {
        Exception ultimaExcecao = null;

        for (int tentativa = 1; tentativa <= maxTentativas; tentativa++) {
            try {
                return operacao.get();

            } catch (Exception e) {
                ultimaExcecao = e;

                if (tentativa < maxTentativas) {
                    try {
                        Thread.sleep(delayEntreRetries.toMillis());
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException(ie);
                    }
                }
            }
        }

        throw new RuntimeException("Falha ap√≥s " + maxTentativas + " tentativas", ultimaExcecao);
    }
}
```

### 7. Generic DAO

```java
interface GenericDAO<T, ID> {
    Optional<T> buscarPorId(ID id);
    List<T> buscarTodos();
    T salvar(T entidade);
    void atualizar(T entidade);
    void deletar(ID id);
    int contarTodos();
    boolean existe(ID id);
}

abstract class AbstractDAO<T, ID> implements GenericDAO<T, ID> {

    protected final JdbcTemplate jdbc;
    protected final String nomeTabela;

    protected AbstractDAO(JdbcTemplate jdbc, String nomeTabela) {
        this.jdbc = jdbc;
        this.nomeTabela = nomeTabela;
    }

    @Override
    public List<T> buscarTodos() {
        return jdbc.query("SELECT * FROM " + nomeTabela, this::mapRow);
    }

    @Override
    public int contarTodos() {
        return jdbc.queryForObject("SELECT COUNT(*) FROM " + nomeTabela, Integer.class);
    }

    @Override
    public boolean existe(ID id) {
        Integer count = jdbc.queryForObject(
            "SELECT COUNT(*) FROM " + nomeTabela + " WHERE id = ?",
            Integer.class,
            id
        );
        return count != null && count > 0;
    }

    protected abstract T mapRow(ResultSet rs, int rowNum) throws SQLException;
}
```

### 8. DAO Factory

```java
interface DAOFactory {
    ProdutoDAO criarProdutoDAO();
    PedidoDAO criarPedidoDAO();
    ClienteDAO criarClienteDAO();
}

@Configuration
class JdbcDAOFactory implements DAOFactory {

    @Autowired
    private JdbcTemplate jdbc;

    @Override
    @Bean
    public ProdutoDAO criarProdutoDAO() {
        return new ProdutoDAOJdbc(jdbc);
    }

    @Override
    @Bean
    public PedidoDAO criarPedidoDAO() {
        return new PedidoDAOJdbc(jdbc);
    }

    @Override
    @Bean
    public ClienteDAO criarClienteDAO() {
        return new ClienteDAOJdbc(jdbc);
    }
}

class InMemoryDAOFactory implements DAOFactory {

    @Override
    public ProdutoDAO criarProdutoDAO() {
        return new ProdutoDAOInMemory();
    }

    @Override
    public PedidoDAO criarPedidoDAO() {
        return new PedidoDAOInMemory();
    }

    @Override
    public ClienteDAO criarClienteDAO() {
        return new ClienteDAOInMemory();
    }
}
```

---

## üß™ Como Testar

### 1. Testar CRUD B√°sico

```java
@Test
void deveSalvarEBuscarProduto() {
    // Arrange
    ProdutoDAO dao = new ProdutoDAOInMemory();
    Produto produto = Produto.novo("Notebook", BigDecimal.valueOf(3000), 10);

    // Act
    Produto salvo = dao.salvar(produto);
    Optional<Produto> encontrado = dao.buscarPorId(salvo.id());

    // Assert
    assertTrue(encontrado.isPresent());
    assertEquals("Notebook", encontrado.get().nome());
}
```

### 2. Testar Atualiza√ß√£o

```java
@Test
void deveAtualizarProduto() {
    // Arrange
    ProdutoDAO dao = new ProdutoDAOInMemory();
    Produto produto = dao.salvar(Produto.novo("Mouse", BigDecimal.valueOf(50), 20));

    // Act
    Produto atualizado = produto.atualizarEstoque(15);
    dao.atualizar(atualizado);

    // Assert
    Optional<Produto> resultado = dao.buscarPorId(produto.id());
    assertTrue(resultado.isPresent());
    assertEquals(15, resultado.get().estoque());
}
```

### 3. Testar Dele√ß√£o

```java
@Test
void deveDeletarProduto() {
    // Arrange
    ProdutoDAO dao = new ProdutoDAOInMemory();
    Produto produto = dao.salvar(Produto.novo("Teclado", BigDecimal.valueOf(100), 5));

    // Act
    dao.deletar(produto.id());

    // Assert
    assertFalse(dao.existe(produto.id()));
}
```

### 4. Testar Consultas Customizadas

```java
@Test
void deveBuscarProdutosComEstoqueBaixo() {
    // Arrange
    ProdutoDAO dao = new ProdutoDAOInMemory();
    dao.salvar(Produto.novo("A", BigDecimal.valueOf(10), 2)); // Baixo
    dao.salvar(Produto.novo("B", BigDecimal.valueOf(20), 50)); // Normal
    dao.salvar(Produto.novo("C", BigDecimal.valueOf(30), 3)); // Baixo

    // Act
    List<Produto> baixoEstoque = dao.buscarComEstoqueBaixo(5);

    // Assert
    assertEquals(2, baixoEstoque.size());
}
```

### 5. Testar Cache

```java
@Test
void cacheDeveEvitarConsultasRedundantes() {
    // Arrange
    ProdutoDAO daoReal = mock(ProdutoDAO.class);
    Produto produto = Produto.novo("Test", BigDecimal.valueOf(100), 10).comId(1L);
    when(daoReal.buscarPorId(1L)).thenReturn(Optional.of(produto));

    ProdutoDAOComCache daoComCache = new ProdutoDAOComCache(daoReal);

    // Act
    daoComCache.buscarPorId(1L); // Miss - consulta real
    daoComCache.buscarPorId(1L); // Hit - cache
    daoComCache.buscarPorId(1L); // Hit - cache

    // Assert
    verify(daoReal, times(1)).buscarPorId(1L); // Apenas 1 consulta real
    assertEquals(2.0/3.0, daoComCache.getTaxaHit(), 0.01);
}
```

### 6. Testar Retry

```java
@Test
void retryDeveTentarNovamenteAposFalha() {
    // Arrange
    ProdutoDAO daoInstavel = mock(ProdutoDAO.class);
    when(daoInstavel.buscarPorId(1L))
        .thenThrow(new RuntimeException("Erro tempor√°rio"))
        .thenThrow(new RuntimeException("Erro tempor√°rio"))
        .thenReturn(Optional.of(Produto.novo("Test", BigDecimal.TEN, 5).comId(1L)));

    ProdutoDAO daoComRetry = new ProdutoDAOComRetry(daoInstavel, 3, Duration.ofMillis(10));

    // Act
    Optional<Produto> resultado = daoComRetry.buscarPorId(1L);

    // Assert
    assertTrue(resultado.isPresent());
    verify(daoInstavel, times(3)).buscarPorId(1L);
}
```

### 7. Testar com Servi√ßo

```java
@Test
void servicoDeveUsarDAO() {
    // Arrange
    ProdutoDAO dao = mock(ProdutoDAO.class);
    Produto produto = Produto.novo("Test", BigDecimal.valueOf(100), 5).comId(1L);
    when(dao.buscarPorId(1L)).thenReturn(Optional.of(produto));

    ProdutoService service = new ProdutoService(dao);

    // Act
    service.reduzirEstoque(1L, 2);

    // Assert
    verify(dao).buscarPorId(1L);
    verify(dao).atualizar(argThat(p -> p.estoque() == 3));
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå DAO retornando DTOs
class BadDAO {
    ProdutoDTO buscar(Long id) { // DTO no DAO ‚ùå
        return new ProdutoDTO(...);
    }
}

// ‚ùå L√≥gica de neg√≥cio no DAO
class BadDAO {
    void aprovarPedido(Long id) { // L√≥gica de neg√≥cio ‚ùå
        // Valida√ß√µes, regras...
    }
}

// ‚ùå Transa√ß√µes no DAO
class BadDAO {
    @Transactional // ‚ùå Transa√ß√£o deve ser no servi√ßo
    void salvar(Produto p) { }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ DAO retorna entidades de dom√≠nio
class GoodDAO {
    Produto buscar(Long id) { // Entidade ‚úÖ
        return new Produto(...);
    }
}

// ‚úÖ L√≥gica no servi√ßo
@Service
class ProdutoService {
    @Transactional // ‚úÖ Transa√ß√£o no servi√ßo
    void aprovarPedido(Long id) {
        // L√≥gica de neg√≥cio aqui
        dao.atualizar(pedido);
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Interface primeiro**: DAO sempre como interface
- ‚úÖ **Uma entidade por DAO**: ProdutoDAO para Produto
- ‚úÖ **Sem l√≥gica de neg√≥cio**: DAO apenas acessa dados
- ‚úÖ **Transa√ß√µes no servi√ßo**: N√£o no DAO
- ‚úÖ **In-memory para testes**: Implementa√ß√£o fake
- ‚úÖ **Decorators**: Cache, Retry, Logging via composi√ß√£o
- ‚úÖ **Generic DAO**: Reduzir boilerplate

---

## üîó Integra√ß√£o com Frameworks

### Spring Data JPA (abstrai DAO)

```java
interface ProdutoRepository extends JpaRepository<Produto, Long> {
    List<Produto> findByNomeContaining(String nome);
    List<Produto> findByEstoqueLessThan(int limite);
}

// Spring gera implementa√ß√£o automaticamente
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                   | ‚ö†Ô∏è Desvantagens                                 |
| ------------------------------ | ----------------------------------------------- |
| Isola l√≥gica de acesso a dados | Camada adicional                                |
| Facilita testes com mocks      | Boilerplate para CRUD simples                   |
| Troca de banco transparente    | Pode ser overkill para apps pequenos            |
| Reutiliza√ß√£o de consultas      | Frameworks como Spring Data reduzem necessidade |

---

## üîç Compara√ß√£o

| Padr√£o            | Prop√≥sito                 | Quando Usar                    |
| ----------------- | ------------------------- | ------------------------------ |
| **DAO**           | Abstra√ß√£o de persist√™ncia | Isolar SQL/NoSQL da l√≥gica     |
| **Repository**    | Cole√ß√£o de agregados      | DDD, persist√™ncia de agregados |
| **Active Record** | Modelo = persist√™ncia     | Rails, modelos simples         |
| **Unit of Work**  | Rastrear mudan√ßas         | Controlar transa√ß√µes           |

---

## üß† Exerc√≠cios Pr√°ticos

1. **DAO com pagina√ß√£o** (Pageable, Page)
2. **DAO com transa√ß√£o** (Transactional via proxy)
3. **DAO com auditoria** (log de opera√ß√µes)
4. **DAO com m√©tricas** (tempo de consultas)
5. **DAO com batch** (opera√ß√µes em lote)

---

## üìö Relacionado

- **Repository Pattern**: Evolu√ß√£o do DAO (DDD)
- **Unit of Work**: Gerenciar transa√ß√µes
- **Factory Method**: Criar DAOs
- **Proxy**: Adicionar comportamento (cache, retry)

---

**DAO Pattern isola persist√™ncia e facilita testes com mocks, permitindo trocar bancos sem afetar l√≥gica!** üíæ‚ú®
