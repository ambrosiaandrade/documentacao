# 04.28 Facade Pattern [F√ÅCIL] üè¢

## üéØ Objetivo

Fornecer uma **interface simplificada** para um subsistema complexo, ocultando sua complexidade e facilitando **testes com mock da facade**.

---

## üìö O Que √â?

**Facade** √© um padr√£o estrutural GoF que fornece uma interface unificada e simplificada para um conjunto de interfaces em um subsistema, tornando o subsistema mais f√°cil de usar. Essencial para reduzir acoplamento e criar APIs de alto n√≠vel.

### Analogia

Como um **concierge de hotel**:

- **Subsistemas**: Restaurante, lavanderia, t√°xi, turismo
- **Facade**: Concierge coordena todos
- **Cliente**: Faz um pedido simples ao concierge
- **Vantagem**: Cliente n√£o precisa conhecer detalhes de cada servi√ßo

---

## ‚ùå Problema que Resolve

### Antes (Cliente Acoplado com M√∫ltiplos Subsistemas)

```java
// ‚ùå PROBLEMA: Cliente conhece e coordena m√∫ltiplos subsistemas
class CheckoutController {

    void finalizarCompra(Pedido pedido) {
        // Cliente precisa conhecer e coordenar 5 subsistemas! ‚ùå

        // 1. Validar estoque
        EstoqueService estoque = new EstoqueService();
        if (!estoque.verificarDisponibilidade(pedido.getItens())) {
            throw new RuntimeException("Estoque insuficiente");
        }
        estoque.reservar(pedido.getItens());

        // 2. Processar pagamento
        PagamentoGateway gateway = new PagamentoGateway();
        gateway.configurar("chave-api", "secreto");
        ResultadoPagamento resultado = gateway.processar(
            pedido.getValorTotal(),
            pedido.getFormaPagamento()
        );
        if (!resultado.sucesso()) {
            estoque.liberar(pedido.getItens());
            throw new RuntimeException("Pagamento falhou");
        }

        // 3. Gerar nota fiscal
        NotaFiscalService nf = new NotaFiscalService();
        nf.conectarSefaz();
        NotaFiscal nota = nf.emitir(pedido);
        nf.enviarPorEmail(nota, pedido.getClienteEmail());

        // 4. Solicitar envio
        LogisticaService logistica = new LogisticaService();
        logistica.calcularFrete(pedido);
        logistica.gerarEtiqueta(pedido);
        logistica.notificarTransportadora(pedido);

        // 5. Notificar cliente
        EmailService email = new EmailService();
        email.conectarSmtp("smtp.gmail.com", 587);
        email.enviar(pedido.getClienteEmail(), "Compra realizada!", "...");

        // Muita complexidade! ‚ùå
        // Acoplamento alto! ‚ùå
        // Dif√≠cil testar! ‚ùå
    }
}
```

**Problemas**:

- üîó Alto acoplamento (cliente conhece 5+ subsistemas)
- üß© Complexidade exposta ao cliente
- üîÑ L√≥gica de coordena√ß√£o duplicada
- üß™ Dif√≠cil testar (muitas depend√™ncias)
- üêõ Erro em um subsistema afeta todos

### Depois (Facade Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Facade simplifica acesso aos subsistemas
class CheckoutFacade {
    private final EstoqueService estoque;
    private final PagamentoGateway pagamento;
    private final NotaFiscalService notaFiscal;
    private final LogisticaService logistica;
    private final EmailService email;

    // Dependency Injection (test√°vel)
    CheckoutFacade(EstoqueService estoque, PagamentoGateway pagamento,
                   NotaFiscalService notaFiscal, LogisticaService logistica,
                   EmailService email) {
        this.estoque = estoque;
        this.pagamento = pagamento;
        this.notaFiscal = notaFiscal;
        this.logistica = logistica;
        this.email = email;
    }

    // Interface simplificada
    ResultadoCheckout finalizarCompra(Pedido pedido) {
        try {
            // Facade coordena subsistemas
            validarEstoque(pedido);
            processarPagamento(pedido);
            emitirNotaFiscal(pedido);
            solicitarEnvio(pedido);
            notificarCliente(pedido);

            return ResultadoCheckout.sucesso(pedido.getId());

        } catch (Exception e) {
            return ResultadoCheckout.falha(e.getMessage());
        }
    }

    private void validarEstoque(Pedido pedido) {
        if (!estoque.verificarDisponibilidade(pedido.getItens())) {
            throw new RuntimeException("Estoque insuficiente");
        }
        estoque.reservar(pedido.getItens());
    }

    private void processarPagamento(Pedido pedido) {
        ResultadoPagamento resultado = pagamento.processar(
            pedido.getValorTotal(),
            pedido.getFormaPagamento()
        );
        if (!resultado.sucesso()) {
            estoque.liberar(pedido.getItens());
            throw new RuntimeException("Pagamento falhou");
        }
    }

    // ... outros m√©todos privados
}

// Cliente simplificado
class CheckoutController {
    private final CheckoutFacade facade;

    CheckoutController(CheckoutFacade facade) {
        this.facade = facade;
    }

    void finalizarCompra(Pedido pedido) {
        ResultadoCheckout resultado = facade.finalizarCompra(pedido);

        if (resultado.sucesso()) {
            System.out.println("Compra finalizada: " + resultado.pedidoId());
        } else {
            System.err.println("Erro: " + resultado.mensagem());
        }
    }
}

// Teste simplificado
@Test
void deveFinalizarCompraComFacadeMock() {
    CheckoutFacade facadeMock = mock(CheckoutFacade.class);
    when(facadeMock.finalizarCompra(any()))
        .thenReturn(ResultadoCheckout.sucesso("PED-001"));

    CheckoutController controller = new CheckoutController(facadeMock);
    controller.finalizarCompra(pedido);

    verify(facadeMock).finalizarCompra(pedido);
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Subsistemas (Complexos)

```java
// Subsistema: Estoque
class EstoqueService {
    private final Map<String, Integer> estoque = new ConcurrentHashMap<>();

    EstoqueService() {
        // Simula dados iniciais
        estoque.put("PROD-001", 100);
        estoque.put("PROD-002", 50);
    }

    boolean verificarDisponibilidade(List<ItemPedido> itens) {
        System.out.println("üì¶ Verificando disponibilidade de " + itens.size() + " itens...");

        for (ItemPedido item : itens) {
            Integer disponivel = estoque.getOrDefault(item.produtoId(), 0);
            if (disponivel < item.quantidade()) {
                System.out.println("‚ùå Produto " + item.produtoId() + " indispon√≠vel");
                return false;
            }
        }

        System.out.println("‚úÖ Todos os itens dispon√≠veis");
        return true;
    }

    void reservar(List<ItemPedido> itens) {
        System.out.println("üîí Reservando estoque...");
        itens.forEach(item -> {
            estoque.compute(item.produtoId(), (k, v) ->
                v == null ? 0 : v - item.quantidade()
            );
        });
        System.out.println("‚úÖ Estoque reservado");
    }

    void liberar(List<ItemPedido> itens) {
        System.out.println("üîì Liberando estoque...");
        itens.forEach(item -> {
            estoque.compute(item.produtoId(), (k, v) ->
                v == null ? item.quantidade() : v + item.quantidade()
            );
        });
        System.out.println("‚úÖ Estoque liberado");
    }
}

// Subsistema: Pagamento
class PagamentoGateway {
    private boolean configurado = false;

    void configurar(String apiKey, String secret) {
        System.out.println("üîß Configurando gateway de pagamento...");
        this.configurado = true;
    }

    ResultadoPagamento processar(BigDecimal valor, String formaPagamento) {
        if (!configurado) {
            throw new IllegalStateException("Gateway n√£o configurado");
        }

        System.out.println("üí≥ Processando pagamento: R$ " + valor + " via " + formaPagamento);

        // Simula processamento
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("‚úÖ Pagamento aprovado");
        return new ResultadoPagamento(true, "TXN-" + UUID.randomUUID(), "Aprovado");
    }
}

record ResultadoPagamento(boolean sucesso, String transacaoId, String mensagem) {}

// Subsistema: Nota Fiscal
class NotaFiscalService {
    private boolean conectado = false;

    void conectarSefaz() {
        System.out.println("üîó Conectando com SEFAZ...");
        this.conectado = true;
    }

    NotaFiscal emitir(Pedido pedido) {
        if (!conectado) {
            throw new IllegalStateException("N√£o conectado ao SEFAZ");
        }

        System.out.println("üìÑ Emitindo nota fiscal para pedido " + pedido.id());

        String chaveAcesso = "NFe-" + UUID.randomUUID().toString().substring(0, 8);
        NotaFiscal nf = new NotaFiscal(chaveAcesso, pedido.id(), LocalDateTime.now());

        System.out.println("‚úÖ Nota fiscal emitida: " + chaveAcesso);
        return nf;
    }

    void enviarPorEmail(NotaFiscal nf, String email) {
        System.out.println("üìß Enviando NF para " + email);
    }
}

record NotaFiscal(String chaveAcesso, String pedidoId, LocalDateTime emissao) {}

// Subsistema: Log√≠stica
class LogisticaService {

    BigDecimal calcularFrete(Pedido pedido) {
        System.out.println("üìä Calculando frete...");
        BigDecimal frete = new BigDecimal("15.00");
        System.out.println("‚úÖ Frete calculado: R$ " + frete);
        return frete;
    }

    String gerarEtiqueta(Pedido pedido) {
        System.out.println("üè∑Ô∏è Gerando etiqueta de envio...");
        String etiqueta = "ETQ-" + pedido.id();
        System.out.println("‚úÖ Etiqueta gerada: " + etiqueta);
        return etiqueta;
    }

    void notificarTransportadora(Pedido pedido) {
        System.out.println("üöö Notificando transportadora...");
        System.out.println("‚úÖ Transportadora notificada");
    }
}

// Subsistema: Email
class EmailService {
    private boolean conectado = false;

    void conectarSmtp(String host, int porta) {
        System.out.println("üîó Conectando SMTP: " + host + ":" + porta);
        this.conectado = true;
    }

    void enviar(String destinatario, String assunto, String corpo) {
        if (!conectado) {
            throw new IllegalStateException("SMTP n√£o conectado");
        }

        System.out.println("üìß Enviando email para " + destinatario);
        System.out.println("   Assunto: " + assunto);
        System.out.println("‚úÖ Email enviado");
    }
}
```

### 2. Facade Principal

```java
final class CheckoutFacade {
    private final EstoqueService estoque;
    private final PagamentoGateway pagamento;
    private final NotaFiscalService notaFiscal;
    private final LogisticaService logistica;
    private final EmailService email;
    private final AtomicInteger checkoutsRealizados = new AtomicInteger(0);

    CheckoutFacade(EstoqueService estoque, PagamentoGateway pagamento,
                   NotaFiscalService notaFiscal, LogisticaService logistica,
                   EmailService email) {
        this.estoque = estoque;
        this.pagamento = pagamento;
        this.notaFiscal = notaFiscal;
        this.logistica = logistica;
        this.email = email;

        inicializarSubsistemas();
    }

    private void inicializarSubsistemas() {
        System.out.println("üîß Inicializando subsistemas...");
        pagamento.configurar("api-key-123", "secret-xyz");
        notaFiscal.conectarSefaz();
        email.conectarSmtp("smtp.gmail.com", 587);
        System.out.println("‚úÖ Subsistemas inicializados\n");
    }

    // Interface simplificada de alto n√≠vel
    public ResultadoCheckout finalizarCompra(Pedido pedido) {
        System.out.println("üõí Iniciando checkout do pedido: " + pedido.id());
        System.out.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");

        try {
            // 1. Validar e reservar estoque
            validarEstoque(pedido);

            // 2. Processar pagamento
            ResultadoPagamento resultadoPagamento = processarPagamento(pedido);

            // 3. Emitir nota fiscal
            NotaFiscal nf = emitirNotaFiscal(pedido);

            // 4. Solicitar envio
            String etiqueta = solicitarEnvio(pedido);

            // 5. Notificar cliente
            notificarCliente(pedido, nf);

            checkoutsRealizados.incrementAndGet();

            System.out.println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
            System.out.println("‚úÖ Checkout finalizado com sucesso!\n");

            return ResultadoCheckout.sucesso(
                pedido.id(),
                resultadoPagamento.transacaoId(),
                nf.chaveAcesso(),
                etiqueta
            );

        } catch (Exception e) {
            System.err.println("‚ùå Erro no checkout: " + e.getMessage());

            // Compensa√ß√£o em caso de erro
            try {
                estoque.liberar(pedido.itens());
            } catch (Exception ex) {
                System.err.println("‚ö†Ô∏è Erro ao liberar estoque: " + ex.getMessage());
            }

            return ResultadoCheckout.falha(pedido.id(), e.getMessage());
        }
    }

    private void validarEstoque(Pedido pedido) {
        if (!estoque.verificarDisponibilidade(pedido.itens())) {
            throw new EstoqueInsuficienteException("Estoque insuficiente");
        }
        estoque.reservar(pedido.itens());
    }

    private ResultadoPagamento processarPagamento(Pedido pedido) {
        ResultadoPagamento resultado = pagamento.processar(
            pedido.valorTotal(),
            pedido.formaPagamento()
        );

        if (!resultado.sucesso()) {
            throw new PagamentoException("Pagamento falhou: " + resultado.mensagem());
        }

        return resultado;
    }

    private NotaFiscal emitirNotaFiscal(Pedido pedido) {
        NotaFiscal nf = notaFiscal.emitir(pedido);
        notaFiscal.enviarPorEmail(nf, pedido.clienteEmail());
        return nf;
    }

    private String solicitarEnvio(Pedido pedido) {
        logistica.calcularFrete(pedido);
        String etiqueta = logistica.gerarEtiqueta(pedido);
        logistica.notificarTransportadora(pedido);
        return etiqueta;
    }

    private void notificarCliente(Pedido pedido, NotaFiscal nf) {
        String mensagem = String.format(
            "Seu pedido %s foi confirmado!\nNota Fiscal: %s",
            pedido.id(), nf.chaveAcesso()
        );

        email.enviar(
            pedido.clienteEmail(),
            "Pedido Confirmado",
            mensagem
        );
    }

    public int getTotalCheckouts() {
        return checkoutsRealizados.get();
    }
}

record ResultadoCheckout(
    boolean sucesso,
    String pedidoId,
    String transacaoId,
    String notaFiscal,
    String etiqueta,
    String mensagem
) {
    static ResultadoCheckout sucesso(String pedidoId, String transacaoId,
                                     String notaFiscal, String etiqueta) {
        return new ResultadoCheckout(
            true, pedidoId, transacaoId, notaFiscal, etiqueta, "Checkout realizado"
        );
    }

    static ResultadoCheckout falha(String pedidoId, String mensagem) {
        return new ResultadoCheckout(
            false, pedidoId, null, null, null, mensagem
        );
    }
}
```

### 3. Models

```java
record Pedido(
    String id,
    String clienteEmail,
    List<ItemPedido> itens,
    BigDecimal valorTotal,
    String formaPagamento
) {}

record ItemPedido(String produtoId, int quantidade, BigDecimal precoUnitario) {}

class EstoqueInsuficienteException extends RuntimeException {
    EstoqueInsuficienteException(String msg) { super(msg); }
}

class PagamentoException extends RuntimeException {
    PagamentoException(String msg) { super(msg); }
}
```

### 4. Facade com Async (Opera√ß√µes Paralelas)

```java
final class AsyncCheckoutFacade {
    private final CheckoutFacade syncFacade;
    private final ExecutorService executor;

    AsyncCheckoutFacade(CheckoutFacade syncFacade) {
        this.syncFacade = syncFacade;
        this.executor = Executors.newFixedThreadPool(4);
    }

    CompletableFuture<ResultadoCheckout> finalizarCompraAsync(Pedido pedido) {
        return CompletableFuture.supplyAsync(
            () -> syncFacade.finalizarCompra(pedido),
            executor
        );
    }

    void shutdown() {
        executor.shutdown();
    }
}
```

### 5. Facade com Cache

```java
final class CachedCheckoutFacade {
    private final CheckoutFacade delegate;
    private final Map<String, ResultadoCheckout> cache = new ConcurrentHashMap<>();

    CachedCheckoutFacade(CheckoutFacade delegate) {
        this.delegate = delegate;
    }

    ResultadoCheckout finalizarCompra(Pedido pedido) {
        // Cache por ID do pedido (idempot√™ncia)
        return cache.computeIfAbsent(pedido.id(), k -> {
            System.out.println("‚è≠Ô∏è Cache MISS - executando checkout");
            return delegate.finalizarCompra(pedido);
        });
    }

    void invalidar(String pedidoId) {
        cache.remove(pedidoId);
    }
}
```

### 6. Facade Builder

```java
final class CheckoutFacadeBuilder {
    private EstoqueService estoque;
    private PagamentoGateway pagamento;
    private NotaFiscalService notaFiscal;
    private LogisticaService logistica;
    private EmailService email;

    CheckoutFacadeBuilder comEstoque(EstoqueService estoque) {
        this.estoque = estoque;
        return this;
    }

    CheckoutFacadeBuilder comPagamento(PagamentoGateway pagamento) {
        this.pagamento = pagamento;
        return this;
    }

    CheckoutFacadeBuilder comNotaFiscal(NotaFiscalService nf) {
        this.notaFiscal = nf;
        return this;
    }

    CheckoutFacadeBuilder comLogistica(LogisticaService logistica) {
        this.logistica = logistica;
        return this;
    }

    CheckoutFacadeBuilder comEmail(EmailService email) {
        this.email = email;
        return this;
    }

    CheckoutFacadeBuilder padrao() {
        this.estoque = new EstoqueService();
        this.pagamento = new PagamentoGateway();
        this.notaFiscal = new NotaFiscalService();
        this.logistica = new LogisticaService();
        this.email = new EmailService();
        return this;
    }

    CheckoutFacade build() {
        if (estoque == null || pagamento == null || notaFiscal == null ||
            logistica == null || email == null) {
            throw new IllegalStateException("Todos os subsistemas s√£o obrigat√≥rios");
        }

        return new CheckoutFacade(estoque, pagamento, notaFiscal, logistica, email);
    }

    static CheckoutFacadeBuilder criar() {
        return new CheckoutFacadeBuilder();
    }
}
```

---

## üß™ Como Testar

### 1. Testar Facade com Mocks

```java
@Test
void facadeDeveCoordenaSubsistemas() {
    // Arrange
    EstoqueService estoqueM = mock(EstoqueService.class);
    PagamentoGateway pagamentoM = mock(PagamentoGateway.class);
    NotaFiscalService nfM = mock(NotaFiscalService.class);
    LogisticaService logisticaM = mock(LogisticaService.class);
    EmailService emailM = mock(EmailService.class);

    when(estoqueM.verificarDisponibilidade(any())).thenReturn(true);
    when(pagamentoM.processar(any(), any()))
        .thenReturn(new ResultadoPagamento(true, "TXN-123", "OK"));
    when(nfM.emitir(any()))
        .thenReturn(new NotaFiscal("NF-123", "PED-001", LocalDateTime.now()));
    when(logisticaM.gerarEtiqueta(any())).thenReturn("ETQ-123");

    CheckoutFacade facade = new CheckoutFacade(
        estoqueM, pagamentoM, nfM, logisticaM, emailM
    );

    Pedido pedido = new Pedido(
        "PED-001",
        "cliente@email.com",
        List.of(new ItemPedido("PROD-001", 2, new BigDecimal("50"))),
        new BigDecimal("100"),
        "CREDITO"
    );

    // Act
    ResultadoCheckout resultado = facade.finalizarCompra(pedido);

    // Assert
    assertTrue(resultado.sucesso());
    verify(estoqueM).verificarDisponibilidade(any());
    verify(estoqueM).reservar(any());
    verify(pagamentoM).processar(any(), any());
    verify(nfM).emitir(any());
    verify(logisticaM).gerarEtiqueta(any());
    verify(emailM).enviar(any(), any(), any());
}
```

### 2. Testar Falha com Rollback

```java
@Test
void deveRealizarRollbackSeEstoqueInsuficiente() {
    // Arrange
    EstoqueService estoqueM = mock(EstoqueService.class);
    when(estoqueM.verificarDisponibilidade(any())).thenReturn(false);

    CheckoutFacade facade = CheckoutFacadeBuilder.criar()
        .comEstoque(estoqueM)
        .comPagamento(mock(PagamentoGateway.class))
        .comNotaFiscal(mock(NotaFiscalService.class))
        .comLogistica(mock(LogisticaService.class))
        .comEmail(mock(EmailService.class))
        .build();

    Pedido pedido = criarPedidoTeste();

    // Act
    ResultadoCheckout resultado = facade.finalizarCompra(pedido);

    // Assert
    assertFalse(resultado.sucesso());
    assertTrue(resultado.mensagem().contains("Estoque insuficiente"));
}
```

### 3. Testar Ordem de Execu√ß√£o

```java
@Test
void deveExecutarSubsistemasNaOrdemCorreta() {
    // Arrange
    InOrder inOrder = inOrder(estoqueM, pagamentoM, nfM, logisticaM, emailM);

    // Act
    facade.finalizarCompra(pedido);

    // Assert - Verifica ordem
    inOrder.verify(estoqueM).verificarDisponibilidade(any());
    inOrder.verify(estoqueM).reservar(any());
    inOrder.verify(pagamentoM).processar(any(), any());
    inOrder.verify(nfM).emitir(any());
    inOrder.verify(logisticaM).gerarEtiqueta(any());
    inOrder.verify(emailM).enviar(any(), any(), any());
}
```

### 4. Testar Async Facade

```java
@Test
void asyncFacadeDeveProcessarEmBackground() throws Exception {
    // Arrange
    CheckoutFacade syncFacade = mock(CheckoutFacade.class);
    when(syncFacade.finalizarCompra(any()))
        .thenReturn(ResultadoCheckout.sucesso("PED-001", "TXN", "NF", "ETQ"));

    AsyncCheckoutFacade asyncFacade = new AsyncCheckoutFacade(syncFacade);

    // Act
    CompletableFuture<ResultadoCheckout> future =
        asyncFacade.finalizarCompraAsync(pedido);

    ResultadoCheckout resultado = future.get(5, TimeUnit.SECONDS);

    // Assert
    assertTrue(resultado.sucesso());
    verify(syncFacade).finalizarCompra(pedido);

    asyncFacade.shutdown();
}
```

### 5. Testar Cache Facade

```java
@Test
void cachedFacadeDeveEvitarChamadasRedundantes() {
    // Arrange
    CheckoutFacade delegateM = mock(CheckoutFacade.class);
    when(delegateM.finalizarCompra(any()))
        .thenReturn(ResultadoCheckout.sucesso("PED-001", "TXN", "NF", "ETQ"));

    CachedCheckoutFacade cached = new CachedCheckoutFacade(delegateM);

    // Act
    cached.finalizarCompra(pedido); // MISS
    cached.finalizarCompra(pedido); // HIT
    cached.finalizarCompra(pedido); // HIT

    // Assert - Apenas 1 chamada ao delegate
    verify(delegateM, times(1)).finalizarCompra(any());
}
```

### 6. Testar Builder

```java
@Test
void builderDeveCriarFacadeCompleta() {
    // Act
    CheckoutFacade facade = CheckoutFacadeBuilder.criar()
        .padrao()
        .build();

    // Assert
    assertNotNull(facade);

    Pedido pedido = criarPedidoTeste();
    ResultadoCheckout resultado = facade.finalizarCompra(pedido);

    assertTrue(resultado.sucesso());
}
```

### 7. Testar M√©tricas

```java
@Test
void facadeDeveRastrearTotalDeCheckouts() {
    // Arrange
    CheckoutFacade facade = CheckoutFacadeBuilder.criar().padrao().build();

    // Act
    facade.finalizarCompra(criarPedidoTeste());
    facade.finalizarCompra(criarPedidoTeste());
    facade.finalizarCompra(criarPedidoTeste());

    // Assert
    assertEquals(3, facade.getTotalCheckouts());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Facade com l√≥gica de neg√≥cio complexa
class BadFacade {
    ResultadoCheckout finalizarCompra(Pedido pedido) {
        // L√≥gica de neg√≥cio na facade ‚ùå
        if (pedido.valorTotal().compareTo(new BigDecimal("1000")) > 0) {
            BigDecimal desconto = pedido.valorTotal().multiply(new BigDecimal("0.1"));
            // Facade n√£o deve conter regras de neg√≥cio!
        }
    }
}

// ‚ùå Facade acoplada (new nos subsistemas)
class TightFacade {
    ResultadoCheckout finalizarCompra(Pedido pedido) {
        EstoqueService estoque = new EstoqueService(); // ‚ùå
        PagamentoGateway pagamento = new PagamentoGateway(); // ‚ùå
    }
}

// ‚ùå Facade expondo subsistemas
class LeakyFacade {
    public EstoqueService getEstoque() { // ‚ùå
        return estoque;
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Facade apenas coordena
class GoodFacade {
    ResultadoCheckout finalizarCompra(Pedido pedido) {
        // Apenas orquestra subsistemas
        validarEstoque(pedido);
        processarPagamento(pedido);
        // L√≥gica complexa nos subsistemas
    }
}

// ‚úÖ Dependency Injection
class InjectableFacade {
    private final EstoqueService estoque;

    InjectableFacade(EstoqueService estoque) { // ‚úÖ
        this.estoque = estoque;
    }
}

// ‚úÖ Interface simplificada (n√£o vaza subsistemas)
class SimpleFacade {
    ResultadoCheckout finalizarCompra(Pedido pedido) {
        // Retorna tipo pr√≥prio, n√£o dos subsistemas
        return ResultadoCheckout.sucesso(...);
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Interface simplificada**: Ocultar complexidade dos subsistemas
- ‚úÖ **Dependency Injection**: Injetar subsistemas (testabilidade)
- ‚úÖ **Apenas coordena√ß√£o**: L√≥gica de neg√≥cio nos subsistemas
- ‚úÖ **N√£o vazar subsistemas**: N√£o expor classes internas
- ‚úÖ **Tratamento de erros**: Capturar exce√ß√µes dos subsistemas
- ‚úÖ **Rollback/compensa√ß√£o**: Desfazer em caso de erro
- ‚úÖ **M√∫ltiplas facades**: Uma facade por contexto/dom√≠nio

---

## üîó Integra√ß√£o com Frameworks

### Spring Service Facade

```java
@Service
public class CheckoutFacade {

    @Autowired
    private EstoqueService estoque;

    @Autowired
    private PagamentoGateway pagamento;

    @Transactional
    public ResultadoCheckout finalizarCompra(Pedido pedido) {
        // Spring gerencia depend√™ncias
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                          | ‚ö†Ô∏è Desvantagens                       |
| ------------------------------------- | ------------------------------------- |
| Simplifica interface complexa         | Camada adicional                      |
| Reduz acoplamento cliente-subsistemas | Pode virar "god object"               |
| Facilita testes (mock da facade)      | N√£o elimina subsistemas               |
| Isola mudan√ßas de subsistemas         | Pode esconder complexidade necess√°ria |
| Melhora legibilidade                  |                                       |

---

## üîç Compara√ß√£o

| Padr√£o       | Prop√≥sito               | Quando Usar                     |
| ------------ | ----------------------- | ------------------------------- |
| **Facade**   | Simplificar subsistema  | M√∫ltiplos subsistemas complexos |
| **Adapter**  | Converter interface     | Incompatibilidade de interfaces |
| **Proxy**    | Controlar acesso        | Lazy load, cache, security      |
| **Mediator** | Centralizar comunica√ß√£o | Objetos comunicando entre si    |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Facade com circuit breaker** (proteger subsistemas falhando)
2. **Facade com metrics** (rastrear performance dos subsistemas)
3. **Facade com retry** (tentar novamente opera√ß√µes falhadas)
4. **Facade hier√°rquica** (facade usando outras facades)
5. **Facade com event sourcing** (registrar todas opera√ß√µes)

---

## üìö Relacionado

- **Adapter**: Converte interfaces incompat√≠veis
- **Mediator**: Centraliza comunica√ß√£o entre objetos
- **Abstract Factory**: Criar fam√≠lias de objetos
- **Template Method**: Define esqueleto de algoritmo

---

**Facade Pattern simplifica subsistemas complexos e facilita testes mockando a facade!** üè¢‚ú®
