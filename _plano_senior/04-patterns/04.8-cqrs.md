# 04.8 CQRS Pattern [EXPERT] üîÄ

## üéØ Objetivo

Separar **modelos de leitura (Query)** e **modelos de escrita (Command)** para otimizar escalabilidade, performance e evolu√ß√£o independente de cada responsabilidade.

---

## üìö O Que √â?

**CQRS (Command Query Responsibility Segregation)** √© um padr√£o arquitetural que separa opera√ß√µes de leitura e escrita em modelos distintos, permitindo otimiza√ß√µes espec√≠ficas para cada lado.

### Analogia

Como um **restaurante**: a cozinha (Commands) usa um modelo otimizado para preparar pratos (ingredientes, receitas), enquanto o card√°pio (Queries) usa um modelo otimizado para clientes escolherem (fotos, pre√ßos, descri√ß√µes).

### Princ√≠pio Fundamental

- **Commands**: Alteram estado, validam regras de neg√≥cio, geram eventos
- **Queries**: Leem dados otimizados para visualiza√ß√£o, sem l√≥gica de neg√≥cio

---

## ‚ùå Problema que Resolve

### Antes (Modelo √önico CRUD)

```java
// ‚ùå PROBLEMA: Modelo inchado, queries afetam transa√ß√µes
@Entity
public class Pedido {
    @Id private String id;
    private BigDecimal valor;

    @OneToMany(fetch = EAGER) // Afeta performance de escrita
    private List<ItemPedido> itens;

    @ManyToOne(fetch = EAGER) // Join pesado para relat√≥rios
    private Cliente cliente;

    @ManyToOne(fetch = EAGER) // Mais joins
    private Endereco entrega;

    // M√©todo usado s√≥ para queries de relat√≥rio
    public BigDecimal calcularValorComDesconto() {
        // L√≥gica complexa s√≥ para dashboard
    }
}

// Comando e Query usam mesmo modelo
pedidoRepository.save(pedido);        // Comando
pedidoRepository.findById(id);        // Query
// Ambos carregam tudo (itens, cliente, endere√ßo)
```

**Problemas**:

- üêå Queries lentas devido a joins necess√°rios para escrita
- üß© Entidades inchadas com campos s√≥ para relat√≥rios
- üîí Conten√ß√£o: leituras bloqueadas por escritas transacionais
- üìà Escalabilidade limitada (n√£o pode escalar leitura independentemente)

### Depois (CQRS)

```java
// ‚úÖ SOLU√á√ÉO: Modelos separados e otimizados

// COMMAND SIDE - Modelo de escrita simplificado
final class CriarPedidoCommand {
    String pedidoId;
    String clienteId;
    BigDecimal valor;
}

final class PedidoCommandHandler {
    void handle(CriarPedidoCommand cmd) {
        // Valida regras, gera eventos, persiste
        validarRegrasNegocio(cmd);
        eventStore.append(new PedidoCriadoEvent(cmd));
    }
}

// QUERY SIDE - Modelo de leitura otimizado
record PedidoView(String id, String cliente, BigDecimal valor, String status) {}

final class PedidoQueryHandler {
    List<PedidoView> listarPedidos() {
        // L√™ de proje√ß√£o desnormalizada (cache, NoSQL)
        return pedidoViewRepository.findAll();
    }
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Definir Commands e Events

```java
// Hierarquia de comandos
sealed interface PedidoCommand
    permits CriarPedidoCommand, AdicionarItemCommand, ConfirmarPedidoCommand {}

record CriarPedidoCommand(
    String pedidoId,
    String clienteId,
    LocalDateTime timestamp
) implements PedidoCommand {}

record AdicionarItemCommand(
    String pedidoId,
    String sku,
    int quantidade,
    BigDecimal precoUnitario
) implements PedidoCommand {}

record ConfirmarPedidoCommand(
    String pedidoId,
    String formaPagamento
) implements PedidoCommand {}

// Eventos resultantes
sealed interface PedidoEvent
    permits PedidoCriado, ItemAdicionado, PedidoConfirmado {}

record PedidoCriado(
    String pedidoId,
    String clienteId,
    LocalDateTime timestamp
) implements PedidoEvent {}

record ItemAdicionado(
    String pedidoId,
    String sku,
    int quantidade,
    BigDecimal precoUnitario,
    LocalDateTime timestamp
) implements PedidoEvent {}

record PedidoConfirmado(
    String pedidoId,
    String formaPagamento,
    BigDecimal valorTotal,
    LocalDateTime timestamp
) implements PedidoEvent {}
```

### 2. Command Side (Modelo de Escrita)

```java
// Aggregate otimizado para escrita
final class PedidoAggregate {
    private String pedidoId;
    private String clienteId;
    private Map<String, ItemPedido> itens = new HashMap<>();
    private boolean confirmado = false;
    private final List<PedidoEvent> pendingEvents = new ArrayList<>();

    record ItemPedido(String sku, int quantidade, BigDecimal precoUnitario) {}

    // Comandos que geram eventos
    void criar(String pedidoId, String clienteId, LocalDateTime timestamp) {
        if (this.pedidoId != null) {
            throw new IllegalStateException("Pedido j√° existe");
        }

        var evento = new PedidoCriado(pedidoId, clienteId, timestamp);
        apply(evento);
        pendingEvents.add(evento);
    }

    void adicionarItem(String sku, int quantidade, BigDecimal preco, LocalDateTime timestamp) {
        if (confirmado) {
            throw new IllegalStateException("Pedido j√° confirmado");
        }
        if (quantidade <= 0) {
            throw new IllegalArgumentException("Quantidade deve ser positiva");
        }

        var evento = new ItemAdicionado(pedidoId, sku, quantidade, preco, timestamp);
        apply(evento);
        pendingEvents.add(evento);
    }

    void confirmar(String formaPagamento, LocalDateTime timestamp) {
        if (confirmado) {
            throw new IllegalStateException("Pedido j√° confirmado");
        }
        if (itens.isEmpty()) {
            throw new IllegalStateException("Pedido vazio n√£o pode ser confirmado");
        }

        BigDecimal total = calcularTotal();
        var evento = new PedidoConfirmado(pedidoId, formaPagamento, total, timestamp);
        apply(evento);
        pendingEvents.add(evento);
    }

    // Aplicar eventos ao estado
    private void apply(PedidoEvent evento) {
        switch (evento) {
            case PedidoCriado e -> {
                this.pedidoId = e.pedidoId();
                this.clienteId = e.clienteId();
            }
            case ItemAdicionado e -> {
                itens.put(e.sku(), new ItemPedido(e.sku(), e.quantidade(), e.precoUnitario()));
            }
            case PedidoConfirmado e -> {
                this.confirmado = true;
            }
        }
    }

    private BigDecimal calcularTotal() {
        return itens.values().stream()
            .map(item -> item.precoUnitario().multiply(BigDecimal.valueOf(item.quantidade())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Reidrata√ß√£o para Event Sourcing
    static PedidoAggregate rehydrate(List<PedidoEvent> history) {
        var aggregate = new PedidoAggregate();
        history.forEach(aggregate::apply);
        return aggregate;
    }

    List<PedidoEvent> getPendingEvents() {
        return List.copyOf(pendingEvents);
    }

    void clearEvents() {
        pendingEvents.clear();
    }
}

// Command Handler
final class PedidoCommandHandler {
    private final EventStore eventStore;

    PedidoCommandHandler(EventStore eventStore) {
        this.eventStore = eventStore;
    }

    void handle(CriarPedidoCommand cmd) {
        var aggregate = new PedidoAggregate();
        aggregate.criar(cmd.pedidoId(), cmd.clienteId(), cmd.timestamp());

        eventStore.append(cmd.pedidoId(), aggregate.getPendingEvents());
    }

    void handle(AdicionarItemCommand cmd) {
        List<PedidoEvent> history = eventStore.load(cmd.pedidoId());
        var aggregate = PedidoAggregate.rehydrate(history);

        aggregate.adicionarItem(cmd.sku(), cmd.quantidade(), cmd.precoUnitario(), LocalDateTime.now());

        eventStore.append(cmd.pedidoId(), aggregate.getPendingEvents());
    }

    void handle(ConfirmarPedidoCommand cmd) {
        List<PedidoEvent> history = eventStore.load(cmd.pedidoId());
        var aggregate = PedidoAggregate.rehydrate(history);

        aggregate.confirmar(cmd.formaPagamento(), LocalDateTime.now());

        eventStore.append(cmd.pedidoId(), aggregate.getPendingEvents());
    }
}
```

### 3. Query Side (Modelo de Leitura)

```java
// Views otimizadas para leitura
record PedidoListView(
    String pedidoId,
    String clienteNome,
    BigDecimal valorTotal,
    String status,
    LocalDateTime dataCriacao
) {}

record PedidoDetalheView(
    String pedidoId,
    String clienteNome,
    String clienteEmail,
    List<ItemView> itens,
    BigDecimal valorTotal,
    String status,
    String formaPagamento,
    LocalDateTime dataCriacao,
    LocalDateTime dataConfirmacao
) {}

record ItemView(String sku, String nome, int quantidade, BigDecimal precoUnitario) {}

// Reposit√≥rio de leitura (proje√ß√£o desnormalizada)
interface PedidoQueryRepository {
    List<PedidoListView> findAll();
    Optional<PedidoDetalheView> findById(String pedidoId);
    List<PedidoListView> findByCliente(String clienteId);
    List<PedidoListView> findByStatus(String status);
}

// Implementa√ß√£o em mem√≥ria (pode ser cache, NoSQL, etc)
final class InMemoryPedidoQueryRepository implements PedidoQueryRepository {
    private final Map<String, PedidoDetalheView> store = new ConcurrentHashMap<>();

    void save(PedidoDetalheView view) {
        store.put(view.pedidoId(), view);
    }

    @Override
    public List<PedidoListView> findAll() {
        return store.values().stream()
            .map(d -> new PedidoListView(
                d.pedidoId(), d.clienteNome(), d.valorTotal(),
                d.status(), d.dataCriacao()
            ))
            .toList();
    }

    @Override
    public Optional<PedidoDetalheView> findById(String pedidoId) {
        return Optional.ofNullable(store.get(pedidoId));
    }

    @Override
    public List<PedidoListView> findByCliente(String clienteId) {
        return store.values().stream()
            .filter(v -> v.clienteNome().contains(clienteId)) // Simplificado
            .map(d -> new PedidoListView(
                d.pedidoId(), d.clienteNome(), d.valorTotal(),
                d.status(), d.dataCriacao()
            ))
            .toList();
    }

    @Override
    public List<PedidoListView> findByStatus(String status) {
        return store.values().stream()
            .filter(v -> v.status().equals(status))
            .map(d -> new PedidoListView(
                d.pedidoId(), d.clienteNome(), d.valorTotal(),
                d.status(), d.dataCriacao()
            ))
            .toList();
    }
}
```

### 4. Event Projector (Sincroniza Write ‚Üí Read)

```java
// Projeta eventos para modelo de leitura
final class PedidoEventProjector {
    private final InMemoryPedidoQueryRepository queryRepo;

    PedidoEventProjector(InMemoryPedidoQueryRepository queryRepo) {
        this.queryRepo = queryRepo;
    }

    void project(PedidoEvent evento) {
        switch (evento) {
            case PedidoCriado e -> {
                var view = new PedidoDetalheView(
                    e.pedidoId(),
                    "Cliente-" + e.clienteId(), // Simplificado
                    "cliente@email.com",
                    new ArrayList<>(),
                    BigDecimal.ZERO,
                    "CRIADO",
                    null,
                    e.timestamp(),
                    null
                );
                queryRepo.save(view);
            }

            case ItemAdicionado e -> {
                queryRepo.findById(e.pedidoId()).ifPresent(view -> {
                    List<ItemView> novosItens = new ArrayList<>(view.itens());
                    novosItens.add(new ItemView(e.sku(), "Produto-" + e.sku(),
                        e.quantidade(), e.precoUnitario()));

                    BigDecimal novoTotal = view.valorTotal()
                        .add(e.precoUnitario().multiply(BigDecimal.valueOf(e.quantidade())));

                    var updated = new PedidoDetalheView(
                        view.pedidoId(), view.clienteNome(), view.clienteEmail(),
                        novosItens, novoTotal, view.status(), view.formaPagamento(),
                        view.dataCriacao(), view.dataConfirmacao()
                    );
                    queryRepo.save(updated);
                });
            }

            case PedidoConfirmado e -> {
                queryRepo.findById(e.pedidoId()).ifPresent(view -> {
                    var updated = new PedidoDetalheView(
                        view.pedidoId(), view.clienteNome(), view.clienteEmail(),
                        view.itens(), e.valorTotal(), "CONFIRMADO", e.formaPagamento(),
                        view.dataCriacao(), e.timestamp()
                    );
                    queryRepo.save(updated);
                });
            }
        }
    }

    void rebuildProjection(List<PedidoEvent> allEvents) {
        // Reconstruir toda a proje√ß√£o do zero
        allEvents.forEach(this::project);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Command Handler Isoladamente

```java
@Test
void deveCriarPedidoComSucesso() {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    PedidoCommandHandler handler = new PedidoCommandHandler(eventStore);

    var cmd = new CriarPedidoCommand("P1", "C1", LocalDateTime.now());

    // Act
    handler.handle(cmd);

    // Assert
    List<PedidoEvent> events = eventStore.load("P1");
    assertEquals(1, events.size());
    assertInstanceOf(PedidoCriado.class, events.get(0));
}
```

### 2. Testar Query Handler Isoladamente

```java
@Test
void deveRetornarPedidosDaProjecao() {
    // Arrange
    var queryRepo = new InMemoryPedidoQueryRepository();
    queryRepo.save(new PedidoDetalheView(
        "P1", "Jo√£o Silva", "joao@test.com", List.of(),
        BigDecimal.valueOf(100), "CRIADO", null,
        LocalDateTime.now(), null
    ));

    // Act
    List<PedidoListView> pedidos = queryRepo.findAll();

    // Assert
    assertEquals(1, pedidos.size());
    assertEquals("P1", pedidos.get(0).pedidoId());
}
```

### 3. Testar Ciclo Completo (Command ‚Üí Event ‚Üí Query)

```java
@Test
void cicloCompletoComandoEventoQuery() {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    var queryRepo = new InMemoryPedidoQueryRepository();
    var projector = new PedidoEventProjector(queryRepo);
    var commandHandler = new PedidoCommandHandler(eventStore);

    // Act - Criar pedido
    var cmdCriar = new CriarPedidoCommand("P1", "C1", LocalDateTime.now());
    commandHandler.handle(cmdCriar);

    // Projetar eventos
    eventStore.load("P1").forEach(projector::project);

    // Adicionar item
    var cmdItem = new AdicionarItemCommand("P1", "SKU1", 2, BigDecimal.valueOf(50));
    commandHandler.handle(cmdItem);
    eventStore.load("P1").stream()
        .filter(e -> e instanceof ItemAdicionado)
        .forEach(projector::project);

    // Assert - Query retorna estado atualizado
    Optional<PedidoDetalheView> view = queryRepo.findById("P1");
    assertTrue(view.isPresent());
    assertEquals(1, view.get().itens().size());
    assertEquals(BigDecimal.valueOf(100), view.get().valorTotal());
}
```

### 4. Testar Valida√ß√µes de Neg√≥cio no Command

```java
@Test
void naoDeveConfirmarPedidoVazio() {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    var commandHandler = new PedidoCommandHandler(eventStore);

    var cmdCriar = new CriarPedidoCommand("P1", "C1", LocalDateTime.now());
    commandHandler.handle(cmdCriar);

    // Act & Assert
    var cmdConfirmar = new ConfirmarPedidoCommand("P1", "CARTAO");
    assertThrows(IllegalStateException.class, () -> {
        commandHandler.handle(cmdConfirmar);
    });
}
```

### 5. Testar Eventual Consistency (Delay na Proje√ß√£o)

```java
@Test
void projecaoEventualmenteConsistente() throws InterruptedException {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    var queryRepo = new InMemoryPedidoQueryRepository();
    var projector = new PedidoEventProjector(queryRepo);
    var commandHandler = new PedidoCommandHandler(eventStore);

    // Act - Comando executado
    var cmd = new CriarPedidoCommand("P1", "C1", LocalDateTime.now());
    commandHandler.handle(cmd);

    // Query ainda n√£o reflete (eventual consistency)
    Optional<PedidoDetalheView> viewAntes = queryRepo.findById("P1");
    assertFalse(viewAntes.isPresent());

    // Proje√ß√£o ass√≠ncrona (simulado com delay)
    Thread.sleep(100);
    eventStore.load("P1").forEach(projector::project);

    // Query agora reflete
    Optional<PedidoDetalheView> viewDepois = queryRepo.findById("P1");
    assertTrue(viewDepois.isPresent());
}
```

### 6. Testar Rebuild de Proje√ß√£o

```java
@Test
void deveReconstruirProjecaoDoZero() {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    var commandHandler = new PedidoCommandHandler(eventStore);

    // Executar comandos
    commandHandler.handle(new CriarPedidoCommand("P1", "C1", LocalDateTime.now()));
    commandHandler.handle(new AdicionarItemCommand("P1", "SKU1", 1, BigDecimal.TEN));

    // Act - Rebuild proje√ß√£o
    var queryRepo = new InMemoryPedidoQueryRepository();
    var projector = new PedidoEventProjector(queryRepo);

    List<PedidoEvent> allEvents = eventStore.load("P1");
    projector.rebuildProjection(allEvents);

    // Assert
    Optional<PedidoDetalheView> view = queryRepo.findById("P1");
    assertTrue(view.isPresent());
    assertEquals(1, view.get().itens().size());
}
```

### 7. Testar Filtros de Query

```java
@Test
void deveFilterarPorStatus() {
    // Arrange
    var queryRepo = new InMemoryPedidoQueryRepository();
    queryRepo.save(new PedidoDetalheView("P1", "Jo√£o", "j@test.com", List.of(),
        BigDecimal.TEN, "CRIADO", null, LocalDateTime.now(), null));
    queryRepo.save(new PedidoDetalheView("P2", "Maria", "m@test.com", List.of(),
        BigDecimal.TEN, "CONFIRMADO", "CARTAO", LocalDateTime.now(), LocalDateTime.now()));

    // Act
    List<PedidoListView> confirmados = queryRepo.findByStatus("CONFIRMADO");

    // Assert
    assertEquals(1, confirmados.size());
    assertEquals("P2", confirmados.get(0).pedidoId());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Query alterando estado
public void aprovarPedido(String id) {
    PedidoView pedido = queryRepo.findById(id);
    pedido.setStatus("APROVADO"); // NUNCA!
}

// ‚ùå Command retornando dados
public PedidoView criarPedido(CriarPedidoCommand cmd) {
    commandHandler.handle(cmd);
    return queryRepo.findById(cmd.pedidoId()); // Mistura responsabilidades
}

// ‚ùå Acoplamento forte entre models
public class PedidoEntity {
    // Usado em Command E Query - EVITAR!
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Query apenas l√™
public PedidoView buscarPedido(String id) {
    return queryRepo.findById(id);
}

// ‚úÖ Command retorna apenas sucesso/falha
public void criarPedido(CriarPedidoCommand cmd) {
    commandHandler.handle(cmd);
    // Cliente busca depois via Query se precisar
}

// ‚úÖ Models separados
// PedidoAggregate para Command
// PedidoView para Query
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Consist√™ncia eventual**: Aceitar delay entre escrita e leitura
- ‚úÖ **Modelos independentes**: Command e Query n√£o compartilham c√≥digo
- ‚úÖ **Proje√ß√µes especializadas**: M√∫ltiplas views para casos diferentes
- ‚úÖ **Event-driven**: Usar eventos para sincronizar proje√ß√µes
- ‚úÖ **Idempot√™ncia**: Proje√ß√µes devem ser reprocess√°veis
- ‚úÖ **Versioning**: Versionamento de commands e events
- ‚úÖ **Monitoramento**: Alertar se proje√ß√£o atrasar muito

---

## üîó Integra√ß√£o com Frameworks

### Axon Framework

```java
@Aggregate
public class PedidoAggregate {
    @AggregateIdentifier
    private String pedidoId;

    @CommandHandler
    public PedidoAggregate(CriarPedidoCommand cmd) {
        AggregateLifecycle.apply(new PedidoCriado(cmd.pedidoId(), cmd.clienteId()));
    }
}

@Component
public class PedidoProjection {
    @EventHandler
    public void on(PedidoCriado event) {
        // Atualizar modelo de leitura
        queryRepo.save(new PedidoView(event.pedidoId(), "CRIADO"));
    }
}
```

### Spring CQRS

```java
@RestController
@RequestMapping("/pedidos")
public class PedidoController {

    @PostMapping
    public ResponseEntity<Void> criar(@RequestBody CriarPedidoCommand cmd) {
        commandGateway.send(cmd);
        return ResponseEntity.accepted().build();
    }

    @GetMapping("/{id}")
    public PedidoView buscar(@PathVariable String id) {
        return queryService.findById(id);
    }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                                     | ‚ö†Ô∏è Desvantagens                      |
| ------------------------------------------------ | ------------------------------------ |
| Escalabilidade independente (leitura vs escrita) | Consist√™ncia eventual (n√£o imediata) |
| Otimiza√ß√£o espec√≠fica (√≠ndices, cache, NoSQL)    | Complexidade (dois modelos)          |
| Evolu√ß√£o independente                            | Sincroniza√ß√£o entre models           |
| Performance de leitura                           | Curva de aprendizado                 |
| M√∫ltiplas proje√ß√µes especializadas               | Overhead de infraestrutura           |

---

## üîç Compara√ß√£o com Outras Abordagens

| Aspecto                 | CQRS            | CRUD √önico | Event Sourcing + CQRS |
| ----------------------- | --------------- | ---------- | --------------------- |
| **Complexidade**        | M√©dia           | Baixa      | Alta                  |
| **Escalabilidade**      | Alta (separada) | Limitada   | Muito Alta            |
| **Consist√™ncia**        | Eventual        | Forte      | Eventual              |
| **Auditoria**           | Manual          | Limitada   | Completa              |
| **Performance Leitura** | √ìtima           | Depende    | √ìtima                 |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar proje√ß√£o ass√≠ncrona** com fila de eventos (Kafka, RabbitMQ)
2. **Criar m√∫ltiplas views** (resumo, detalhe, analytics) do mesmo aggregate
3. **Implementar cache** na camada de Query (Redis)
4. **Testar rebuild** de proje√ß√£o corrompida
5. **Adicionar versionamento** de commands e garantir compatibilidade

---

## üìö Relacionado

- **Event Sourcing**: Fonte de eventos para proje√ß√µes CQRS
- **Saga Pattern**: Commands coordenam transa√ß√µes distribu√≠das
- **Domain Events**: Base para sincroniza√ß√£o entre models
- **Cache Aside**: Otimiza√ß√£o adicional no Query side

---

**CQRS separa responsabilidades para escalar leitura e escrita independentemente, mas requer aceitar consist√™ncia eventual!** üîÄ‚ú®
