# 04.37 Gateway Padr√£o Arquitetural [EXPERT] üö™

## üéØ Objetivo

Dominar o **API Gateway** como **padr√£o arquitetural** para **roteamento**, **autentica√ß√£o**, **rate limiting**, **load balancing** e **agrega√ß√£o** em arquiteturas de microservices com **Kong**, **Spring Cloud Gateway** e **Zuul**.

---

## üìñ Defini√ß√£o

**API Gateway** √© um padr√£o arquitetural que atua como **ponto de entrada √∫nico** para todas as requisi√ß√µes de clientes em uma arquitetura de microservices.

**Analogia:** √â como a **recep√ß√£o de um hotel** que direciona visitantes para os quartos corretos, valida credenciais e aplica regras de acesso.

---

## üé® Problema

Em arquiteturas de microservices:

```
Cliente ‚Üí Service A (porta 8081)
Cliente ‚Üí Service B (porta 8082)
Cliente ‚Üí Service C (porta 8083)
```

**Problemas:**

- ‚ùå Cliente precisa conhecer m√∫ltiplos endpoints
- ‚ùå CORS precisa ser configurado em cada servi√ßo
- ‚ùå Autentica√ß√£o duplicada em cada servi√ßo
- ‚ùå Rate limiting inconsistente
- ‚ùå N√£o h√° ponto central de monitoramento
- ‚ùå Mudan√ßas em servi√ßos afetam clientes

---

## ‚úÖ Solu√ß√£o

**API Gateway** como ponto de entrada √∫nico:

```
Cliente ‚Üí API Gateway ‚Üí Service A
                     ‚Üí Service B
                     ‚Üí Service C
```

**Vantagens:**

- ‚úÖ **Single Entry Point**: Um endpoint para todos os servi√ßos
- ‚úÖ **Autentica√ß√£o centralizada**: JWT validation em um lugar
- ‚úÖ **Rate Limiting**: Controle de requisi√ß√µes por cliente
- ‚úÖ **Load Balancing**: Distribui√ß√£o de carga
- ‚úÖ **Protocol Translation**: REST ‚Üí gRPC, HTTP ‚Üí WebSocket
- ‚úÖ **Response Aggregation**: Combinar respostas de m√∫ltiplos servi√ßos
- ‚úÖ **Monitoramento**: M√©tricas centralizadas

---

## üèóÔ∏è Implementa√ß√£o: Spring Cloud Gateway

### pom.xml

```xml
<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>

    <!-- Service Discovery (Eureka Client) -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>

    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>

    <!-- Redis (Rate Limiting) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
</dependencies>
```

### Configura√ß√£o B√°sica

```java
@Configuration
public class GatewayConfig {

    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            // Rota para User Service
            .route("user-service", r -> r
                .path("/api/users/**")
                .filters(f -> f
                    .stripPrefix(2)  // Remove /api/users
                    .addRequestHeader("X-Gateway", "true")
                    .circuitBreaker(c -> c
                        .setName("userServiceCB")
                        .setFallbackUri("forward:/fallback/users")
                    )
                )
                .uri("lb://user-service")  // Load balanced via Eureka
            )

            // Rota para Order Service
            .route("order-service", r -> r
                .path("/api/orders/**")
                .filters(f -> f
                    .stripPrefix(2)
                    .rewritePath("/api/orders/(?<segment>.*)", "/${segment}")
                )
                .uri("lb://order-service")
            )

            // Rota para Payment Service
            .route("payment-service", r -> r
                .path("/api/payments/**")
                .filters(f -> f
                    .stripPrefix(2)
                    .requestRateLimiter(c -> c
                        .setRateLimiter(redisRateLimiter())
                        .setKeyResolver(userKeyResolver())
                    )
                )
                .uri("lb://payment-service")
            )

            .build();
    }

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        return new RedisRateLimiter(10, 20);  // 10 req/s, burst 20
    }

    @Bean
    public KeyResolver userKeyResolver() {
        return exchange -> Mono.just(
            exchange.getRequest().getHeaders().getFirst("X-User-Id")
        );
    }
}
```

### application.yml

```yaml
spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://user-service
          predicates:
            - Path=/api/users/**
          filters:
            - StripPrefix=2
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 10
                redis-rate-limiter.burstCapacity: 20

        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
            - Method=GET,POST
          filters:
            - StripPrefix=2
            - AddRequestHeader=X-Request-Source, Gateway

        - id: payment-service
          uri: lb://payment-service
          predicates:
            - Path=/api/payments/**
            - Header=Authorization, Bearer (.*)
          filters:
            - StripPrefix=2

      # Global CORS
      globalcors:
        corsConfigurations:
          "[/**]":
            allowedOrigins: "http://localhost:3000"
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
            allowedHeaders: "*"
            allowCredentials: true

      # Default filters (aplicados a todas as rotas)
      default-filters:
        - AddResponseHeader=X-Response-Time, ${responseTime}

eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
```

---

## üîê Autentica√ß√£o Centralizada

### JWT Authentication Filter

```java
@Component
public class JwtAuthenticationFilter implements GatewayFilter {

    private final JwtUtil jwtUtil;

    public JwtAuthenticationFilter(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();

        // Pula autentica√ß√£o para endpoints p√∫blicos
        if (isPublicPath(request.getPath().toString())) {
            return chain.filter(exchange);
        }

        // Extrai token
        String token = extractToken(request);

        if (token == null || !jwtUtil.validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }

        // Extrai informa√ß√µes do token e adiciona ao header
        String userId = jwtUtil.extractUserId(token);
        String roles = jwtUtil.extractRoles(token);

        ServerHttpRequest modifiedRequest = request.mutate()
            .header("X-User-Id", userId)
            .header("X-User-Roles", roles)
            .build();

        return chain.filter(exchange.mutate().request(modifiedRequest).build());
    }

    private boolean isPublicPath(String path) {
        return path.startsWith("/api/auth/") ||
               path.startsWith("/actuator/health");
    }

    private String extractToken(ServerHttpRequest request) {
        String bearerToken = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### Aplicar Filter Globalmente

```java
@Configuration
public class GatewaySecurityConfig {

    @Bean
    public GlobalFilter jwtAuthenticationGlobalFilter(JwtUtil jwtUtil) {
        return (exchange, chain) -> {
            JwtAuthenticationFilter filter = new JwtAuthenticationFilter(jwtUtil);
            return filter.filter(exchange, chain);
        };
    }
}
```

---

## üö¶ Rate Limiting

### Redis Rate Limiter

```java
@Configuration
public class RateLimitingConfig {

    @Bean
    public RedisRateLimiter redisRateLimiter() {
        // 100 requisi√ß√µes por segundo, burst de 200
        return new RedisRateLimiter(100, 200);
    }

    @Bean
    public KeyResolver ipKeyResolver() {
        // Rate limit por IP
        return exchange -> Mono.just(
            exchange.getRequest().getRemoteAddress().getAddress().getHostAddress()
        );
    }

    @Bean
    public KeyResolver userKeyResolver() {
        // Rate limit por usu√°rio (requer autentica√ß√£o)
        return exchange -> Mono.justOrEmpty(
            exchange.getRequest().getHeaders().getFirst("X-User-Id")
        ).defaultIfEmpty("anonymous");
    }
}
```

### Rate Limiting por Endpoint

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: api-expensive
          uri: lb://expensive-service
          predicates:
            - Path=/api/expensive/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 5 # 5 req/s
                redis-rate-limiter.burstCapacity: 10
                key-resolver: "#{@userKeyResolver}"
```

---

## üîÑ Circuit Breaker

### Resilience4j Circuit Breaker

```java
@Configuration
public class CircuitBreakerConfig {

    @Bean
    public RouteLocator circuitBreakerRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("user-service-resilient", r -> r
                .path("/api/users/**")
                .filters(f -> f
                    .circuitBreaker(c -> c
                        .setName("userServiceCB")
                        .setFallbackUri("forward:/fallback/users")
                        .setStatusCodes("500", "503")
                    )
                )
                .uri("lb://user-service")
            )
            .build();
    }
}
```

### Fallback Controller

```java
@RestController
@RequestMapping("/fallback")
public class FallbackController {

    @GetMapping("/users")
    public ResponseEntity<Map<String, Object>> userServiceFallback() {
        Map<String, Object> response = Map.of(
            "message", "User service is temporarily unavailable",
            "fallback", true,
            "timestamp", LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }

    @GetMapping("/orders")
    public ResponseEntity<Map<String, Object>> orderServiceFallback() {
        Map<String, Object> response = Map.of(
            "message", "Order service is temporarily unavailable",
            "fallback", true,
            "cachedOrders", List.of()  // Retornar cache se dispon√≠vel
        );
        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(response);
    }
}
```

---

## üìä Response Aggregation

### Custom Filter para Agrega√ß√£o

```java
@Component
public class ResponseAggregationFilter implements GlobalFilter, Ordered {

    private final WebClient webClient;

    public ResponseAggregationFilter(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.build();
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String path = exchange.getRequest().getPath().toString();

        // Apenas para endpoint de agrega√ß√£o
        if (!path.equals("/api/aggregate/user-profile")) {
            return chain.filter(exchange);
        }

        String userId = exchange.getRequest().getQueryParams().getFirst("userId");

        // Buscar dados de m√∫ltiplos servi√ßos em paralelo
        Mono<UserDTO> userMono = webClient.get()
            .uri("http://user-service/users/" + userId)
            .retrieve()
            .bodyToMono(UserDTO.class);

        Mono<List<OrderDTO>> ordersMono = webClient.get()
            .uri("http://order-service/orders?userId=" + userId)
            .retrieve()
            .bodyToFlux(OrderDTO.class)
            .collectList();

        Mono<PaymentInfoDTO> paymentMono = webClient.get()
            .uri("http://payment-service/payment-info/" + userId)
            .retrieve()
            .bodyToMono(PaymentInfoDTO.class);

        // Combinar respostas
        return Mono.zip(userMono, ordersMono, paymentMono)
            .flatMap(tuple -> {
                UserProfileAggregateDTO aggregate = new UserProfileAggregateDTO(
                    tuple.getT1(),  // user
                    tuple.getT2(),  // orders
                    tuple.getT3()   // payment info
                );

                // Escrever resposta agregada
                byte[] bytes = serializeToJson(aggregate);
                DataBuffer buffer = exchange.getResponse().bufferFactory().wrap(bytes);
                exchange.getResponse().setStatusCode(HttpStatus.OK);
                exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);

                return exchange.getResponse().writeWith(Mono.just(buffer));
            });
    }

    @Override
    public int getOrder() {
        return -1;  // Alta prioridade
    }

    private byte[] serializeToJson(Object obj) {
        try {
            return new ObjectMapper().writeValueAsBytes(obj);
        } catch (Exception e) {
            throw new RuntimeException("Error serializing response", e);
        }
    }
}
```

---

## üîß Kong API Gateway

### docker-compose.yml

```yaml
version: "3.8"

services:
  kong-database:
    image: postgres:15
    environment:
      POSTGRES_USER: kong
      POSTGRES_DB: kong
      POSTGRES_PASSWORD: kong
    volumes:
      - kong-db:/var/lib/postgresql/data

  kong-migration:
    image: kong:3.5
    command: kong migrations bootstrap
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
    depends_on:
      - kong-database

  kong:
    image: kong:3.5
    ports:
      - "8000:8000" # Proxy
      - "8001:8001" # Admin API
      - "8443:8443" # Proxy SSL
      - "8444:8444" # Admin API SSL
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
    depends_on:
      - kong-database
      - kong-migration

volumes:
  kong-db:
```

### Configurar Services e Routes (Kong)

```bash
# Adicionar Service
curl -i -X POST http://localhost:8001/services \
  --data name=user-service \
  --data url=http://user-service:8080

# Adicionar Route
curl -i -X POST http://localhost:8001/services/user-service/routes \
  --data paths[]=/api/users

# Adicionar Rate Limiting Plugin
curl -i -X POST http://localhost:8001/services/user-service/plugins \
  --data name=rate-limiting \
  --data config.minute=100 \
  --data config.policy=local

# Adicionar JWT Plugin
curl -i -X POST http://localhost:8001/services/user-service/plugins \
  --data name=jwt

# Adicionar CORS Plugin
curl -i -X POST http://localhost:8001/plugins \
  --data name=cors \
  --data config.origins=* \
  --data config.methods=GET,POST,PUT,DELETE
```

---

## üß™ Testando Gateway

### Teste de Roteamento

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
class GatewayRoutingTest {

    @Autowired
    private WebTestClient webTestClient;

    @MockBean
    private UserServiceClient userServiceClient;

    @Test
    @DisplayName("Deve rotear requisi√ß√£o para user-service")
    void deveRotearParaUserService() {
        // Given
        UserDTO user = new UserDTO(1L, "Jo√£o", "joao@mail.com");
        when(userServiceClient.getUser(1L)).thenReturn(Mono.just(user));

        // When & Then
        webTestClient.get()
            .uri("/api/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.nome").isEqualTo("Jo√£o");
    }

    @Test
    @DisplayName("Deve aplicar rate limiting")
    void deveAplicarRateLimiting() {
        // Fazer 101 requisi√ß√µes (limite √© 100/s)
        for (int i = 0; i < 101; i++) {
            WebTestClient.ResponseSpec response = webTestClient.get()
                .uri("/api/users")
                .exchange();

            if (i < 100) {
                response.expectStatus().isOk();
            } else {
                response.expectStatus().isEqualTo(HttpStatus.TOO_MANY_REQUESTS);
            }
        }
    }
}
```

---

## üìã Compara√ß√£o: Kong vs Spring Cloud Gateway vs Zuul

| Caracter√≠stica      | Kong           | Spring Cloud Gateway | Netflix Zuul 2 |
| ------------------- | -------------- | -------------------- | -------------- |
| **Linguagem**       | Lua/Go         | Java                 | Java           |
| **Performance**     | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê     | ‚≠ê‚≠ê‚≠ê‚≠ê             | ‚≠ê‚≠ê‚≠ê         |
| **Plugins**         | 100+ plugins   | Filtros customizados | Filtros custom |
| **Admin UI**        | Konga/Kong GUI | N√£o nativo           | N√£o nativo     |
| **Cloud Native**    | Kubernetes     | Spring Cloud         | Limited        |
| **Rate Limiting**   | ‚úÖ Nativo      | ‚úÖ Redis             | ‚úÖ Custom      |
| **Circuit Breaker** | ‚úÖ Plugin      | ‚úÖ Resilience4j      | ‚úÖ Hystrix     |
| **Service Mesh**    | ‚úÖ Sim         | Limitado             | N√£o            |

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Centralize autentica√ß√£o no Gateway
// Services n√£o precisam validar JWT

// ‚úÖ Use Circuit Breaker
.circuitBreaker(c -> c.setFallbackUri("forward:/fallback"))

// ‚úÖ Rate Limiting por usu√°rio/IP
.requestRateLimiter(c -> c.setKeyResolver(userKeyResolver()))

// ‚úÖ Timeouts configurados
spring.cloud.gateway.httpclient.connect-timeout=3000
spring.cloud.gateway.httpclient.response-timeout=5000

// ‚úÖ Monitoramento com Actuator
management.endpoints.web.exposure.include=health,metrics,gateway

// ‚úÖ CORS centralizado
spring.cloud.gateway.globalcors.corsConfigurations

// ‚úÖ Service Discovery (Eureka)
uri: lb://user-service  // Load balanced

// ‚úÖ Logs estruturados
logging.level.org.springframework.cloud.gateway=DEBUG
```

### ‚ùå Anti-Patterns

```java
// ‚ùå L√≥gica de neg√≥cio no Gateway
// Gateway deve apenas rotear, n√£o processar

// ‚úÖ L√≥gica nos microservices
// Gateway faz roteamento, autentica√ß√£o, rate limiting

// ‚ùå Gateway sem Circuit Breaker
// Um servi√ßo lento derruba o gateway

// ‚úÖ Sempre use Circuit Breaker
.circuitBreaker(c -> c.setFallbackUri(...))

// ‚ùå Sem rate limiting
// Clientes podem sobrecarregar servi√ßos

// ‚úÖ Rate limit por endpoint/usu√°rio
.requestRateLimiter(...)

// ‚ùå Hardcoded service URLs
uri: http://localhost:8081

// ‚úÖ Service Discovery
uri: lb://user-service

// ‚ùå Gateway como single point of failure
// Sem redund√¢ncia

// ‚úÖ M√∫ltiplas inst√¢ncias do Gateway
# Load balancer na frente de N gateways
```

---

## üéØ Quando Usar?

### ‚úÖ Use API Gateway quando:

- Arquitetura de **microservices** com m√∫ltiplos servi√ßos
- Precisa de **autentica√ß√£o centralizada**
- Requer **rate limiting** e **throttling**
- Clientes diversos (web, mobile, IoT)
- Necessita **response aggregation**
- Monitoramento e logging centralizados

### ‚ùå N√£o use quando:

- Aplica√ß√£o **monol√≠tica** simples
- √önico servi√ßo backend
- Performance cr√≠tica (lat√™ncia adicional do gateway)
- Equipe pequena (overhead de manuten√ß√£o)

---

## üìù Resumo

**API Gateway (Padr√£o Arquitetural)** fornece:

- ‚úÖ **Single Entry Point**: Um endpoint para todos os servi√ßos
- ‚úÖ **Roteamento**: Direciona requisi√ß√µes para servi√ßos corretos
- ‚úÖ **Autentica√ß√£o**: JWT validation centralizada
- ‚úÖ **Rate Limiting**: Controle de requisi√ß√µes por cliente/IP
- ‚úÖ **Load Balancing**: Distribui√ß√£o de carga entre inst√¢ncias
- ‚úÖ **Circuit Breaker**: Resili√™ncia contra falhas de servi√ßos
- ‚úÖ **Response Aggregation**: Combina m√∫ltiplas respostas
- ‚úÖ **Protocol Translation**: REST ‚Üî gRPC, HTTP ‚Üî WebSocket
- ‚úÖ **Monitoramento**: M√©tricas e logs centralizados

**Regra de ouro:** Use **API Gateway** como **ponto de entrada √∫nico** em arquiteturas de microservices para **autentica√ß√£o**, **roteamento**, **rate limiting** e **resili√™ncia**.

---

**√öltima Atualiza√ß√£o:** 2025-11-15  
**N√≠vel:** EXPERT  
**Tempo Estimado:** 45 minutos
