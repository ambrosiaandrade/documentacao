# 4.2 Retry Pattern [EXPERT]

üéØ **Objetivo:** Implementar e testar o padr√£o Retry para recuperar automaticamente de falhas transientes com estrat√©gias de backoff exponencial e jitter.

---

## üîÑ O Que √â Retry Pattern?

Padr√£o que **reexecuta opera√ß√µes falhas** automaticamente segundo uma pol√≠tica configur√°vel, permitindo recupera√ß√£o de **falhas tempor√°rias** sem interven√ß√£o manual.

### Analogia

Como tentar ligar para algu√©m ocupado: voc√™ aguarda alguns segundos e tenta novamente, aumentando gradualmente o intervalo entre tentativas.

---

## üéØ Problema que Resolve

### Cen√°rio Sem Retry

```
Cliente ‚Üí API (falha tempor√°ria de rede)
  ‚Üì
ERRO retornado imediatamente
  ‚Üì
Usu√°rio recebe erro evit√°vel
```

### Com Retry

```
Cliente ‚Üí API (falha) ‚Üí Aguarda 100ms ‚Üí Tenta novamente (sucesso)
  ‚Üì
Opera√ß√£o completa transparentemente
```

---

## üîß Tipos de Falhas

### ‚úÖ Falhas Transientes (Usar Retry)

- **Rede**: Timeout moment√¢neo, packet loss
- **Servidor**: 503 Service Unavailable (sobrecarga tempor√°ria)
- **Database**: Deadlock, lock timeout
- **Cloud**: Throttling tempor√°rio

### ‚ùå Falhas Permanentes (N√ÉO Usar Retry)

- **Valida√ß√£o**: 400 Bad Request
- **Autentica√ß√£o**: 401 Unauthorized
- **Autoriza√ß√£o**: 403 Forbidden
- **Recurso inexistente**: 404 Not Found
- **Regra de neg√≥cio**: Exce√ß√µes de dom√≠nio

---

## üìä Estrat√©gias de Backoff

### 1. Backoff Fixo

```
Tentativa 1: aguarda 1s
Tentativa 2: aguarda 1s
Tentativa 3: aguarda 1s
```

**Problema:** N√£o adapta √† carga, pode sobrecarregar sistema.

### 2. Backoff Exponencial

```
Tentativa 1: aguarda 100ms (2^0 √ó 100)
Tentativa 2: aguarda 200ms (2^1 √ó 100)
Tentativa 3: aguarda 400ms (2^2 √ó 100)
Tentativa 4: aguarda 800ms (2^3 √ó 100)
```

**Benef√≠cio:** Reduz press√£o progressivamente.

### 3. Backoff Exponencial + Jitter

```
Tentativa 1: aguarda 100ms + random(0-50ms)
Tentativa 2: aguarda 200ms + random(0-100ms)
Tentativa 3: aguarda 400ms + random(0-200ms)
```

**Benef√≠cio:** Evita "thundering herd" (todos retentam simultaneamente).

---

## üíª Implementa√ß√£o com Java 17

### Estrutura Base

```java
record PoliticaRetry(
    int maxTentativas,
    long backoffInicialMs,
    double multiplicador,
    long maxBackoffMs
) {
    public PoliticaRetry {
        if (maxTentativas < 1) throw new IllegalArgumentException("maxTentativas deve ser >= 1");
        if (backoffInicialMs < 0) throw new IllegalArgumentException("backoffInicial deve ser >= 0");
        if (multiplicador < 1.0) throw new IllegalArgumentException("multiplicador deve ser >= 1.0");
    }

    public static PoliticaRetry padrao() {
        return new PoliticaRetry(3, 100, 2.0, 5000);
    }
}

@FunctionalInterface
interface Acao<T> {
    T executar() throws Exception;
}

final class RetryExecutor {

    public <T> T executar(Acao<T> acao, PoliticaRetry politica) throws Exception {
        return executar(acao, politica, false);
    }

    public <T> T executar(Acao<T> acao, PoliticaRetry politica, boolean usarJitter) throws Exception {
        long espera = politica.backoffInicialMs();
        Exception ultimaExcecao = null;

        for (int tentativa = 1; tentativa <= politica.maxTentativas(); tentativa++) {
            try {
                return acao.executar();

            } catch (Exception e) {
                ultimaExcecao = e;

                // √öltima tentativa - lan√ßa exce√ß√£o
                if (tentativa == politica.maxTentativas()) {
                    throw e;
                }

                // Calcular tempo de espera
                long esperaAtual = Math.min(espera, politica.maxBackoffMs());

                if (usarJitter) {
                    esperaAtual = aplicarJitter(esperaAtual);
                }

                Thread.sleep(esperaAtual);

                // Pr√≥ximo backoff exponencial
                espera = (long) (espera * politica.multiplicador());
            }
        }

        throw ultimaExcecao;
    }

    private long aplicarJitter(long espera) {
        // Randomizar at√© 50% do valor
        long jitter = (long) (Math.random() * espera * 0.5);
        return espera + jitter;
    }
}
```

---

## üß™ Como Testar o Pattern

### Teste 1: Sucesso na Primeira Tentativa

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class RetryExecutorTest {

    @Test
    void deveSucessoNaPrimeiraTentativa() throws Exception {
        Acao<String> acao = mock(Acao.class);
        when(acao.executar()).thenReturn("OK");

        RetryExecutor executor = new RetryExecutor();
        PoliticaRetry politica = new PoliticaRetry(3, 10, 2.0, 1000);

        String resultado = executor.executar(acao, politica);

        assertEquals("OK", resultado);
        verify(acao, times(1)).executar();
    }
}
```

### Teste 2: Falha Transiente, Sucesso na Segunda

```java
@Test
void deveTentarNovamenteAposFalhaTransiente() throws Exception {
    Acao<String> acao = mock(Acao.class);
    when(acao.executar())
        .thenThrow(new RuntimeException("Falha tempor√°ria"))
        .thenReturn("SUCESSO");

    RetryExecutor executor = new RetryExecutor();
    PoliticaRetry politica = new PoliticaRetry(3, 1, 2.0, 1000);

    String resultado = executor.executar(acao, politica);

    assertEquals("SUCESSO", resultado);
    verify(acao, times(2)).executar();
}
```

### Teste 3: Esgotar Todas as Tentativas

```java
@Test
void deveLancarExcecaoAoEsgotarTentativas() throws Exception {
    Acao<String> acao = mock(Acao.class);
    when(acao.executar()).thenThrow(new IllegalStateException("Sempre falha"));

    RetryExecutor executor = new RetryExecutor();
    PoliticaRetry politica = new PoliticaRetry(3, 1, 2.0, 1000);

    Exception ex = assertThrows(IllegalStateException.class,
        () -> executor.executar(acao, politica));

    assertEquals("Sempre falha", ex.getMessage());
    verify(acao, times(3)).executar();
}
```

### Teste 4: Backoff Exponencial

```java
@Test
void deveAplicarBackoffExponencial() throws Exception {
    Acao<String> acao = mock(Acao.class);
    when(acao.executar())
        .thenThrow(new RuntimeException("1"))
        .thenThrow(new RuntimeException("2"))
        .thenReturn("OK");

    RetryExecutor executor = new RetryExecutor();
    PoliticaRetry politica = new PoliticaRetry(3, 100, 2.0, 5000);

    long inicio = System.currentTimeMillis();
    String resultado = executor.executar(acao, politica);
    long duracao = System.currentTimeMillis() - inicio;

    assertEquals("OK", resultado);
    // 100ms + 200ms = 300ms m√≠nimo
    assertTrue(duracao >= 300, "Dura√ß√£o: " + duracao + "ms");
    verify(acao, times(3)).executar();
}
```

### Teste 5: Limite M√°ximo de Backoff

```java
@Test
void deveRespeitarLimiteMaximoBackoff() throws Exception {
    Acao<String> acao = mock(Acao.class);
    when(acao.executar())
        .thenThrow(new RuntimeException("1"))
        .thenThrow(new RuntimeException("2"))
        .thenReturn("OK");

    RetryExecutor executor = new RetryExecutor();
    // Backoff inicial grande, mas limitado a 50ms
    PoliticaRetry politica = new PoliticaRetry(3, 1000, 2.0, 50);

    long inicio = System.currentTimeMillis();
    executor.executar(acao, politica);
    long duracao = System.currentTimeMillis() - inicio;

    // N√£o deve ultrapassar 100ms (2x 50ms)
    assertTrue(duracao < 150, "Dura√ß√£o: " + duracao + "ms");
}
```

### Teste 6: Valida√ß√£o de Pol√≠tica

```java
@Test
void deveLancarExcecaoParaPoliticaInvalida() {
    assertThrows(IllegalArgumentException.class,
        () -> new PoliticaRetry(0, 100, 2.0, 1000));

    assertThrows(IllegalArgumentException.class,
        () -> new PoliticaRetry(3, -10, 2.0, 1000));

    assertThrows(IllegalArgumentException.class,
        () -> new PoliticaRetry(3, 100, 0.5, 1000));
}
```

### Teste 7: Teste com Jitter

```java
@Test
void deveVariarIntervaloComJitter() throws Exception {
    List<Long> intervalos = new ArrayList<>();

    for (int i = 0; i < 10; i++) {
        Acao<String> acao = mock(Acao.class);
        when(acao.executar())
            .thenThrow(new RuntimeException())
            .thenReturn("OK");

        RetryExecutor executor = new RetryExecutor();
        PoliticaRetry politica = new PoliticaRetry(2, 100, 2.0, 1000);

        long inicio = System.currentTimeMillis();
        executor.executar(acao, politica, true); // com jitter
        long duracao = System.currentTimeMillis() - inicio;

        intervalos.add(duracao);
    }

    // Deve haver varia√ß√£o nos intervalos
    long min = Collections.min(intervalos);
    long max = Collections.max(intervalos);

    assertTrue(max - min > 20, "Jitter deve criar varia√ß√£o");
}
```

---

## ‚ö† Cuidados Importantes

### 1. Idempot√™ncia

```java
// ‚ùå PERIGO - Opera√ß√£o n√£o idempotente
@Test
void retryNaoIdempotenteProblematico() {
    // POST que cria recurso duplicado a cada retry
    Acao<String> criarUsuario = () -> {
        userRepository.save(new Usuario("admin"));
        return "OK";
    };
    // Se falhar ap√≥s salvar, retry cria duplicata!
}

// ‚úÖ SEGURO - Opera√ß√£o idempotente
@Test
void retryIdempotenteSeguro() {
    Acao<String> buscarUsuario = () -> {
        return userRepository.findById(1L).getName();
    };
    // Retry seguro - busca n√£o altera estado
}
```

### 2. Tipos de Exce√ß√£o

```java
// ‚úÖ Retry seletivo por tipo de exce√ß√£o
public <T> T executarComFiltro(Acao<T> acao, PoliticaRetry politica,
                                 Class<? extends Exception>... retriableExceptions) {
    // S√≥ tenta novamente para exce√ß√µes espec√≠ficas
    for (int i = 1; i <= politica.maxTentativas(); i++) {
        try {
            return acao.executar();
        } catch (Exception e) {
            boolean deveRetentar = Arrays.stream(retriableExceptions)
                .anyMatch(clazz -> clazz.isInstance(e));

            if (!deveRetentar || i == politica.maxTentativas()) {
                throw e;
            }
            // ... backoff ...
        }
    }
}
```

---

## üìä Boas Pr√°ticas de Teste

### ‚úÖ O Que Testar

- [ ] Sucesso na **primeira tentativa** (sem retries)
- [ ] Falha transiente ‚Üí **sucesso posterior**
- [ ] **Esgotar tentativas** ‚Üí lan√ßar exce√ß√£o
- [ ] **Backoff exponencial** aplicado corretamente
- [ ] **Limite m√°ximo** de backoff respeitado
- [ ] **Jitter** cria varia√ß√£o nos intervalos
- [ ] **Valida√ß√£o** de par√¢metros da pol√≠tica
- [ ] **Logging** de cada tentativa
- [ ] **M√©tricas** (total de retries, taxa de sucesso)

### ‚ö† Evitar

- ‚ùå Sleeps longos em testes (usar valores m√≠nimos)
- ‚ùå Retry em opera√ß√µes **n√£o idempotentes**
- ‚ùå Retry para **todas** as exce√ß√µes (filtrar)
- ‚ùå N√∫mero excessivo de tentativas (esgotar recursos)

---

## ‚öô Frameworks de Produ√ß√£o

### Resilience4j Retry

```java
RetryConfig config = RetryConfig.custom()
    .maxAttempts(3)
    .waitDuration(Duration.ofMillis(100))
    .intervalFunction(IntervalFunction.ofExponentialBackoff(100, 2))
    .retryExceptions(IOException.class, TimeoutException.class)
    .ignoreExceptions(IllegalArgumentException.class)
    .build();

Retry retry = Retry.of("backend", config);

String result = Retry.decorateSupplier(retry,
    () -> remoteService.call()).get();
```

### Spring Retry

```java
@Retryable(
    value = {IOException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 100, multiplier = 2, maxDelay = 5000)
)
public String callRemoteService() {
    return restTemplate.getForObject("/api/data", String.class);
}

@Recover
public String recover(IOException e) {
    return "Fallback ap√≥s esgotar retries";
}
```

---

## üéì Vantagens vs Desvantagens

### ‚úÖ Vantagens

- **Recupera√ß√£o autom√°tica**: Falhas transientes resolvidas transparentemente
- **Simplicidade**: F√°cil de implementar e entender
- **Configur√°vel**: Ajusta para diferentes cen√°rios
- **SLA melhorado**: Menos falhas percebidas pelo usu√°rio

### ‚ö† Desvantagens

- **Lat√™ncia aumentada**: Opera√ß√£o leva mais tempo
- **Carga amplificada**: M√∫ltiplas tentativas sobrecarregam backend
- **Thundering herd**: Sem jitter, todos retem simultaneamente
- **Custo**: Recursos (threads, conex√µes) bloqueados

---

## üîç Compara√ß√£o com Outros Patterns

| Pattern             | Comportamento                   | Quando Usar               |
| ------------------- | ------------------------------- | ------------------------- |
| **Retry**           | Reexecuta at√© sucesso ou limite | Falhas transientes        |
| **Circuit Breaker** | Bloqueia ap√≥s padr√£o de falhas  | Proteger de instabilidade |
| **Timeout**         | Limita tempo de execu√ß√£o        | Evitar bloqueios          |
| **Fallback**        | Retorna alternativa             | Degrada√ß√£o graciosa       |

### Combina√ß√£o Recomendada

```java
// Retry + Circuit Breaker + Timeout
Retry retry = Retry.of("api", retryConfig);
CircuitBreaker cb = CircuitBreaker.of("api", cbConfig);
TimeLimiter limiter = TimeLimiter.of("api", timeoutConfig);

Supplier<String> decorated = Decorators
    .ofSupplier(() -> remoteService.call())
    .withTimeLimiter(limiter)
    .withCircuitBreaker(cb)
    .withRetry(retry)
    .decorate();
```

---

## üß† Exerc√≠cios Pr√°ticos

### 1. Implementar Retry com Dead Letter Queue

Ap√≥s esgotar tentativas, enviar falha para fila DLQ para processamento posterior.

### 2. M√©tricas Detalhadas

Adicionar contadores:

- Total de retries por tipo de exce√ß√£o
- Histograma de dura√ß√£o com retries
- Taxa de sucesso ap√≥s N tentativas

### 3. Retry Ass√≠ncrono

Implementar retry n√£o bloqueante com `CompletableFuture`.

### 4. Retry com Predicado Customizado

Permitir retry apenas se exce√ß√£o atende condi√ß√£o customizada:

```java
.retryOnException(e -> e instanceof IOException && !e.getMessage().contains("fatal"))
```

---

## üìö Refer√™ncias

- **Frameworks:**

  - [Resilience4j Retry](https://resilience4j.readme.io/docs/retry)
  - [Spring Retry](https://github.com/spring-projects/spring-retry)
  - [Guava Retrying](https://github.com/rholder/guava-retrying)

- **Artigos:**
  - [AWS - Exponential Backoff And Jitter](https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/)
  - [Google SRE Book - Handling Overload](https://sre.google/sre-book/handling-overload/)

---

## üìö Pr√≥ximos Passos

- [4.1 Circuit Breaker](04.1-circuit-breaker.md) - Prote√ß√£o contra instabilidade
- [4.3 Fallback Pattern](04.3-fallback.md) - Respostas alternativas
- [4.4 Timeout Pattern](04.4-timeout.md) - Limites de tempo
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [EXPERT]  
**Tempo Estimado:** 2,5 horas  
**Frameworks:** Resilience4j, Spring Retry, Guava Retrying
