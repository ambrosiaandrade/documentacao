# 04.39 Monolithic Architecture [B√ÅSICO] üèõÔ∏è

## üéØ Objetivo

Organizar aplica√ß√£o como **unidade √∫nica** onde todos os componentes s√£o deployados juntos, permitindo **testes integrados simples** e desenvolvimento inicial r√°pido.

---

## üìö O Que √â?

**Monolithic Architecture** estrutura aplica√ß√£o como um √∫nico artefato deploy√°vel, onde UI, l√≥gica de neg√≥cio e acesso a dados residem no mesmo processo e s√£o implantados juntos.

### Analogia

Como **pr√©dio residencial**:

- **Pr√©dio (Monolito)**: Tudo em uma estrutura
- **Apartamentos (M√≥dulos)**: Diferentes fun√ß√µes dentro
- **Funda√ß√£o (Database)**: Base compartilhada
- **Vantagem**: Simples de construir e gerenciar inicialmente

---

## ‚ùå Problema que Resolve

### Antes (Scripts Desorganizados)

```java
// ‚ùå PROBLEMA: C√≥digo sem estrutura, tudo misturado

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Tudo no main ‚ùå
        while (true) {
            System.out.println("1. Criar pedido");
            System.out.println("2. Listar pedidos");
            int opcao = scanner.nextInt();

            if (opcao == 1) {
                // L√≥gica de cria√ß√£o inline ‚ùå
                System.out.println("ID cliente:");
                int clienteId = scanner.nextInt();

                // SQL inline ‚ùå
                Connection conn = DriverManager.getConnection("jdbc:mysql://...");
                PreparedStatement ps = conn.prepareStatement(
                    "INSERT INTO pedidos (cliente_id, data) VALUES (?, ?)"
                );
                ps.setInt(1, clienteId);
                ps.setDate(2, new Date(System.currentTimeMillis()));
                ps.executeUpdate();

                // Email inline ‚ùå
                System.out.println("Enviando email...");
                // ... 50 linhas de SMTP

                conn.close();
            }

            // Sem testes poss√≠veis ‚ùå
            // Sem reutiliza√ß√£o ‚ùå
            // Manuten√ß√£o imposs√≠vel ‚ùå
        }
    }
}
```

**Problemas**:

- üçù C√≥digo spaghetti
- üö´ Sem separa√ß√£o de responsabilidades
- üß™ Imposs√≠vel testar
- üîÅ C√≥digo duplicado
- üìù Sem documenta√ß√£o

### Depois (Monolito Bem Estruturado)

```java
// ‚úÖ SOLU√á√ÉO: Monolito organizado em camadas

// ==== ENTIDADES (Domain) ====
@Entity
@Table(name = "pedidos")
class Pedido {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "cliente_id")
    private Cliente cliente;

    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL)
    private List<ItemPedido> itens = new ArrayList<>();

    private LocalDateTime dataCriacao;

    @Enumerated(EnumType.STRING)
    private StatusPedido status;

    // Getters, setters
}

// ==== REPOSITORY (Persistence) ====
@Repository
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByClienteId(Long clienteId);
    List<Pedido> findByStatus(StatusPedido status);
}

// ==== SERVICE (Business Logic) ====
@Service
@Transactional
class PedidoService {

    private final PedidoRepository repository;
    private final EstoqueService estoqueService;
    private final EmailService emailService;

    @Autowired
    PedidoService(
        PedidoRepository repository,
        EstoqueService estoqueService,
        EmailService emailService
    ) {
        this.repository = repository;
        this.estoqueService = estoqueService;
        this.emailService = emailService;
    }

    Pedido criarPedido(CriarPedidoRequest request) {
        // Valida√ß√µes
        validarRequest(request);

        // Criar entidade
        Pedido pedido = new Pedido();
        pedido.setCliente(buscarCliente(request.clienteId()));
        pedido.setDataCriacao(LocalDateTime.now());
        pedido.setStatus(StatusPedido.PENDENTE);

        // Adicionar itens
        request.itens().forEach(itemReq -> {
            ItemPedido item = new ItemPedido(
                itemReq.produtoId(),
                itemReq.quantidade(),
                itemReq.precoUnitario()
            );
            pedido.adicionarItem(item);
        });

        // Reservar estoque
        estoqueService.reservar(pedido.getItens());

        // Salvar
        Pedido salvo = repository.save(pedido);

        // Notificar
        emailService.enviarConfirmacao(salvo);

        return salvo;
    }

    List<Pedido> listarPedidos(Long clienteId) {
        return repository.findByClienteId(clienteId);
    }

    private void validarRequest(CriarPedidoRequest request) {
        if (request.itens().isEmpty()) {
            throw new IllegalArgumentException("Pedido sem itens");
        }
    }
}

// ==== CONTROLLER (Presentation) ====
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service;

    @Autowired
    PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    ResponseEntity<PedidoDTO> criar(@RequestBody @Valid CriarPedidoRequest request) {
        Pedido pedido = service.criarPedido(request);
        return ResponseEntity.status(201).body(PedidoDTO.from(pedido));
    }

    @GetMapping
    List<PedidoDTO> listar(@RequestParam Long clienteId) {
        return service.listarPedidos(clienteId).stream()
            .map(PedidoDTO::from)
            .toList();
    }
}

// ==== TUDO NO MESMO JAR/WAR ====
// target/loja-monolitica.jar
// - controllers
// - services
// - repositories
// - entities
// Deploy √∫nico ‚úÖ
// Banco compartilhado ‚úÖ
// Testes integrados simples ‚úÖ

// ‚úÖ Vantagens:
// - Estrutura clara em camadas ‚úÖ
// - Test√°vel (mocks, integration tests) ‚úÖ
// - Deploy simples (√∫nico artefato) ‚úÖ
// - Desenvolvimento r√°pido inicial ‚úÖ
// - Transa√ß√µes ACID simples ‚úÖ
// - Debugging f√°cil ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Estrutura Modular do Monolito

```java
// Organiza√ß√£o por packages (modular monolith)

// === Package: com.loja.domain ===
@Entity
class Produto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String nome;
    private String descricao;
    private BigDecimal preco;
    private Integer estoque;
}

@Entity
class Cliente {
    @Id
    @GeneratedValue
    private Long id;
    private String nome;
    private String email;
    private String telefone;

    @Enumerated(EnumType.STRING)
    private TipoCliente tipo;
}

@Entity
class Pedido {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Cliente cliente;

    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ItemPedido> itens = new ArrayList<>();

    private LocalDateTime dataCriacao;
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    private StatusPedido status;

    void adicionarItem(ItemPedido item) {
        itens.add(item);
        item.setPedido(this);
        recalcularTotal();
    }

    void recalcularTotal() {
        this.valorTotal = itens.stream()
            .map(item -> item.getPrecoUnitario().multiply(
                new BigDecimal(item.getQuantidade())
            ))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

@Entity
class ItemPedido {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Pedido pedido;

    @ManyToOne(fetch = FetchType.LAZY)
    private Produto produto;

    private Integer quantidade;
    private BigDecimal precoUnitario;
}

enum StatusPedido {
    PENDENTE, PROCESSANDO, CONFIRMADO, ENVIADO, ENTREGUE, CANCELADO
}

enum TipoCliente {
    REGULAR, PREMIUM, VIP
}

// === Package: com.loja.repository ===
@Repository
interface ProdutoRepository extends JpaRepository<Produto, Long> {
    List<Produto> findByNomeContainingIgnoreCase(String nome);
    List<Produto> findByPrecoLessThanEqual(BigDecimal preco);

    @Query("SELECT p FROM Produto p WHERE p.estoque > 0")
    List<Produto> findDisponiveis();
}

@Repository
interface ClienteRepository extends JpaRepository<Cliente, Long> {
    Optional<Cliente> findByEmail(String email);
    List<Cliente> findByTipo(TipoCliente tipo);
}

@Repository
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByClienteIdOrderByDataCriacaoDesc(Long clienteId);
    List<Pedido> findByStatus(StatusPedido status);

    @Query("SELECT p FROM Pedido p WHERE p.dataCriacao >= :inicio")
    List<Pedido> findPedidosApartirDe(@Param("inicio") LocalDateTime inicio);
}

// === Package: com.loja.service ===
@Service
@Transactional
public class ProdutoService {

    private final ProdutoRepository repository;

    @Autowired
    public ProdutoService(ProdutoRepository repository) {
        this.repository = repository;
    }

    public Produto criar(CriarProdutoRequest request) {
        Produto produto = new Produto();
        produto.setNome(request.nome());
        produto.setDescricao(request.descricao());
        produto.setPreco(request.preco());
        produto.setEstoque(request.estoque());

        return repository.save(produto);
    }

    public List<Produto> listarDisponiveis() {
        return repository.findDisponiveis();
    }

    public Produto buscarPorId(Long id) {
        return repository.findById(id)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(id));
    }

    public void reduzirEstoque(Long produtoId, int quantidade) {
        Produto produto = buscarPorId(produtoId);

        if (produto.getEstoque() < quantidade) {
            throw new EstoqueInsuficienteException(produtoId, produto.getEstoque(), quantidade);
        }

        produto.setEstoque(produto.getEstoque() - quantidade);
        repository.save(produto);
    }
}

@Service
@Transactional
public class ClienteService {

    private final ClienteRepository repository;

    @Autowired
    public ClienteService(ClienteRepository repository) {
        this.repository = repository;
    }

    public Cliente criar(CriarClienteRequest request) {
        // Validar email √∫nico
        repository.findByEmail(request.email()).ifPresent(c -> {
            throw new EmailJaCadastradoException(request.email());
        });

        Cliente cliente = new Cliente();
        cliente.setNome(request.nome());
        cliente.setEmail(request.email());
        cliente.setTelefone(request.telefone());
        cliente.setTipo(TipoCliente.REGULAR);

        return repository.save(cliente);
    }

    public BigDecimal calcularDesconto(Long clienteId, BigDecimal valorTotal) {
        Cliente cliente = repository.findById(clienteId)
            .orElseThrow(() -> new ClienteNaoEncontradoException(clienteId));

        return switch (cliente.getTipo()) {
            case VIP -> valorTotal.multiply(new BigDecimal("0.15"));
            case PREMIUM -> valorTotal.multiply(new BigDecimal("0.10"));
            case REGULAR -> valorTotal.multiply(new BigDecimal("0.05"));
        };
    }
}

@Service
@Transactional
public class PedidoService {

    private final PedidoRepository pedidoRepository;
    private final ClienteRepository clienteRepository;
    private final ProdutoService produtoService;
    private final EmailService emailService;

    @Autowired
    public PedidoService(
        PedidoRepository pedidoRepository,
        ClienteRepository clienteRepository,
        ProdutoService produtoService,
        EmailService emailService
    ) {
        this.pedidoRepository = pedidoRepository;
        this.clienteRepository = clienteRepository;
        this.produtoService = produtoService;
        this.emailService = emailService;
    }

    public Pedido criarPedido(CriarPedidoRequest request) {
        // 1. Validar cliente
        Cliente cliente = clienteRepository.findById(request.clienteId())
            .orElseThrow(() -> new ClienteNaoEncontradoException(request.clienteId()));

        // 2. Criar pedido
        Pedido pedido = new Pedido();
        pedido.setCliente(cliente);
        pedido.setDataCriacao(LocalDateTime.now());
        pedido.setStatus(StatusPedido.PENDENTE);

        // 3. Adicionar itens
        for (ItemPedidoRequest itemReq : request.itens()) {
            Produto produto = produtoService.buscarPorId(itemReq.produtoId());

            ItemPedido item = new ItemPedido();
            item.setProduto(produto);
            item.setQuantidade(itemReq.quantidade());
            item.setPrecoUnitario(produto.getPreco());

            pedido.adicionarItem(item);
        }

        // 4. Reservar estoque
        for (ItemPedido item : pedido.getItens()) {
            produtoService.reduzirEstoque(
                item.getProduto().getId(),
                item.getQuantidade()
            );
        }

        // 5. Salvar pedido
        Pedido salvo = pedidoRepository.save(pedido);

        // 6. Enviar email (ass√≠ncrono)
        emailService.enviarConfirmacaoPedido(salvo);

        return salvo;
    }

    public List<Pedido> listarPedidosCliente(Long clienteId) {
        return pedidoRepository.findByClienteIdOrderByDataCriacaoDesc(clienteId);
    }

    public void atualizarStatus(Long pedidoId, StatusPedido novoStatus) {
        Pedido pedido = pedidoRepository.findById(pedidoId)
            .orElseThrow(() -> new PedidoNaoEncontradoException(pedidoId));

        pedido.setStatus(novoStatus);
        pedidoRepository.save(pedido);

        // Notificar cliente
        emailService.enviarAtualizacaoStatus(pedido);
    }
}

@Service
public class EmailService {

    public void enviarConfirmacaoPedido(Pedido pedido) {
        System.out.println("üìß Enviando confirma√ß√£o do pedido: " + pedido.getId());
        // L√≥gica de email
    }

    public void enviarAtualizacaoStatus(Pedido pedido) {
        System.out.println("üìß Enviando atualiza√ß√£o de status: " + pedido.getStatus());
        // L√≥gica de email
    }
}

// === Package: com.loja.controller ===
@RestController
@RequestMapping("/api/produtos")
public class ProdutoController {

    private final ProdutoService service;

    @Autowired
    public ProdutoController(ProdutoService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<ProdutoDTO> criar(@RequestBody @Valid CriarProdutoRequest request) {
        Produto produto = service.criar(request);
        return ResponseEntity.status(201).body(ProdutoDTO.from(produto));
    }

    @GetMapping
    public List<ProdutoDTO> listar() {
        return service.listarDisponiveis().stream()
            .map(ProdutoDTO::from)
            .toList();
    }

    @GetMapping("/{id}")
    public ProdutoDTO buscar(@PathVariable Long id) {
        return ProdutoDTO.from(service.buscarPorId(id));
    }
}

@RestController
@RequestMapping("/api/pedidos")
public class PedidoController {

    private final PedidoService service;

    @Autowired
    public PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<PedidoDTO> criar(@RequestBody @Valid CriarPedidoRequest request) {
        Pedido pedido = service.criarPedido(request);
        return ResponseEntity.status(201).body(PedidoDTO.from(pedido));
    }

    @GetMapping
    public List<PedidoDTO> listar(@RequestParam Long clienteId) {
        return service.listarPedidosCliente(clienteId).stream()
            .map(PedidoDTO::from)
            .toList();
    }

    @PatchMapping("/{id}/status")
    public void atualizarStatus(
        @PathVariable Long id,
        @RequestBody AtualizarStatusRequest request
    ) {
        service.atualizarStatus(id, request.status());
    }
}
```

### 2. Configura√ß√£o do Monolito

```java
// Application.properties
server.port=8080
spring.application.name=loja-monolitica

# Database
spring.datasource.url=jdbc:postgresql://localhost:5432/loja
spring.datasource.username=admin
spring.datasource.password=secret
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Connection Pool
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5

# Email
spring.mail.host=smtp.gmail.com
spring.mail.port=587

// Main Application Class
@SpringBootApplication
@EnableTransactionManagement
@EnableScheduling
public class LojaMonolithicApplication {

    public static void main(String[] args) {
        SpringApplication.run(LojaMonolithicApplication.class, args);
    }

    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper()
            .registerModule(new JavaTimeModule())
            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }
}

// Build como JAR √∫nico
// mvn clean package
// target/loja-monolitica.jar (50MB)
```

---

## üß™ Como Testar

### 1. Teste de Integra√ß√£o (Monolito)

```java
@SpringBootTest
@AutoConfigureMockMvc
class PedidoIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private PedidoRepository pedidoRepository;

    @Autowired
    private ClienteRepository clienteRepository;

    @Autowired
    private ProdutoRepository produtoRepository;

    @BeforeEach
    void setUp() {
        // Limpar dados
        pedidoRepository.deleteAll();
        clienteRepository.deleteAll();
        produtoRepository.deleteAll();
    }

    @Test
    void deveCriarPedidoCompletoIntegrado() throws Exception {
        // Arrange - criar dados no banco real
        Cliente cliente = clienteRepository.save(new Cliente("Jo√£o", "joao@test.com"));
        Produto produto = produtoRepository.save(new Produto("Notebook", new BigDecimal("3000"), 10));

        String requestJson = """
            {
                "clienteId": %d,
                "itens": [
                    {
                        "produtoId": %d,
                        "quantidade": 2
                    }
                ]
            }
            """.formatted(cliente.getId(), produto.getId());

        // Act
        mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestJson))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").exists())
            .andExpect(jsonPath("$.status").value("PENDENTE"))
            .andExpect(jsonPath("$.valorTotal").value(6000));

        // Assert - verificar efeitos colaterais
        Produto atualizado = produtoRepository.findById(produto.getId()).get();
        assertEquals(8, atualizado.getEstoque()); // Estoque reduzido
    }
}
```

### 2. Teste de Unidade (Service)

```java
@ExtendWith(MockitoExtension.class)
class PedidoServiceTest {

    @Mock
    private PedidoRepository pedidoRepository;

    @Mock
    private ClienteRepository clienteRepository;

    @Mock
    private ProdutoService produtoService;

    @InjectMocks
    private PedidoService service;

    @Test
    void deveCriarPedidoComSucesso() {
        // Arrange
        when(clienteRepository.findById(1L))
            .thenReturn(Optional.of(new Cliente()));

        when(produtoService.buscarPorId(1L))
            .thenReturn(new Produto("Notebook", new BigDecimal("3000"), 10));

        // Act
        Pedido pedido = service.criarPedido(criarRequest());

        // Assert
        verify(pedidoRepository).save(any(Pedido.class));
        verify(produtoService).reduzirEstoque(1L, 2);
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Modular**: Organizar por packages/features
- ‚úÖ **Camadas**: Separar presentation/business/data
- ‚úÖ **Testes**: Integration tests s√£o pr√°ticos
- ‚úÖ **Transa√ß√µes**: Usar @Transactional
- ‚úÖ **Cache**: Usar cache local (Caffeine)
- ‚úÖ **Logging**: Centralizado (SLF4J)
- ‚úÖ **Monitoramento**: Actuator, Prometheus

---

## üîó Compara√ß√£o com Outras Arquiteturas

| Caracter√≠stica     | Monolith        | Microservices       | SOA          |
| ------------------ | --------------- | ------------------- | ------------ |
| **Deployment**     | √önico           | M√∫ltiplos           | M√∫ltiplos    |
| **Complexidade**   | Baixa           | Alta                | M√©dia        |
| **Escalabilidade** | Vertical        | Horizontal          | Horizontal   |
| **Testes**         | Simples         | Complexo            | Complexo     |
| **Startup**        | R√°pido          | Lento (coordena√ß√£o) | M√©dio        |
| **Manuten√ß√£o**     | F√°cil (pequeno) | Distribu√≠da         | Centralizada |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens             | ‚ö†Ô∏è Desvantagens              |
| ------------------------ | ---------------------------- |
| Simples de desenvolver   | Escala com aplica√ß√£o inteira |
| Deploy √∫nico             | Deploy de tudo ou nada       |
| F√°cil debugar            | Pode se tornar grande demais |
| Transa√ß√µes ACID simples  | Tecnologia √∫nica             |
| Performance (in-process) | Dif√≠cil modularizar depois   |
| Ideal para MVPs          | Requer restarts completos    |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Monolith quando:

- Aplica√ß√£o nova/pequena
- Time pequeno (< 10 pessoas)
- Dom√≠nio bem definido
- Performance cr√≠tica (lat√™ncia)
- Desenvolvimento r√°pido necess√°rio

### ‚ùå Evite Monolith quando:

- Aplica√ß√£o enorme (> 500k LOC)
- Times grandes/distribu√≠dos
- Necessidade de deploy independente
- Tecnologias heterog√™neas
- Escalabilidade extrema

---

**Monolithic Architecture organiza aplica√ß√£o como unidade √∫nica, permitindo desenvolvimento r√°pido e testes simples!** üèõÔ∏è‚ú®
