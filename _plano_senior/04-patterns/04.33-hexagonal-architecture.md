# 04.33 Hexagonal Architecture (Ports & Adapters) [AVAN√áADO] ‚¨°

## üéØ Objetivo

Isolar **dom√≠nio** de detalhes t√©cnicos externos atrav√©s de **portas** (interfaces) e **adaptadores** (implementa√ß√µes), permitindo **testes completos sem depend√™ncias externas** e facilitando troca de tecnologias.

---

## üìö O Que √â?

**Hexagonal Architecture** (tamb√©m conhecida como **Ports & Adapters**) organiza a aplica√ß√£o em torno de um n√∫cleo de dom√≠nio puro, com interfaces (portas) e implementa√ß√µes intercambi√°veis (adaptadores) isolando tecnologias externas.

### Analogia

Como um **smartphone**:

- **N√∫cleo (Dom√≠nio)**: Processador e l√≥gica interna
- **Portas**: USB-C, Bluetooth, WiFi (interfaces padronizadas)
- **Adaptadores**: Carregadores, fones, dispositivos que conectam nas portas
- **Vantagem**: Trocar adaptador (tecnologia) sem mudar o n√∫cleo

---

## ‚ùå Problema que Resolve

### Antes (Dom√≠nio Acoplado a Frameworks)

```java
// ‚ùå PROBLEMA: Dom√≠nio depende de frameworks
@Entity // JPA invade o dom√≠nio ‚ùå
@Table(name = "pedidos")
class Pedido {

    @Id
    @GeneratedValue // Anota√ß√µes de persist√™ncia ‚ùå
    private Long id;

    @Autowired // Spring invade o dom√≠nio ‚ùå
    private PagamentoGateway gateway;

    @Transactional // Frameworks no dom√≠nio ‚ùå
    void processar() {
        // L√≥gica de neg√≥cio misturada com infra
        gateway.processar(...); // Depend√™ncia direta ‚ùå
    }
}

// Repository com Spring Data
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    // Spring Data no dom√≠nio ‚ùå
}

// Service com depend√™ncias de frameworks
@Service // Spring ‚ùå
class PedidoService {

    @Autowired // ‚ùå
    private PedidoRepository repository;

    @Autowired // ‚ùå
    private RestTemplate restTemplate; // Cliente HTTP no dom√≠nio ‚ùå
}

// Problemas:
// - Dom√≠nio depende de JPA, Spring ‚ùå
// - Imposs√≠vel testar sem Spring Context ‚ùå
// - Trocar framework = refatorar dom√≠nio ‚ùå
// - L√≥gica de neg√≥cio polu√≠da ‚ùå
```

**Problemas**:

- üß© Dom√≠nio acoplado a frameworks
- üß™ Testes exigem infra (DB, Spring Context)
- üîß Trocar tecnologia = refatorar dom√≠nio
- üìö L√≥gica de neg√≥cio polu√≠da
- üîÄ Depend√™ncias invertidas

### Depois (Hexagonal Architecture)

```java
// ‚úÖ SOLU√á√ÉO: Dom√≠nio puro com portas

// ==== DOM√çNIO (Centro - SEM depend√™ncias externas) ====
// Entidade pura (POJO)
class Pedido {
    private final PedidoId id;
    private final ClienteId clienteId;
    private final List<ItemPedido> itens;
    private StatusPedido status;
    private BigDecimal valorTotal;

    // Apenas l√≥gica de neg√≥cio
    void processar(ProcessadorPagamento processador) { // Porta inbound
        validarItens();
        this.valorTotal = calcularTotal();

        boolean pagamentoOk = processador.processar(this);

        if (pagamentoOk) {
            this.status = StatusPedido.APROVADO;
        } else {
            this.status = StatusPedido.REJEITADO;
        }
    }

    private void validarItens() {
        if (itens.isEmpty()) {
            throw new PedidoInvalidoException("Pedido sem itens");
        }
    }

    private BigDecimal calcularTotal() {
        return itens.stream()
            .map(ItemPedido::subtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// ==== PORTAS (Interfaces no dom√≠nio) ====
// Porta de entrada (use cases)
interface CriarPedidoUseCase {
    Pedido executar(ComandoCriarPedido comando);
}

// Porta de sa√≠da (depend√™ncias externas)
interface PedidoRepository {
    void salvar(Pedido pedido);
    Optional<Pedido> buscarPorId(PedidoId id);
}

interface ProcessadorPagamento {
    boolean processar(Pedido pedido);
}

// ==== ADAPTADORES (Implementa√ß√µes fora do dom√≠nio) ====
// Adaptador de entrada (REST)
@RestController // Framework fora do dom√≠nio ‚úÖ
class PedidoRestAdapter {

    private final CriarPedidoUseCase useCase; // Depende de PORTA ‚úÖ

    @PostMapping("/pedidos")
    ResponseEntity<PedidoResponse> criar(@RequestBody PedidoRequest request) {
        ComandoCriarPedido comando = request.toComando();
        Pedido pedido = useCase.executar(comando);
        return ResponseEntity.ok(PedidoResponse.from(pedido));
    }
}

// Adaptador de sa√≠da (JPA)
@Repository // Framework fora do dom√≠nio ‚úÖ
class PedidoRepositoryJpa implements PedidoRepository { // Implementa PORTA ‚úÖ

    @PersistenceContext
    private EntityManager em;

    @Override
    public void salvar(Pedido pedido) {
        // Converte dom√≠nio ‚Üí JPA entity
        PedidoEntity entity = PedidoEntity.from(pedido);
        em.persist(entity);
    }
}

// ‚úÖ Teste do dom√≠nio - SEM frameworks!
@Test
void pedidoDeveSerAprovadoComPagamentoSucesso() {
    // Mock da PORTA (n√£o depende de framework)
    ProcessadorPagamento processadorMock = mock(ProcessadorPagamento.class);
    when(processadorMock.processar(any())).thenReturn(true);

    // Dom√≠nio puro
    Pedido pedido = new Pedido(
        new PedidoId(1L),
        new ClienteId(1L),
        List.of(new ItemPedido("P1", 2, BigDecimal.TEN))
    );

    // Act
    pedido.processar(processadorMock);

    // Assert
    assertEquals(StatusPedido.APROVADO, pedido.getStatus());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Dom√≠nio (N√∫cleo - Hex√°gono Central)

```java
// Value Objects (sem frameworks)
record PedidoId(Long valor) {
    PedidoId {
        if (valor == null || valor <= 0) {
            throw new IllegalArgumentException("ID inv√°lido");
        }
    }
}

record ClienteId(Long valor) {}

record ItemPedido(String produtoId, int quantidade, BigDecimal precoUnitario) {
    BigDecimal subtotal() {
        return precoUnitario.multiply(BigDecimal.valueOf(quantidade));
    }
}

enum StatusPedido {
    PENDENTE, APROVADO, REJEITADO, CANCELADO
}

// Entidade de Dom√≠nio (POJO puro)
final class Pedido {
    private final PedidoId id;
    private final ClienteId clienteId;
    private final List<ItemPedido> itens;
    private StatusPedido status;
    private BigDecimal valorTotal;
    private final LocalDateTime criadoEm;

    private Pedido(PedidoId id, ClienteId clienteId, List<ItemPedido> itens, LocalDateTime criadoEm) {
        this.id = id;
        this.clienteId = clienteId;
        this.itens = new ArrayList<>(itens);
        this.status = StatusPedido.PENDENTE;
        this.criadoEm = criadoEm;
        this.valorTotal = BigDecimal.ZERO;
    }

    // Factory method
    static Pedido criar(ClienteId clienteId, List<ItemPedido> itens) {
        if (itens.isEmpty()) {
            throw new PedidoInvalidoException("Pedido deve ter pelo menos 1 item");
        }

        return new Pedido(null, clienteId, itens, LocalDateTime.now());
    }

    // Reconstruir (da persist√™ncia)
    static Pedido reconstituir(PedidoId id, ClienteId clienteId, List<ItemPedido> itens,
                               StatusPedido status, BigDecimal valorTotal, LocalDateTime criadoEm) {
        Pedido pedido = new Pedido(id, clienteId, itens, criadoEm);
        pedido.status = status;
        pedido.valorTotal = valorTotal;
        return pedido;
    }

    // L√≥gica de neg√≥cio
    ResultadoProcessamento processar(ProcessadorPagamento processador, NotificadorPedido notificador) {
        this.valorTotal = calcularTotal();

        try {
            boolean pagamentoOk = processador.processar(this);

            if (pagamentoOk) {
                this.status = StatusPedido.APROVADO;
                notificador.notificarAprovacao(this);
                return ResultadoProcessamento.sucesso("Pedido aprovado");
            } else {
                this.status = StatusPedido.REJEITADO;
                notificador.notificarRejeicao(this);
                return ResultadoProcessamento.falha("Pagamento recusado");
            }

        } catch (Exception e) {
            this.status = StatusPedido.REJEITADO;
            return ResultadoProcessamento.falha("Erro ao processar: " + e.getMessage());
        }
    }

    void cancelar(String motivo) {
        if (status != StatusPedido.PENDENTE && status != StatusPedido.APROVADO) {
            throw new IllegalStateException("Apenas pedidos pendentes/aprovados podem ser cancelados");
        }
        this.status = StatusPedido.CANCELADO;
    }

    private BigDecimal calcularTotal() {
        return itens.stream()
            .map(ItemPedido::subtotal)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    // Getters
    PedidoId getId() { return id; }
    ClienteId getClienteId() { return clienteId; }
    List<ItemPedido> getItens() { return List.copyOf(itens); }
    StatusPedido getStatus() { return status; }
    BigDecimal getValorTotal() { return valorTotal; }
    LocalDateTime getCriadoEm() { return criadoEm; }

    Pedido comId(PedidoId novoId) {
        return Pedido.reconstituir(novoId, clienteId, itens, status, valorTotal, criadoEm);
    }
}

// Domain Exception
class PedidoInvalidoException extends RuntimeException {
    PedidoInvalidoException(String mensagem) {
        super(mensagem);
    }
}

// Domain Result
record ResultadoProcessamento(boolean sucesso, String mensagem) {
    static ResultadoProcessamento sucesso(String msg) {
        return new ResultadoProcessamento(true, msg);
    }

    static ResultadoProcessamento falha(String msg) {
        return new ResultadoProcessamento(false, msg);
    }
}
```

### 2. Portas de Entrada (Use Cases - no dom√≠nio)

```java
// Comandos (DTOs de entrada)
record ComandoCriarPedido(Long clienteId, List<ItemComando> itens) {}
record ItemComando(String produtoId, int quantidade, BigDecimal precoUnitario) {}

record ComandoCancelarPedido(Long pedidoId, String motivo) {}

// Use Cases (portas de entrada)
interface CriarPedidoUseCase {
    Pedido executar(ComandoCriarPedido comando);
}

interface BuscarPedidoUseCase {
    Optional<Pedido> executar(Long pedidoId);
}

interface CancelarPedidoUseCase {
    void executar(ComandoCancelarPedido comando);
}

interface ListarPedidosUseCase {
    List<Pedido> executar(StatusPedido status);
}
```

### 3. Portas de Sa√≠da (Interfaces - no dom√≠nio)

```java
// Porta de persist√™ncia
interface PedidoRepository {
    void salvar(Pedido pedido);
    Optional<Pedido> buscarPorId(PedidoId id);
    List<Pedido> buscarPorStatus(StatusPedido status);
    List<Pedido> buscarTodos();
    void atualizar(Pedido pedido);
}

// Porta de pagamento
interface ProcessadorPagamento {
    boolean processar(Pedido pedido);
    void estornar(PedidoId pedidoId);
}

// Porta de notifica√ß√£o
interface NotificadorPedido {
    void notificarAprovacao(Pedido pedido);
    void notificarRejeicao(Pedido pedido);
    void notificarCancelamento(Pedido pedido, String motivo);
}
```

### 4. Implementa√ß√£o dos Use Cases (Application Services)

```java
// Use Case: Criar Pedido
class CriarPedidoUseCaseImpl implements CriarPedidoUseCase {

    private final PedidoRepository repository;
    private final ProcessadorPagamento processador;
    private final NotificadorPedido notificador;

    CriarPedidoUseCaseImpl(PedidoRepository repository,
                          ProcessadorPagamento processador,
                          NotificadorPedido notificador) {
        this.repository = repository;
        this.processador = processador;
        this.notificador = notificador;
    }

    @Override
    public Pedido executar(ComandoCriarPedido comando) {
        // Converte comando ‚Üí dom√≠nio
        ClienteId clienteId = new ClienteId(comando.clienteId());
        List<ItemPedido> itens = comando.itens().stream()
            .map(i -> new ItemPedido(i.produtoId(), i.quantidade(), i.precoUnitario()))
            .toList();

        // Cria pedido (dom√≠nio puro)
        Pedido pedido = Pedido.criar(clienteId, itens);

        // Processa (l√≥gica de neg√≥cio)
        ResultadoProcessamento resultado = pedido.processar(processador, notificador);

        if (!resultado.sucesso()) {
            throw new PedidoInvalidoException(resultado.mensagem());
        }

        // Persiste
        repository.salvar(pedido);

        return pedido;
    }
}

// Use Case: Buscar Pedido
class BuscarPedidoUseCaseImpl implements BuscarPedidoUseCase {

    private final PedidoRepository repository;

    BuscarPedidoUseCaseImpl(PedidoRepository repository) {
        this.repository = repository;
    }

    @Override
    public Optional<Pedido> executar(Long pedidoId) {
        return repository.buscarPorId(new PedidoId(pedidoId));
    }
}

// Use Case: Cancelar Pedido
class CancelarPedidoUseCaseImpl implements CancelarPedidoUseCase {

    private final PedidoRepository repository;
    private final NotificadorPedido notificador;

    CancelarPedidoUseCaseImpl(PedidoRepository repository, NotificadorPedido notificador) {
        this.repository = repository;
        this.notificador = notificador;
    }

    @Override
    public void executar(ComandoCancelarPedido comando) {
        Pedido pedido = repository.buscarPorId(new PedidoId(comando.pedidoId()))
            .orElseThrow(() -> new PedidoInvalidoException("Pedido n√£o encontrado"));

        pedido.cancelar(comando.motivo());

        repository.atualizar(pedido);
        notificador.notificarCancelamento(pedido, comando.motivo());
    }
}
```

### 5. Adaptador de Entrada (REST API)

```java
// Adaptador REST (fora do dom√≠nio - lado esquerdo do hex√°gono)
@RestController
@RequestMapping("/api/pedidos")
class PedidoRestAdapter {

    private final CriarPedidoUseCase criarUseCase;
    private final BuscarPedidoUseCase buscarUseCase;
    private final CancelarPedidoUseCase cancelarUseCase;
    private final ListarPedidosUseCase listarUseCase;

    @Autowired
    PedidoRestAdapter(CriarPedidoUseCase criarUseCase,
                      BuscarPedidoUseCase buscarUseCase,
                      CancelarPedidoUseCase cancelarUseCase,
                      ListarPedidosUseCase listarUseCase) {
        this.criarUseCase = criarUseCase;
        this.buscarUseCase = buscarUseCase;
        this.cancelarUseCase = cancelarUseCase;
        this.listarUseCase = listarUseCase;
    }

    @PostMapping
    ResponseEntity<PedidoResponse> criar(@Valid @RequestBody PedidoRequest request) {
        ComandoCriarPedido comando = new ComandoCriarPedido(
            request.clienteId(),
            request.itens().stream()
                .map(i -> new ItemComando(i.produtoId(), i.quantidade(), i.precoUnitario()))
                .toList()
        );

        Pedido pedido = criarUseCase.executar(comando);

        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(PedidoResponse.from(pedido));
    }

    @GetMapping("/{id}")
    ResponseEntity<PedidoResponse> buscar(@PathVariable Long id) {
        return buscarUseCase.executar(id)
            .map(PedidoResponse::from)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping("/{id}/cancelar")
    ResponseEntity<Void> cancelar(@PathVariable Long id, @RequestBody CancelarRequest request) {
        ComandoCancelarPedido comando = new ComandoCancelarPedido(id, request.motivo());
        cancelarUseCase.executar(comando);
        return ResponseEntity.noContent().build();
    }

    @GetMapping
    ResponseEntity<List<PedidoResponse>> listar(@RequestParam(required = false) StatusPedido status) {
        List<Pedido> pedidos = listarUseCase.executar(status);
        List<PedidoResponse> response = pedidos.stream()
            .map(PedidoResponse::from)
            .toList();
        return ResponseEntity.ok(response);
    }

    @ExceptionHandler(PedidoInvalidoException.class)
    ResponseEntity<ErrorResponse> handleDomainException(PedidoInvalidoException ex) {
        return ResponseEntity.badRequest().body(new ErrorResponse(ex.getMessage()));
    }
}

// DTOs do adaptador REST
record PedidoRequest(
    @NotNull Long clienteId,
    @NotEmpty List<ItemRequest> itens
) {}

record ItemRequest(
    @NotBlank String produtoId,
    @Min(1) int quantidade,
    @DecimalMin("0.01") BigDecimal precoUnitario
) {}

record PedidoResponse(
    Long id,
    Long clienteId,
    BigDecimal valorTotal,
    String status,
    LocalDateTime criadoEm,
    List<ItemResponse> itens
) {
    static PedidoResponse from(Pedido pedido) {
        return new PedidoResponse(
            pedido.getId().valor(),
            pedido.getClienteId().valor(),
            pedido.getValorTotal(),
            pedido.getStatus().name(),
            pedido.getCriadoEm(),
            pedido.getItens().stream()
                .map(i -> new ItemResponse(i.produtoId(), i.quantidade(), i.precoUnitario()))
                .toList()
        );
    }
}

record ItemResponse(String produtoId, int quantidade, BigDecimal precoUnitario) {}
record CancelarRequest(String motivo) {}
record ErrorResponse(String mensagem) {}
```

### 6. Adaptador de Sa√≠da (Persist√™ncia JPA)

```java
// Entity JPA (fora do dom√≠nio - lado direito do hex√°gono)
@Entity
@Table(name = "pedidos")
class PedidoEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "cliente_id", nullable = false)
    private Long clienteId;

    @Column(name = "valor_total", nullable = false)
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private StatusPedido status;

    @Column(name = "criado_em", nullable = false)
    private LocalDateTime criadoEm;

    @OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<ItemPedidoEntity> itens = new ArrayList<>();

    // Convers√£o Entity ‚Üí Domain
    Pedido toDomain() {
        List<ItemPedido> itensDomain = itens.stream()
            .map(ItemPedidoEntity::toDomain)
            .toList();

        return Pedido.reconstituir(
            new PedidoId(id),
            new ClienteId(clienteId),
            itensDomain,
            status,
            valorTotal,
            criadoEm
        );
    }

    // Convers√£o Domain ‚Üí Entity
    static PedidoEntity from(Pedido pedido) {
        PedidoEntity entity = new PedidoEntity();
        entity.id = pedido.getId() != null ? pedido.getId().valor() : null;
        entity.clienteId = pedido.getClienteId().valor();
        entity.valorTotal = pedido.getValorTotal();
        entity.status = pedido.getStatus();
        entity.criadoEm = pedido.getCriadoEm();

        pedido.getItens().forEach(item -> {
            ItemPedidoEntity itemEntity = ItemPedidoEntity.from(item);
            itemEntity.setPedido(entity);
            entity.itens.add(itemEntity);
        });

        return entity;
    }
}

@Entity
@Table(name = "pedido_itens")
class ItemPedidoEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "pedido_id", nullable = false)
    private PedidoEntity pedido;

    @Column(name = "produto_id", nullable = false)
    private String produtoId;

    @Column(nullable = false)
    private Integer quantidade;

    @Column(name = "preco_unitario", nullable = false)
    private BigDecimal precoUnitario;

    ItemPedido toDomain() {
        return new ItemPedido(produtoId, quantidade, precoUnitario);
    }

    static ItemPedidoEntity from(ItemPedido item) {
        ItemPedidoEntity entity = new ItemPedidoEntity();
        entity.produtoId = item.produtoId();
        entity.quantidade = item.quantidade();
        entity.precoUnitario = item.precoUnitario();
        return entity;
    }

    void setPedido(PedidoEntity pedido) {
        this.pedido = pedido;
    }
}

// Spring Data Repository
@Repository
interface PedidoJpaRepository extends JpaRepository<PedidoEntity, Long> {
    List<PedidoEntity> findByStatus(StatusPedido status);
}

// Adaptador que implementa porta
@Component
class PedidoRepositoryAdapter implements PedidoRepository {

    private final PedidoJpaRepository jpaRepository;

    @Autowired
    PedidoRepositoryAdapter(PedidoJpaRepository jpaRepository) {
        this.jpaRepository = jpaRepository;
    }

    @Override
    public void salvar(Pedido pedido) {
        PedidoEntity entity = PedidoEntity.from(pedido);
        jpaRepository.save(entity);
    }

    @Override
    public Optional<Pedido> buscarPorId(PedidoId id) {
        return jpaRepository.findById(id.valor())
            .map(PedidoEntity::toDomain);
    }

    @Override
    public List<Pedido> buscarPorStatus(StatusPedido status) {
        return jpaRepository.findByStatus(status).stream()
            .map(PedidoEntity::toDomain)
            .toList();
    }

    @Override
    public List<Pedido> buscarTodos() {
        return jpaRepository.findAll().stream()
            .map(PedidoEntity::toDomain)
            .toList();
    }

    @Override
    public void atualizar(Pedido pedido) {
        PedidoEntity entity = PedidoEntity.from(pedido);
        jpaRepository.save(entity);
    }
}
```

### 7. Adaptador de Sa√≠da (Pagamento)

```java
// Adaptador de pagamento externo
@Component
class PagamentoGatewayAdapter implements ProcessadorPagamento {

    private final RestTemplate restTemplate;

    @Value("${pagamento.gateway.url}")
    private String gatewayUrl;

    @Autowired
    PagamentoGatewayAdapter(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    @Override
    public boolean processar(Pedido pedido) {
        try {
            // Chama API externa
            PagamentoRequest request = new PagamentoRequest(
                pedido.getClienteId().valor(),
                pedido.getValorTotal()
            );

            ResponseEntity<PagamentoResponse> response = restTemplate.postForEntity(
                gatewayUrl + "/pagamentos",
                request,
                PagamentoResponse.class
            );

            return response.getStatusCode() == HttpStatus.OK
                && response.getBody().aprovado();

        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public void estornar(PedidoId pedidoId) {
        // Implementa√ß√£o de estorno
    }
}

record PagamentoRequest(Long clienteId, BigDecimal valor) {}
record PagamentoResponse(boolean aprovado, String transacaoId) {}

// Adaptador fake para testes
class PagamentoFakeAdapter implements ProcessadorPagamento {

    private boolean simularAprovacao = true;

    @Override
    public boolean processar(Pedido pedido) {
        return simularAprovacao;
    }

    @Override
    public void estornar(PedidoId pedidoId) {}

    void configurarAprovacao(boolean aprovado) {
        this.simularAprovacao = aprovado;
    }
}
```

### 8. Adaptador de Sa√≠da (Notifica√ß√£o)

```java
@Component
class NotificadorEmailAdapter implements NotificadorPedido {

    private final JavaMailSender mailSender;

    @Autowired
    NotificadorEmailAdapter(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    @Override
    public void notificarAprovacao(Pedido pedido) {
        enviarEmail(
            "cliente@email.com",
            "Pedido Aprovado",
            "Seu pedido #" + pedido.getId().valor() + " foi aprovado!"
        );
    }

    @Override
    public void notificarRejeicao(Pedido pedido) {
        enviarEmail(
            "cliente@email.com",
            "Pedido Rejeitado",
            "Seu pedido #" + pedido.getId().valor() + " foi rejeitado."
        );
    }

    @Override
    public void notificarCancelamento(Pedido pedido, String motivo) {
        enviarEmail(
            "cliente@email.com",
            "Pedido Cancelado",
            "Seu pedido foi cancelado. Motivo: " + motivo
        );
    }

    private void enviarEmail(String destinatario, String assunto, String corpo) {
        // Implementa√ß√£o real de envio
    }
}

// Adaptador fake para testes
class NotificadorSilenciosoAdapter implements NotificadorPedido {
    @Override
    public void notificarAprovacao(Pedido pedido) {}

    @Override
    public void notificarRejeicao(Pedido pedido) {}

    @Override
    public void notificarCancelamento(Pedido pedido, String motivo) {}
}
```

---

## üß™ Como Testar

### 1. Testar Dom√≠nio Puro (Sem Frameworks)

```java
class PedidoTest {

    @Test
    void deveCriarPedidoValido() {
        // Arrange
        ClienteId clienteId = new ClienteId(1L);
        List<ItemPedido> itens = List.of(
            new ItemPedido("P1", 2, BigDecimal.valueOf(10))
        );

        // Act
        Pedido pedido = Pedido.criar(clienteId, itens);

        // Assert
        assertEquals(StatusPedido.PENDENTE, pedido.getStatus());
        assertEquals(1, pedido.getItens().size());
    }

    @Test
    void deveAprovarPedidoComPagamentoSucesso() {
        // Arrange - mocks das PORTAS
        ProcessadorPagamento processador = mock(ProcessadorPagamento.class);
        NotificadorPedido notificador = mock(NotificadorPedido.class);
        when(processador.processar(any())).thenReturn(true);

        Pedido pedido = Pedido.criar(
            new ClienteId(1L),
            List.of(new ItemPedido("P1", 2, BigDecimal.TEN))
        );

        // Act
        ResultadoProcessamento resultado = pedido.processar(processador, notificador);

        // Assert
        assertTrue(resultado.sucesso());
        assertEquals(StatusPedido.APROVADO, pedido.getStatus());
        verify(notificador).notificarAprovacao(pedido);
    }
}
```

### 2. Testar Use Case com Adaptadores Fake

```java
class CriarPedidoUseCaseTest {

    @Test
    void deveCriarEProcessarPedido() {
        // Arrange - adaptadores fake
        PedidoRepository repositoryFake = new PedidoRepositoryInMemory();
        ProcessadorPagamento processadorFake = new PagamentoFakeAdapter();
        NotificadorPedido notificadorFake = new NotificadorSilenciosoAdapter();

        CriarPedidoUseCase useCase = new CriarPedidoUseCaseImpl(
            repositoryFake,
            processadorFake,
            notificadorFake
        );

        ComandoCriarPedido comando = new ComandoCriarPedido(
            1L,
            List.of(new ItemComando("P1", 2, BigDecimal.TEN))
        );

        // Act
        Pedido pedido = useCase.executar(comando);

        // Assert
        assertNotNull(pedido);
        assertEquals(StatusPedido.APROVADO, pedido.getStatus());
    }
}

// Adaptador fake in-memory
class PedidoRepositoryInMemory implements PedidoRepository {
    private final Map<PedidoId, Pedido> storage = new HashMap<>();
    private long sequencia = 1;

    @Override
    public void salvar(Pedido pedido) {
        PedidoId id = new PedidoId(sequencia++);
        Pedido comId = pedido.comId(id);
        storage.put(id, comId);
    }

    @Override
    public Optional<Pedido> buscarPorId(PedidoId id) {
        return Optional.ofNullable(storage.get(id));
    }

    @Override
    public List<Pedido> buscarPorStatus(StatusPedido status) {
        return storage.values().stream()
            .filter(p -> p.getStatus() == status)
            .toList();
    }

    @Override
    public List<Pedido> buscarTodos() {
        return new ArrayList<>(storage.values());
    }

    @Override
    public void atualizar(Pedido pedido) {
        storage.put(pedido.getId(), pedido);
    }
}
```

### 3. Testar Adaptador REST

```java
@WebMvcTest(PedidoRestAdapter.class)
class PedidoRestAdapterTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private CriarPedidoUseCase criarUseCase;

    @Test
    void deveCriarPedidoViaREST() throws Exception {
        // Arrange
        Pedido pedido = Pedido.criar(
            new ClienteId(1L),
            List.of(new ItemPedido("P1", 2, BigDecimal.TEN))
        ).comId(new PedidoId(1L));

        when(criarUseCase.executar(any())).thenReturn(pedido);

        // Act & Assert
        mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                        "clienteId": 1,
                        "itens": [
                            {"produtoId": "P1", "quantidade": 2, "precoUnitario": 10.0}
                        ]
                    }
                    """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1));
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Dom√≠nio dependendo de frameworks
class BadDomain {
    @Autowired // ‚ùå
    private SomeService service;

    @Transactional // ‚ùå
    void method() {}
}

// ‚ùå Porta com depend√™ncia de framework
interface BadPort extends JpaRepository<Entity, Long> { // ‚ùå
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Dom√≠nio puro (POJO)
class GoodDomain {
    // Sem anota√ß√µes ‚úÖ
    // Sem depend√™ncias externas ‚úÖ
}

// ‚úÖ Porta como interface simples
interface GoodPort {
    void save(Domain entity);
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Dom√≠nio no centro**: Sem depend√™ncias externas
- ‚úÖ **Portas no dom√≠nio**: Interfaces pertencem ao dom√≠nio
- ‚úÖ **Adaptadores fora**: Implementa√ß√µes isoladas
- ‚úÖ **Inje√ß√£o de depend√™ncia**: Via construtor
- ‚úÖ **Adaptadores intercambi√°veis**: F√°cil trocar implementa√ß√µes
- ‚úÖ **Testes com fakes**: Implementa√ß√µes in-memory
- ‚úÖ **Value Objects**: Valida√ß√£o no dom√≠nio

---

## üîó Compara√ß√£o

| Padr√£o                 | Organiza√ß√£o          | Depend√™ncias                  | Quando Usar           |
| ---------------------- | -------------------- | ----------------------------- | --------------------- |
| **Hexagonal**          | Dom√≠nio central      | Invertidas (para dentro)      | Dom√≠nio complexo, DDD |
| **Layers**             | Horizontal           | Unidirecional (para baixo)    | Apps tradicionais     |
| **Clean Architecture** | Circular             | Invertidas (regras no centro) | M√°xima independ√™ncia  |
| **Onion**              | Camadas conc√™ntricas | Para dentro                   | Similar Hexagonal     |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                     | ‚ö†Ô∏è Desvantagens              |
| -------------------------------- | ---------------------------- |
| Dom√≠nio totalmente isolado       | Mais camadas/abstra√ß√µes      |
| Test√°vel sem frameworks          | Curva de aprendizado         |
| Troca de tecnologia transparente | Overhead inicial             |
| L√≥gica de neg√≥cio protegida      | Pode ser overkill para CRUDs |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Hexagonal com eventos** (Event Bus como adaptador)
2. **M√∫ltiplos adaptadores entrada** (REST + gRPC + CLI)
3. **M√∫ltiplos adaptadores sa√≠da** (JPA + MongoDB + Cache)
4. **Hexagonal com CQRS** (portas separadas read/write)
5. **Migrar Layers ‚Üí Hexagonal** (refatorar para portas/adapters)

---

## üìö Relacionado

- **DDD (Domain-Driven Design)**: Modelagem do dom√≠nio
- **Clean Architecture**: Evolu√ß√£o do Hexagonal
- **Onion Architecture**: Similar ao Hexagonal
- **Dependency Inversion**: Princ√≠pio base

---

**Hexagonal Architecture isola dom√≠nio de frameworks, permitindo testes puros e arquitetura flex√≠vel!** ‚¨°‚ú®
