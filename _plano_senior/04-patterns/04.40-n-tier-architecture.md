# 04.40 N-Tier Architecture [INTERMEDI√ÅRIO] üèóÔ∏è

## üéØ Objetivo

Separar aplica√ß√£o em **camadas f√≠sicas independentes** (presentation tier, application tier, data tier), permitindo **testes por camada** e escalabilidade independente de cada tier.

---

## üìö O Que √â?

**N-Tier Architecture** (ou Multi-Tier) distribui aplica√ß√£o em camadas f√≠sicas separadas, onde cada tier executa em infraestrutura pr√≥pria e se comunica via rede com outros tiers.

### Analogia

Como **restaurante dividido em espa√ßos**:

- **Sal√£o (Presentation Tier)**: Atendimento ao cliente
- **Cozinha (Application Tier)**: Prepara√ß√£o das refei√ß√µes
- **Despensa (Data Tier)**: Armazenamento de ingredientes
- **Vantagem**: Cada espa√ßo pode ser ampliado independentemente

---

## ‚ùå Problema que Resolve

### Antes (Tudo em Um Servidor - 1-Tier)

```java
// ‚ùå PROBLEMA: Tudo no mesmo servidor

// Servidor √∫nico rodando TUDO
public class ServidorUnico {

    // UI (desktop app no servidor) ‚ùå
    JFrame frame = new JFrame("Sistema");
    JButton btnCriarPedido = new JButton("Criar Pedido");

    btnCriarPedido.addActionListener(e -> {
        // L√≥gica de neg√≥cio no mesmo processo ‚ùå
        Pedido pedido = new Pedido();
        pedido.setCliente(clienteAtual);

        // Acesso direto ao banco no mesmo servidor ‚ùå
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/loja");
        PreparedStatement ps = conn.prepareStatement("INSERT INTO pedidos ...");
        ps.executeUpdate();

        JOptionPane.showMessageDialog(frame, "Pedido criado!");
    });
}

// Problemas:
// - UI e banco no mesmo servidor ‚ùå
// - Sem escalabilidade (1 servidor = 1 limite) ‚ùå
// - Falha = tudo para ‚ùå
// - Dif√≠cil adicionar novos clientes (mobile, web) ‚ùå
// - Usu√°rios acessam banco diretamente ‚ùå
```

**Problemas**:

- üñ•Ô∏è Tudo em um servidor
- üìà Escalabilidade limitada
- üí• Single Point of Failure
- üîê Seguran√ßa (banco exposto)
- üì± Dif√≠cil suportar m√∫ltiplos clientes

### Depois (3-Tier Architecture)

```java
// ‚úÖ SOLU√á√ÉO: Camadas f√≠sicas separadas

// ==== TIER 1: PRESENTATION (Cliente - Frontend) ====
// Servidor Web (Nginx/Apache) porta 80/443
// Arquivos: HTML, CSS, JavaScript

// index.html (no navegador do usu√°rio)
<html>
<body>
    <button onclick="criarPedido()">Criar Pedido</button>

    <script>
    async function criarPedido() {
        // Chama Application Tier via HTTP ‚úÖ
        const response = await fetch('http://app-tier:8080/api/pedidos', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                clienteId: 1,
                itens: [{produtoId: 1, quantidade: 2}]
            })
        });

        const pedido = await response.json();
        alert('Pedido criado: ' + pedido.id);
    }
    </script>
</body>
</html>

// ==== TIER 2: APPLICATION (Backend - Business Logic) ====
// Servidor de Aplica√ß√£o (Tomcat/WildFly) porta 8080

@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    @Autowired
    private PedidoService service; // L√≥gica de neg√≥cio ‚úÖ

    @PostMapping
    ResponseEntity<PedidoDTO> criar(@RequestBody CriarPedidoRequest request) {
        // Processa no Application Tier ‚úÖ
        Pedido pedido = service.criarPedido(request);
        return ResponseEntity.status(201).body(PedidoDTO.from(pedido));
    }
}

@Service
@Transactional
class PedidoService {

    @Autowired
    private DataTierClient dataTierClient; // Cliente para Data Tier ‚úÖ

    Pedido criarPedido(CriarPedidoRequest request) {
        // Valida√ß√µes
        validar(request);

        // Chama Data Tier via rede ‚úÖ
        Pedido pedido = dataTierClient.salvarPedido(request);

        return pedido;
    }
}

// Cliente para Data Tier
@Component
class DataTierClient {

    private final RestTemplate restTemplate = new RestTemplate();
    private final String dataTierUrl = "http://data-tier:9090";

    Pedido salvarPedido(CriarPedidoRequest request) {
        // Chama Data Tier via HTTP ‚úÖ
        return restTemplate.postForObject(
            dataTierUrl + "/data/pedidos",
            request,
            Pedido.class
        );
    }
}

// ==== TIER 3: DATA (Database Access - Persistence) ====
// Servidor de Dados (Database Server) porta 9090

@RestController
@RequestMapping("/data/pedidos")
class PedidoDataController {

    @Autowired
    private PedidoRepository repository; // Acesso ao banco ‚úÖ

    @PostMapping
    Pedido salvar(@RequestBody CriarPedidoRequest request) {
        // APENAS acesso a dados ‚úÖ
        Pedido pedido = new Pedido();
        pedido.setClienteId(request.clienteId());
        // ...

        return repository.save(pedido);
    }

    @GetMapping("/{id}")
    Pedido buscar(@PathVariable Long id) {
        return repository.findById(id)
            .orElseThrow(() -> new PedidoNaoEncontradoException(id));
    }
}

// Database Server (PostgreSQL) porta 5432
// - Isolado da aplica√ß√£o ‚úÖ
// - Acesso apenas via Data Tier ‚úÖ

// ‚úÖ Vantagens:
// - Escalabilidade independente por tier ‚úÖ
// - Falha em um tier n√£o derruba outros ‚úÖ
// - Seguran√ßa: banco n√£o exposto ‚úÖ
// - M√∫ltiplos clientes (web, mobile, desktop) ‚úÖ
// - Deploy independente por tier ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Presentation Tier (Frontend)

```java
// React/Angular/Vue (SPA)

// App.jsx
import React, { useState } from 'react';

function PedidoForm() {
    const [pedido, setPedido] = useState(null);
    const APP_TIER_URL = 'http://app-server.com:8080';

    const criarPedido = async () => {
        try {
            // Chama Application Tier ‚úÖ
            const response = await fetch(`${APP_TIER_URL}/api/pedidos`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ' + getToken()
                },
                body: JSON.stringify({
                    clienteId: 1,
                    itens: [
                        { produtoId: 1, quantidade: 2, precoUnitario: 100.00 }
                    ]
                })
            });

            if (!response.ok) {
                throw new Error('Erro ao criar pedido');
            }

            const data = await response.json();
            setPedido(data);

        } catch (error) {
            console.error('Erro:', error);
            alert('Falha ao criar pedido');
        }
    };

    return (
        <div>
            <h1>Criar Pedido</h1>
            <button onClick={criarPedido}>Criar</button>
            {pedido && <p>Pedido criado: {pedido.id}</p>}
        </div>
    );
}

// Deploy: nginx serving static files
// Roda em: web-server:80
```

### 2. Application Tier (Backend - Spring Boot)

```java
// Servidor de Aplica√ß√£o (Business Logic)

@SpringBootApplication
@EnableAsync
public class ApplicationTierApp {
    public static void main(String[] args) {
        SpringApplication.run(ApplicationTierApp.class, args);
    }
}

// application.yml
server:
  port: 8080

# Conex√£o com Data Tier
data-tier:
  url: http://data-tier-server:9090

// Controller (exp√µe APIs para Presentation Tier)
@RestController
@RequestMapping("/api/pedidos")
@CrossOrigin(origins = "*") // Permite Presentation Tier chamar
public class PedidoController {

    private final PedidoService service;

    @Autowired
    public PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<PedidoDTO> criar(@RequestBody @Valid CriarPedidoRequest request) {
        System.out.println("üì• [App Tier] Recebendo request de Presentation Tier");

        PedidoDTO pedido = service.criarPedido(request);

        return ResponseEntity.status(HttpStatus.CREATED).body(pedido);
    }

    @GetMapping("/{id}")
    public PedidoDTO buscar(@PathVariable Long id) {
        System.out.println("üì• [App Tier] Buscando pedido: " + id);
        return service.buscarPedido(id);
    }

    @GetMapping
    public List<PedidoDTO> listar(@RequestParam Long clienteId) {
        System.out.println("üì• [App Tier] Listando pedidos do cliente: " + clienteId);
        return service.listarPedidosCliente(clienteId);
    }
}

// Service (l√≥gica de neg√≥cio)
@Service
@Transactional
public class PedidoService {

    private final DataTierClient dataTierClient;
    private final EmailService emailService;

    @Autowired
    public PedidoService(DataTierClient dataTierClient, EmailService emailService) {
        this.dataTierClient = dataTierClient;
        this.emailService = emailService;
    }

    public PedidoDTO criarPedido(CriarPedidoRequest request) {
        System.out.println("üîß [App Tier] Processando l√≥gica de neg√≥cio");

        // 1. Valida√ß√µes (Application Tier)
        validarRequest(request);

        // 2. Calcular desconto (Application Tier)
        BigDecimal desconto = calcularDesconto(request.clienteId(), request.valorTotal());

        // 3. Chamar Data Tier para persistir ‚úÖ
        System.out.println("üì° [App Tier] Chamando Data Tier...");
        PedidoDTO pedido = dataTierClient.criarPedido(request);

        // 4. L√≥gica de neg√≥cio adicional (Application Tier)
        emailService.enviarConfirmacao(pedido);

        System.out.println("‚úÖ [App Tier] Pedido criado com sucesso");

        return pedido;
    }

    public PedidoDTO buscarPedido(Long id) {
        // Delega ao Data Tier ‚úÖ
        return dataTierClient.buscarPedido(id);
    }

    public List<PedidoDTO> listarPedidosCliente(Long clienteId) {
        // Delega ao Data Tier ‚úÖ
        return dataTierClient.listarPedidos(clienteId);
    }

    private void validarRequest(CriarPedidoRequest request) {
        if (request.itens() == null || request.itens().isEmpty()) {
            throw new IllegalArgumentException("Pedido sem itens");
        }
    }

    private BigDecimal calcularDesconto(Long clienteId, BigDecimal valorTotal) {
        // L√≥gica de desconto (pode chamar Data Tier para buscar tipo de cliente)
        return valorTotal.multiply(new BigDecimal("0.05"));
    }
}

// Cliente para Data Tier (comunica√ß√£o via HTTP)
@Component
public class DataTierClient {

    private final RestTemplate restTemplate;
    private final String dataTierUrl;

    @Autowired
    public DataTierClient(@Value("${data-tier.url}") String dataTierUrl) {
        this.restTemplate = new RestTemplate();
        this.dataTierUrl = dataTierUrl;
    }

    public PedidoDTO criarPedido(CriarPedidoRequest request) {
        String url = dataTierUrl + "/data/pedidos";

        System.out.println("üì§ [App Tier ‚Üí Data Tier] POST " + url);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<CriarPedidoRequest> entity = new HttpEntity<>(request, headers);

        ResponseEntity<PedidoDTO> response = restTemplate.exchange(
            url,
            HttpMethod.POST,
            entity,
            PedidoDTO.class
        );

        return response.getBody();
    }

    public PedidoDTO buscarPedido(Long id) {
        String url = dataTierUrl + "/data/pedidos/" + id;
        System.out.println("üì§ [App Tier ‚Üí Data Tier] GET " + url);

        return restTemplate.getForObject(url, PedidoDTO.class);
    }

    public List<PedidoDTO> listarPedidos(Long clienteId) {
        String url = dataTierUrl + "/data/pedidos?clienteId=" + clienteId;
        System.out.println("üì§ [App Tier ‚Üí Data Tier] GET " + url);

        ResponseEntity<PedidoDTO[]> response = restTemplate.getForEntity(
            url,
            PedidoDTO[].class
        );

        return Arrays.asList(response.getBody());
    }
}

// Deploy: java -jar application-tier.jar
// Roda em: app-server:8080
```

### 3. Data Tier (Database Access Layer)

```java
// Servidor de Dados (APENAS acesso ao banco)

@SpringBootApplication
public class DataTierApp {
    public static void main(String[] args) {
        SpringApplication.run(DataTierApp.class, args);
    }
}

// application.yml
server:
  port: 9090

spring:
  datasource:
    url: jdbc:postgresql://database-server:5432/loja
    username: admin
    password: secret
  jpa:
    hibernate:
      ddl-auto: update

// Controller (exp√µe APIs para Application Tier)
@RestController
@RequestMapping("/data/pedidos")
public class PedidoDataController {

    private final PedidoRepository repository;
    private final ClienteRepository clienteRepository;
    private final ProdutoRepository produtoRepository;

    @Autowired
    public PedidoDataController(
        PedidoRepository repository,
        ClienteRepository clienteRepository,
        ProdutoRepository produtoRepository
    ) {
        this.repository = repository;
        this.clienteRepository = clienteRepository;
        this.produtoRepository = produtoRepository;
    }

    @PostMapping
    @Transactional
    public PedidoDTO criar(@RequestBody CriarPedidoRequest request) {
        System.out.println("üíæ [Data Tier] Persistindo pedido");

        // APENAS opera√ß√µes de dados ‚úÖ (sem l√≥gica de neg√≥cio)

        Cliente cliente = clienteRepository.findById(request.clienteId())
            .orElseThrow(() -> new ClienteNaoEncontradoException(request.clienteId()));

        Pedido pedido = new Pedido();
        pedido.setCliente(cliente);
        pedido.setDataCriacao(LocalDateTime.now());
        pedido.setStatus(StatusPedido.PENDENTE);

        for (ItemPedidoRequest itemReq : request.itens()) {
            Produto produto = produtoRepository.findById(itemReq.produtoId())
                .orElseThrow(() -> new ProdutoNaoEncontradoException(itemReq.produtoId()));

            ItemPedido item = new ItemPedido();
            item.setProduto(produto);
            item.setQuantidade(itemReq.quantidade());
            item.setPrecoUnitario(itemReq.precoUnitario());

            pedido.adicionarItem(item);
        }

        Pedido salvo = repository.save(pedido);

        System.out.println("‚úÖ [Data Tier] Pedido persistido: " + salvo.getId());

        return PedidoDTO.from(salvo);
    }

    @GetMapping("/{id}")
    public PedidoDTO buscar(@PathVariable Long id) {
        System.out.println("üíæ [Data Tier] Buscando pedido: " + id);

        Pedido pedido = repository.findById(id)
            .orElseThrow(() -> new PedidoNaoEncontradoException(id));

        return PedidoDTO.from(pedido);
    }

    @GetMapping
    public List<PedidoDTO> listar(@RequestParam Long clienteId) {
        System.out.println("üíæ [Data Tier] Listando pedidos do cliente: " + clienteId);

        return repository.findByClienteId(clienteId).stream()
            .map(PedidoDTO::from)
            .toList();
    }

    @PutMapping("/{id}/status")
    @Transactional
    public void atualizarStatus(@PathVariable Long id, @RequestBody StatusRequest request) {
        System.out.println("üíæ [Data Tier] Atualizando status do pedido: " + id);

        Pedido pedido = repository.findById(id)
            .orElseThrow(() -> new PedidoNaoEncontradoException(id));

        pedido.setStatus(request.status());
        repository.save(pedido);
    }
}

@Repository
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByClienteId(Long clienteId);
    List<Pedido> findByStatus(StatusPedido status);
}

// Deploy: java -jar data-tier.jar
// Roda em: data-server:9090
// Conecta a: database-server:5432 (PostgreSQL)
```

### 4. Infraestrutura (Docker Compose)

```yaml
# docker-compose.yml

version: "3.8"

services:
  # Tier 3: Database
  database:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: loja
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: secret
    networks:
      - tier-network

  # Tier 2: Data Tier (acesso a dados)
  data-tier:
    build: ./data-tier
    ports:
      - "9090:9090"
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://database:5432/loja
    depends_on:
      - database
    networks:
      - tier-network

  # Tier 1: Application Tier (l√≥gica de neg√≥cio)
  app-tier:
    build: ./app-tier
    ports:
      - "8080:8080"
    environment:
      DATA_TIER_URL: http://data-tier:9090
    depends_on:
      - data-tier
    networks:
      - tier-network

  # Tier 0: Presentation Tier (frontend)
  web-tier:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./presentation-tier/build:/usr/share/nginx/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app-tier
    networks:
      - tier-network

networks:
  tier-network:
    driver: bridge
```

---

## üß™ Como Testar

### 1. Teste por Tier (Isolado)

```java
// Teste do Application Tier (mock Data Tier)
@SpringBootTest
@AutoConfigureMockMvc
class ApplicationTierTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private DataTierClient dataTierClient; // Mock Data Tier ‚úÖ

    @Test
    void deveCriarPedidoViaMockDataTier() throws Exception {
        // Arrange - mock do Data Tier
        when(dataTierClient.criarPedido(any()))
            .thenReturn(new PedidoDTO(1L, StatusPedido.PENDENTE));

        String requestJson = """
            {
                "clienteId": 1,
                "valorTotal": 100.00,
                "itens": [
                    {"produtoId": 1, "quantidade": 2, "precoUnitario": 50.00}
                ]
            }
            """;

        // Act & Assert
        mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content(requestJson))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.status").value("PENDENTE"));

        verify(dataTierClient).criarPedido(any());
    }
}
```

### 2. Teste de Integra√ß√£o Entre Tiers

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class NTierIntegrationTest {

    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void deveIntegrarApplicationTierComDataTier() {
        // Simula chamada do Presentation Tier ‚Üí Application Tier
        String url = "http://localhost:" + port + "/api/pedidos";

        CriarPedidoRequest request = new CriarPedidoRequest(
            1L,
            List.of(new ItemPedidoRequest(1L, 2, new BigDecimal("50")))
        );

        // Act
        ResponseEntity<PedidoDTO> response = restTemplate.postForEntity(
            url,
            request,
            PedidoDTO.class
        );

        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertNotNull(response.getBody().id());
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Firewall**: Proteger cada tier
- ‚úÖ **Load Balancer**: Distribuir carga por tier
- ‚úÖ **Cache**: Adicionar cache tier (Redis)
- ‚úÖ **Monitoring**: Monitorar cada tier independentemente
- ‚úÖ **Rollback**: Deploy independente permite rollback por tier
- ‚úÖ **Security**: Criptografia entre tiers (TLS)

---

## üîó Compara√ß√£o com Layered Architecture

| Caracter√≠stica     | N-Tier (Physical)     | Layers (Logical)    |
| ------------------ | --------------------- | ------------------- |
| **Separa√ß√£o**      | F√≠sica (servidores)   | L√≥gica (packages)   |
| **Comunica√ß√£o**    | Rede (HTTP/TCP)       | In-process (m√©todo) |
| **Deploy**         | Independente          | Junto               |
| **Escalabilidade** | Por tier              | Aplica√ß√£o inteira   |
| **Lat√™ncia**       | Maior (rede)          | Menor (mem√≥ria)     |
| **Custo**          | Alto (infraestrutura) | Baixo               |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                     | ‚ö†Ô∏è Desvantagens          |
| -------------------------------- | ------------------------ |
| Escalabilidade por tier          | Lat√™ncia de rede         |
| Isolamento de falhas             | Complexidade operacional |
| Seguran√ßa (firewall entre tiers) | Custo de infraestrutura  |
| Deploy independente              | Debugging distribu√≠do    |
| Tecnologia diferente por tier    | Requer serializa√ß√£o      |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use N-Tier quando:

- Escalabilidade por componente necess√°ria
- Times separados (frontend/backend/data)
- Alta carga (precisa escalar tiers independentemente)
- Seguran√ßa cr√≠tica (isolamento f√≠sico)

### ‚ùå Evite N-Tier quando:

- Aplica√ß√£o pequena (overhead desnecess√°rio)
- Baixa carga (tr√°fego simples)
- Lat√™ncia cr√≠tica (rede adiciona overhead)
- Custo limitado (m√∫ltiplos servidores)

---

**N-Tier Architecture separa aplica√ß√£o em camadas f√≠sicas, permitindo escalabilidade e deploy independente por tier!** üèóÔ∏è‚ú®
