# 04.19 Observer Pattern [M√âDIO] üëÅÔ∏è

## üéØ Objetivo

Estabelecer **depend√™ncia 1-para-N** entre objetos, notificando automaticamente todos os observadores quando o estado do sujeito muda, permitindo **testes de eventos** e **desacoplamento** entre produtores e consumidores.

---

## üìö O Que √â?

**Observer** (tamb√©m conhecido como Publish-Subscribe) √© um padr√£o comportamental GoF onde um objeto (Subject) mant√©m lista de dependentes (Observers) e os notifica automaticamente de mudan√ßas de estado. Fundamental para sistemas orientados a eventos.

### Analogia

Como **canal do YouTube**:

- **Subject (Canal)**: Publica novos v√≠deos
- **Observers (Inscritos)**: Recebem notifica√ß√£o autom√°tica
- **Inscrever**: `canal.adicionar(observer)`
- **Desinscrever**: `canal.remover(observer)`
- **Notifica√ß√£o**: Todos inscritos s√£o avisados simultaneamente

---

## ‚ùå Problema que Resolve

### Antes (Acoplamento Forte)

```java
// ‚ùå PROBLEMA: Chamadas diretas acoplam produtor e consumidores
public class PedidoService {
    private final EmailService emailService;
    private final NotificacaoService notificacaoService;
    private final EstoqueService estoqueService;
    private final LogService logService;

    public void criarPedido(Pedido pedido) {
        repository.save(pedido);

        // Acoplamento forte com todos consumidores
        emailService.enviarConfirmacao(pedido);
        notificacaoService.notificarCliente(pedido);
        estoqueService.reservarItens(pedido);
        logService.registrar("Pedido criado: " + pedido.getId());
    }
}

// Problemas:
// - PedidoService conhece todos consumidores
// - Adicionar novo consumidor = modificar PedidoService
// - Imposs√≠vel testar pedido sem todos os servi√ßos
// - Ordem de chamada hardcoded
```

**Problemas**:

- üîó Acoplamento forte (produtor conhece consumidores)
- üß™ Dif√≠cil testar isoladamente
- üîß Viola√ß√£o do Open/Closed (modificar para adicionar)
- ‚ö° Ordem de execu√ß√£o r√≠gida

### Depois (Observer Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Notifica√ß√£o desacoplada via eventos
interface PedidoObserver {
    void onPedidoCriado(PedidoEvent event);
}

public class PedidoService {
    private final List<PedidoObserver> observers = new ArrayList<>();

    public void adicionarObserver(PedidoObserver observer) {
        observers.add(observer);
    }

    public void criarPedido(Pedido pedido) {
        repository.save(pedido);

        // Notifica todos observadores
        PedidoEvent event = new PedidoEvent(pedido.getId(), pedido.getTotal());
        notificar(event);
    }

    private void notificar(PedidoEvent event) {
        observers.forEach(observer -> observer.onPedidoCriado(event));
    }
}

// Observers independentes
class EmailObserver implements PedidoObserver {
    public void onPedidoCriado(PedidoEvent event) {
        emailService.enviar(event);
    }
}

// Testes isolados
@Test
void deveNotificarObservers() {
    PedidoService service = new PedidoService();
    PedidoObserver mock = mock(PedidoObserver.class);
    service.adicionarObserver(mock);

    service.criarPedido(pedido);

    verify(mock).onPedidoCriado(any());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Evento e Observer

```java
record PedidoEvent(
    String pedidoId,
    BigDecimal valor,
    Instant timestamp,
    String tipo
) {
    static PedidoEvent criado(String id, BigDecimal valor) {
        return new PedidoEvent(id, valor, Instant.now(), "CRIADO");
    }

    static PedidoEvent cancelado(String id) {
        return new PedidoEvent(id, BigDecimal.ZERO, Instant.now(), "CANCELADO");
    }
}

@FunctionalInterface
interface PedidoObserver {
    void onEvent(PedidoEvent event);
}
```

### 2. Subject (Observable)

```java
final class PedidoSubject {
    private final List<PedidoObserver> observers = new CopyOnWriteArrayList<>();

    // M√©tricas
    private final AtomicInteger notificacoesEnviadas = new AtomicInteger(0);
    private final AtomicInteger observersAtivos = new AtomicInteger(0);

    void adicionar(PedidoObserver observer) {
        observers.add(observer);
        observersAtivos.incrementAndGet();
        System.out.println("‚úÖ Observer adicionado: " + observer.getClass().getSimpleName());
    }

    void remover(PedidoObserver observer) {
        if (observers.remove(observer)) {
            observersAtivos.decrementAndGet();
            System.out.println("‚ùå Observer removido");
        }
    }

    void notificar(PedidoEvent event) {
        System.out.println("üì¢ Notificando " + observers.size() + " observers...");

        observers.forEach(observer -> {
            try {
                observer.onEvent(event);
                notificacoesEnviadas.incrementAndGet();
            } catch (Exception e) {
                System.err.println("‚ùå Erro notificando observer: " + e.getMessage());
            }
        });
    }

    int totalObservers() {
        return observers.size();
    }

    ObserverMetrics getMetrics() {
        return new ObserverMetrics(
            observersAtivos.get(),
            notificacoesEnviadas.get()
        );
    }
}

record ObserverMetrics(int observersAtivos, int notificacoesEnviadas) {}
```

### 3. Observers Concretos

```java
final class EmailObserver implements PedidoObserver {
    private final AtomicInteger emailsEnviados = new AtomicInteger(0);

    @Override
    public void onEvent(PedidoEvent event) {
        System.out.println("üìß Enviando email para pedido: " + event.pedidoId());

        if (event.tipo().equals("CRIADO")) {
            enviarConfirmacao(event);
        } else if (event.tipo().equals("CANCELADO")) {
            enviarCancelamento(event);
        }

        emailsEnviados.incrementAndGet();
    }

    private void enviarConfirmacao(PedidoEvent event) {
        System.out.println("   ‚úâÔ∏è Email de confirma√ß√£o enviado");
    }

    private void enviarCancelamento(PedidoEvent event) {
        System.out.println("   ‚úâÔ∏è Email de cancelamento enviado");
    }

    int getEmailsEnviados() {
        return emailsEnviados.get();
    }
}

final class EstoqueObserver implements PedidoObserver {
    private final AtomicInteger reservas = new AtomicInteger(0);

    @Override
    public void onEvent(PedidoEvent event) {
        System.out.println("üì¶ Atualizando estoque para pedido: " + event.pedidoId());

        if (event.tipo().equals("CRIADO")) {
            reservarItens(event);
        } else if (event.tipo().equals("CANCELADO")) {
            liberarItens(event);
        }
    }

    private void reservarItens(PedidoEvent event) {
        reservas.incrementAndGet();
        System.out.println("   ‚úÖ Itens reservados");
    }

    private void liberarItens(PedidoEvent event) {
        reservas.decrementAndGet();
        System.out.println("   üîì Itens liberados");
    }

    int getReservasAtivas() {
        return reservas.get();
    }
}

final class LogObserver implements PedidoObserver {
    private final List<String> logs = new CopyOnWriteArrayList<>();

    @Override
    public void onEvent(PedidoEvent event) {
        String log = String.format("[%s] Pedido %s - %s - R$ %s",
            event.timestamp(),
            event.pedidoId(),
            event.tipo(),
            event.valor()
        );

        logs.add(log);
        System.out.println("üìù Log: " + log);
    }

    List<String> getLogs() {
        return Collections.unmodifiableList(logs);
    }
}
```

### 4. Service com Subject Integrado

```java
final class PedidoService {
    private final PedidoSubject subject = new PedidoSubject();
    private final Map<String, Pedido> pedidos = new ConcurrentHashMap<>();

    void adicionarObserver(PedidoObserver observer) {
        subject.adicionar(observer);
    }

    void removerObserver(PedidoObserver observer) {
        subject.remover(observer);
    }

    void criarPedido(String id, BigDecimal valor) {
        Pedido pedido = new Pedido(id, valor, "CRIADO");
        pedidos.put(id, pedido);

        PedidoEvent event = PedidoEvent.criado(id, valor);
        subject.notificar(event);

        System.out.println("‚úÖ Pedido criado: " + id);
    }

    void cancelarPedido(String id) {
        Pedido pedido = pedidos.get(id);
        if (pedido == null) {
            throw new IllegalArgumentException("Pedido n√£o encontrado: " + id);
        }

        pedido = new Pedido(id, pedido.valor(), "CANCELADO");
        pedidos.put(id, pedido);

        PedidoEvent event = PedidoEvent.cancelado(id);
        subject.notificar(event);

        System.out.println("‚ùå Pedido cancelado: " + id);
    }

    ObserverMetrics getMetrics() {
        return subject.getMetrics();
    }
}

record Pedido(String id, BigDecimal valor, String status) {}
```

### 5. Event Bus (Pub/Sub Gen√©rico)

```java
final class EventBus {
    private final Map<Class<?>, List<Object>> subscribers = new ConcurrentHashMap<>();

    @SuppressWarnings("unchecked")
    <T> void subscribe(Class<T> eventType, Consumer<T> handler) {
        subscribers
            .computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
            .add(handler);

        System.out.println("üìù Inscrito em: " + eventType.getSimpleName());
    }

    <T> void publish(T event) {
        Class<?> eventClass = event.getClass();
        List<Object> handlers = subscribers.get(eventClass);

        if (handlers == null || handlers.isEmpty()) {
            System.out.println("‚ö†Ô∏è Nenhum subscriber para: " + eventClass.getSimpleName());
            return;
        }

        System.out.println("üì¢ Publicando evento: " + eventClass.getSimpleName());

        handlers.forEach(handler -> {
            @SuppressWarnings("unchecked")
            Consumer<T> typedHandler = (Consumer<T>) handler;

            try {
                typedHandler.accept(event);
            } catch (Exception e) {
                System.err.println("‚ùå Erro processando evento: " + e.getMessage());
            }
        });
    }

    int totalSubscribers(Class<?> eventType) {
        List<Object> handlers = subscribers.get(eventType);
        return handlers != null ? handlers.size() : 0;
    }
}
```

---

## üß™ Como Testar

### 1. Testar Observer Recebe Notifica√ß√£o

```java
@Test
void observerDeveReceberNotificacao() {
    // Arrange
    PedidoSubject subject = new PedidoSubject();
    PedidoObserver observer = mock(PedidoObserver.class);
    subject.adicionar(observer);

    PedidoEvent event = PedidoEvent.criado("P1", new BigDecimal("100"));

    // Act
    subject.notificar(event);

    // Assert
    verify(observer).onEvent(event);
}
```

### 2. Testar M√∫ltiplos Observers

```java
@Test
void devNotificarTodosObservers() {
    // Arrange
    PedidoSubject subject = new PedidoSubject();

    EmailObserver emailObs = new EmailObserver();
    EstoqueObserver estoqueObs = new EstoqueObserver();
    LogObserver logObs = new LogObserver();

    subject.adicionar(emailObs);
    subject.adicionar(estoqueObs);
    subject.adicionar(logObs);

    PedidoEvent event = PedidoEvent.criado("P1", new BigDecimal("100"));

    // Act
    subject.notificar(event);

    // Assert
    assertEquals(1, emailObs.getEmailsEnviados());
    assertEquals(1, estoqueObs.getReservasAtivas());
    assertEquals(1, logObs.getLogs().size());
}
```

### 3. Testar Remo√ß√£o de Observer

```java
@Test
void deveRemoverObserver() {
    // Arrange
    PedidoSubject subject = new PedidoSubject();
    PedidoObserver observer = mock(PedidoObserver.class);

    subject.adicionar(observer);
    assertEquals(1, subject.totalObservers());

    // Act
    subject.remover(observer);

    // Assert
    assertEquals(0, subject.totalObservers());

    subject.notificar(PedidoEvent.criado("P1", BigDecimal.TEN));
    verify(observer, never()).onEvent(any());
}
```

### 4. Testar Isolamento de Falhas

```java
@Test
void falhaEmUmObserverNaoDeveAfetarOutros() {
    // Arrange
    PedidoSubject subject = new PedidoSubject();

    PedidoObserver observerComFalha = event -> {
        throw new RuntimeException("Erro simulado");
    };

    PedidoObserver observerNormal = mock(PedidoObserver.class);

    subject.adicionar(observerComFalha);
    subject.adicionar(observerNormal);

    PedidoEvent event = PedidoEvent.criado("P1", BigDecimal.TEN);

    // Act
    subject.notificar(event); // N√£o deve lan√ßar exce√ß√£o

    // Assert
    verify(observerNormal).onEvent(event); // Observer normal foi chamado
}
```

### 5. Testar Service com Observers

```java
@Test
void serviceDeveNotificarObserversAoCriarPedido() {
    // Arrange
    PedidoService service = new PedidoService();
    PedidoObserver observer = mock(PedidoObserver.class);
    service.adicionarObserver(observer);

    // Act
    service.criarPedido("P1", new BigDecimal("150"));

    // Assert
    ArgumentCaptor<PedidoEvent> captor = ArgumentCaptor.forClass(PedidoEvent.class);
    verify(observer).onEvent(captor.capture());

    PedidoEvent event = captor.getValue();
    assertEquals("P1", event.pedidoId());
    assertEquals(new BigDecimal("150"), event.valor());
    assertEquals("CRIADO", event.tipo());
}
```

### 6. Testar Event Bus Gen√©rico

```java
@Test
void eventBusDevePublicarEventos() {
    // Arrange
    EventBus eventBus = new EventBus();

    AtomicInteger contador = new AtomicInteger(0);

    eventBus.subscribe(PedidoEvent.class, event -> {
        contador.incrementAndGet();
    });

    // Act
    eventBus.publish(PedidoEvent.criado("P1", BigDecimal.TEN));
    eventBus.publish(PedidoEvent.criado("P2", BigDecimal.ONE));

    // Assert
    assertEquals(2, contador.get());
}
```

### 7. Testar M√©tricas de Notifica√ß√£o

```java
@Test
void deveRastrearMetricasDeNotificacao() {
    // Arrange
    PedidoSubject subject = new PedidoSubject();
    subject.adicionar(event -> {});
    subject.adicionar(event -> {});
    subject.adicionar(event -> {});

    // Act
    subject.notificar(PedidoEvent.criado("P1", BigDecimal.TEN));
    subject.notificar(PedidoEvent.criado("P2", BigDecimal.TEN));

    ObserverMetrics metrics = subject.getMetrics();

    // Assert
    assertEquals(3, metrics.observersAtivos());
    assertEquals(6, metrics.notificacoesEnviadas()); // 3 observers * 2 eventos
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Observer com l√≥gica pesada (bloqueia notifica√ß√£o)
class EmailObserver implements PedidoObserver {
    public void onEvent(PedidoEvent event) {
        // Opera√ß√£o lenta bloqueia outros observers
        Thread.sleep(5000);
        enviarEmail();
    }
}

// ‚ùå Observer modifica subject (ciclo infinito)
class RecursivoObserver implements PedidoObserver {
    private PedidoService service;

    public void onEvent(PedidoEvent event) {
        service.criarPedido("novo", BigDecimal.TEN); // Loop infinito!
    }
}

// ‚ùå Vazamento de mem√≥ria (n√£o remover observers)
subject.adicionar(observer);
// Observer nunca √© removido mesmo quando n√£o √© mais necess√°rio
```

### ‚úÖ Fazer

```java
// ‚úÖ Observer ass√≠ncrono
class EmailObserver implements PedidoObserver {
    private final ExecutorService executor = Executors.newCachedThreadPool();

    public void onEvent(PedidoEvent event) {
        executor.submit(() -> enviarEmail(event));
    }
}

// ‚úÖ Remover observer quando n√£o necess√°rio
class TemporaryObserver implements PedidoObserver {
    public void onEvent(PedidoEvent event) {
        processarEvento(event);
        subject.remover(this); // Remove ap√≥s usar
    }
}

// ‚úÖ Isolamento de falhas
observers.forEach(observer -> {
    try {
        observer.onEvent(event);
    } catch (Exception e) {
        log.error("Erro em observer", e);
    }
});
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Thread-safety**: Usar CopyOnWriteArrayList
- ‚úÖ **Isolamento de falhas**: Try-catch em cada notifica√ß√£o
- ‚úÖ **Observers leves**: Delegar trabalho pesado para threads
- ‚úÖ **Weak references**: Evitar vazamento de mem√≥ria
- ‚úÖ **Event immutability**: Records imut√°veis para eventos
- ‚úÖ **M√©tricas**: Rastrear observers ativos e notifica√ß√µes
- ‚úÖ **Desinscri√ß√£o**: Permitir remover observers

---

## üîó Integra√ß√£o com Frameworks

### Spring ApplicationEventPublisher

```java
@Service
public class PedidoService {
    @Autowired
    private ApplicationEventPublisher eventPublisher;

    public void criarPedido(Pedido pedido) {
        repository.save(pedido);
        eventPublisher.publishEvent(new PedidoCriadoEvent(pedido));
    }
}

@Component
public class EmailListener {
    @EventListener
    public void onPedidoCriado(PedidoCriadoEvent event) {
        emailService.enviar(event.getPedido());
    }
}
```

### Guava EventBus

```java
EventBus eventBus = new EventBus();

eventBus.register(new Object() {
    @Subscribe
    public void handlePedido(PedidoEvent event) {
        System.out.println("Pedido: " + event.pedidoId());
    }
});

eventBus.post(PedidoEvent.criado("P1", BigDecimal.TEN));
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                                   | ‚ö†Ô∏è Desvantagens                          |
| ---------------------------------------------- | ---------------------------------------- |
| Desacoplamento (subject n√£o conhece observers) | Ordem de notifica√ß√£o n√£o garantida       |
| Extens√≠vel (adicionar observers sem modificar) | Dif√≠cil rastrear fluxo em debug          |
| Open/Closed Principle                          | Observers podem vazar mem√≥ria            |
| F√°cil testar com mocks                         | Performance (notificar muitos observers) |

---

## üîç Compara√ß√£o

| Padr√£o       | Comunica√ß√£o                | Acoplamento | Uso                |
| ------------ | -------------------------- | ----------- | ------------------ |
| **Observer** | 1-para-N (push)            | Baixo       | Eventos, listeners |
| **Mediator** | N-para-N (hub central)     | M√©dio       | Chat, coordena√ß√£o  |
| **Pub/Sub**  | M-para-N (t√≥picos)         | Muito baixo | Messaging          |
| **Command**  | 1-para-1 (encapsular a√ß√£o) | M√©dio       | Undo/redo, queue   |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Observer ass√≠ncrono** com ExecutorService e callback de conclus√£o
2. **Event sourcing** - persistir todos eventos antes de notificar
3. **Priority observers** - executar observers em ordem de prioridade
4. **Typed EventBus** - type-safe com generics
5. **Dead letter queue** para observers que falharam

---

## üìö Relacionado

- **Publisher/Subscriber**: Extens√£o com t√≥picos
- **Mediator**: Comunica√ß√£o N-para-N centralizada
- **Command**: Encapsular a√ß√µes como objetos
- **Event Sourcing**: Persistir eventos como fonte de verdade

---

**Observer Pattern desacopla produtores de consumidores e facilita sistemas orientados a eventos!** üëÅÔ∏è‚ú®
