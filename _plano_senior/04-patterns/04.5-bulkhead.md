# 4.5 Bulkhead Pattern [EXPERT]

üéØ **Objetivo:** Implementar e testar o padr√£o Bulkhead para isolar recursos em compartimentos independentes, evitando que falha em um segmento comprometa todo o sistema.

---

## üö¢ O Que √â Bulkhead Pattern?

Padr√£o que **isola recursos** (threads, conex√µes, mem√≥ria) em pools separados, impedindo que **sobrecarga em um servi√ßo** esgote recursos de outros servi√ßos cr√≠ticos.

### Analogia

Como compartimentos estanques em navios: se um compartimento alagar, os outros permanecem intactos e o navio continua flutuando.

---

## üéØ Problema que Resolve

### Cen√°rio Sem Bulkhead

```
Pool √önico de Threads (100 threads)
  ‚Üì
Endpoint A (normal): 10 req/s
Endpoint B (lento): 1000 req/s (bug causa lentid√£o)
  ‚Üì
Todas as 100 threads bloqueadas em B
  ‚Üì
Endpoint A n√£o consegue mais responder
  ‚Üì
SISTEMA INTEIRO INDISPON√çVEL
```

### Com Bulkhead

```
Pool A: 50 threads (cr√≠tico)
Pool B: 30 threads (normal)
Pool C: 20 threads (baixa prioridade)
  ‚Üì
Pool C satura por bug
  ‚Üì
Pools A e B continuam funcionando
  ‚Üì
ISOLAMENTO DE FALHA
```

---

## üìä Tipos de Bulkhead

### 1. Thread Pool Bulkhead

Pools de threads separados por servi√ßo.

```java
ExecutorService poolA = Executors.newFixedThreadPool(10);
ExecutorService poolB = Executors.newFixedThreadPool(5);
```

### 2. Semaphore Bulkhead

Limite de execu√ß√µes concorrentes via sem√°foro (mais leve).

```java
Semaphore semaforo = new Semaphore(10);
```

### 3. Connection Pool Bulkhead

Pools de conex√µes separados por destino.

```java
HikariConfig configDB1 = new HikariConfig();
configDB1.setMaximumPoolSize(20);

HikariConfig configDB2 = new HikariConfig();
configDB2.setMaximumPoolSize(10);
```

---

## üíª Implementa√ß√£o com Java 17

### Bulkhead com Sem√°foro (Leve)

```java
import java.util.concurrent.Semaphore;
import java.util.function.Supplier;

final class BulkheadSemaphore {
    private final Semaphore semaforo;
    private final String nome;

    BulkheadSemaphore(String nome, int capacidade) {
        this.nome = nome;
        this.semaforo = new Semaphore(capacidade);
    }

    public <T> T executar(Supplier<T> acao, Supplier<T> fallback) {
        boolean adquirido = semaforo.tryAcquire();

        if (!adquirido) {
            System.err.println("Bulkhead " + nome + " saturado, usando fallback");
            return fallback.get();
        }

        try {
            return acao.get();
        } finally {
            semaforo.release();
        }
    }

    public int disponivel() {
        return semaforo.availablePermits();
    }

    public int capacidadeTotal() {
        return semaforo.availablePermits() +
               (capacidadeInicial - semaforo.availablePermits());
    }
}
```

### Bulkhead com Thread Pool (Isolamento Completo)

```java
import java.util.concurrent.*;
import java.util.function.Supplier;

final class BulkheadThreadPool {
    private final ExecutorService executor;
    private final String nome;
    private final int capacidade;

    BulkheadThreadPool(String nome, int capacidade) {
        this.nome = nome;
        this.capacidade = capacidade;
        this.executor = Executors.newFixedThreadPool(capacidade);
    }

    public <T> T executar(Supplier<T> acao,
                          long timeout,
                          TimeUnit unidade,
                          Supplier<T> fallback) {
        Future<T> future = executor.submit(() -> acao.get());

        try {
            return future.get(timeout, unidade);

        } catch (TimeoutException e) {
            future.cancel(true);
            System.err.println("Timeout no bulkhead " + nome);
            return fallback.get();

        } catch (RejectedExecutionException e) {
            System.err.println("Bulkhead " + nome + " saturado");
            return fallback.get();

        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException("Erro na execu√ß√£o", e);
        }
    }

    public void shutdown() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

---

## üß™ Como Testar o Pattern

### Teste 1: Opera√ß√£o Dentro da Capacidade

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class BulkheadSemaphoreTest {

    @Test
    void devePermitirExecucaoDentroCapacidade() {
        BulkheadSemaphore bulkhead = new BulkheadSemaphore("teste", 2);

        String resultado = bulkhead.executar(
            () -> "SUCESSO",
            () -> "FALLBACK"
        );

        assertEquals("SUCESSO", resultado);
        assertEquals(2, bulkhead.disponivel()); // Capacidade restaurada
    }
}
```

### Teste 2: Satura√ß√£o Aciona Fallback

```java
@Test
void deveUsarFallbackQuandoSaturado() throws InterruptedException {
    BulkheadSemaphore bulkhead = new BulkheadSemaphore("teste", 1);
    CountDownLatch iniciar = new CountDownLatch(1);
    CountDownLatch finalizar = new CountDownLatch(1);

    // Thread 1 ocupa o bulkhead
    new Thread(() -> {
        bulkhead.executar(() -> {
            iniciar.countDown();
            try {
                finalizar.await();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "THREAD-1";
        }, () -> "FB");
    }).start();

    // Aguardar thread 1 ocupar
    iniciar.await();
    assertEquals(0, bulkhead.disponivel());

    // Thread 2 deve usar fallback
    String resultado = bulkhead.executar(
        () -> "NUNCA",
        () -> "FALLBACK"
    );

    assertEquals("FALLBACK", resultado);
    finalizar.countDown();
}
```

### Teste 3: M√∫ltiplas Threads Concorrentes

```java
@Test
void deveIsoliarRecursosConcorrentemente() throws InterruptedException {
    int capacidade = 3;
    BulkheadSemaphore bulkhead = new BulkheadSemaphore("teste", capacidade);

    int numThreads = 10;
    CountDownLatch latch = new CountDownLatch(numThreads);
    AtomicInteger sucessos = new AtomicInteger(0);
    AtomicInteger fallbacks = new AtomicInteger(0);

    for (int i = 0; i < numThreads; i++) {
        new Thread(() -> {
            String resultado = bulkhead.executar(
                () -> {
                    Thread.sleep(100);
                    return "OK";
                },
                () -> "FB"
            );

            if ("OK".equals(resultado)) {
                sucessos.incrementAndGet();
            } else {
                fallbacks.incrementAndGet();
            }

            latch.countDown();
        }).start();
    }

    assertTrue(latch.await(3, TimeUnit.SECONDS));

    // Apenas 'capacidade' threads executam por vez
    // O resto usa fallback
    assertTrue(sucessos.get() <= capacidade * 2); // Margem para timing
    assertTrue(fallbacks.get() > 0);
}
```

### Teste 4: Libera√ß√£o de Recursos Ap√≥s Exce√ß√£o

```java
@Test
void deveLiberarRecursosMesmoComExcecao() {
    BulkheadSemaphore bulkhead = new BulkheadSemaphore("teste", 2);

    assertEquals(2, bulkhead.disponivel());

    assertThrows(RuntimeException.class, () -> {
        bulkhead.executar(
            () -> { throw new RuntimeException("Erro"); },
            () -> "FB"
        );
    });

    // Recurso deve ter sido liberado
    assertEquals(2, bulkhead.disponivel());
}
```

### Teste 5: Thread Pool Bulkhead com Timeout

```java
@Test
void threadPoolDeveRespeitarTimeout() {
    BulkheadThreadPool bulkhead = new BulkheadThreadPool("teste", 2);

    try {
        String resultado = bulkhead.executar(
            () -> {
                Thread.sleep(2000);
                return "LENTO";
            },
            100,
            TimeUnit.MILLISECONDS,
            () -> "TIMEOUT_FALLBACK"
        );

        assertEquals("TIMEOUT_FALLBACK", resultado);

    } finally {
        bulkhead.shutdown();
    }
}
```

### Teste 6: Isolamento Entre Bulkheads

```java
@Test
void bulkheadsDevemSerIndependentes() throws InterruptedException {
    BulkheadSemaphore bulkheadA = new BulkheadSemaphore("A", 1);
    BulkheadSemaphore bulkheadB = new BulkheadSemaphore("B", 1);

    CountDownLatch bloqueioA = new CountDownLatch(1);

    // Saturar bulkhead A
    new Thread(() -> {
        bulkheadA.executar(() -> {
            try {
                bloqueioA.await();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "A";
        }, () -> "FB-A");
    }).start();

    Thread.sleep(50); // Garantir que A est√° ocupado

    // Bulkhead B deve estar dispon√≠vel
    String resultadoB = bulkheadB.executar(
        () -> "SUCESSO-B",
        () -> "FB-B"
    );

    assertEquals("SUCESSO-B", resultadoB);
    assertEquals(0, bulkheadA.disponivel());
    assertEquals(1, bulkheadB.disponivel());

    bloqueioA.countDown();
}
```

### Teste 7: M√©tricas de Utiliza√ß√£o

```java
@Test
void deveMonitorarUtilizacao() throws InterruptedException {
    BulkheadSemaphore bulkhead = new BulkheadSemaphore("teste", 5);
    CountDownLatch iniciar = new CountDownLatch(3);
    CountDownLatch finalizar = new CountDownLatch(1);

    // Ocupar 3 dos 5 slots
    for (int i = 0; i < 3; i++) {
        new Thread(() -> {
            bulkhead.executar(() -> {
                iniciar.countDown();
                try {
                    finalizar.await();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return "OK";
            }, () -> "FB");
        }).start();
    }

    iniciar.await();

    // Verificar utiliza√ß√£o
    assertEquals(2, bulkhead.disponivel());

    finalizar.countDown();
    Thread.sleep(100);

    assertEquals(5, bulkhead.disponivel());
}
```

---

## ‚ö† Cuidados Importantes

### 1. Dimensionamento Correto

```java
// ‚ùå Pool muito pequeno - gera conten√ß√£o desnecess√°ria
BulkheadThreadPool pequeno = new BulkheadThreadPool("api", 2); // Muito restritivo

// ‚ùå Pool muito grande - n√£o isola efetivamente
BulkheadThreadPool grande = new BulkheadThreadPool("api", 1000); // Sem isolamento

// ‚úÖ Baseado em carga esperada e criticidade
BulkheadThreadPool adequado = new BulkheadThreadPool("api-critica", 20);
BulkheadThreadPool secundario = new BulkheadThreadPool("api-secundaria", 10);
```

### 2. Deadlocks em Bulkheads Aninhados

```java
// ‚ùå PERIGO - Deadlock potencial
bulkheadA.executar(() -> {
    return bulkheadB.executar(() -> "nested", () -> "fb");
}, () -> "fb");

// ‚úÖ Evitar aninhamento ou usar timeouts
```

### 3. Fallback Adequado

```java
// ‚ùå Fallback que bloqueia tamb√©m
Supplier<String> fallbackBloqueante = () -> {
    chamarOutroServicoLento(); // Ruim!
    return "FB";
};

// ‚úÖ Fallback r√°pido (cache, valor padr√£o)
Supplier<String> fallbackRapido = () -> cache.get("chave");
```

---

## üìä Boas Pr√°ticas de Teste

### ‚úÖ O Que Testar

- [ ] Execu√ß√£o **dentro da capacidade** funciona
- [ ] **Fallback acionado** quando saturado
- [ ] **Isolamento** entre bulkheads
- [ ] **Libera√ß√£o** de recursos ap√≥s exce√ß√£o
- [ ] **Thread safety** sob concorr√™ncia
- [ ] **M√©tricas** de utiliza√ß√£o corretas
- [ ] **Timeout** integrado funciona
- [ ] **Shutdown** gracioso de thread pools

### ‚ö† Evitar

- ‚ùå Pools compartilhados entre bulkheads
- ‚ùå Dimensionamento sem an√°lise de carga
- ‚ùå Fallback que pode bloquear
- ‚ùå Aninhamento de bulkheads

---

## ‚öô Frameworks de Produ√ß√£o

### Resilience4j Bulkhead

```java
// Semaphore-based
BulkheadConfig config = BulkheadConfig.custom()
    .maxConcurrentCalls(10)
    .maxWaitDuration(Duration.ofMillis(500))
    .build();

Bulkhead bulkhead = Bulkhead.of("api", config);

Supplier<String> decorated = Bulkhead.decorateSupplier(bulkhead,
    () -> remoteService.call());

// ThreadPool-based
ThreadPoolBulkheadConfig threadConfig = ThreadPoolBulkheadConfig.custom()
    .maxThreadPoolSize(10)
    .coreThreadPoolSize(5)
    .queueCapacity(20)
    .build();

ThreadPoolBulkhead threadBulkhead = ThreadPoolBulkhead.of("api", threadConfig);
```

### Spring @Bulkhead

```java
@Service
public class UserService {

    @Bulkhead(name = "userService", fallbackMethod = "fallbackGetUser")
    public User getUser(Long id) {
        return restTemplate.getForObject("/api/users/" + id, User.class);
    }

    private User fallbackGetUser(Long id, BulkheadFullException e) {
        log.warn("Bulkhead saturado para user {}", id);
        return User.defaultUser();
    }
}
```

---

## üéì Vantagens vs Desvantagens

### ‚úÖ Vantagens

- **Isolamento**: Falha em um servi√ßo n√£o afeta outros
- **Prioriza√ß√£o**: Recursos cr√≠ticos protegidos
- **Controle de carga**: Limita concorr√™ncia
- **Visibilidade**: M√©tricas por pool

### ‚ö† Desvantagens

- **Complexidade**: M√∫ltiplos pools para gerenciar
- **Overhead**: Mais threads/sem√°foros em mem√≥ria
- **Tuning**: Dif√≠cil dimensionar corretamente
- **Desperd√≠cio**: Recursos ociosos em pools subutilizados

---

## üîç Compara√ß√£o com Outros Patterns

| Pattern             | Comportamento              | Quando Usar                        |
| ------------------- | -------------------------- | ---------------------------------- |
| **Bulkhead**        | Isola recursos em pools    | Evitar contamina√ß√£o entre servi√ßos |
| **Circuit Breaker** | Bloqueia ap√≥s falhas       | Proteger de instabilidade          |
| **Timeout**         | Limita tempo               | Evitar bloqueios longos            |
| **Rate Limiter**    | Limita taxa de requisi√ß√µes | Controlar throughput               |

### Combina√ß√£o Recomendada

```java
// Bulkhead + Circuit Breaker + Timeout + Retry
ThreadPoolBulkhead bulkhead = ThreadPoolBulkhead.of("api", bulkheadConfig);
CircuitBreaker cb = CircuitBreaker.of("api", cbConfig);
TimeLimiter limiter = TimeLimiter.of("api", timeoutConfig);
Retry retry = Retry.of("api", retryConfig);

Supplier<String> resilient = Decorators
    .ofSupplier(() -> remoteService.call())
    .withThreadPoolBulkhead(bulkhead) // 1. Isolar recursos
    .withTimeLimiter(limiter)          // 2. Limitar tempo
    .withCircuitBreaker(cb)            // 3. Proteger instabilidade
    .withRetry(retry)                  // 4. Recuperar falhas
    .decorate();
```

---

## üß† Exerc√≠cios Pr√°ticos

### 1. Bulkhead Hier√°rquico

Implementar bulkhead com prioridades (VIP, normal, baixa prioridade).

### 2. Bulkhead Adaptativo

Ajustar capacidade dinamicamente baseado em lat√™ncia m√©dia.

### 3. M√©tricas Detalhadas

Adicionar: tempo m√©dio em fila, taxa de rejei√ß√£o, histograma de utiliza√ß√£o.

### 4. Shed Load Inteligente

Rejeitar requisi√ß√µes menos priorit√°rias quando saturado.

---

## üìö Refer√™ncias

- **Livros:**

  - "Release It!" (Michael Nygard) - origem do pattern
  - "Building Microservices" (Sam Newman)

- **Frameworks:**

  - [Resilience4j Bulkhead](https://resilience4j.readme.io/docs/bulkhead)
  - [Hystrix Bulkhead](https://github.com/Netflix/Hystrix/wiki/Configuration#ThreadPool) (legacy)

- **Artigos:**
  - [Microsoft - Bulkhead Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead)

---

## üìö Pr√≥ximos Passos

- [4.1 Circuit Breaker](04.1-circuit-breaker.md) - Prote√ß√£o contra instabilidade
- [4.2 Retry Pattern](04.2-retry.md) - Tentativas autom√°ticas
- [4.3 Fallback Pattern](04.3-fallback.md) - Respostas alternativas
- [4.4 Timeout Pattern](04.4-timeout.md) - Limites de tempo
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [EXPERT]  
**Tempo Estimado:** 2,5 horas  
**Frameworks:** Resilience4j, Spring Cloud, Java Semaphore/ExecutorService
