# 04.23 Command Pattern [M√âDIO] üéÆ

## üéØ Objetivo

Encapsular **requisi√ß√µes como objetos**, permitindo parametrizar clientes com diferentes solicita√ß√µes, enfileirar opera√ß√µes, implementar **undo/redo** e facilitar **testes de comandos isolados**.

---

## üìö O Que √â?

**Command** (tamb√©m conhecido como Action, Transaction) √© um padr√£o comportamental GoF que transforma requisi√ß√µes em objetos independentes contendo toda informa√ß√£o necess√°ria. Essencial para implementar opera√ß√µes revers√≠veis, filas de tarefas, macros e hist√≥rico de a√ß√µes.

### Analogia

Como um **controle remoto**:

- **Bot√£o**: Command (objeto com execute())
- **TV/Som/Luz**: Receivers (executam a√ß√£o real)
- **Controle**: Invoker (dispara commands)
- **Hist√≥rico**: Stack de commands para undo/redo
- **Vantagem**: Trocar bot√µes sem modificar aparelhos, gravar macros

---

## ‚ùå Problema que Resolve

### Antes (Acoplamento Direto)

```java
// ‚ùå PROBLEMA: Cliente acoplado com l√≥gica de execu√ß√£o
class PedidoController {
    private final PedidoService pedidoService;
    private final EstoqueService estoqueService;
    private final EmailService emailService;

    void aprovarPedido(String pedidoId) {
        // L√≥gica direta ‚ùå
        Pedido pedido = pedidoService.buscar(pedidoId);
        pedido.setStatus(Status.APROVADO);
        pedidoService.salvar(pedido);
        estoqueService.reservar(pedido);
        emailService.enviar(pedido.getClienteEmail(), "Aprovado");
    }

    void cancelarPedido(String pedidoId) {
        // L√≥gica diferente, mas controller conhece tudo ‚ùå
        Pedido pedido = pedidoService.buscar(pedidoId);
        pedido.setStatus(Status.CANCELADO);
        pedidoService.salvar(pedido);
        estoqueService.liberar(pedido);
        emailService.enviar(pedido.getClienteEmail(), "Cancelado");
    }

    // Como implementar UNDO? ‚ùå
    // Como enfileirar opera√ß√µes? ‚ùå
    // Como testar comandos isoladamente? ‚ùå
}
```

**Problemas**:

- üîó Controller acoplado com m√∫ltiplos services
- üîÑ Imposs√≠vel implementar undo/redo
- üìã N√£o pode enfileirar ou agendar comandos
- üß™ Dif√≠cil testar l√≥gica de cada opera√ß√£o
- üîß Adicionar nova opera√ß√£o = modificar controller

### Depois (Command Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Encapsular opera√ß√µes como objetos
interface Command {
    void execute();
    void undo();
    String getDescricao();
}

class AprovarPedidoCommand implements Command {
    private final String pedidoId;
    private final PedidoService pedidoService;
    private final EstoqueService estoqueService;
    private final EmailService emailService;
    private Status statusAnterior;

    AprovarPedidoCommand(String pedidoId, /* services */) {
        this.pedidoId = pedidoId;
        // ... injetar services
    }

    public void execute() {
        Pedido pedido = pedidoService.buscar(pedidoId);
        statusAnterior = pedido.getStatus(); // Salva para undo

        pedido.setStatus(Status.APROVADO);
        pedidoService.salvar(pedido);
        estoqueService.reservar(pedido);
        emailService.enviar(pedido.getClienteEmail(), "Aprovado");
    }

    public void undo() {
        Pedido pedido = pedidoService.buscar(pedidoId);
        pedido.setStatus(statusAnterior);
        pedidoService.salvar(pedido);
        estoqueService.liberar(pedido);
    }

    public String getDescricao() {
        return "Aprovar pedido " + pedidoId;
    }
}

// Invoker com hist√≥rico
class CommandInvoker {
    private final Deque<Command> historico = new ArrayDeque<>();

    void executar(Command command) {
        command.execute();
        historico.push(command);
    }

    void desfazer() {
        if (!historico.isEmpty()) {
            Command ultimo = historico.pop();
            ultimo.undo();
        }
    }
}

// Teste isolado
@Test
void aprovarPedidoCommandDeveExecutarCorretamente() {
    PedidoService serviceMock = mock(PedidoService.class);
    Command cmd = new AprovarPedidoCommand("PED-1", serviceMock, ...);

    cmd.execute();

    verify(serviceMock).salvar(any());
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Command

```java
interface Command {
    void execute();
    void undo();
    String getDescricao();
    boolean isReversivel();
}

// Resultado da execu√ß√£o
record ResultadoCommand(boolean sucesso, String mensagem, Exception erro) {
    static ResultadoCommand sucesso(String mensagem) {
        return new ResultadoCommand(true, mensagem, null);
    }

    static ResultadoCommand falha(String mensagem, Exception erro) {
        return new ResultadoCommand(false, mensagem, erro);
    }
}
```

### 2. Commands Concretos

```java
// Command: Criar Pedido
final class CriarPedidoCommand implements Command {
    private final String pedidoId;
    private final String cliente;
    private final BigDecimal valor;
    private final PedidoRepository repository;
    private boolean executado = false;

    CriarPedidoCommand(String pedidoId, String cliente, BigDecimal valor,
                       PedidoRepository repository) {
        this.pedidoId = pedidoId;
        this.cliente = cliente;
        this.valor = valor;
        this.repository = repository;
    }

    @Override
    public void execute() {
        if (executado) {
            throw new IllegalStateException("Command j√° executado");
        }

        Pedido pedido = new Pedido(pedidoId, cliente, valor, Status.PENDENTE);
        repository.salvar(pedido);
        executado = true;

        System.out.println("‚úÖ Pedido criado: " + pedidoId);
    }

    @Override
    public void undo() {
        if (!executado) {
            throw new IllegalStateException("Command n√£o foi executado");
        }

        repository.remover(pedidoId);
        executado = false;

        System.out.println("‚Ü©Ô∏è Pedido removido (undo): " + pedidoId);
    }

    @Override
    public String getDescricao() {
        return "Criar pedido " + pedidoId + " para " + cliente;
    }

    @Override
    public boolean isReversivel() {
        return true;
    }
}

// Command: Atualizar Status
final class AtualizarStatusCommand implements Command {
    private final String pedidoId;
    private final Status novoStatus;
    private final PedidoRepository repository;
    private Status statusAnterior;
    private boolean executado = false;

    AtualizarStatusCommand(String pedidoId, Status novoStatus, PedidoRepository repository) {
        this.pedidoId = pedidoId;
        this.novoStatus = novoStatus;
        this.repository = repository;
    }

    @Override
    public void execute() {
        Pedido pedido = repository.buscar(pedidoId);
        statusAnterior = pedido.status(); // Salva estado anterior

        Pedido atualizado = new Pedido(
            pedido.id(),
            pedido.cliente(),
            pedido.valor(),
            novoStatus
        );

        repository.salvar(atualizado);
        executado = true;

        System.out.println("‚úÖ Status atualizado: " + statusAnterior + " ‚Üí " + novoStatus);
    }

    @Override
    public void undo() {
        if (!executado) {
            throw new IllegalStateException("Command n√£o foi executado");
        }

        Pedido pedido = repository.buscar(pedidoId);
        Pedido revertido = new Pedido(
            pedido.id(),
            pedido.cliente(),
            pedido.valor(),
            statusAnterior
        );

        repository.salvar(revertido);
        executado = false;

        System.out.println("‚Ü©Ô∏è Status revertido: " + novoStatus + " ‚Üí " + statusAnterior);
    }

    @Override
    public String getDescricao() {
        return "Atualizar status do pedido " + pedidoId + " para " + novoStatus;
    }

    @Override
    public boolean isReversivel() {
        return executado && statusAnterior != null;
    }
}

// Command: Aplicar Desconto
final class AplicarDescontoCommand implements Command {
    private final String pedidoId;
    private final BigDecimal percentualDesconto;
    private final PedidoRepository repository;
    private BigDecimal valorOriginal;
    private boolean executado = false;

    AplicarDescontoCommand(String pedidoId, BigDecimal percentualDesconto,
                           PedidoRepository repository) {
        this.pedidoId = pedidoId;
        this.percentualDesconto = percentualDesconto;
        this.repository = repository;
    }

    @Override
    public void execute() {
        Pedido pedido = repository.buscar(pedidoId);
        valorOriginal = pedido.valor();

        BigDecimal desconto = valorOriginal.multiply(percentualDesconto)
            .divide(new BigDecimal("100"), 2, RoundingMode.HALF_UP);

        BigDecimal valorComDesconto = valorOriginal.subtract(desconto);

        Pedido atualizado = new Pedido(
            pedido.id(),
            pedido.cliente(),
            valorComDesconto,
            pedido.status()
        );

        repository.salvar(atualizado);
        executado = true;

        System.out.println("‚úÖ Desconto aplicado: " + percentualDesconto + "% (R$ " + desconto + ")");
    }

    @Override
    public void undo() {
        if (!executado) {
            throw new IllegalStateException("Command n√£o foi executado");
        }

        Pedido pedido = repository.buscar(pedidoId);
        Pedido revertido = new Pedido(
            pedido.id(),
            pedido.cliente(),
            valorOriginal,
            pedido.status()
        );

        repository.salvar(revertido);
        executado = false;

        System.out.println("‚Ü©Ô∏è Desconto removido (valor restaurado: R$ " + valorOriginal + ")");
    }

    @Override
    public String getDescricao() {
        return "Aplicar desconto de " + percentualDesconto + "% no pedido " + pedidoId;
    }

    @Override
    public boolean isReversivel() {
        return executado;
    }
}
```

### 3. Command Composto (Macro)

```java
final class MacroCommand implements Command {
    private final List<Command> commands;
    private final String descricao;
    private final List<Command> executados = new ArrayList<>();

    MacroCommand(String descricao, List<Command> commands) {
        this.descricao = descricao;
        this.commands = new ArrayList<>(commands);
    }

    MacroCommand(String descricao, Command... commands) {
        this(descricao, Arrays.asList(commands));
    }

    @Override
    public void execute() {
        System.out.println("üé¨ Executando macro: " + descricao);

        for (Command command : commands) {
            try {
                command.execute();
                executados.add(command);
            } catch (Exception e) {
                System.err.println("‚ùå Erro ao executar: " + command.getDescricao());
                // Desfaz comandos executados at√© aqui
                desfazerExecutados();
                throw new RuntimeException("Falha no macro command", e);
            }
        }

        System.out.println("‚úÖ Macro conclu√≠do: " + executados.size() + " comandos");
    }

    @Override
    public void undo() {
        System.out.println("‚Ü©Ô∏è Desfazendo macro: " + descricao);
        desfazerExecutados();
    }

    private void desfazerExecutados() {
        // Desfaz em ordem reversa
        for (int i = executados.size() - 1; i >= 0; i--) {
            Command command = executados.get(i);
            try {
                command.undo();
            } catch (Exception e) {
                System.err.println("‚ùå Erro ao desfazer: " + command.getDescricao());
            }
        }
        executados.clear();
    }

    @Override
    public String getDescricao() {
        return descricao + " (" + commands.size() + " comandos)";
    }

    @Override
    public boolean isReversivel() {
        return executados.stream().allMatch(Command::isReversivel);
    }
}
```

### 4. Command Invoker com Hist√≥rico

```java
final class CommandInvoker {
    private final Deque<Command> historico = new ArrayDeque<>();
    private final Deque<Command> desfeitos = new ArrayDeque<>();
    private final int limiteHistorico;

    CommandInvoker(int limiteHistorico) {
        this.limiteHistorico = limiteHistorico;
    }

    CommandInvoker() {
        this(100);
    }

    void executar(Command command) {
        try {
            System.out.println("‚ñ∂Ô∏è Executando: " + command.getDescricao());

            command.execute();
            historico.push(command);
            desfeitos.clear(); // Limpa redo ao executar novo comando

            // Limita tamanho do hist√≥rico
            while (historico.size() > limiteHistorico) {
                historico.removeLast();
            }

        } catch (Exception e) {
            System.err.println("‚ùå Falha ao executar: " + e.getMessage());
            throw e;
        }
    }

    boolean desfazer() {
        if (historico.isEmpty()) {
            System.out.println("‚ö†Ô∏è Nenhum comando para desfazer");
            return false;
        }

        Command command = historico.pop();

        if (!command.isReversivel()) {
            System.out.println("‚ö†Ô∏è Command n√£o √© revers√≠vel: " + command.getDescricao());
            historico.push(command); // Volta para hist√≥rico
            return false;
        }

        try {
            System.out.println("‚Ü©Ô∏è Desfazendo: " + command.getDescricao());
            command.undo();
            desfeitos.push(command);
            return true;

        } catch (Exception e) {
            System.err.println("‚ùå Erro ao desfazer: " + e.getMessage());
            historico.push(command); // Volta para hist√≥rico em caso de erro
            return false;
        }
    }

    boolean refazer() {
        if (desfeitos.isEmpty()) {
            System.out.println("‚ö†Ô∏è Nenhum comando para refazer");
            return false;
        }

        Command command = desfeitos.pop();

        try {
            System.out.println("‚Ü™Ô∏è Refazendo: " + command.getDescricao());
            command.execute();
            historico.push(command);
            return true;

        } catch (Exception e) {
            System.err.println("‚ùå Erro ao refazer: " + e.getMessage());
            desfeitos.push(command); // Volta para desfeitos em caso de erro
            return false;
        }
    }

    List<String> getHistorico() {
        return historico.stream()
            .map(Command::getDescricao)
            .toList();
    }

    List<String> getDesfeitos() {
        return desfeitos.stream()
            .map(Command::getDescricao)
            .toList();
    }

    void limpar() {
        historico.clear();
        desfeitos.clear();
        System.out.println("üóë Hist√≥rico limpo");
    }

    int tamanhoHistorico() {
        return historico.size();
    }
}
```

### 5. Command Queue (Fila de Comandos)

```java
final class CommandQueue {
    private final Queue<Command> fila = new ConcurrentLinkedQueue<>();
    private final AtomicInteger executados = new AtomicInteger(0);
    private final AtomicInteger falhas = new AtomicInteger(0);
    private volatile boolean processando = false;

    void enfileirar(Command command) {
        fila.offer(command);
        System.out.println("üì• Command enfileirado: " + command.getDescricao() +
                         " (fila: " + fila.size() + ")");
    }

    void processar() {
        if (processando) {
            System.out.println("‚ö†Ô∏è J√° est√° processando");
            return;
        }

        processando = true;
        System.out.println("‚öôÔ∏è Iniciando processamento (" + fila.size() + " comandos)");

        try {
            while (!fila.isEmpty()) {
                Command command = fila.poll();

                try {
                    System.out.println("‚ñ∂Ô∏è Processando: " + command.getDescricao());
                    command.execute();
                    executados.incrementAndGet();

                } catch (Exception e) {
                    falhas.incrementAndGet();
                    System.err.println("‚ùå Falha ao processar: " + e.getMessage());
                }
            }

            System.out.println("‚úÖ Processamento conclu√≠do - Executados: " +
                             executados.get() + ", Falhas: " + falhas.get());

        } finally {
            processando = false;
        }
    }

    void processarAsync(ExecutorService executor) {
        executor.submit(this::processar);
    }

    int tamanhoFila() {
        return fila.size();
    }

    CommandQueueStats getStats() {
        return new CommandQueueStats(
            fila.size(),
            executados.get(),
            falhas.get(),
            processando
        );
    }
}

record CommandQueueStats(int filaAtual, int executados, int falhas, boolean processando) {}
```

### 6. Command com Valida√ß√£o

```java
abstract class ValidatedCommand implements Command {

    protected abstract void doExecute();
    protected abstract void doUndo();
    protected abstract List<String> validar();

    @Override
    public final void execute() {
        List<String> erros = validar();

        if (!erros.isEmpty()) {
            throw new IllegalStateException(
                "Valida√ß√£o falhou: " + String.join(", ", erros)
            );
        }

        doExecute();
    }

    @Override
    public final void undo() {
        doUndo();
    }
}

final class CriarPedidoValidadoCommand extends ValidatedCommand {
    private final String pedidoId;
    private final String cliente;
    private final BigDecimal valor;
    private final PedidoRepository repository;

    CriarPedidoValidadoCommand(String pedidoId, String cliente, BigDecimal valor,
                               PedidoRepository repository) {
        this.pedidoId = pedidoId;
        this.cliente = cliente;
        this.valor = valor;
        this.repository = repository;
    }

    @Override
    protected List<String> validar() {
        List<String> erros = new ArrayList<>();

        if (pedidoId == null || pedidoId.isBlank()) {
            erros.add("ID n√£o pode ser vazio");
        }

        if (cliente == null || cliente.isBlank()) {
            erros.add("Cliente n√£o pode ser vazio");
        }

        if (valor == null || valor.compareTo(BigDecimal.ZERO) <= 0) {
            erros.add("Valor deve ser positivo");
        }

        if (repository.existe(pedidoId)) {
            erros.add("Pedido j√° existe: " + pedidoId);
        }

        return erros;
    }

    @Override
    protected void doExecute() {
        Pedido pedido = new Pedido(pedidoId, cliente, valor, Status.PENDENTE);
        repository.salvar(pedido);
        System.out.println("‚úÖ Pedido validado e criado: " + pedidoId);
    }

    @Override
    protected void doUndo() {
        repository.remover(pedidoId);
        System.out.println("‚Ü©Ô∏è Pedido removido: " + pedidoId);
    }

    @Override
    public String getDescricao() {
        return "Criar pedido validado " + pedidoId;
    }

    @Override
    public boolean isReversivel() {
        return true;
    }
}
```

### 7. Command Factory

```java
final class CommandFactory {
    private final PedidoRepository repository;

    CommandFactory(PedidoRepository repository) {
        this.repository = repository;
    }

    Command criarPedido(String id, String cliente, BigDecimal valor) {
        return new CriarPedidoCommand(id, cliente, valor, repository);
    }

    Command atualizarStatus(String pedidoId, Status novoStatus) {
        return new AtualizarStatusCommand(pedidoId, novoStatus, repository);
    }

    Command aplicarDesconto(String pedidoId, BigDecimal percentual) {
        return new AplicarDescontoCommand(pedidoId, percentual, repository);
    }

    Command aprovarPedido(String pedidoId) {
        return new MacroCommand(
            "Aprovar pedido " + pedidoId,
            atualizarStatus(pedidoId, Status.APROVADO),
            new NotificarClienteCommand(pedidoId, "Pedido aprovado!")
        );
    }

    Command processarPedidoCompleto(String pedidoId, String cliente, BigDecimal valor) {
        return new MacroCommand(
            "Processar pedido completo " + pedidoId,
            criarPedido(pedidoId, cliente, valor),
            aplicarDesconto(pedidoId, new BigDecimal("10")),
            atualizarStatus(pedidoId, Status.APROVADO)
        );
    }
}

// Command auxiliar
final class NotificarClienteCommand implements Command {
    private final String pedidoId;
    private final String mensagem;

    NotificarClienteCommand(String pedidoId, String mensagem) {
        this.pedidoId = pedidoId;
        this.mensagem = mensagem;
    }

    @Override
    public void execute() {
        System.out.println("üìß Notifica√ß√£o enviada para pedido " + pedidoId + ": " + mensagem);
    }

    @Override
    public void undo() {
        System.out.println("üîï Notifica√ß√£o n√£o pode ser desfeita");
    }

    @Override
    public String getDescricao() {
        return "Notificar cliente do pedido " + pedidoId;
    }

    @Override
    public boolean isReversivel() {
        return false; // Notifica√ß√µes n√£o s√£o revers√≠veis
    }
}
```

---

## üß™ Como Testar

### 1. Testar Command Isoladamente

```java
@Test
void criarPedidoCommandDeveExecutarCorretamente() {
    // Arrange
    PedidoRepository repoMock = mock(PedidoRepository.class);
    Command command = new CriarPedidoCommand(
        "PED-001",
        "Cliente A",
        new BigDecimal("100"),
        repoMock
    );

    // Act
    command.execute();

    // Assert
    ArgumentCaptor<Pedido> captor = ArgumentCaptor.forClass(Pedido.class);
    verify(repoMock).salvar(captor.capture());

    Pedido pedido = captor.getValue();
    assertEquals("PED-001", pedido.id());
    assertEquals("Cliente A", pedido.cliente());
    assertEquals(Status.PENDENTE, pedido.status());
}
```

### 2. Testar Undo/Redo

```java
@Test
void deveDesfazerERefazerComando() {
    // Arrange
    PedidoRepository repo = new PedidoRepositoryInMemory();
    CommandInvoker invoker = new CommandInvoker();

    Command criar = new CriarPedidoCommand("PED-001", "Cliente", new BigDecimal("100"), repo);

    // Act - Executar
    invoker.executar(criar);
    assertTrue(repo.existe("PED-001"));

    // Act - Desfazer
    invoker.desfazer();
    assertFalse(repo.existe("PED-001"));

    // Act - Refazer
    invoker.refazer();
    assertTrue(repo.existe("PED-001"));
}
```

### 3. Testar Macro Command

```java
@Test
void macroCommandDeveExecutarTodosComandos() {
    // Arrange
    Command cmd1 = mock(Command.class);
    Command cmd2 = mock(Command.class);
    Command cmd3 = mock(Command.class);

    MacroCommand macro = new MacroCommand("Macro teste", cmd1, cmd2, cmd3);

    // Act
    macro.execute();

    // Assert
    InOrder inOrder = inOrder(cmd1, cmd2, cmd3);
    inOrder.verify(cmd1).execute();
    inOrder.verify(cmd2).execute();
    inOrder.verify(cmd3).execute();
}
```

### 4. Testar Macro Rollback em Falha

```java
@Test
void macroDeveDesfazerComandosExecutadosEmCasoDeFalha() {
    // Arrange
    Command cmd1 = mock(Command.class);
    Command cmd2 = mock(Command.class);
    Command cmd3 = mock(Command.class);

    // cmd2 falha
    doThrow(new RuntimeException("Erro simulado")).when(cmd2).execute();

    MacroCommand macro = new MacroCommand("Macro com falha", cmd1, cmd2, cmd3);

    // Act & Assert
    assertThrows(RuntimeException.class, () -> macro.execute());

    // Verifica rollback
    verify(cmd1).execute();
    verify(cmd1).undo(); // Desfez cmd1
    verify(cmd2).execute();
    verify(cmd2, never()).undo(); // cmd2 n√£o foi desfeito (falhou no execute)
    verify(cmd3, never()).execute(); // cmd3 n√£o foi executado
}
```

### 5. Testar Command Queue

```java
@Test
void commandQueueDeveProcessarTodos() {
    // Arrange
    PedidoRepository repo = new PedidoRepositoryInMemory();
    CommandQueue queue = new CommandQueue();

    queue.enfileirar(new CriarPedidoCommand("PED-001", "A", new BigDecimal("100"), repo));
    queue.enfileirar(new CriarPedidoCommand("PED-002", "B", new BigDecimal("200"), repo));
    queue.enfileirar(new CriarPedidoCommand("PED-003", "C", new BigDecimal("300"), repo));

    // Act
    queue.processar();

    // Assert
    assertEquals(0, queue.tamanhoFila());
    assertTrue(repo.existe("PED-001"));
    assertTrue(repo.existe("PED-002"));
    assertTrue(repo.existe("PED-003"));

    CommandQueueStats stats = queue.getStats();
    assertEquals(3, stats.executados());
    assertEquals(0, stats.falhas());
}
```

### 6. Testar Valida√ß√£o

```java
@Test
void commandValidadoDeveRejeitarDadosInvalidos() {
    // Arrange
    PedidoRepository repo = new PedidoRepositoryInMemory();
    Command command = new CriarPedidoValidadoCommand(
        "",  // ID inv√°lido
        "Cliente",
        new BigDecimal("100"),
        repo
    );

    // Act & Assert
    IllegalStateException ex = assertThrows(
        IllegalStateException.class,
        () -> command.execute()
    );

    assertTrue(ex.getMessage().contains("ID n√£o pode ser vazio"));
}
```

### 7. Testar Hist√≥rico com Limite

```java
@Test
void invokerDeveLimitarTamanhoDoHistorico() {
    // Arrange
    CommandInvoker invoker = new CommandInvoker(3); // Limite de 3
    Command cmd = mock(Command.class);

    // Act - Executar 5 comandos
    invoker.executar(cmd);
    invoker.executar(cmd);
    invoker.executar(cmd);
    invoker.executar(cmd);
    invoker.executar(cmd);

    // Assert - Hist√≥rico limitado a 3
    assertEquals(3, invoker.tamanhoHistorico());
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Command com estado compartilhado
class BadCommand implements Command {
    private static int contador = 0; // Estado global ‚ùå

    public void execute() {
        contador++; // Race condition!
    }
}

// ‚ùå Command sem informa√ß√£o para undo
class SemUndoCommand implements Command {
    public void execute() {
        // Modifica estado mas n√£o salva anterior ‚ùå
        pedido.setStatus(Status.APROVADO);
    }

    public void undo() {
        // Como reverter sem saber estado anterior? ‚ùå
    }
}

// ‚ùå Command acoplado
class AcopladoCommand implements Command {
    public void execute() {
        new PedidoService().salvar(pedido); // new ‚ùå
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Command stateless ou com estado isolado
class GoodCommand implements Command {
    private final String pedidoId; // Estado isolado por inst√¢ncia
    private Status statusAnterior; // Estado para undo

    public void execute() {
        Pedido pedido = repository.buscar(pedidoId);
        statusAnterior = pedido.status(); // Salva para undo
        // ...
    }

    public void undo() {
        // Usa statusAnterior salvo
    }
}

// ‚úÖ Command com depend√™ncias injetadas
class DesacopladoCommand implements Command {
    private final PedidoService service;

    DesacopladoCommand(PedidoService service) {
        this.service = service; // Injetado
    }

    public void execute() {
        service.salvar(pedido);
    }
}

// ‚úÖ Command que declara se √© revers√≠vel
class HonestoCommand implements Command {
    public boolean isReversivel() {
        return false; // Honesto sobre n√£o poder reverter
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Encapsular par√¢metros**: Command tem tudo para executar
- ‚úÖ **Salvar estado**: Guardar informa√ß√£o necess√°ria para undo
- ‚úÖ **Idempot√™ncia**: Execute m√∫ltiplas vezes = mesmo resultado
- ‚úÖ **Valida√ß√£o**: Validar antes de executar
- ‚úÖ **Reversibilidade clara**: isReversivel() expl√≠cito
- ‚úÖ **Descri√ß√£o √∫til**: getDescricao() para logging/hist√≥rico
- ‚úÖ **Imutabilidade**: Commands como objetos imut√°veis

---

## üîó Integra√ß√£o com Frameworks

### Spring com Command Pattern

```java
@Service
public class PedidoCommandService {

    @Transactional
    public void executar(Command command) {
        command.execute();
    }

    @Async
    public CompletableFuture<Void> executarAsync(Command command) {
        return CompletableFuture.runAsync(command::execute);
    }
}
```

### Event Sourcing (Commands como Eventos)

```java
interface Event {
    UUID getAggregateId();
    LocalDateTime getTimestamp();
}

class PedidoCriadoEvent implements Event {
    private final UUID aggregateId;
    private final String cliente;
    private final BigDecimal valor;
    private final LocalDateTime timestamp;

    // Event Store persiste commands como eventos
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                    | ‚ö†Ô∏è Desvantagens                          |
| ------------------------------- | ---------------------------------------- |
| Desacopla emissor de receptor   | Muitas classes pequenas                  |
| Implementa undo/redo facilmente | Complexidade adicional                   |
| Enfileira e agenda opera√ß√µes    | Estado para undo consome mem√≥ria         |
| Testa comandos isoladamente     | Pode ser overkill para opera√ß√µes simples |
| Comp√µe comandos (macros)        | Debug pode ser complexo                  |

---

## üîç Compara√ß√£o

| Padr√£o                      | Prop√≥sito             | Quando Usar                     |
| --------------------------- | --------------------- | ------------------------------- |
| **Command**                 | Encapsular requisi√ß√£o | Undo/redo, filas, macros        |
| **Strategy**                | Encapsular algoritmo  | Trocar comportamento em runtime |
| **Template Method**         | Definir esqueleto     | Passos fixos com customiza√ß√£o   |
| **Chain of Responsibility** | Encadear handlers     | M√∫ltiplos handlers poss√≠veis    |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Command scheduler** (agendar comandos para executar em hor√°rio espec√≠fico)
2. **Command com compensa√ß√£o** (implementar saga pattern)
3. **Command remoto** (serializar e enviar via rede)
4. **Command com prioridade** (fila priorit√°ria)
5. **Command logger** (persistir hist√≥rico em banco)

---

## üìö Relacionado

- **Memento**: Salvar/restaurar estado de objetos
- **Strategy**: Encapsular algoritmos intercambi√°veis
- **Composite**: Compor objetos em √°rvore (similar a MacroCommand)
- **Chain of Responsibility**: Encadear handlers

---

**Command Pattern encapsula opera√ß√µes como objetos, permitindo undo/redo e testes isolados!** üéÆ‚ú®
