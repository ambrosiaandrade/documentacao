# 04.7 Event Sourcing [EXPERT] üìú

## üéØ Objetivo

Armazenar o **estado da aplica√ß√£o** como uma sequ√™ncia **imut√°vel de eventos** ao inv√©s de persistir apenas o estado atual, permitindo **auditoria completa**, **replay temporal** e **m√∫ltiplas proje√ß√µes** a partir da mesma fonte de eventos.

---

## üìö O Que √â?

**Event Sourcing** √© um padr√£o arquitetural onde todas as mudan√ßas de estado s√£o armazenadas como eventos em um log **append-only** (somente adi√ß√£o). O estado atual √© derivado aplicando todos os eventos em sequ√™ncia.

### Analogia

Como um **extrato banc√°rio**: ao inv√©s de guardar apenas o saldo atual (R$ 1.000), voc√™ guarda todas as transa√ß√µes (dep√≥sito +500, compra -200, saque -100) e calcula o saldo somando tudo.

### Diferen√ßa Fundamental

- **CRUD Tradicional**: `UPDATE usuarios SET email='novo@mail.com' WHERE id=1` (perde estado anterior)
- **Event Sourcing**: Adiciona evento `EmailAlterado(userId=1, novoEmail='novo@mail.com', timestamp=X)` (mant√©m hist√≥rico)

---

## ‚ùå Problema que Resolve

### Antes (CRUD Tradicional)

```java
// ‚ùå PROBLEMA: Perde hist√≥rico, n√£o audit√°vel
public void alterarEmail(String userId, String novoEmail) {
    User user = repository.findById(userId);
    user.setEmail(novoEmail); // Email antigo perdido
    repository.save(user);    // Sobrescreve estado
}

// Imposs√≠vel responder:
// - Quando o email foi alterado?
// - Qual era o email anterior?
// - Quem alterou?
```

**Problemas**:

- üîç Auditoria imposs√≠vel (sem hist√≥rico)
- üïí Rollback temporal complexo
- üìä Dificuldade para criar novas vis√µes dos dados
- üêõ Debugging dif√≠cil ("como chegamos aqui?")

### Depois (Event Sourcing)

```java
// ‚úÖ SOLU√á√ÉO: Hist√≥rico completo de eventos
public void alterarEmail(String userId, String novoEmail) {
    List<UserEvent> history = eventStore.load(userId);
    UserAggregate aggregate = UserAggregate.rehydrate(history);

    aggregate.alterarEmail(novoEmail, Instant.now());

    eventStore.append(userId, aggregate.pendingChanges());
    // Eventos: UserCreated, EmailChanged armazenados permanentemente
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Definir Eventos com Sealed Interfaces

```java
// Hierarquia de eventos de dom√≠nio
sealed interface UserEvent
    permits UserCreated, EmailChanged, UserDeactivated {
    String userId();
    Instant timestamp();
}

record UserCreated(
    String userId,
    String email,
    String nome,
    Instant timestamp
) implements UserEvent {}

record EmailChanged(
    String userId,
    String emailAntigo,
    String emailNovo,
    Instant timestamp
) implements UserEvent {}

record UserDeactivated(
    String userId,
    String motivo,
    Instant timestamp
) implements UserEvent {}
```

### 2. Aggregate Root com Reidrata√ß√£o

```java
final class UserAggregate {
    private String userId;
    private String email;
    private String nome;
    private boolean ativo;
    private final List<UserEvent> pendingChanges = new ArrayList<>();

    // Estado atual derivado dos eventos
    public static UserAggregate rehydrate(List<UserEvent> history) {
        var aggregate = new UserAggregate();
        history.forEach(aggregate::apply);
        return aggregate;
    }

    // Comandos que geram eventos
    public void criar(String userId, String email, String nome, Instant timestamp) {
        if (this.userId != null) {
            throw new IllegalStateException("Usu√°rio j√° existe");
        }

        var evento = new UserCreated(userId, email, nome, timestamp);
        apply(evento);
        pendingChanges.add(evento);
    }

    public void alterarEmail(String novoEmail, Instant timestamp) {
        if (userId == null) {
            throw new IllegalStateException("Usu√°rio n√£o existe");
        }
        if (email.equals(novoEmail)) {
            return; // Sem mudan√ßa, sem evento
        }

        var evento = new EmailChanged(userId, email, novoEmail, timestamp);
        apply(evento);
        pendingChanges.add(evento);
    }

    public void desativar(String motivo, Instant timestamp) {
        if (!ativo) {
            throw new IllegalStateException("Usu√°rio j√° desativado");
        }

        var evento = new UserDeactivated(userId, motivo, timestamp);
        apply(evento);
        pendingChanges.add(evento);
    }

    // Aplicar evento ao estado interno
    private void apply(UserEvent evento) {
        switch (evento) {
            case UserCreated e -> {
                this.userId = e.userId();
                this.email = e.email();
                this.nome = e.nome();
                this.ativo = true;
            }
            case EmailChanged e -> {
                this.email = e.emailNovo();
            }
            case UserDeactivated e -> {
                this.ativo = false;
            }
        }
    }

    // Getters
    public String getUserId() { return userId; }
    public String getEmail() { return email; }
    public String getNome() { return nome; }
    public boolean isAtivo() { return ativo; }
    public List<UserEvent> getPendingChanges() {
        return List.copyOf(pendingChanges);
    }
    public void clearChanges() {
        pendingChanges.clear();
    }
}
```

### 3. Event Store (Reposit√≥rio de Eventos)

```java
interface EventStore {
    void append(String streamId, List<UserEvent> eventos);
    List<UserEvent> load(String streamId);
    List<UserEvent> loadAfter(String streamId, Instant after);
}

final class InMemoryEventStore implements EventStore {
    private final Map<String, List<UserEvent>> streams = new ConcurrentHashMap<>();

    @Override
    public void append(String streamId, List<UserEvent> eventos) {
        streams.compute(streamId, (key, existing) -> {
            List<UserEvent> list = existing != null
                ? new ArrayList<>(existing)
                : new ArrayList<>();
            list.addAll(eventos);
            return list;
        });
    }

    @Override
    public List<UserEvent> load(String streamId) {
        return streams.getOrDefault(streamId, List.of());
    }

    @Override
    public List<UserEvent> loadAfter(String streamId, Instant after) {
        return load(streamId).stream()
            .filter(e -> e.timestamp().isAfter(after))
            .toList();
    }
}
```

### 4. Repository que Usa Event Store

```java
final class UserRepository {
    private final EventStore eventStore;

    public UserRepository(EventStore eventStore) {
        this.eventStore = eventStore;
    }

    public UserAggregate findById(String userId) {
        List<UserEvent> history = eventStore.load(userId);
        if (history.isEmpty()) {
            return null;
        }
        return UserAggregate.rehydrate(history);
    }

    public void save(UserAggregate aggregate) {
        List<UserEvent> changes = aggregate.getPendingChanges();
        if (!changes.isEmpty()) {
            eventStore.append(aggregate.getUserId(), changes);
            aggregate.clearChanges();
        }
    }

    public List<UserEvent> getHistory(String userId) {
        return eventStore.load(userId);
    }

    public UserAggregate getStateAt(String userId, Instant timestamp) {
        List<UserEvent> historyUntil = eventStore.load(userId).stream()
            .filter(e -> e.timestamp().isBefore(timestamp) ||
                         e.timestamp().equals(timestamp))
            .toList();

        if (historyUntil.isEmpty()) {
            return null;
        }

        return UserAggregate.rehydrate(historyUntil);
    }
}
```

### 5. Snapshot para Performance

```java
record Snapshot(String aggregateId, int version, Object state, Instant timestamp) {}

final class SnapshotStore {
    private final Map<String, Snapshot> snapshots = new ConcurrentHashMap<>();

    void save(String aggregateId, int version, Object state) {
        snapshots.put(aggregateId,
            new Snapshot(aggregateId, version, state, Instant.now()));
    }

    Optional<Snapshot> load(String aggregateId) {
        return Optional.ofNullable(snapshots.get(aggregateId));
    }
}

final class UserRepositoryWithSnapshot {
    private final EventStore eventStore;
    private final SnapshotStore snapshotStore;
    private static final int SNAPSHOT_FREQUENCY = 50; // A cada 50 eventos

    public UserAggregate findById(String userId) {
        Optional<Snapshot> snapshot = snapshotStore.load(userId);

        List<UserEvent> events;
        UserAggregate aggregate;

        if (snapshot.isPresent()) {
            // Carregar apenas eventos ap√≥s snapshot
            aggregate = (UserAggregate) snapshot.get().state();
            events = eventStore.loadAfter(userId, snapshot.get().timestamp());
        } else {
            // Carregar todos os eventos
            aggregate = new UserAggregate();
            events = eventStore.load(userId);
        }

        // Aplicar eventos restantes
        events.forEach(aggregate::apply);

        return aggregate;
    }

    public void save(UserAggregate aggregate) {
        List<UserEvent> changes = aggregate.getPendingChanges();
        if (changes.isEmpty()) return;

        eventStore.append(aggregate.getUserId(), changes);

        // Criar snapshot se atingir frequ√™ncia
        List<UserEvent> allEvents = eventStore.load(aggregate.getUserId());
        if (allEvents.size() % SNAPSHOT_FREQUENCY == 0) {
            snapshotStore.save(aggregate.getUserId(), allEvents.size(), aggregate);
        }

        aggregate.clearChanges();
    }
}
```

---

## üß™ Como Testar

### 1. Testar Cria√ß√£o e Reidrata√ß√£o

```java
@Test
void deveCriarERecarregarAggregate() {
    // Arrange
    EventStore store = new InMemoryEventStore();
    UserRepository repo = new UserRepository(store);

    // Act - criar usu√°rio
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "test@mail.com", "Jo√£o", Instant.now());
    repo.save(aggregate);

    // Assert - recarregar do event store
    UserAggregate reloaded = repo.findById("user1");
    assertNotNull(reloaded);
    assertEquals("test@mail.com", reloaded.getEmail());
    assertEquals("Jo√£o", reloaded.getNome());
    assertTrue(reloaded.isAtivo());
}
```

### 2. Testar Hist√≥rico de Mudan√ßas

```java
@Test
void deveManterHistoricoCompleto() {
    // Arrange
    EventStore store = new InMemoryEventStore();
    UserRepository repo = new UserRepository(store);

    // Act - criar e modificar m√∫ltiplas vezes
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "email1@test.com", "Jo√£o", Instant.now());
    repo.save(aggregate);

    var loaded = repo.findById("user1");
    loaded.alterarEmail("email2@test.com", Instant.now());
    repo.save(loaded);

    loaded = repo.findById("user1");
    loaded.alterarEmail("email3@test.com", Instant.now());
    repo.save(loaded);

    // Assert - hist√≥rico tem todos os eventos
    List<UserEvent> history = repo.getHistory("user1");
    assertEquals(3, history.size());
    assertInstanceOf(UserCreated.class, history.get(0));
    assertInstanceOf(EmailChanged.class, history.get(1));
    assertInstanceOf(EmailChanged.class, history.get(2));

    // Estado final correto
    UserAggregate final = repo.findById("user1");
    assertEquals("email3@test.com", final.getEmail());
}
```

### 3. Testar Rollback Temporal

```java
@Test
void deveRecuperarEstadoNoPassado() {
    // Arrange
    EventStore store = new InMemoryEventStore();
    UserRepository repo = new UserRepository(store);

    Instant t1 = Instant.now();
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "email1@test.com", "Jo√£o", t1);
    repo.save(aggregate);

    Instant t2 = t1.plusSeconds(100);
    aggregate = repo.findById("user1");
    aggregate.alterarEmail("email2@test.com", t2);
    repo.save(aggregate);

    Instant t3 = t2.plusSeconds(100);
    aggregate = repo.findById("user1");
    aggregate.alterarEmail("email3@test.com", t3);
    repo.save(aggregate);

    // Act - recuperar estado em t2
    UserAggregate estadoEmT2 = repo.getStateAt("user1", t2);

    // Assert
    assertEquals("email2@test.com", estadoEmT2.getEmail());
}
```

### 4. Testar Invariantes de Neg√≥cio

```java
@Test
void naoDevePermitirDuplicacaoDeCriacao() {
    // Arrange
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "test@mail.com", "Jo√£o", Instant.now());

    // Act & Assert
    assertThrows(IllegalStateException.class, () -> {
        aggregate.criar("user1", "outro@mail.com", "Jos√©", Instant.now());
    });
}

@Test
void naoDeveDesativarUsuarioJaDesativado() {
    // Arrange
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "test@mail.com", "Jo√£o", Instant.now());
    aggregate.desativar("Solicita√ß√£o do usu√°rio", Instant.now());

    // Act & Assert
    assertThrows(IllegalStateException.class, () -> {
        aggregate.desativar("Tentando novamente", Instant.now());
    });
}
```

### 5. Testar Eventos N√£o Geram Mudan√ßas Desnecess√°rias

```java
@Test
void naoDeveGerarEventoParaMesmoEmail() {
    // Arrange
    var aggregate = new UserAggregate();
    aggregate.criar("user1", "test@mail.com", "Jo√£o", Instant.now());
    int eventosAposCriacao = aggregate.getPendingChanges().size();

    // Act - tentar alterar para mesmo email
    aggregate.alterarEmail("test@mail.com", Instant.now());

    // Assert - nenhum novo evento gerado
    assertEquals(eventosAposCriacao, aggregate.getPendingChanges().size());
}
```

### 6. Testar Snapshot e Replay Parcial

```java
@Test
void deveUsarSnapshotParaPerformance() {
    // Arrange
    EventStore eventStore = new InMemoryEventStore();
    SnapshotStore snapshotStore = new SnapshotStore();

    var aggregate = new UserAggregate();
    aggregate.criar("user1", "email@test.com", "Jo√£o", Instant.now());

    // Simular 100 mudan√ßas de email
    for (int i = 1; i <= 100; i++) {
        aggregate.alterarEmail("email" + i + "@test.com", Instant.now());
    }

    eventStore.append("user1", aggregate.getPendingChanges());

    // Act - criar snapshot no evento 50
    snapshotStore.save("user1", 50, aggregate);

    // Assert - carregar com snapshot requer menos eventos
    Optional<Snapshot> snapshot = snapshotStore.load("user1");
    assertTrue(snapshot.isPresent());
    assertEquals(50, snapshot.get().version());
}
```

### 7. Testar Proje√ß√£o de Leitura

```java
@Test
void deveCriarProjecaoDeQuantidadeAlteracoesEmail() {
    // Arrange
    EventStore store = new InMemoryEventStore();
    UserRepository repo = new UserRepository(store);

    var aggregate = new UserAggregate();
    aggregate.criar("user1", "email1@test.com", "Jo√£o", Instant.now());
    aggregate.alterarEmail("email2@test.com", Instant.now());
    aggregate.alterarEmail("email3@test.com", Instant.now());
    repo.save(aggregate);

    // Act - proje√ß√£o customizada
    List<UserEvent> history = repo.getHistory("user1");
    long alteracoesEmail = history.stream()
        .filter(e -> e instanceof EmailChanged)
        .count();

    // Assert
    assertEquals(2, alteracoesEmail);
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Mutar estado fora do apply()
public void alterarEmail(String email) {
    this.email = email; // NUNCA! Muda sem evento
}

// ‚ùå Eventos mut√°veis
class UserEvent {
    private String email; // Permite setEmail() - NUNCA!
}

// ‚ùå Deletar eventos do store
eventStore.delete(userId); // Viola imutabilidade!
```

### ‚úÖ Fazer

```java
// ‚úÖ Apenas apply() muda estado
private void apply(UserEvent evento) {
    switch (evento) {
        case EmailChanged e -> this.email = e.emailNovo();
    }
}

// ‚úÖ Eventos imut√°veis (records)
record EmailChanged(String userId, String emailNovo, Instant timestamp)
    implements UserEvent {}

// ‚úÖ "Soft delete" com evento
record UserDeleted(String userId, Instant timestamp) implements UserEvent {}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Eventos imut√°veis**: Use records (Java 17+)
- ‚úÖ **Sealed interfaces**: Tipo seguro para eventos
- ‚úÖ **Versionamento**: Adicione campo `version` em eventos para evolu√ß√£o
- ‚úÖ **Snapshots**: A cada N eventos para performance
- ‚úÖ **Idempot√™ncia**: Replay deve produzir mesmo estado
- ‚úÖ **Timestamps**: Sempre incluir para auditoria e rollback temporal
- ‚úÖ **Granularidade**: Eventos de neg√≥cio, n√£o t√©cnicos ("EmailAlterado" n√£o "SetEmail")

---

## üîó Integra√ß√£o com Frameworks

### Axon Framework

```java
@Aggregate
public class UserAggregate {
    @AggregateIdentifier
    private String userId;
    private String email;

    @CommandHandler
    public UserAggregate(CreateUserCommand cmd) {
        AggregateLifecycle.apply(new UserCreatedEvent(cmd.userId(), cmd.email()));
    }

    @EventSourcingHandler
    public void on(UserCreatedEvent event) {
        this.userId = event.userId();
        this.email = event.email();
    }

    @CommandHandler
    public void handle(ChangeEmailCommand cmd) {
        AggregateLifecycle.apply(new EmailChangedEvent(userId, cmd.newEmail()));
    }

    @EventSourcingHandler
    public void on(EmailChangedEvent event) {
        this.email = event.newEmail();
    }
}
```

### EventStoreDB (EventStore.com)

```java
EventStoreDBClient client = EventStoreDBClient.create(settings);

// Append eventos
client.appendToStream(
    "user-123",
    EventData.builderAsJson("EmailChanged", emailChangedEvent).build()
).get();

// Ler stream
ReadResult result = client.readStream("user-123").get();
List<ResolvedEvent> events = result.getEvents();
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                             | ‚ö†Ô∏è Desvantagens                        |
| ---------------------------------------- | -------------------------------------- |
| Auditoria completa (quem, quando, o qu√™) | Complexidade de infraestrutura         |
| Rollback temporal (debugar produ√ß√£o)     | Migra√ß√£o de eventos (versionamento)    |
| M√∫ltiplas proje√ß√µes (CQRS)               | Performance (replay de muitos eventos) |
| Imutabilidade (sem race conditions)      | Curva de aprendizado alta              |
| An√°lise retroativa (data science)        | N√£o funciona para todos os dom√≠nios    |

---

## üîç Compara√ß√£o com Outras Abordagens

| Aspecto                 | Event Sourcing     | CRUD Tradicional | Audit Log          |
| ----------------------- | ------------------ | ---------------- | ------------------ |
| **Hist√≥rico**           | Completo (eventos) | Perdido          | Parcial (triggers) |
| **Performance Leitura** | Lenta (replay)     | R√°pida           | R√°pida             |
| **Rollback Temporal**   | Nativo             | Imposs√≠vel       | Manual             |
| **Complexidade**        | Alta               | Baixa            | M√©dia              |
| **Proje√ß√µes**           | M√∫ltiplas          | √önica            | √önica              |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar versionamento** de eventos (v1 ‚Üí v2) com upcasting
2. **Criar proje√ß√£o ass√≠ncrona** que atualiza banco de leitura ao receber eventos
3. **Implementar snapshot autom√°tico** a cada N eventos com limpeza
4. **Migrar esquema de evento** sem quebrar hist√≥rico (adicionar campo opcional)
5. **Criar projection de analytics** (ex: quantidade de mudan√ßas de email por dia)

---

## üìö Relacionado

- **CQRS**: Separar modelo de escrita (eventos) e leitura (proje√ß√µes)
- **Saga Pattern**: Coordenar transa√ß√µes distribu√≠das usando eventos
- **Domain Events**: Eventos de dom√≠nio s√£o a base do Event Sourcing
- **Snapshot Pattern**: Otimiza√ß√£o para evitar replay completo

---

**Event Sourcing transforma seu banco de dados em uma m√°quina do tempo audit√°vel, mas requer disciplina e infraestrutura adequada!** üìú‚ú®
