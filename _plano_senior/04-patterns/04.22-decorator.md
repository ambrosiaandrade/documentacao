# 04.22 Decorator Pattern [M√âDIO] üéÅ

## üéØ Objetivo

Adicionar **responsabilidades din√¢micas** a objetos sem modificar seu c√≥digo, permitindo combinar comportamentos e facilitando **testes isolados de cada funcionalidade**.

---

## üìö O Que √â?

**Decorator** (tamb√©m conhecido como Wrapper) √© um padr√£o estrutural GoF que permite anexar novos comportamentos a objetos colocando-os dentro de objetos wrapper especiais que cont√™m os comportamentos. Essencial para adicionar funcionalidades cross-cutting como logging, cache, valida√ß√£o.

### Analogia

Como **acess√≥rios de um carro**:

- **Carro b√°sico**: Funcionalidade essencial (dirigir)
- **Air bag**: Decorator adiciona seguran√ßa
- **GPS**: Decorator adiciona navega√ß√£o
- **Ar-condicionado**: Decorator adiciona conforto
- **Vantagem**: Combinar acess√≥rios conforme necessidade, sem modificar o carro base

---

## ‚ùå Problema que Resolve

### Antes (Heran√ßa R√≠gida)

```java
// ‚ùå PROBLEMA: Explos√£o de subclasses com heran√ßa
class Notificador {
    void enviar(String mensagem) {
        System.out.println("Enviando: " + mensagem);
    }
}

class NotificadorComEmail extends Notificador {
    void enviar(String mensagem) {
        super.enviar(mensagem);
        System.out.println("Email enviado");
    }
}

class NotificadorComSMS extends Notificador {
    void enviar(String mensagem) {
        super.enviar(mensagem);
        System.out.println("SMS enviado");
    }
}

// E se quisermos Email + SMS?
class NotificadorComEmailESMS extends Notificador {
    void enviar(String mensagem) {
        super.enviar(mensagem);
        System.out.println("Email enviado");
        System.out.println("SMS enviado");
    }
}

// E se quisermos Email + SMS + Push?
// Explos√£o combinat√≥ria! 2^n subclasses! ‚ùå
```

**Problemas**:

- üí• Explos√£o de subclasses (combina√ß√µes)
- üîí Heran√ßa r√≠gida (compile-time)
- üß™ Dif√≠cil testar funcionalidades isoladamente
- üîß Adicionar nova feature = nova subclasse

### Depois (Decorator Pattern)

```java
// ‚úÖ SOLU√á√ÉO: Composi√ß√£o din√¢mica
interface Notificador {
    void enviar(String mensagem);
}

class NotificadorBase implements Notificador {
    public void enviar(String mensagem) {
        System.out.println("Enviando: " + mensagem);
    }
}

// Decorator abstrato
abstract class NotificadorDecorator implements Notificador {
    protected final Notificador wrapped;

    NotificadorDecorator(Notificador wrapped) {
        this.wrapped = wrapped;
    }

    public void enviar(String mensagem) {
        wrapped.enviar(mensagem);
    }
}

// Decorators concretos
class EmailDecorator extends NotificadorDecorator {
    EmailDecorator(Notificador wrapped) {
        super(wrapped);
    }

    public void enviar(String mensagem) {
        super.enviar(mensagem);
        System.out.println("Email enviado");
    }
}

class SMSDecorator extends NotificadorDecorator {
    SMSDecorator(Notificador wrapped) {
        super(wrapped);
    }

    public void enviar(String mensagem) {
        super.enviar(mensagem);
        System.out.println("SMS enviado");
    }
}

// Composi√ß√£o din√¢mica em runtime
Notificador notif = new EmailDecorator(
    new SMSDecorator(
        new NotificadorBase()
    )
);
notif.enviar("Alerta!"); // Base ‚Üí SMS ‚Üí Email

// Teste isolado
@Test
void emailDecoratorDeveEnviarEmail() {
    Notificador baseMock = mock(Notificador.class);
    Notificador decorator = new EmailDecorator(baseMock);

    decorator.enviar("teste");

    verify(baseMock).enviar("teste"); // Verifica delega√ß√£o
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Interface Component e Concrete Component

```java
interface RepositorioPedido {
    Pedido buscar(String id);
    void salvar(Pedido pedido);
}

record Pedido(String id, String cliente, BigDecimal valor, Status status) {}

enum Status { PENDENTE, APROVADO, CANCELADO }

// Concrete Component
final class RepositorioPedidoSimples implements RepositorioPedido {
    private final Map<String, Pedido> storage = new ConcurrentHashMap<>();

    @Override
    public Pedido buscar(String id) {
        Pedido pedido = storage.get(id);
        if (pedido == null) {
            throw new RuntimeException("Pedido n√£o encontrado: " + id);
        }
        return pedido;
    }

    @Override
    public void salvar(Pedido pedido) {
        storage.put(pedido.id(), pedido);
        System.out.println("üíæ Pedido salvo: " + pedido.id());
    }
}
```

### 2. Decorator Base (Abstrato)

```java
abstract class RepositorioPedidoDecorator implements RepositorioPedido {
    protected final RepositorioPedido wrapped;

    protected RepositorioPedidoDecorator(RepositorioPedido wrapped) {
        this.wrapped = wrapped;
    }

    @Override
    public Pedido buscar(String id) {
        return wrapped.buscar(id);
    }

    @Override
    public void salvar(Pedido pedido) {
        wrapped.salvar(pedido);
    }
}
```

### 3. Decorator: Logging

```java
final class LoggingDecorator extends RepositorioPedidoDecorator {
    private final String nome;

    LoggingDecorator(String nome, RepositorioPedido wrapped) {
        super(wrapped);
        this.nome = nome;
    }

    @Override
    public Pedido buscar(String id) {
        System.out.println("üìã [" + nome + "] Buscando pedido: " + id);
        long inicio = System.currentTimeMillis();

        try {
            Pedido pedido = super.buscar(id);
            long duracao = System.currentTimeMillis() - inicio;
            System.out.println("‚úÖ [" + nome + "] Pedido encontrado em " + duracao + "ms");
            return pedido;

        } catch (Exception e) {
            System.err.println("‚ùå [" + nome + "] Erro ao buscar: " + e.getMessage());
            throw e;
        }
    }

    @Override
    public void salvar(Pedido pedido) {
        System.out.println("üìã [" + nome + "] Salvando pedido: " + pedido.id());
        long inicio = System.currentTimeMillis();

        try {
            super.salvar(pedido);
            long duracao = System.currentTimeMillis() - inicio;
            System.out.println("‚úÖ [" + nome + "] Pedido salvo em " + duracao + "ms");

        } catch (Exception e) {
            System.err.println("‚ùå [" + nome + "] Erro ao salvar: " + e.getMessage());
            throw e;
        }
    }
}
```

### 4. Decorator: Cache

```java
final class CacheDecorator extends RepositorioPedidoDecorator {
    private final Map<String, Pedido> cache = new ConcurrentHashMap<>();
    private final AtomicInteger hits = new AtomicInteger(0);
    private final AtomicInteger misses = new AtomicInteger(0);

    CacheDecorator(RepositorioPedido wrapped) {
        super(wrapped);
    }

    @Override
    public Pedido buscar(String id) {
        Pedido cached = cache.get(id);

        if (cached != null) {
            hits.incrementAndGet();
            System.out.println("üéØ Cache HIT: " + id + " (hits: " + hits.get() + ")");
            return cached;
        }

        misses.incrementAndGet();
        System.out.println("‚ùå Cache MISS: " + id + " (misses: " + misses.get() + ")");

        Pedido pedido = super.buscar(id);
        cache.put(id, pedido);

        return pedido;
    }

    @Override
    public void salvar(Pedido pedido) {
        super.salvar(pedido);
        cache.put(pedido.id(), pedido);
        System.out.println("üîÑ Cache atualizado: " + pedido.id());
    }

    void invalidar(String id) {
        cache.remove(id);
        System.out.println("üóë Cache invalidado: " + id);
    }

    CacheStats getStats() {
        int total = hits.get() + misses.get();
        double hitRate = total == 0 ? 0.0 : (hits.get() * 100.0) / total;
        return new CacheStats(hits.get(), misses.get(), hitRate);
    }
}

record CacheStats(int hits, int misses, double hitRate) {}
```

### 5. Decorator: Valida√ß√£o

```java
final class ValidacaoDecorator extends RepositorioPedidoDecorator {

    ValidacaoDecorator(RepositorioPedido wrapped) {
        super(wrapped);
    }

    @Override
    public Pedido buscar(String id) {
        validarId(id);
        return super.buscar(id);
    }

    @Override
    public void salvar(Pedido pedido) {
        validarPedido(pedido);
        super.salvar(pedido);
    }

    private void validarId(String id) {
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("ID n√£o pode ser vazio");
        }

        if (!id.matches("PED-\\d{4}")) {
            throw new IllegalArgumentException(
                "ID deve ter formato PED-XXXX: " + id
            );
        }
    }

    private void validarPedido(Pedido pedido) {
        validarId(pedido.id());

        if (pedido.cliente() == null || pedido.cliente().isBlank()) {
            throw new IllegalArgumentException("Cliente n√£o pode ser vazio");
        }

        if (pedido.valor() == null || pedido.valor().compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Valor deve ser positivo");
        }

        if (pedido.status() == null) {
            throw new IllegalArgumentException("Status n√£o pode ser nulo");
        }

        System.out.println("‚úÖ Valida√ß√£o OK: " + pedido.id());
    }
}
```

### 6. Decorator: M√©tricas

```java
final class MetricasDecorator extends RepositorioPedidoDecorator {
    private final AtomicInteger buscas = new AtomicInteger(0);
    private final AtomicInteger salvamentos = new AtomicInteger(0);
    private final AtomicLong tempoBuscaTotal = new AtomicLong(0);
    private final AtomicLong tempoSalvarTotal = new AtomicLong(0);

    MetricasDecorator(RepositorioPedido wrapped) {
        super(wrapped);
    }

    @Override
    public Pedido buscar(String id) {
        buscas.incrementAndGet();

        long inicio = System.nanoTime();
        Pedido pedido = super.buscar(id);
        long duracao = System.nanoTime() - inicio;

        tempoBuscaTotal.addAndGet(duracao);

        return pedido;
    }

    @Override
    public void salvar(Pedido pedido) {
        salvamentos.incrementAndGet();

        long inicio = System.nanoTime();
        super.salvar(pedido);
        long duracao = System.nanoTime() - inicio;

        tempoSalvarTotal.addAndGet(duracao);
    }

    Metricas getMetricas() {
        long mediaBusca = buscas.get() == 0 ? 0
            : tempoBuscaTotal.get() / buscas.get();

        long mediaSalvar = salvamentos.get() == 0 ? 0
            : tempoSalvarTotal.get() / salvamentos.get();

        return new Metricas(
            buscas.get(),
            salvamentos.get(),
            mediaBusca / 1_000_000.0, // Converter para ms
            mediaSalvar / 1_000_000.0
        );
    }
}

record Metricas(int buscas, int salvamentos, double mediaBuscaMs, double mediaSalvarMs) {}
```

### 7. Decorator: Retry com Exponential Backoff

```java
final class RetryDecorator extends RepositorioPedidoDecorator {
    private final int maxTentativas;
    private final long delayInicial;

    RetryDecorator(RepositorioPedido wrapped, int maxTentativas, long delayInicial) {
        super(wrapped);
        this.maxTentativas = maxTentativas;
        this.delayInicial = delayInicial;
    }

    @Override
    public Pedido buscar(String id) {
        return executarComRetry(() -> super.buscar(id), "buscar");
    }

    @Override
    public void salvar(Pedido pedido) {
        executarComRetry(() -> {
            super.salvar(pedido);
            return null;
        }, "salvar");
    }

    private <T> T executarComRetry(Supplier<T> operacao, String nomeOperacao) {
        Exception ultimaExcecao = null;

        for (int tentativa = 1; tentativa <= maxTentativas; tentativa++) {
            try {
                System.out.println("üîÑ Tentativa " + tentativa + "/" + maxTentativas + " - " + nomeOperacao);
                return operacao.get();

            } catch (Exception e) {
                ultimaExcecao = e;
                System.err.println("‚ùå Falha na tentativa " + tentativa + ": " + e.getMessage());

                if (tentativa < maxTentativas) {
                    long delay = delayInicial * (long) Math.pow(2, tentativa - 1);
                    System.out.println("‚è≥ Aguardando " + delay + "ms antes de retry...");

                    try {
                        Thread.sleep(delay);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException("Retry interrompido", ie);
                    }
                }
            }
        }

        throw new RuntimeException(
            "Falha ap√≥s " + maxTentativas + " tentativas",
            ultimaExcecao
        );
    }
}
```

### 8. Composi√ß√£o Din√¢mica

```java
final class RepositorioPedidoFactory {

    static RepositorioPedido criar(ConfiguracaoRepositorio config) {
        RepositorioPedido repo = new RepositorioPedidoSimples();

        if (config.habilitarValidacao()) {
            repo = new ValidacaoDecorator(repo);
            System.out.println("‚úÖ Valida√ß√£o habilitada");
        }

        if (config.habilitarCache()) {
            repo = new CacheDecorator(repo);
            System.out.println("‚úÖ Cache habilitado");
        }

        if (config.habilitarMetricas()) {
            repo = new MetricasDecorator(repo);
            System.out.println("‚úÖ M√©tricas habilitadas");
        }

        if (config.habilitarLogging()) {
            repo = new LoggingDecorator("RepositorioPedido", repo);
            System.out.println("‚úÖ Logging habilitado");
        }

        if (config.habilitarRetry()) {
            repo = new RetryDecorator(repo, config.maxRetries(), config.delayRetry());
            System.out.println("‚úÖ Retry habilitado");
        }

        return repo;
    }
}

record ConfiguracaoRepositorio(
    boolean habilitarValidacao,
    boolean habilitarCache,
    boolean habilitarMetricas,
    boolean habilitarLogging,
    boolean habilitarRetry,
    int maxRetries,
    long delayRetry
) {
    static ConfiguracaoRepositorio padrao() {
        return new ConfiguracaoRepositorio(true, true, true, true, false, 3, 100L);
    }

    static ConfiguracaoRepositorio completa() {
        return new ConfiguracaoRepositorio(true, true, true, true, true, 3, 100L);
    }

    static ConfiguracaoRepositorio minimal() {
        return new ConfiguracaoRepositorio(true, false, false, false, false, 0, 0L);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Decorator Isoladamente

```java
@Test
void loggingDecoratorDeveLogarOperacoes() {
    // Arrange
    RepositorioPedido baseMock = mock(RepositorioPedido.class);
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"), Status.PENDENTE);
    when(baseMock.buscar("PED-001")).thenReturn(pedido);

    RepositorioPedido decorator = new LoggingDecorator("TestRepo", baseMock);

    // Act
    Pedido resultado = decorator.buscar("PED-001");

    // Assert
    assertEquals(pedido, resultado);
    verify(baseMock).buscar("PED-001");
}
```

### 2. Testar Cache Decorator

```java
@Test
void cacheDecoratorDeveEvitarChamadasRedundantes() {
    // Arrange
    RepositorioPedido baseMock = mock(RepositorioPedido.class);
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"), Status.PENDENTE);
    when(baseMock.buscar("PED-001")).thenReturn(pedido);

    CacheDecorator decorator = new CacheDecorator(baseMock);

    // Act
    Pedido primeira = decorator.buscar("PED-001"); // MISS
    Pedido segunda = decorator.buscar("PED-001");  // HIT
    Pedido terceira = decorator.buscar("PED-001"); // HIT

    // Assert
    assertEquals(pedido, primeira);
    assertEquals(pedido, segunda);
    assertEquals(pedido, terceira);

    verify(baseMock, times(1)).buscar("PED-001"); // Apenas 1 chamada ao base!

    CacheStats stats = decorator.getStats();
    assertEquals(2, stats.hits());
    assertEquals(1, stats.misses());
    assertEquals(66.67, stats.hitRate(), 0.01);
}
```

### 3. Testar Valida√ß√£o Decorator

```java
@Test
void validacaoDecoratorDeveRejeitarDadosInvalidos() {
    // Arrange
    RepositorioPedido baseMock = mock(RepositorioPedido.class);
    RepositorioPedido decorator = new ValidacaoDecorator(baseMock);

    Pedido pedidoInvalido = new Pedido(
        "INVALIDO", // Formato errado
        "Cliente A",
        new BigDecimal("100"),
        Status.PENDENTE
    );

    // Act & Assert
    IllegalArgumentException ex = assertThrows(
        IllegalArgumentException.class,
        () -> decorator.salvar(pedidoInvalido)
    );

    assertTrue(ex.getMessage().contains("formato PED-XXXX"));
    verify(baseMock, never()).salvar(any());
}
```

### 4. Testar Composi√ß√£o de Decorators

```java
@Test
void deveComporMultiplosDecorators() {
    // Arrange
    RepositorioPedido base = new RepositorioPedidoSimples();

    RepositorioPedido decorado = new LoggingDecorator("Test",
        new CacheDecorator(
            new ValidacaoDecorator(base)
        )
    );

    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"), Status.PENDENTE);

    // Act
    decorado.salvar(pedido); // Valida√ß√£o ‚Üí Cache ‚Üí Logging ‚Üí Base
    Pedido resultado = decorado.buscar("PED-001"); // Cache hit!

    // Assert
    assertEquals(pedido, resultado);
}
```

### 5. Testar M√©tricas Decorator

```java
@Test
void metricasDecoratorDeveRastrearOperacoes() {
    // Arrange
    RepositorioPedido base = new RepositorioPedidoSimples();
    MetricasDecorator decorator = new MetricasDecorator(base);

    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"), Status.PENDENTE);

    // Act
    decorator.salvar(pedido);
    decorator.buscar("PED-001");
    decorator.buscar("PED-001");

    Metricas metricas = decorator.getMetricas();

    // Assert
    assertEquals(2, metricas.buscas());
    assertEquals(1, metricas.salvamentos());
    assertTrue(metricas.mediaBuscaMs() >= 0);
    assertTrue(metricas.mediaSalvarMs() >= 0);
}
```

### 6. Testar Retry Decorator

```java
@Test
void retryDecoratorDeveTentarNovamenteAposFalha() {
    // Arrange
    RepositorioPedido baseMock = mock(RepositorioPedido.class);
    Pedido pedido = new Pedido("PED-001", "Cliente A", new BigDecimal("100"), Status.PENDENTE);

    when(baseMock.buscar("PED-001"))
        .thenThrow(new RuntimeException("Falha 1"))
        .thenThrow(new RuntimeException("Falha 2"))
        .thenReturn(pedido); // Sucesso na 3¬™ tentativa

    RepositorioPedido decorator = new RetryDecorator(baseMock, 3, 10L);

    // Act
    Pedido resultado = decorator.buscar("PED-001");

    // Assert
    assertEquals(pedido, resultado);
    verify(baseMock, times(3)).buscar("PED-001");
}
```

### 7. Testar Factory com Configura√ß√µes

```java
@Test
void factoryDeveCriarRepositorioComDecoratorsConfigurados() {
    // Arrange
    ConfiguracaoRepositorio config = new ConfiguracaoRepositorio(
        true,  // valida√ß√£o
        true,  // cache
        false, // m√©tricas
        false, // logging
        false, // retry
        0, 0L
    );

    // Act
    RepositorioPedido repo = RepositorioPedidoFactory.criar(config);

    // Assert - Verifica ordem dos decorators
    assertTrue(repo instanceof CacheDecorator);

    // Valida√ß√£o deve estar no fundo da pilha
    Pedido invalido = new Pedido("INVALIDO", "Cliente", new BigDecimal("100"), Status.PENDENTE);
    assertThrows(IllegalArgumentException.class, () -> repo.salvar(invalido));
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Decorator com l√≥gica de neg√≥cio
class DescontoDecorator extends RepositorioPedidoDecorator {
    public void salvar(Pedido pedido) {
        // L√≥gica de neg√≥cio no decorator ‚ùå
        if (pedido.valor().compareTo(new BigDecimal("1000")) > 0) {
            pedido = new Pedido(pedido.id(), pedido.cliente(),
                pedido.valor().multiply(new BigDecimal("0.9")), pedido.status());
        }
        super.salvar(pedido);
    }
}

// ‚ùå Decorator acoplado
class EmailDecorator extends RepositorioPedidoDecorator {
    private final EmailService emailService = new EmailService(); // ‚ùå

    public void salvar(Pedido pedido) {
        super.salvar(pedido);
        emailService.enviar("pedido.salvo@email.com", "Pedido salvo");
    }
}

// ‚ùå Decorator modificando comportamento
class FakeDecorator extends RepositorioPedidoDecorator {
    public Pedido buscar(String id) {
        // Retorna objeto diferente ‚ùå
        return new Pedido("FAKE", "Fake", BigDecimal.ZERO, Status.PENDENTE);
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Decorator com responsabilidade √∫nica (cross-cutting)
class AuditDecorator extends RepositorioPedidoDecorator {
    private final AuditService auditService;

    AuditDecorator(AuditService auditService, RepositorioPedido wrapped) {
        super(wrapped);
        this.auditService = auditService;
    }

    public void salvar(Pedido pedido) {
        super.salvar(pedido);
        auditService.registrar("SALVAR", pedido.id());
    }
}

// ‚úÖ Decorator preserva comportamento
class TimingDecorator extends RepositorioPedidoDecorator {
    public Pedido buscar(String id) {
        long inicio = System.currentTimeMillis();
        Pedido resultado = super.buscar(id); // Preserva resultado
        long duracao = System.currentTimeMillis() - inicio;
        System.out.println("Dura√ß√£o: " + duracao + "ms");
        return resultado;
    }
}

// ‚úÖ Decorator transparente
class MonitoringDecorator extends RepositorioPedidoDecorator {
    public void salvar(Pedido pedido) {
        try {
            super.salvar(pedido);
            metrics.increment("pedido.salvo.sucesso");
        } catch (Exception e) {
            metrics.increment("pedido.salvo.erro");
            throw e;
        }
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Responsabilidade √∫nica**: Cada decorator uma preocupa√ß√£o (SRP)
- ‚úÖ **Transpar√™ncia**: Decorators preservam comportamento original
- ‚úÖ **Composi√ß√£o**: Permitir combinar decorators livremente
- ‚úÖ **Interface comum**: Decorator e component implementam mesma interface
- ‚úÖ **Ordem importa**: Valida√ß√£o ‚Üí Cache ‚Üí Logging ‚Üí Retry
- ‚úÖ **Stateless prefer√≠vel**: Evitar estado compartilhado entre chamadas
- ‚úÖ **Testes isolados**: Testar cada decorator com mock do component

---

## üîó Integra√ß√£o com Frameworks

### Spring Decorator com AOP

```java
@Aspect
@Component
public class CacheAspect {

    @Around("@annotation(Cacheable)")
    public Object cache(ProceedingJoinPoint pjp) throws Throwable {
        String key = generateKey(pjp);

        Object cached = cache.get(key);
        if (cached != null) {
            return cached;
        }

        Object result = pjp.proceed();
        cache.put(key, result);
        return result;
    }
}
```

### Java I/O Streams (Decorator Cl√°ssico)

```java
InputStream input = new BufferedInputStream(
    new GZIPInputStream(
        new FileInputStream("data.gz")
    )
);
// File ‚Üí GZIP ‚Üí Buffer (3 decorators!)
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                            | ‚ö†Ô∏è Desvantagens                       |
| --------------------------------------- | ------------------------------------- |
| Adiciona comportamento sem heran√ßa      | Muitos objetos pequenos               |
| Combina responsabilidades dinamicamente | Ordem dos decorators importa          |
| Testa funcionalidades isoladamente      | Debug pode ser complexo (stack trace) |
| Segue Open/Closed Principle             | Configura√ß√£o verbosa                  |
| Flex√≠vel em runtime                     | Pode esconder component original      |

---

## üîç Compara√ß√£o

| Padr√£o        | Prop√≥sito                                | Quando Usar                         |
| ------------- | ---------------------------------------- | ----------------------------------- |
| **Decorator** | Adicionar comportamento                  | Cross-cutting concerns (log, cache) |
| **Proxy**     | Controlar acesso                         | Lazy loading, seguran√ßa, remote     |
| **Adapter**   | Converter interface                      | Integrar APIs incompat√≠veis         |
| **Composite** | Tratar objetos/composi√ß√µes uniformemente | Hierarquias √°rvore                  |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Decorator de autoriza√ß√£o** (verificar permiss√µes antes de opera√ß√µes)
2. **Decorator de rate limiting** (limitar chamadas por segundo)
3. **Decorator de circuit breaker** (abrir circuito ap√≥s N falhas)
4. **Decorator de compress√£o** (comprimir dados antes de salvar)
5. **Decorator de criptografia** (criptografar campos sens√≠veis)

---

## üìö Relacionado

- **Proxy**: Controla acesso (lazy load, remote, protection)
- **Adapter**: Converte interface incompat√≠vel
- **Composite**: Composi√ß√£o hier√°rquica (√°rvore)
- **Chain of Responsibility**: Encadeia handlers

---

**Decorator Pattern adiciona comportamento dinamicamente e permite testar funcionalidades isoladamente!** üéÅ‚ú®
