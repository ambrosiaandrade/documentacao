# 04.34 Microservices Architecture [AVAN√áADO] üî∑

## üéØ Objetivo

Decompor aplica√ß√£o em **servi√ßos independentes** que se comunicam via APIs, permitindo **testes isolados por servi√ßo**, deploy independente e escalabilidade granular.

---

## üìö O Que √â?

**Microservices Architecture** organiza aplica√ß√£o em servi√ßos pequenos, aut√¥nomos e especializados, cada um com sua pr√≥pria base de dados, comunicando-se via protocolos leves (REST, gRPC, mensagens).

### Analogia

Como uma **cidade**:

- **Mon√≥lito**: Mega shopping com tudo (roupas, comida, eletr√¥nicos)
- **Microservices**: Lojas especializadas (padaria, farm√°cia, livraria)
- **API Gateway**: Portaria do bairro comercial
- **Service Discovery**: Mapa da cidade
- **Vantagem**: Cada loja opera independentemente, pode reformar sem fechar outras

---

## ‚ùå Problema que Resolve

### Antes (Mon√≥lito)

```java
// ‚ùå PROBLEMA: Tudo em um √∫nico deployment

// M√≥dulo de Pedidos
@RestController
class PedidoController {
    @Autowired
    private PedidoService pedidoService;

    @Autowired
    private ProdutoService produtoService; // Acoplamento ‚ùå

    @Autowired
    private PagamentoService pagamentoService; // Acoplamento ‚ùå

    @PostMapping("/pedidos")
    Pedido criar(@RequestBody PedidoRequest request) {
        // Chama outros m√≥dulos diretamente ‚ùå
        Produto produto = produtoService.buscar(request.produtoId);

        Pedido pedido = pedidoService.criar(request);

        // Falha em um m√≥dulo = falha em tudo ‚ùå
        pagamentoService.processar(pedido);

        return pedido;
    }
}

// Problemas:
// - Um √∫nico JAR/WAR gigante ‚ùå
// - Deploy de tudo mesmo mudando 1 linha ‚ùå
// - Escalar tudo mesmo que apenas pagamentos esteja lento ‚ùå
// - Tecnologias acopladas (todos usam Java) ‚ùå
// - Falha em um m√≥dulo = sistema inteiro cai ‚ùå
// - Equipes dependem umas das outras ‚ùå
// - Testar tudo junto = lento ‚ùå
```

**Problemas**:

- üèóÔ∏è Deploy monol√≠tico (tudo junto)
- ‚öñÔ∏è Escalar tudo ou nada
- üîß Tecnologias acopladas
- üí• Falha em um m√≥dulo afeta tudo
- üë• Equipes interdependentes
- üß™ Testes lentos e complexos

### Depois (Microservices)

```java
// ‚úÖ SOLU√á√ÉO: Servi√ßos independentes

// ==== SERVI√áO 1: PEDIDOS (porta 8081) ====
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service;
    private final ProdutoClient produtoClient; // Cliente HTTP ‚úÖ
    private final PagamentoClient pagamentoClient; // Cliente HTTP ‚úÖ

    @PostMapping
    ResponseEntity<Pedido> criar(@RequestBody PedidoRequest request) {
        // Chama OUTROS SERVI√áOS via HTTP/REST ‚úÖ
        Produto produto = produtoClient.buscar(request.produtoId);

        Pedido pedido = service.criar(request);

        // Async - n√£o bloqueia se pagamento cair ‚úÖ
        CompletableFuture.runAsync(() ->
            pagamentoClient.processar(pedido)
        );

        return ResponseEntity.ok(pedido);
    }
}

// Cliente para comunica√ß√£o entre servi√ßos
@FeignClient(name = "produto-service", url = "http://produto-service:8082")
interface ProdutoClient {
    @GetMapping("/api/produtos/{id}")
    Produto buscar(@PathVariable Long id);
}

// ==== SERVI√áO 2: PRODUTOS (porta 8082) ====
@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    private final ProdutoService service;

    @GetMapping("/{id}")
    Produto buscar(@PathVariable Long id) {
        return service.buscar(id);
    }
}

// ==== SERVI√áO 3: PAGAMENTOS (porta 8083) ====
@RestController
@RequestMapping("/api/pagamentos")
class PagamentoController {

    private final PagamentoService service;

    @PostMapping
    void processar(@RequestBody PagamentoRequest request) {
        service.processar(request);
    }
}

// ‚úÖ Vantagens:
// - Deploy independente de cada servi√ßo ‚úÖ
// - Escalar apenas pagamentos se necess√°rio ‚úÖ
// - Cada servi√ßo pode usar tecnologia diferente ‚úÖ
// - Falha isolada (Circuit Breaker protege) ‚úÖ
// - Equipes aut√¥nomas por servi√ßo ‚úÖ
// - Testes r√°pidos por servi√ßo ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Servi√ßo de Pedidos (Order Service)

```java
// ===== order-service/src/main/java =====

// Entidade
@Entity
@Table(name = "pedidos")
class Pedido {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "cliente_id", nullable = false)
    private Long clienteId;

    @Column(name = "produto_id", nullable = false)
    private Long produtoId;

    @Column(nullable = false)
    private Integer quantidade;

    @Column(name = "valor_total", nullable = false)
    private BigDecimal valorTotal;

    @Enumerated(EnumType.STRING)
    private StatusPedido status;

    // Getters, setters, construtores
}

enum StatusPedido {
    PENDENTE, PROCESSANDO, APROVADO, REJEITADO
}

// Repository
@Repository
interface PedidoRepository extends JpaRepository<Pedido, Long> {
    List<Pedido> findByClienteId(Long clienteId);
    List<Pedido> findByStatus(StatusPedido status);
}

// Service
@Service
class PedidoService {

    private final PedidoRepository repository;
    private final ProdutoClient produtoClient;
    private final PagamentoClient pagamentoClient;
    private final EventPublisher eventPublisher;

    @Autowired
    PedidoService(PedidoRepository repository,
                  ProdutoClient produtoClient,
                  PagamentoClient pagamentoClient,
                  EventPublisher eventPublisher) {
        this.repository = repository;
        this.produtoClient = produtoClient;
        this.pagamentoClient = pagamentoClient;
        this.eventPublisher = eventPublisher;
    }

    @Transactional
    Pedido criarPedido(CriarPedidoRequest request) {
        // Valida produto via outro servi√ßo
        ProdutoDTO produto = produtoClient.buscar(request.produtoId())
            .orElseThrow(() -> new ProdutoNaoEncontradoException(request.produtoId()));

        // Verifica estoque
        if (produto.estoque() < request.quantidade()) {
            throw new EstoqueInsuficienteException(produto.nome());
        }

        // Cria pedido
        Pedido pedido = new Pedido();
        pedido.setClienteId(request.clienteId());
        pedido.setProdutoId(request.produtoId());
        pedido.setQuantidade(request.quantidade());
        pedido.setValorTotal(produto.preco().multiply(BigDecimal.valueOf(request.quantidade())));
        pedido.setStatus(StatusPedido.PENDENTE);

        Pedido salvo = repository.save(pedido);

        // Publica evento (async)
        eventPublisher.publicar(new PedidoCriadoEvent(salvo.getId(), salvo.getProdutoId(), salvo.getQuantidade()));

        // Processa pagamento (async)
        processarPagamentoAsync(salvo);

        return salvo;
    }

    private void processarPagamentoAsync(Pedido pedido) {
        CompletableFuture.runAsync(() -> {
            try {
                PagamentoRequest pagamentoReq = new PagamentoRequest(
                    pedido.getId(),
                    pedido.getClienteId(),
                    pedido.getValorTotal()
                );

                boolean aprovado = pagamentoClient.processar(pagamentoReq);

                pedido.setStatus(aprovado ? StatusPedido.APROVADO : StatusPedido.REJEITADO);
                repository.save(pedido);

                eventPublisher.publicar(new PedidoProcessadoEvent(pedido.getId(), aprovado));

            } catch (Exception e) {
                pedido.setStatus(StatusPedido.REJEITADO);
                repository.save(pedido);
            }
        });
    }

    public Optional<Pedido> buscarPorId(Long id) {
        return repository.findById(id);
    }

    public List<Pedido> listarPorCliente(Long clienteId) {
        return repository.findByClienteId(clienteId);
    }
}

// Controller
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service;

    @Autowired
    PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    ResponseEntity<PedidoResponse> criar(@Valid @RequestBody CriarPedidoRequest request) {
        Pedido pedido = service.criarPedido(request);
        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(PedidoResponse.from(pedido));
    }

    @GetMapping("/{id}")
    ResponseEntity<PedidoResponse> buscar(@PathVariable Long id) {
        return service.buscarPorId(id)
            .map(PedidoResponse::from)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping("/cliente/{clienteId}")
    ResponseEntity<List<PedidoResponse>> listarPorCliente(@PathVariable Long clienteId) {
        List<PedidoResponse> pedidos = service.listarPorCliente(clienteId).stream()
            .map(PedidoResponse::from)
            .toList();
        return ResponseEntity.ok(pedidos);
    }
}

// DTOs
record CriarPedidoRequest(
    @NotNull Long clienteId,
    @NotNull Long produtoId,
    @Min(1) int quantidade
) {}

record PedidoResponse(
    Long id,
    Long clienteId,
    Long produtoId,
    int quantidade,
    BigDecimal valorTotal,
    String status
) {
    static PedidoResponse from(Pedido pedido) {
        return new PedidoResponse(
            pedido.getId(),
            pedido.getClienteId(),
            pedido.getProdutoId(),
            pedido.getQuantidade(),
            pedido.getValorTotal(),
            pedido.getStatus().name()
        );
    }
}

// Clientes Feign para comunica√ß√£o entre servi√ßos
@FeignClient(
    name = "produto-service",
    url = "${services.produto.url}",
    fallback = ProdutoClientFallback.class
)
interface ProdutoClient {
    @GetMapping("/api/produtos/{id}")
    Optional<ProdutoDTO> buscar(@PathVariable Long id);
}

@Component
class ProdutoClientFallback implements ProdutoClient {
    @Override
    public Optional<ProdutoDTO> buscar(Long id) {
        // Fallback em caso de falha
        return Optional.empty();
    }
}

record ProdutoDTO(Long id, String nome, BigDecimal preco, int estoque) {}

@FeignClient(
    name = "pagamento-service",
    url = "${services.pagamento.url}"
)
interface PagamentoClient {
    @PostMapping("/api/pagamentos")
    boolean processar(@RequestBody PagamentoRequest request);
}

record PagamentoRequest(Long pedidoId, Long clienteId, BigDecimal valor) {}

// application.yml
/*
spring:
  application:
    name: order-service
  datasource:
    url: jdbc:postgresql://localhost:5432/order_db

server:
  port: 8081

services:
  produto:
    url: http://localhost:8082
  pagamento:
    url: http://localhost:8083

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
*/
```

### 2. Servi√ßo de Produtos (Product Service)

```java
// ===== product-service/src/main/java =====

@Entity
@Table(name = "produtos")
class Produto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String nome;

    @Column(nullable = false)
    private BigDecimal preco;

    @Column(nullable = false)
    private Integer estoque;

    @Version
    private Long versao; // Controle de concorr√™ncia otimista

    // Getters, setters
}

@Repository
interface ProdutoRepository extends JpaRepository<Produto, Long> {
    List<Produto> findByEstoqueLessThan(int limite);
}

@Service
class ProdutoService {

    private final ProdutoRepository repository;

    @Autowired
    ProdutoService(ProdutoRepository repository) {
        this.repository = repository;
    }

    public Optional<Produto> buscarPorId(Long id) {
        return repository.findById(id);
    }

    public List<Produto> listarTodos() {
        return repository.findAll();
    }

    @Transactional
    public void reservarEstoque(Long produtoId, int quantidade) {
        Produto produto = repository.findById(produtoId)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(produtoId));

        if (produto.getEstoque() < quantidade) {
            throw new EstoqueInsuficienteException(produto.getNome());
        }

        produto.setEstoque(produto.getEstoque() - quantidade);
        repository.save(produto);
    }

    @Transactional
    public void liberarEstoque(Long produtoId, int quantidade) {
        Produto produto = repository.findById(produtoId)
            .orElseThrow(() -> new ProdutoNaoEncontradoException(produtoId));

        produto.setEstoque(produto.getEstoque() + quantidade);
        repository.save(produto);
    }
}

@RestController
@RequestMapping("/api/produtos")
class ProdutoController {

    private final ProdutoService service;

    @Autowired
    ProdutoController(ProdutoService service) {
        this.service = service;
    }

    @GetMapping("/{id}")
    ResponseEntity<ProdutoDTO> buscar(@PathVariable Long id) {
        return service.buscarPorId(id)
            .map(p -> new ProdutoDTO(p.getId(), p.getNome(), p.getPreco(), p.getEstoque()))
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @GetMapping
    ResponseEntity<List<ProdutoDTO>> listar() {
        List<ProdutoDTO> produtos = service.listarTodos().stream()
            .map(p -> new ProdutoDTO(p.getId(), p.getNome(), p.getPreco(), p.getEstoque()))
            .toList();
        return ResponseEntity.ok(produtos);
    }

    @PostMapping("/{id}/reservar")
    ResponseEntity<Void> reservar(@PathVariable Long id, @RequestParam int quantidade) {
        service.reservarEstoque(id, quantidade);
        return ResponseEntity.ok().build();
    }
}

// application.yml
/*
spring:
  application:
    name: product-service
  datasource:
    url: jdbc:postgresql://localhost:5432/product_db

server:
  port: 8082
*/
```

### 3. Servi√ßo de Pagamentos (Payment Service)

```java
// ===== payment-service/src/main/java =====

@Entity
@Table(name = "pagamentos")
class Pagamento {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "pedido_id", nullable = false)
    private Long pedidoId;

    @Column(name = "cliente_id", nullable = false)
    private Long clienteId;

    @Column(nullable = false)
    private BigDecimal valor;

    @Enumerated(EnumType.STRING)
    private StatusPagamento status;

    @Column(name = "transacao_id")
    private String transacaoId;

    @Column(name = "processado_em")
    private LocalDateTime processadoEm;

    // Getters, setters
}

enum StatusPagamento {
    PENDENTE, APROVADO, RECUSADO
}

@Repository
interface PagamentoRepository extends JpaRepository<Pagamento, Long> {
    Optional<Pagamento> findByPedidoId(Long pedidoId);
}

@Service
class PagamentoService {

    private final PagamentoRepository repository;
    private final GatewayPagamentoExterno gateway;

    @Autowired
    PagamentoService(PagamentoRepository repository, GatewayPagamentoExterno gateway) {
        this.repository = repository;
        this.gateway = gateway;
    }

    @Transactional
    public boolean processar(PagamentoRequest request) {
        Pagamento pagamento = new Pagamento();
        pagamento.setPedidoId(request.pedidoId());
        pagamento.setClienteId(request.clienteId());
        pagamento.setValor(request.valor());
        pagamento.setStatus(StatusPagamento.PENDENTE);

        // Chama gateway externo
        boolean aprovado = gateway.processar(request);

        pagamento.setStatus(aprovado ? StatusPagamento.APROVADO : StatusPagamento.RECUSADO);
        pagamento.setTransacaoId(UUID.randomUUID().toString());
        pagamento.setProcessadoEm(LocalDateTime.now());

        repository.save(pagamento);

        return aprovado;
    }
}

@Component
class GatewayPagamentoExterno {

    boolean processar(PagamentoRequest request) {
        // Simula chamada a gateway real (Stripe, PayPal, etc)
        // Em produ√ß√£o, faria chamada HTTP real
        return request.valor().compareTo(BigDecimal.valueOf(10000)) < 0; // Aprova se < R$ 10k
    }
}

@RestController
@RequestMapping("/api/pagamentos")
class PagamentoController {

    private final PagamentoService service;

    @Autowired
    PagamentoController(PagamentoService service) {
        this.service = service;
    }

    @PostMapping
    ResponseEntity<Boolean> processar(@RequestBody PagamentoRequest request) {
        boolean aprovado = service.processar(request);
        return ResponseEntity.ok(aprovado);
    }
}

// application.yml
/*
spring:
  application:
    name: payment-service
  datasource:
    url: jdbc:postgresql://localhost:5432/payment_db

server:
  port: 8083
*/
```

### 4. API Gateway (Ponto de Entrada √önico)

```java
// ===== api-gateway/src/main/java =====

@SpringBootApplication
@EnableZuulProxy // Ou Spring Cloud Gateway
class ApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}

// Filtro de autentica√ß√£o
@Component
class AuthenticationFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return "pre"; // Antes da requisi√ß√£o
    }

    @Override
    public int filterOrder() {
        return 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        String token = request.getHeader("Authorization");

        if (token == null || !validarToken(token)) {
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
            ctx.setResponseBody("{\"erro\": \"Token inv√°lido\"}");
        }

        return null;
    }

    private boolean validarToken(String token) {
        // Valida JWT, OAuth, etc
        return token != null && token.startsWith("Bearer ");
    }
}

// Filtro de logging
@Component
class LoggingFilter extends ZuulFilter {

    @Override
    public String filterType() {
        return "post"; // Depois da requisi√ß√£o
    }

    @Override
    public int filterOrder() {
        return 1;
    }

    @Override
    public boolean shouldFilter() {
        return true;
    }

    @Override
    public Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        System.out.println(String.format("üìä %s request to %s - Status: %d",
            request.getMethod(),
            request.getRequestURL(),
            ctx.getResponseStatusCode()
        ));

        return null;
    }
}

// application.yml
/*
spring:
  application:
    name: api-gateway

server:
  port: 8080

zuul:
  routes:
    order-service:
      path: /orders/**
      service-id: order-service
      strip-prefix: false

    product-service:
      path: /products/**
      service-id: product-service
      strip-prefix: false

    payment-service:
      path: /payments/**
      service-id: payment-service
      strip-prefix: false

  # Circuit Breaker
  ribbon:
    ConnectTimeout: 3000
    ReadTimeout: 10000

  # Retry
  retryable: true

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
*/
```

### 5. Service Discovery (Eureka)

```java
// ===== service-discovery/src/main/java =====

@SpringBootApplication
@EnableEurekaServer
class ServiceDiscoveryApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceDiscoveryApplication.class, args);
    }
}

// application.yml
/*
spring:
  application:
    name: service-discovery

server:
  port: 8761

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false
  server:
    enable-self-preservation: false
*/
```

### 6. Eventos e Mensageria (RabbitMQ/Kafka)

```java
// Event Publisher
@Component
class EventPublisher {

    private final RabbitTemplate rabbitTemplate;

    @Autowired
    EventPublisher(RabbitTemplate rabbitTemplate) {
        this.rabbitTemplate = rabbitTemplate;
    }

    void publicar(DomainEvent event) {
        String exchange = event.getClass().getSimpleName() + ".exchange";
        rabbitTemplate.convertAndSend(exchange, "", event);
        System.out.println("üì§ Evento publicado: " + event);
    }
}

// Domain Events
interface DomainEvent {}

record PedidoCriadoEvent(Long pedidoId, Long produtoId, int quantidade) implements DomainEvent {}
record PedidoProcessadoEvent(Long pedidoId, boolean aprovado) implements DomainEvent {}

// Event Listener (em Product Service)
@Component
class PedidoEventListener {

    private final ProdutoService produtoService;

    @Autowired
    PedidoEventListener(ProdutoService produtoService) {
        this.produtoService = produtoService;
    }

    @RabbitListener(queues = "pedido.criado.queue")
    void onPedidoCriado(PedidoCriadoEvent event) {
        System.out.println("üì• Evento recebido: PedidoCriado - " + event.pedidoId());

        // Reserva estoque
        produtoService.reservarEstoque(event.produtoId(), event.quantidade());
    }

    @RabbitListener(queues = "pedido.processado.queue")
    void onPedidoProcessado(PedidoProcessadoEvent event) {
        if (!event.aprovado()) {
            // Se rejeitado, libera estoque
            System.out.println("üì• Pedido rejeitado - liberando estoque");
            // produtoService.liberarEstoque(...);
        }
    }
}
```

---

## üß™ Como Testar

### 1. Testar Servi√ßo Isoladamente

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
class PedidoServiceTest {

    @Autowired
    private PedidoService service;

    @MockBean
    private ProdutoClient produtoClient;

    @MockBean
    private PagamentoClient pagamentoClient;

    @Test
    void deveCriarPedidoComSucesso() {
        // Arrange - mock de servi√ßos externos
        when(produtoClient.buscar(1L)).thenReturn(
            Optional.of(new ProdutoDTO(1L, "Notebook", BigDecimal.valueOf(3000), 10))
        );

        when(pagamentoClient.processar(any())).thenReturn(true);

        CriarPedidoRequest request = new CriarPedidoRequest(1L, 1L, 2);

        // Act
        Pedido pedido = service.criarPedido(request);

        // Assert
        assertNotNull(pedido.getId());
        assertEquals(StatusPedido.PENDENTE, pedido.getStatus());
    }
}
```

### 2. Testar Comunica√ß√£o entre Servi√ßos (Contract Testing)

```java
@SpringBootTest
@AutoConfigureMockMvc
class ProdutoClientContractTest {

    @Autowired
    private ProdutoClient client;

    @Autowired
    private MockMvc mockMvc;

    @Test
    void clienteDeveComunicarComProdutoService() {
        // Simula resposta do produto-service
        mockMvc.perform(get("/api/produtos/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.nome").exists());
    }
}
```

### 3. Testar API Gateway

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ApiGatewayTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void gatewayDeveRotearParaPedidoService() {
        // Requisi√ß√£o via gateway
        ResponseEntity<String> response = restTemplate.getForEntity(
            "/orders/api/pedidos/1",
            String.class
        );

        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    @Test
    void gatewayDeveBloquearRequisicoesSemToken() {
        HttpHeaders headers = new HttpHeaders();
        // Sem token

        ResponseEntity<String> response = restTemplate.exchange(
            "/orders/api/pedidos",
            HttpMethod.POST,
            new HttpEntity<>(null, headers),
            String.class
        );

        assertEquals(HttpStatus.UNAUTHORIZED, response.getStatusCode());
    }
}
```

### 4. Teste de Integra√ß√£o (End-to-End)

```java
@SpringBootTest
class MicroservicesE2ETest {

    @Test
    void deveProcessarPedidoCompleto() {
        // 1. Cria pedido
        // 2. Verifica estoque reservado
        // 3. Verifica pagamento processado
        // 4. Verifica status final

        // Requer todos os servi√ßos rodando (docker-compose)
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Transa√ß√µes distribu√≠das (2PC)
@Transactional // ‚ùå N√£o funciona entre servi√ßos
void criarPedido() {
    pedidoRepo.save(...);
    produtoService.reservar(...); // Outro servi√ßo ‚ùå
}

// ‚ùå Chamadas s√≠ncronas em cadeia (alta lat√™ncia)
A ‚Üí B ‚Üí C ‚Üí D // ‚ùå Lat√™ncia acumulada

// ‚ùå Servi√ßos compartilhando banco
service-a ‚Üí shared_db ‚Üê service-b // ‚ùå
```

### ‚úÖ Fazer

```java
// ‚úÖ Saga pattern para transa√ß√µes
void criarPedido() {
    pedido.salvar();
    eventBus.publish(PedidoCriadoEvent); // ‚úÖ Async
}

// ‚úÖ Circuit Breaker para falhas
@HystrixCommand(fallbackMethod = "fallback")
Produto buscar() { ... }

// ‚úÖ Banco por servi√ßo
service-a ‚Üí db_a
service-b ‚Üí db_b
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Database per Service**: Cada servi√ßo tem seu BD
- ‚úÖ **API Gateway**: Ponto √∫nico de entrada
- ‚úÖ **Service Discovery**: Registro din√¢mico
- ‚úÖ **Circuit Breaker**: Prote√ß√£o contra falhas
- ‚úÖ **Async Communication**: Eventos para opera√ß√µes longas
- ‚úÖ **Saga Pattern**: Transa√ß√µes distribu√≠das
- ‚úÖ **Containeriza√ß√£o**: Docker para deploy

---

## üîó Ferramentas

| Ferramenta                      | Prop√≥sito                    |
| ------------------------------- | ---------------------------- |
| **Spring Cloud**                | Framework para microservices |
| **Eureka / Consul**             | Service Discovery            |
| **Zuul / Spring Cloud Gateway** | API Gateway                  |
| **Hystrix / Resilience4j**      | Circuit Breaker              |
| **RabbitMQ / Kafka**            | Mensageria                   |
| **Docker / Kubernetes**         | Containeriza√ß√£o              |
| **Prometheus / Grafana**        | Monitoramento                |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens            | ‚ö†Ô∏è Desvantagens                   |
| ----------------------- | --------------------------------- |
| Deploy independente     | Complexidade operacional          |
| Escalabilidade granular | Transa√ß√µes distribu√≠das complexas |
| Tecnologias variadas    | Overhead de comunica√ß√£o           |
| Falhas isoladas         | Debugging dif√≠cil                 |
| Times aut√¥nomos         | Consist√™ncia eventual             |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use Microservices quando:

- Sistema grande e complexo
- M√∫ltiplos times trabalhando
- Necessidade de escalar partes espec√≠ficas
- Deploy frequente de partes isoladas

### ‚ùå Evite Microservices quando:

- Aplica√ß√£o pequena/simples
- Time pequeno
- Requisitos de consist√™ncia forte
- Custo operacional alto demais

---

## üß† Exerc√≠cios Pr√°ticos

1. **Adicionar novo servi√ßo** (Notification Service)
2. **Implementar Saga** (compensa√ß√£o de transa√ß√µes)
3. **Adicionar cache distribu√≠do** (Redis)
4. **Implementar CQRS** (read/write separados)
5. **Adicionar tracing distribu√≠do** (Zipkin, Jaeger)

---

## üìö Relacionado

- **Event-Driven Architecture**: Comunica√ß√£o via eventos
- **CQRS**: Separar leitura/escrita
- **Saga Pattern**: Transa√ß√µes distribu√≠das
- **API Gateway Pattern**: Ponto de entrada √∫nico

---

**Microservices Architecture permite deploy independente e escalabilidade granular, com testes isolados por servi√ßo!** üî∑‚ú®
