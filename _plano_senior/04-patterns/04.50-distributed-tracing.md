# 04.50 Distributed Tracing [EXPERT] üîç

## üéØ Objetivo

Rastrear requisi√ß√µes atrav√©s de **m√∫ltiplos servi√ßos** distribu√≠dos usando **trace IDs** e **span IDs** hier√°rquicos, permitindo visualizar a jornada completa de uma opera√ß√£o, diagnosticar lat√™ncias e identificar gargalos em sistemas de microsservi√ßos.

---

## üìö O Que √â?

**Distributed Tracing** √© um padr√£o de observabilidade que correlaciona opera√ß√µes distribu√≠das usando identificadores √∫nicos (trace ID) e segmentos hier√°rquicos (spans), permitindo visualizar a cadeia completa de chamadas entre servi√ßos.

### Analogia

Como **rastrear uma encomenda** üì¶:

```
Pedido #12345 (Trace ID)
‚îú‚îÄ Separa√ß√£o no CD (Span 1)
‚îÇ  ‚îî‚îÄ Dura√ß√£o: 10min
‚îú‚îÄ Transporte (Span 2)
‚îÇ  ‚îú‚îÄ Rota A (Sub-span 2.1) - 2h
‚îÇ  ‚îî‚îÄ Rota B (Sub-span 2.2) - 3h
‚îî‚îÄ Entrega (Span 3)
   ‚îî‚îÄ Dura√ß√£o: 15min

Total: 5h 25min
```

Cada etapa registra:

- ‚úÖ Quando come√ßou/terminou
- ‚úÖ Quem √© o "pai" (parent span)
- ‚úÖ Qual o pedido geral (trace ID √∫nico)

---

## ‚ùå Problema que Resolve

### Antes (Logs Descorrelacionados)

```java
// ‚ùå PROBLEMA: Logs isolados por servi√ßo

// Servi√ßo A
logger.info("Processando pedido"); // Qual pedido?

// Servi√ßo B (chamado por A)
logger.info("Validando pagamento"); // De qual pedido?

// Servi√ßo C (chamado por B)
logger.error("Erro ao processar cart√£o"); // Imposs√≠vel correlacionar!

// Como descobrir que esses 3 logs s√£o da mesma requisi√ß√£o?
// - Buscar por timestamp? (impreciso)
// - Buscar por IP? (n√£o funciona com load balancer)
// - Buscar por usu√°rio? (pode ter v√°rias requisi√ß√µes simult√¢neas)
```

**Problemas**:

- üîç Imposs√≠vel correlacionar logs entre servi√ßos
- ‚è±Ô∏è Dif√≠cil identificar onde est√° a lat√™ncia
- üêõ Debugging de erros distribu√≠dos √© manual e demorado
- üìä Sem vis√£o da jornada completa do usu√°rio

### Depois (Distributed Tracing)

```java
// ‚úÖ SOLU√á√ÉO: Trace ID propagado automaticamente

// Servi√ßo A
tracer.startSpan("processar-pedido", traceId="abc123");
logger.info("Processando pedido", traceId="abc123", spanId="span1");
servicoB.validarPagamento(); // Propaga traceId automaticamente

// Servi√ßo B
tracer.startSpan("validar-pagamento", traceId="abc123", parentSpanId="span1");
logger.info("Validando pagamento", traceId="abc123", spanId="span2");
servicoC.processarCartao(); // Propaga traceId

// Servi√ßo C
tracer.startSpan("processar-cartao", traceId="abc123", parentSpanId="span2");
logger.error("Erro ao processar cart√£o", traceId="abc123", spanId="span3");

// Agora basta buscar por traceId="abc123" para ver TODA a jornada!
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Dom√≠nio

```java
// Contexto de rastreamento
record TraceContext(
    String traceId,      // ID √∫nico da requisi√ß√£o inteira
    String spanId,       // ID do segmento atual
    String parentSpanId  // ID do segmento pai (null se root)
) {
    static TraceContext root() {
        String traceId = UUID.randomUUID().toString();
        return new TraceContext(traceId, generateSpanId(), null);
    }

    TraceContext createChild() {
        return new TraceContext(
            traceId,                    // Mesmo trace
            generateSpanId(),           // Novo span
            spanId                      // Este span √© o pai
        );
    }

    private static String generateSpanId() {
        return UUID.randomUUID().toString().substring(0, 8);
    }
}

// Span (segmento) de rastreamento
record Span(
    String spanId,
    String name,
    String traceId,
    String parentSpanId,
    long startTimeMs,
    long endTimeMs,
    Map<String, String> tags,
    SpanKind kind
) {
    long durationMs() {
        return endTimeMs - startTimeMs;
    }

    enum SpanKind {
        SERVER,    // Processamento de requisi√ß√£o recebida
        CLIENT,    // Chamada para outro servi√ßo
        INTERNAL   // Opera√ß√£o interna
    }
}

// Resultado de span
sealed interface SpanResult
    permits SpanSuccess, SpanError {}

record SpanSuccess(Span span) implements SpanResult {}
record SpanError(Span span, Exception error) implements SpanResult {}
```

### 2. Tracer Simples com ThreadLocal

```java
final class SimpleTracer {
    private static final ThreadLocal<TraceContext> CONTEXT = new ThreadLocal<>();
    private final List<Span> spans = new CopyOnWriteArrayList<>();

    // Iniciar trace (root)
    public TraceContext startTrace(String operationName) {
        TraceContext context = TraceContext.root();
        CONTEXT.set(context);
        return context;
    }

    // Iniciar span filho
    public TraceContext startSpan(String name, Span.SpanKind kind) {
        TraceContext current = CONTEXT.get();
        if (current == null) {
            // Se n√£o h√° contexto, criar root
            return startTrace(name);
        }

        TraceContext childContext = current.createChild();
        CONTEXT.set(childContext);

        return childContext;
    }

    // Finalizar span
    public SpanResult finishSpan(String name, long startTimeMs, Map<String, String> tags) {
        TraceContext context = CONTEXT.get();
        if (context == null) {
            throw new IllegalStateException("Nenhum span ativo");
        }

        long endTimeMs = System.currentTimeMillis();

        Span span = new Span(
            context.spanId(),
            name,
            context.traceId(),
            context.parentSpanId(),
            startTimeMs,
            endTimeMs,
            tags,
            Span.SpanKind.INTERNAL
        );

        spans.add(span);

        // Restaurar contexto pai
        if (context.parentSpanId() != null) {
            // Em implementa√ß√£o real, restauraria o contexto pai
            // Aqui simplificamos
        }

        return new SpanSuccess(span);
    }

    // Obter contexto atual
    public TraceContext currentContext() {
        return CONTEXT.get();
    }

    // Limpar contexto (importante para thread pools!)
    public void clear() {
        CONTEXT.remove();
    }

    // Obter todos os spans
    public List<Span> getAllSpans() {
        return List.copyOf(spans);
    }

    // Obter spans de um trace espec√≠fico
    public List<Span> getSpansByTraceId(String traceId) {
        return spans.stream()
            .filter(s -> s.traceId().equals(traceId))
            .sorted(Comparator.comparingLong(Span::startTimeMs))
            .toList();
    }

    // Limpar spans (para testes)
    public void clearSpans() {
        spans.clear();
    }
}
```

### 3. API Fluente para Usar Tracer

```java
final class TracedOperation<T> {
    private final SimpleTracer tracer;
    private final String operationName;
    private final Supplier<T> operation;
    private final Map<String, String> tags = new HashMap<>();
    private long startTime;

    TracedOperation(SimpleTracer tracer, String operationName, Supplier<T> operation) {
        this.tracer = tracer;
        this.operationName = operationName;
        this.operation = operation;
    }

    public TracedOperation<T> withTag(String key, String value) {
        tags.put(key, value);
        return this;
    }

    public T execute() {
        startTime = System.currentTimeMillis();
        tracer.startSpan(operationName, Span.SpanKind.INTERNAL);

        try {
            T result = operation.get();
            tags.put("status", "success");
            tracer.finishSpan(operationName, startTime, tags);
            return result;

        } catch (Exception e) {
            tags.put("status", "error");
            tags.put("error.message", e.getMessage());
            tracer.finishSpan(operationName, startTime, tags);
            throw e;
        }
    }
}

// Helper para criar opera√ß√µes rastreadas
final class Traced {
    private final SimpleTracer tracer;

    Traced(SimpleTracer tracer) {
        this.tracer = tracer;
    }

    public <T> TracedOperation<T> operation(String name, Supplier<T> op) {
        return new TracedOperation<>(tracer, name, op);
    }

    public void run(String name, Runnable op) {
        operation(name, () -> {
            op.run();
            return null;
        }).execute();
    }
}
```

### 4. Exemplo de Uso Completo

```java
final class PedidoService {
    private final SimpleTracer tracer;
    private final EstoqueService estoqueService;
    private final PagamentoService pagamentoService;

    PedidoService(SimpleTracer tracer, EstoqueService estoque, PagamentoService pagamento) {
        this.tracer = tracer;
        this.estoqueService = estoque;
        this.pagamentoService = pagamento;
    }

    public ResultadoPedido processar(String pedidoId, String sku, int quantidade) {
        // Iniciar trace raiz
        tracer.startTrace("processar-pedido");

        try {
            // Span 1: Verificar estoque
            Boolean estoqueOk = new TracedOperation<>(
                tracer,
                "verificar-estoque",
                () -> estoqueService.verificar(sku, quantidade)
            )
            .withTag("pedido.id", pedidoId)
            .withTag("produto.sku", sku)
            .execute();

            if (!estoqueOk) {
                return new ResultadoPedido(false, "Estoque insuficiente");
            }

            // Span 2: Processar pagamento
            String transacaoId = new TracedOperation<>(
                tracer,
                "processar-pagamento",
                () -> pagamentoService.processar(pedidoId)
            )
            .withTag("pedido.id", pedidoId)
            .execute();

            return new ResultadoPedido(true, "Pedido processado: " + transacaoId);

        } finally {
            tracer.clear(); // Limpar ThreadLocal
        }
    }
}

record ResultadoPedido(boolean sucesso, String mensagem) {}
```

### 5. Propaga√ß√£o via HTTP Headers

```java
// Constantes para headers
interface TraceHeaders {
    String TRACE_ID = "X-Trace-Id";
    String SPAN_ID = "X-Span-Id";
    String PARENT_SPAN_ID = "X-Parent-Span-Id";
}

// Extrator de contexto de headers
final class TraceContextExtractor {

    public static TraceContext extract(Map<String, String> headers) {
        String traceId = headers.get(TraceHeaders.TRACE_ID);
        String spanId = headers.get(TraceHeaders.SPAN_ID);
        String parentSpanId = headers.get(TraceHeaders.PARENT_SPAN_ID);

        if (traceId == null) {
            // N√£o h√° trace, criar novo
            return TraceContext.root();
        }

        return new TraceContext(traceId, spanId, parentSpanId);
    }

    public static Map<String, String> inject(TraceContext context) {
        Map<String, String> headers = new HashMap<>();
        headers.put(TraceHeaders.TRACE_ID, context.traceId());
        headers.put(TraceHeaders.SPAN_ID, context.spanId());

        if (context.parentSpanId() != null) {
            headers.put(TraceHeaders.PARENT_SPAN_ID, context.parentSpanId());
        }

        return headers;
    }
}

// Cliente HTTP que propaga contexto
final class TracedHttpClient {
    private final SimpleTracer tracer;

    TracedHttpClient(SimpleTracer tracer) {
        this.tracer = tracer;
    }

    public String get(String url) {
        TraceContext context = tracer.currentContext();
        if (context == null) {
            context = tracer.startTrace("http-get");
        }

        // Criar span filho para a chamada HTTP
        TraceContext childContext = context.createChild();

        // Injetar headers
        Map<String, String> headers = TraceContextExtractor.inject(childContext);

        // Simular chamada HTTP
        System.out.println("GET " + url);
        headers.forEach((k, v) -> System.out.println("  " + k + ": " + v));

        return "Response from " + url;
    }
}
```

---

## üß™ Como Testar

### 1. Teste B√°sico de Cria√ß√£o de Trace

```java
import org.junit.jupiter.api.*;
import static org.assertj.core.api.Assertions.*;

class DistributedTracingTest {

    private SimpleTracer tracer;

    @BeforeEach
    void setup() {
        tracer = new SimpleTracer();
        tracer.clearSpans();
    }

    @AfterEach
    void cleanup() {
        tracer.clear();
    }

    @Test
    void deveCriarTraceComUnicoTraceId() {
        // Act
        TraceContext ctx1 = tracer.startTrace("operacao-1");
        TraceContext ctx2 = tracer.startTrace("operacao-2");

        // Assert
        assertThat(ctx1.traceId()).isNotEmpty();
        assertThat(ctx2.traceId()).isNotEmpty();
        assertThat(ctx1.traceId()).isNotEqualTo(ctx2.traceId());
    }

    @Test
    void rootSpanNaoDeveTerPai() {
        // Act
        TraceContext root = tracer.startTrace("root-operation");

        // Assert
        assertThat(root.parentSpanId()).isNull();
    }
}
```

### 2. Teste de Hierarquia de Spans

```java
@Test
void deveManterHierarquiaDeSpans() {
    // Arrange & Act
    tracer.startTrace("operacao-pai");
    long start1 = System.currentTimeMillis();

    tracer.startSpan("operacao-filho-1", Span.SpanKind.INTERNAL);
    long start2 = System.currentTimeMillis();
    tracer.finishSpan("operacao-filho-1", start2, Map.of());

    tracer.startSpan("operacao-filho-2", Span.SpanKind.INTERNAL);
    long start3 = System.currentTimeMillis();
    tracer.finishSpan("operacao-filho-2", start3, Map.of());

    tracer.finishSpan("operacao-pai", start1, Map.of());

    // Assert
    List<Span> spans = tracer.getAllSpans();
    assertThat(spans).hasSize(3);

    Span pai = spans.stream()
        .filter(s -> s.name().equals("operacao-pai"))
        .findFirst()
        .orElseThrow();

    List<Span> filhos = spans.stream()
        .filter(s -> pai.spanId().equals(s.parentSpanId()))
        .toList();

    assertThat(filhos).hasSize(2);
}
```

### 3. Teste de Propaga√ß√£o de Trace ID

```java
@Test
void devePropagar TraceIdEntreSpans() {
    // Arrange
    TraceContext root = tracer.startTrace("root");

    // Act
    TraceContext child1 = tracer.startSpan("child-1", Span.SpanKind.INTERNAL);
    TraceContext child2 = tracer.startSpan("child-2", Span.SpanKind.INTERNAL);

    // Assert - Todos compartilham o mesmo trace ID
    assertThat(child1.traceId()).isEqualTo(root.traceId());
    assertThat(child2.traceId()).isEqualTo(root.traceId());

    // Mas t√™m span IDs diferentes
    assertThat(child1.spanId()).isNotEqualTo(root.spanId());
    assertThat(child2.spanId()).isNotEqualTo(child1.spanId());
}
```

### 4. Teste de Tags em Spans

```java
@Test
void deveAdicionarTagsAoSpan() {
    // Arrange
    tracer.startTrace("operacao-com-tags");
    long start = System.currentTimeMillis();

    Map<String, String> tags = Map.of(
        "usuario.id", "user123",
        "operacao.tipo", "leitura",
        "cache.hit", "true"
    );

    // Act
    SpanResult result = tracer.finishSpan("operacao-com-tags", start, tags);

    // Assert
    assertThat(result).isInstanceOf(SpanSuccess.class);
    Span span = ((SpanSuccess) result).span();

    assertThat(span.tags())
        .containsEntry("usuario.id", "user123")
        .containsEntry("cache.hit", "true");
}
```

### 5. Teste de M√∫ltiplas Opera√ß√µes

```java
@Test
void deveRastrearMultiplasOperacoes() {
    // Arrange
    var traced = new Traced(tracer);
    tracer.startTrace("processar-pedido");

    // Act
    traced.run("validar-estoque", () -> {
        // Simula valida√ß√£o
    });

    traced.run("processar-pagamento", () -> {
        // Simula pagamento
    });

    traced.run("confirmar-pedido", () -> {
        // Simula confirma√ß√£o
    });

    // Assert
    List<Span> spans = tracer.getAllSpans();
    assertThat(spans).hasSize(3);

    assertThat(spans)
        .extracting(Span::name)
        .containsExactly(
            "validar-estoque",
            "processar-pagamento",
            "confirmar-pedido"
        );
}
```

### 6. Teste de Dura√ß√£o de Spans

```java
@Test
void deveCalcularDuracaoDoSpan() throws Exception {
    // Arrange
    tracer.startTrace("operacao-lenta");
    long start = System.currentTimeMillis();

    // Simular opera√ß√£o que demora
    Thread.sleep(100);

    // Act
    SpanResult result = tracer.finishSpan("operacao-lenta", start, Map.of());

    // Assert
    Span span = ((SpanSuccess) result).span();
    assertThat(span.durationMs()).isGreaterThanOrEqualTo(100);
}
```

### 7. Teste de Propaga√ß√£o via Headers HTTP

```java
@Test
void devePropagar ContextoViaHeaders() {
    // Arrange
    TraceContext original = new TraceContext(
        "trace-123",
        "span-456",
        "parent-789"
    );

    // Act - Injetar em headers
    Map<String, String> headers = TraceContextExtractor.inject(original);

    // Simular transmiss√£o HTTP...

    // Act - Extrair de headers
    TraceContext extraido = TraceContextExtractor.extract(headers);

    // Assert
    assertThat(extraido.traceId()).isEqualTo(original.traceId());
    assertThat(extraido.spanId()).isEqualTo(original.spanId());
    assertThat(extraido.parentSpanId()).isEqualTo(original.parentSpanId());
}
```

### 8. Teste de Isolamento entre Threads

```java
@Test
void deveIsolarf ContextoEntre Threads() throws Exception {
    // Arrange
    CountDownLatch latch = new CountDownLatch(2);
    List<String> traceIds = new CopyOnWriteArrayList<>();

    // Act - Duas threads executando traces diferentes
    Thread t1 = new Thread(() -> {
        TraceContext ctx = tracer.startTrace("thread-1");
        traceIds.add(ctx.traceId());
        tracer.clear();
        latch.countDown();
    });

    Thread t2 = new Thread(() -> {
        TraceContext ctx = tracer.startTrace("thread-2");
        traceIds.add(ctx.traceId());
        tracer.clear();
        latch.countDown();
    });

    t1.start();
    t2.start();
    latch.await();

    // Assert - Trace IDs devem ser diferentes (isolados)
    assertThat(traceIds).hasSize(2);
    assertThat(traceIds.get(0)).isNotEqualTo(traceIds.get(1));
}
```

### 9. Teste de Limpeza de ThreadLocal

```java
@Test
void deveLimparThreadLocalAp√≥sUso() {
    // Arrange
    tracer.startTrace("operacao");

    // Assert - Contexto existe
    assertThat(tracer.currentContext()).isNotNull();

    // Act - Limpar
    tracer.clear();

    // Assert - Contexto foi removido
    assertThat(tracer.currentContext()).isNull();
}
```

### 10. Teste de Recupera√ß√£o de Spans por Trace ID

```java
@Test
void deveRecuperarSpansPorTraceId() {
    // Arrange
    String traceId1 = tracer.startTrace("trace-1").traceId();
    tracer.finishSpan("trace-1", System.currentTimeMillis(), Map.of());
    tracer.clear();

    String traceId2 = tracer.startTrace("trace-2").traceId();
    tracer.finishSpan("trace-2", System.currentTimeMillis(), Map.of());
    tracer.clear();

    // Act
    List<Span> spansTrace1 = tracer.getSpansByTraceId(traceId1);
    List<Span> spansTrace2 = tracer.getSpansByTraceId(traceId2);

    // Assert
    assertThat(spansTrace1).hasSize(1);
    assertThat(spansTrace2).hasSize(1);
    assertThat(spansTrace1.get(0).traceId()).isEqualTo(traceId1);
    assertThat(spansTrace2.get(0).traceId()).isEqualTo(traceId2);
}
```

### 11. Teste de Tratamento de Erro

```java
@Test
void deveRegistrarSpanComErro() {
    // Arrange
    var traced = new Traced(tracer);
    tracer.startTrace("operacao-com-erro");

    // Act & Assert
    assertThatThrownBy(() -> {
        traced.operation("operacao-falha", () -> {
            throw new RuntimeException("Erro simulado");
        }).execute();
    }).isInstanceOf(RuntimeException.class);

    // Assert - Span foi registrado mesmo com erro
    List<Span> spans = tracer.getAllSpans();
    assertThat(spans).hasSize(1);

    Span span = spans.get(0);
    assertThat(span.tags())
        .containsEntry("status", "error")
        .containsEntry("error.message", "Erro simulado");
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå N√£o limpar ThreadLocal (vazamento de mem√≥ria em thread pools)
tracer.startTrace("op");
// Esqueceu de chamar tracer.clear()

// ‚ùå Gerar span IDs previs√≠veis (seguran√ßa)
String spanId = String.valueOf(counter++); // Previs√≠vel!

// ‚ùå Spans muito granulares (overhead)
tracer.startSpan("somar-dois-numeros"); // Muito fino!

// ‚ùå N√£o propagar contexto entre threads
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> {
    // Contexto foi perdido! ThreadLocal n√£o propagou
});
```

### ‚úÖ Fazer

```java
// ‚úÖ Sempre limpar em finally
try {
    tracer.startTrace("op");
    // opera√ß√£o
} finally {
    tracer.clear();
}

// ‚úÖ Gerar IDs aleat√≥rios/√∫nicos
String spanId = UUID.randomUUID().toString();

// ‚úÖ Spans em opera√ß√µes significativas
tracer.startSpan("processar-pedido");     // ‚úÖ Bom
tracer.startSpan("consultar-banco");      // ‚úÖ Bom
tracer.startSpan("chamar-api-externa");   // ‚úÖ Bom

// ‚úÖ Propagar contexto explicitamente
TraceContext context = tracer.currentContext();
executor.submit(() -> {
    CONTEXT.set(context); // Restaurar contexto
    // opera√ß√£o
    CONTEXT.remove();
});
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Sempre limpar ThreadLocal**: Usar try-finally ou try-with-resources
- ‚úÖ **Span por opera√ß√£o significativa**: Chamadas de rede, I/O, processamento pesado
- ‚úÖ **Tags consistentes**: Padronizar nomes (`http.status`, `db.query`, `user.id`)
- ‚úÖ **Sampling em produ√ß√£o**: Rastrear 1-10% das requisi√ß√µes (n√£o 100%)
- ‚úÖ **Propaga√ß√£o autom√°tica**: Usar frameworks (Spring Cloud Sleuth, OpenTelemetry)
- ‚úÖ **Timeout em spans**: N√£o deixar spans "abertos" indefinidamente
- ‚úÖ **Correla√ß√£o com logs**: Incluir trace ID em logs estruturados

---

## üîó Integra√ß√£o com Frameworks

### Spring Cloud Sleuth

```java
@RestController
public class PedidoController {

    // Sleuth injeta automaticamente trace/span IDs
    @GetMapping("/pedidos/{id}")
    public Pedido buscar(@PathVariable String id) {
        // Trace ID √© propagado automaticamente
        return pedidoService.buscar(id);
    }
}

// application.yml
spring:
  sleuth:
    sampler:
      probability: 0.1  # Rastrear 10% das requisi√ß√µes
```

### OpenTelemetry (OTel)

```java
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.Tracer;

@Service
public class PedidoService {

    private final Tracer tracer;

    public PedidoService(Tracer tracer) {
        this.tracer = tracer;
    }

    public void processar(String pedidoId) {
        Span span = tracer.spanBuilder("processar-pedido")
            .setAttribute("pedido.id", pedidoId)
            .startSpan();

        try {
            // l√≥gica de neg√≥cio
        } finally {
            span.end();
        }
    }
}
```

### Zipkin / Jaeger (Exportadores)

```java
// Configura√ß√£o de exportador
import zipkin2.reporter.AsyncReporter;
import zipkin2.reporter.urlconnection.URLConnectionSender;

var sender = URLConnectionSender.create("http://localhost:9411/api/v2/spans");
var reporter = AsyncReporter.create(sender);

// Spans s√£o enviados automaticamente para Zipkin/Jaeger
```

---

## üìà Visualiza√ß√£o de Traces

### Exemplo de Timeline Visualizado

```
Trace ID: abc123-def456 (Total: 250ms)

[============================= processar-pedido =============================] 250ms
  [======= verificar-estoque =======] 50ms
  [=============== processar-pagamento ===============] 150ms
    [=== validar-cartao ===] 80ms
    [== debitar ==] 70ms
  [==== confirmar ====] 50ms
```

### Estrutura JSON de um Span

```json
{
  "traceId": "abc123-def456",
  "spanId": "span-001",
  "parentSpanId": null,
  "name": "processar-pedido",
  "timestamp": 1699900000000,
  "duration": 250,
  "tags": {
    "pedido.id": "PED123",
    "usuario.id": "USR456",
    "http.status": "200"
  }
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                                    | ‚ö†Ô∏è Desvantagens                       |
| ----------------------------------------------- | ------------------------------------- |
| Correla√ß√£o completa de requisi√ß√µes distribu√≠das | Overhead de performance (~1-5%)       |
| Identifica√ß√£o r√°pida de gargalos                | Complexidade de implementa√ß√£o         |
| Debugging facilitado                            | Requer infraestrutura (Zipkin/Jaeger) |
| Vis√£o de lat√™ncia end-to-end                    | Pode gerar muito volume de dados      |
| Diagn√≥stico de falhas em cascata                | Necessita sampling em produ√ß√£o        |

---

## üîç Compara√ß√£o com Outras Abordagens

| Aspecto          | Distributed Tracing     | Logs Estruturados         | APM Tools                 |
| ---------------- | ----------------------- | ------------------------- | ------------------------- |
| **Correla√ß√£o**   | Autom√°tica via trace ID | Manual (busca por campos) | Autom√°tica                |
| **Hierarquia**   | Spans parent/child      | N√£o tem                   | Sim                       |
| **Performance**  | Overhead baixo          | Muito baixo               | M√©dio/alto                |
| **Custo**        | Open source (Jaeger)    | Gr√°tis                    | Caro (Datadog, New Relic) |
| **Complexidade** | M√©dia                   | Baixa                     | Baixa (SaaS)              |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar sampling**: Rastrear apenas 10% das requisi√ß√µes
2. **Adicionar span para chamadas de banco**: Criar span espec√≠fico para queries SQL
3. **Exportar para JSON**: Serializar spans e salvar em arquivo
4. **Integrar com SLF4J/Logback**: Incluir trace ID automaticamente nos logs
5. **Criar dashboard**: Visualizar traces usando Grafana + Tempo

---

## üìö Relacionado

- **Logging**: Correlacionar logs com trace ID
- **M√©tricas**: Combinar m√©tricas (RED: Rate, Errors, Duration) com traces
- **Circuit Breaker**: Registrar abertura de circuito como span
- **Retry Pattern**: Criar span para cada tentativa de retry
- **Observabilidade**: Pilar fundamental (Logs, M√©tricas, Traces)

---

## üìñ Refer√™ncias

- **OpenTelemetry**: Padr√£o da CNCF para observabilidade
- **Zipkin**: Distributed tracing system
- **Jaeger**: Distributed tracing platform (CNCF graduated)
- **Spring Cloud Sleuth**: Integra√ß√£o com Spring Boot
- **W3C Trace Context**: Padr√£o de propaga√ß√£o de contexto

---

**Distributed Tracing √© essencial para debugar e otimizar sistemas de microsservi√ßos complexos!** üîç‚ú®
