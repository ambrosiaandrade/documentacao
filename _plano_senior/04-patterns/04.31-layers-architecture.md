# 04.31 Layers Architecture (Arquitetura em Camadas) [M√âDIO] üèóÔ∏è

## üéØ Objetivo

Organizar aplica√ß√£o em **camadas horizontais** com responsabilidades distintas, facilitando **testes isolados por camada** e manuten√ß√£o atrav√©s de separa√ß√£o clara de conceitos.

---

## üìö O Que √â?

**Layers Architecture** √© um padr√£o arquitetural que divide a aplica√ß√£o em camadas horizontais, onde cada camada tem uma responsabilidade espec√≠fica e depende apenas das camadas abaixo dela.

### Analogia

Como um **pr√©dio corporativo**:

- **Cobertura (Presentation)**: Recep√ß√£o, atende clientes
- **Andares Intermedi√°rios (Business)**: Escrit√≥rios, processam trabalho
- **Subsolo (Persistence)**: Arquivo, armazena documentos
- **Funda√ß√£o (Database)**: Cofre, guarda dados cr√≠ticos
- **Vantagem**: Cada andar tem fun√ß√£o espec√≠fica, pode ser reformado independentemente

---

## ‚ùå Problema que Resolve

### Antes (C√≥digo Monol√≠tico sem Camadas)

```java
// ‚ùå PROBLEMA: Tudo misturado em uma √∫nica classe
@RestController
class PedidoController {

    @Autowired
    private DataSource dataSource;

    @PostMapping("/pedidos")
    ResponseEntity<String> criar(@RequestBody Map<String, Object> request) {
        // Valida√ß√£o da requisi√ß√£o ‚ùå (deveria ser em Presentation)
        if (!request.containsKey("clienteId")) {
            return ResponseEntity.badRequest().body("Cliente obrigat√≥rio");
        }

        // L√≥gica de neg√≥cio ‚ùå (deveria ser em Business)
        double valorTotal = 0;
        List<Map<String, Object>> itens = (List) request.get("itens");
        for (Map<String, Object> item : itens) {
            int quantidade = (int) item.get("quantidade");
            double preco = (double) item.get("preco");

            // Desconto especial - regra de neg√≥cio ‚ùå
            if (quantidade > 10) {
                preco *= 0.9; // 10% desconto
            }

            valorTotal += quantidade * preco;
        }

        // SQL direto ‚ùå (deveria ser em Persistence)
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(
                 "INSERT INTO pedidos (cliente_id, valor_total, status) VALUES (?, ?, ?)")) {

            stmt.setLong(1, (Long) request.get("clienteId"));
            stmt.setDouble(2, valorTotal);
            stmt.setString(3, "PENDENTE");
            stmt.executeUpdate();

            return ResponseEntity.ok("Pedido criado");

        } catch (SQLException e) {
            // Tratamento gen√©rico ‚ùå
            return ResponseEntity.status(500).body("Erro interno");
        }
    }
}

// Problemas:
// - Apresenta√ß√£o + L√≥gica + Persist√™ncia misturados ‚ùå
// - Imposs√≠vel testar l√≥gica sem banco ‚ùå
// - Trocar UI = refatorar l√≥gica ‚ùå
// - Trocar banco = refatorar controller ‚ùå
// - C√≥digo n√£o reutiliz√°vel ‚ùå
```

**Problemas**:

- üß© Responsabilidades misturadas
- üß™ Dif√≠cil testar isoladamente
- üîß Mudan√ßa em camada afeta outras
- üìö C√≥digo n√£o reutiliz√°vel
- üîÄ Alto acoplamento

### Depois (Layers Architecture)

```java
// ‚úÖ SOLU√á√ÉO: Camadas separadas e test√°veis

// ==== CAMADA 1: PRESENTATION (Controllers, DTOs) ====
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service; // Depende apenas da camada abaixo

    @Autowired
    PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    ResponseEntity<PedidoResponse> criar(@Valid @RequestBody PedidoRequest request) {
        // Apenas convers√£o DTO ‚Üí Domain
        Pedido pedido = request.toDomain();

        // Delega para camada de neg√≥cio
        Pedido criado = service.criarPedido(pedido);

        // Convers√£o Domain ‚Üí DTO
        return ResponseEntity.ok(PedidoResponse.from(criado));
    }
}

// ==== CAMADA 2: BUSINESS (Services, Domain Logic) ====
@Service
class PedidoService {

    private final PedidoRepository repository; // Depende apenas da camada abaixo
    private final DescontoCalculator descontoCalculator;

    @Transactional
    Pedido criarPedido(Pedido pedido) {
        // Apenas l√≥gica de neg√≥cio
        double valorTotal = calcularValorTotal(pedido);
        pedido.setValorTotal(valorTotal);
        pedido.setStatus(StatusPedido.PENDENTE);

        // Delega persist√™ncia
        return repository.salvar(pedido);
    }

    private double calcularValorTotal(Pedido pedido) {
        return pedido.getItens().stream()
            .mapToDouble(item -> {
                double subtotal = item.getQuantidade() * item.getPrecoUnitario();
                return descontoCalculator.aplicar(subtotal, item.getQuantidade());
            })
            .sum();
    }
}

// ==== CAMADA 3: PERSISTENCE (Repositories, DAOs) ====
@Repository
class PedidoRepositoryJdbc implements PedidoRepository {

    private final JdbcTemplate jdbc; // Depende apenas do framework

    @Override
    public Pedido salvar(Pedido pedido) {
        // Apenas SQL - sem l√≥gica de neg√≥cio
        String sql = "INSERT INTO pedidos (cliente_id, valor_total, status) VALUES (?, ?, ?)";

        KeyHolder keyHolder = new GeneratedKeyHolder();
        jdbc.update(con -> {
            PreparedStatement ps = con.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            ps.setLong(1, pedido.getClienteId());
            ps.setBigDecimal(2, pedido.getValorTotal());
            ps.setString(3, pedido.getStatus().name());
            return ps;
        }, keyHolder);

        return pedido.comId(keyHolder.getKey().longValue());
    }
}

// ==== CAMADA 4: DATABASE (Schema, Migrations) ====
// -- migrations/V1__create_pedidos.sql
// CREATE TABLE pedidos (
//     id BIGSERIAL PRIMARY KEY,
//     cliente_id BIGINT NOT NULL,
//     valor_total DECIMAL(10,2) NOT NULL,
//     status VARCHAR(20) NOT NULL
// );

// ‚úÖ Testes isolados por camada!
@Test
void deveCalcularValorComDesconto() {
    // Testa APENAS camada de neg√≥cio - sem DB, sem HTTP
    PedidoRepository repoMock = mock(PedidoRepository.class);
    PedidoService service = new PedidoService(repoMock, new DescontoCalculator());

    Pedido pedido = Pedido.builder()
        .adicionarItem(new ItemPedido("P1", 15, 10.0)) // 15 itens > 10 = desconto
        .build();

    service.criarPedido(pedido);

    // Verifica apenas l√≥gica
    assertTrue(pedido.getValorTotal() < 150); // Teve desconto
}
```

---

## üîß Implementa√ß√£o Completa

### 1. Camada de Dom√≠nio (Core - sem depend√™ncias)

```java
// Entidade de dom√≠nio (pura)
final class Pedido {
    private Long id;
    private final Long clienteId;
    private final List<ItemPedido> itens;
    private BigDecimal valorTotal;
    private StatusPedido status;
    private final LocalDateTime criadoEm;

    private Pedido(Long clienteId, List<ItemPedido> itens) {
        this.clienteId = clienteId;
        this.itens = new ArrayList<>(itens);
        this.criadoEm = LocalDateTime.now();
    }

    // L√≥gica de neg√≥cio no dom√≠nio
    void aplicarDesconto(BigDecimal percentual) {
        this.valorTotal = valorTotal.multiply(
            BigDecimal.ONE.subtract(percentual.divide(BigDecimal.valueOf(100)))
        );
    }

    void aprovar() {
        if (status != StatusPedido.PENDENTE) {
            throw new IllegalStateException("Apenas pedidos pendentes podem ser aprovados");
        }
        this.status = StatusPedido.APROVADO;
    }

    // Getters, Builder
    static PedidoBuilder builder() {
        return new PedidoBuilder();
    }

    Long getId() { return id; }
    Long getClienteId() { return clienteId; }
    List<ItemPedido> getItens() { return List.copyOf(itens); }
    BigDecimal getValorTotal() { return valorTotal; }
    StatusPedido getStatus() { return status; }
    LocalDateTime getCriadoEm() { return criadoEm; }

    void setId(Long id) { this.id = id; }
    void setValorTotal(BigDecimal valorTotal) { this.valorTotal = valorTotal; }
    void setStatus(StatusPedido status) { this.status = status; }

    Pedido comId(Long novoId) {
        this.id = novoId;
        return this;
    }
}

record ItemPedido(String produtoId, int quantidade, double precoUnitario) {
    double subtotal() {
        return quantidade * precoUnitario;
    }
}

enum StatusPedido {
    PENDENTE, APROVADO, REJEITADO, CANCELADO
}
```

### 2. Camada de Apresenta√ß√£o (Presentation Layer)

```java
// DTOs (Data Transfer Objects)
record PedidoRequest(
    @NotNull Long clienteId,
    @NotEmpty List<ItemRequest> itens
) {
    Pedido toDomain() {
        List<ItemPedido> itensDomain = itens.stream()
            .map(i -> new ItemPedido(i.produtoId(), i.quantidade(), i.precoUnitario()))
            .toList();

        return Pedido.builder()
            .clienteId(clienteId)
            .itens(itensDomain)
            .build();
    }
}

record ItemRequest(
    @NotBlank String produtoId,
    @Min(1) int quantidade,
    @DecimalMin("0.01") double precoUnitario
) {}

record PedidoResponse(
    Long id,
    Long clienteId,
    BigDecimal valorTotal,
    String status,
    LocalDateTime criadoEm,
    List<ItemResponse> itens
) {
    static PedidoResponse from(Pedido pedido) {
        List<ItemResponse> itensResponse = pedido.getItens().stream()
            .map(i -> new ItemResponse(i.produtoId(), i.quantidade(), i.precoUnitario()))
            .toList();

        return new PedidoResponse(
            pedido.getId(),
            pedido.getClienteId(),
            pedido.getValorTotal(),
            pedido.getStatus().name(),
            pedido.getCriadoEm(),
            itensResponse
        );
    }
}

record ItemResponse(String produtoId, int quantidade, double precoUnitario) {}

// Controller (REST API)
@RestController
@RequestMapping("/api/pedidos")
class PedidoController {

    private final PedidoService service;

    @Autowired
    PedidoController(PedidoService service) {
        this.service = service;
    }

    @PostMapping
    ResponseEntity<PedidoResponse> criar(@Valid @RequestBody PedidoRequest request) {
        Pedido pedido = request.toDomain();
        Pedido criado = service.criarPedido(pedido);
        return ResponseEntity.status(HttpStatus.CREATED).body(PedidoResponse.from(criado));
    }

    @GetMapping("/{id}")
    ResponseEntity<PedidoResponse> buscar(@PathVariable Long id) {
        return service.buscarPorId(id)
            .map(PedidoResponse::from)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }

    @PutMapping("/{id}/aprovar")
    ResponseEntity<PedidoResponse> aprovar(@PathVariable Long id) {
        Pedido aprovado = service.aprovarPedido(id);
        return ResponseEntity.ok(PedidoResponse.from(aprovado));
    }

    @GetMapping
    ResponseEntity<List<PedidoResponse>> listar(
        @RequestParam(required = false) String status,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size
    ) {
        List<Pedido> pedidos = status != null
            ? service.buscarPorStatus(StatusPedido.valueOf(status))
            : service.listarTodos(page, size);

        List<PedidoResponse> response = pedidos.stream()
            .map(PedidoResponse::from)
            .toList();

        return ResponseEntity.ok(response);
    }

    @ExceptionHandler(IllegalStateException.class)
    ResponseEntity<ErrorResponse> handleBusinessException(IllegalStateException ex) {
        return ResponseEntity.badRequest().body(new ErrorResponse(ex.getMessage()));
    }
}

record ErrorResponse(String mensagem) {}
```

### 3. Camada de Neg√≥cio (Business Layer)

```java
// Service (L√≥gica de Neg√≥cio)
@Service
class PedidoService {

    private final PedidoRepository repository;
    private final DescontoService descontoService;
    private final NotificacaoService notificacaoService;

    @Autowired
    PedidoService(PedidoRepository repository,
                  DescontoService descontoService,
                  NotificacaoService notificacaoService) {
        this.repository = repository;
        this.descontoService = descontoService;
        this.notificacaoService = notificacaoService;
    }

    @Transactional
    public Pedido criarPedido(Pedido pedido) {
        // Regra de neg√≥cio: calcular valor total
        BigDecimal valorTotal = calcularValorTotal(pedido);
        pedido.setValorTotal(valorTotal);
        pedido.setStatus(StatusPedido.PENDENTE);

        // Regra de neg√≥cio: aplicar desconto por volume
        if (pedido.getItens().size() > 5) {
            BigDecimal desconto = descontoService.calcularDescontoPorVolume(pedido);
            pedido.aplicarDesconto(desconto);
        }

        // Persistir
        Pedido salvo = repository.salvar(pedido);

        // Notificar (side effect)
        notificacaoService.notificarNovoPedido(salvo);

        return salvo;
    }

    public Optional<Pedido> buscarPorId(Long id) {
        return repository.buscarPorId(id);
    }

    @Transactional
    public Pedido aprovarPedido(Long id) {
        Pedido pedido = repository.buscarPorId(id)
            .orElseThrow(() -> new EntityNotFoundException("Pedido n√£o encontrado: " + id));

        // Regra de neg√≥cio
        pedido.aprovar();

        repository.atualizar(pedido);
        notificacaoService.notificarAprovacao(pedido);

        return pedido;
    }

    public List<Pedido> buscarPorStatus(StatusPedido status) {
        return repository.buscarPorStatus(status);
    }

    public List<Pedido> listarTodos(int page, int size) {
        return repository.buscarTodos(page, size);
    }

    private BigDecimal calcularValorTotal(Pedido pedido) {
        return pedido.getItens().stream()
            .map(item -> BigDecimal.valueOf(item.subtotal()))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

// Servi√ßo auxiliar de neg√≥cio
@Service
class DescontoService {

    BigDecimal calcularDescontoPorVolume(Pedido pedido) {
        int totalItens = pedido.getItens().stream()
            .mapToInt(ItemPedido::quantidade)
            .sum();

        // Regras de neg√≥cio de desconto
        if (totalItens > 100) {
            return BigDecimal.valueOf(15); // 15%
        } else if (totalItens > 50) {
            return BigDecimal.valueOf(10); // 10%
        } else if (totalItens > 20) {
            return BigDecimal.valueOf(5); // 5%
        }

        return BigDecimal.ZERO;
    }
}

@Service
class NotificacaoService {

    void notificarNovoPedido(Pedido pedido) {
        System.out.println("üìß Novo pedido criado: " + pedido.getId());
        // Envia email, webhook, etc
    }

    void notificarAprovacao(Pedido pedido) {
        System.out.println("‚úÖ Pedido aprovado: " + pedido.getId());
    }
}
```

### 4. Camada de Persist√™ncia (Persistence Layer)

```java
// Interface do Repository (contrato)
interface PedidoRepository {
    Optional<Pedido> buscarPorId(Long id);
    List<Pedido> buscarTodos(int page, int size);
    List<Pedido> buscarPorStatus(StatusPedido status);
    Pedido salvar(Pedido pedido);
    void atualizar(Pedido pedido);
    void deletar(Long id);
}

// Implementa√ß√£o JDBC
@Repository
class PedidoRepositoryJdbc implements PedidoRepository {

    private final JdbcTemplate jdbc;

    @Autowired
    PedidoRepositoryJdbc(JdbcTemplate jdbc) {
        this.jdbc = jdbc;
    }

    @Override
    public Optional<Pedido> buscarPorId(Long id) {
        String sql = """
            SELECT p.id, p.cliente_id, p.valor_total, p.status, p.criado_em,
                   i.produto_id, i.quantidade, i.preco_unitario
            FROM pedidos p
            LEFT JOIN pedido_itens i ON p.id = i.pedido_id
            WHERE p.id = ?
            """;

        try {
            // Agrupa itens por pedido
            Map<Long, Pedido> pedidos = jdbc.query(sql, new PedidoResultSetExtractor(), id);
            return pedidos.values().stream().findFirst();
        } catch (Exception e) {
            return Optional.empty();
        }
    }

    @Override
    public List<Pedido> buscarTodos(int page, int size) {
        String sql = """
            SELECT p.id, p.cliente_id, p.valor_total, p.status, p.criado_em,
                   i.produto_id, i.quantidade, i.preco_unitario
            FROM pedidos p
            LEFT JOIN pedido_itens i ON p.id = i.pedido_id
            ORDER BY p.criado_em DESC
            LIMIT ? OFFSET ?
            """;

        Map<Long, Pedido> pedidos = jdbc.query(sql, new PedidoResultSetExtractor(), size, page * size);
        return new ArrayList<>(pedidos.values());
    }

    @Override
    public List<Pedido> buscarPorStatus(StatusPedido status) {
        String sql = """
            SELECT p.id, p.cliente_id, p.valor_total, p.status, p.criado_em,
                   i.produto_id, i.quantidade, i.preco_unitario
            FROM pedidos p
            LEFT JOIN pedido_itens i ON p.id = i.pedido_id
            WHERE p.status = ?
            """;

        Map<Long, Pedido> pedidos = jdbc.query(sql, new PedidoResultSetExtractor(), status.name());
        return new ArrayList<>(pedidos.values());
    }

    @Override
    @Transactional
    public Pedido salvar(Pedido pedido) {
        // Insere pedido
        String sqlPedido = """
            INSERT INTO pedidos (cliente_id, valor_total, status, criado_em)
            VALUES (?, ?, ?, ?)
            """;

        KeyHolder keyHolder = new GeneratedKeyHolder();
        jdbc.update(con -> {
            PreparedStatement ps = con.prepareStatement(sqlPedido, Statement.RETURN_GENERATED_KEYS);
            ps.setLong(1, pedido.getClienteId());
            ps.setBigDecimal(2, pedido.getValorTotal());
            ps.setString(3, pedido.getStatus().name());
            ps.setTimestamp(4, Timestamp.valueOf(pedido.getCriadoEm()));
            return ps;
        }, keyHolder);

        Long pedidoId = keyHolder.getKey().longValue();

        // Insere itens
        String sqlItens = """
            INSERT INTO pedido_itens (pedido_id, produto_id, quantidade, preco_unitario)
            VALUES (?, ?, ?, ?)
            """;

        for (ItemPedido item : pedido.getItens()) {
            jdbc.update(sqlItens, pedidoId, item.produtoId(), item.quantidade(), item.precoUnitario());
        }

        return pedido.comId(pedidoId);
    }

    @Override
    public void atualizar(Pedido pedido) {
        String sql = "UPDATE pedidos SET valor_total = ?, status = ? WHERE id = ?";

        int rows = jdbc.update(sql, pedido.getValorTotal(), pedido.getStatus().name(), pedido.getId());
        if (rows == 0) {
            throw new EntityNotFoundException("Pedido n√£o encontrado: " + pedido.getId());
        }
    }

    @Override
    public void deletar(Long id) {
        jdbc.update("DELETE FROM pedido_itens WHERE pedido_id = ?", id);
        jdbc.update("DELETE FROM pedidos WHERE id = ?", id);
    }

    // ResultSetExtractor para agregar pedido + itens
    private static class PedidoResultSetExtractor implements ResultSetExtractor<Map<Long, Pedido>> {
        @Override
        public Map<Long, Pedido> extractData(ResultSet rs) throws SQLException {
            Map<Long, Pedido> pedidos = new LinkedHashMap<>();

            while (rs.next()) {
                Long pedidoId = rs.getLong("id");

                Pedido pedido = pedidos.computeIfAbsent(pedidoId, id -> {
                    try {
                        Pedido.PedidoBuilder builder = Pedido.builder()
                            .clienteId(rs.getLong("cliente_id"));

                        Pedido p = builder.build();
                        p.setId(pedidoId);
                        p.setValorTotal(rs.getBigDecimal("valor_total"));
                        p.setStatus(StatusPedido.valueOf(rs.getString("status")));

                        return p;
                    } catch (SQLException e) {
                        throw new RuntimeException(e);
                    }
                });

                // Adiciona item se presente
                String produtoId = rs.getString("produto_id");
                if (produtoId != null) {
                    ItemPedido item = new ItemPedido(
                        produtoId,
                        rs.getInt("quantidade"),
                        rs.getDouble("preco_unitario")
                    );
                    pedido.getItens().add(item);
                }
            }

            return pedidos;
        }
    }
}
```

### 5. Camada de Dados (Database Layer)

```sql
-- migrations/V1__create_pedidos_schema.sql

CREATE TABLE pedidos (
    id BIGSERIAL PRIMARY KEY,
    cliente_id BIGINT NOT NULL,
    valor_total DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) NOT NULL,
    criado_em TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE pedido_itens (
    id BIGSERIAL PRIMARY KEY,
    pedido_id BIGINT NOT NULL REFERENCES pedidos(id) ON DELETE CASCADE,
    produto_id VARCHAR(50) NOT NULL,
    quantidade INT NOT NULL CHECK (quantidade > 0),
    preco_unitario DECIMAL(10, 2) NOT NULL CHECK (preco_unitario > 0)
);

CREATE INDEX idx_pedidos_status ON pedidos(status);
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
CREATE INDEX idx_pedido_itens_pedido ON pedido_itens(pedido_id);
```

### 6. Configura√ß√£o de Camadas

```java
// Configura√ß√£o Spring para separa√ß√£o clara
@Configuration
class LayersConfiguration {

    // Camada de Apresenta√ß√£o
    @Bean
    PedidoController pedidoController(PedidoService service) {
        return new PedidoController(service);
    }

    // Camada de Neg√≥cio
    @Bean
    PedidoService pedidoService(
        PedidoRepository repository,
        DescontoService descontoService,
        NotificacaoService notificacaoService
    ) {
        return new PedidoService(repository, descontoService, notificacaoService);
    }

    // Camada de Persist√™ncia
    @Bean
    PedidoRepository pedidoRepository(JdbcTemplate jdbc) {
        return new PedidoRepositoryJdbc(jdbc);
    }
}
```

---

## üß™ Como Testar

### 1. Testar Camada de Apresenta√ß√£o (Controller)

```java
@WebMvcTest(PedidoController.class)
class PedidoControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private PedidoService service;

    @Test
    void deveRetornar201AoCriarPedido() throws Exception {
        // Arrange
        Pedido pedido = Pedido.builder()
            .clienteId(1L)
            .adicionarItem(new ItemPedido("P1", 2, 10.0))
            .build();
        pedido.setId(1L);
        pedido.setValorTotal(BigDecimal.valueOf(20));
        pedido.setStatus(StatusPedido.PENDENTE);

        when(service.criarPedido(any())).thenReturn(pedido);

        // Act & Assert
        mockMvc.perform(post("/api/pedidos")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""
                    {
                        "clienteId": 1,
                        "itens": [
                            {"produtoId": "P1", "quantidade": 2, "precoUnitario": 10.0}
                        ]
                    }
                    """))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.id").value(1))
            .andExpect(jsonPath("$.status").value("PENDENTE"));
    }
}
```

### 2. Testar Camada de Neg√≥cio (Service)

```java
@ExtendWith(MockitoExtension.class)
class PedidoServiceTest {

    @Mock
    private PedidoRepository repository;

    @Mock
    private DescontoService descontoService;

    @Mock
    private NotificacaoService notificacaoService;

    @InjectMocks
    private PedidoService service;

    @Test
    void deveCriarPedidoComValorTotalCalculado() {
        // Arrange
        Pedido pedido = Pedido.builder()
            .clienteId(1L)
            .adicionarItem(new ItemPedido("P1", 2, 10.0))
            .adicionarItem(new ItemPedido("P2", 3, 15.0))
            .build();

        when(descontoService.calcularDescontoPorVolume(any())).thenReturn(BigDecimal.ZERO);
        when(repository.salvar(any())).thenAnswer(inv -> {
            Pedido p = inv.getArgument(0);
            return p.comId(1L);
        });

        // Act
        Pedido criado = service.criarPedido(pedido);

        // Assert
        assertEquals(BigDecimal.valueOf(65.0), criado.getValorTotal());
        assertEquals(StatusPedido.PENDENTE, criado.getStatus());
        verify(repository).salvar(any());
        verify(notificacaoService).notificarNovoPedido(any());
    }

    @Test
    void deveAplicarDescontoParaPedidosComMuitosItens() {
        // Arrange
        Pedido.PedidoBuilder builder = Pedido.builder().clienteId(1L);
        for (int i = 0; i < 10; i++) {
            builder.adicionarItem(new ItemPedido("P" + i, 1, 10.0));
        }
        Pedido pedido = builder.build();

        when(descontoService.calcularDescontoPorVolume(any())).thenReturn(BigDecimal.valueOf(5));
        when(repository.salvar(any())).thenAnswer(inv -> inv.getArgument(0));

        // Act
        service.criarPedido(pedido);

        // Assert
        verify(descontoService).calcularDescontoPorVolume(any());
    }
}
```

### 3. Testar Camada de Persist√™ncia (Repository)

```java
@SpringBootTest
@Transactional
class PedidoRepositoryJdbcTest {

    @Autowired
    private PedidoRepository repository;

    @Test
    void deveSalvarEBuscarPedido() {
        // Arrange
        Pedido pedido = Pedido.builder()
            .clienteId(1L)
            .adicionarItem(new ItemPedido("P1", 2, 10.0))
            .build();
        pedido.setValorTotal(BigDecimal.valueOf(20));
        pedido.setStatus(StatusPedido.PENDENTE);

        // Act
        Pedido salvo = repository.salvar(pedido);
        Optional<Pedido> encontrado = repository.buscarPorId(salvo.getId());

        // Assert
        assertTrue(encontrado.isPresent());
        assertEquals(1L, encontrado.get().getClienteId());
        assertEquals(1, encontrado.get().getItens().size());
    }
}
```

### 4. Teste de Integra√ß√£o (Todas Camadas)

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Transactional
class PedidoIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void deveProcessarPedidoCompletoEndToEnd() {
        // Arrange
        PedidoRequest request = new PedidoRequest(
            1L,
            List.of(new ItemRequest("P1", 2, 10.0))
        );

        // Act
        ResponseEntity<PedidoResponse> response = restTemplate.postForEntity(
            "/api/pedidos",
            request,
            PedidoResponse.class
        );

        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("PENDENTE", response.getBody().status());
    }
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå Camada superior chamando camada inferior √† inferior
class Controller {
    @Autowired
    private Repository repository; // ‚ùå Pula camada de neg√≥cio
}

// ‚ùå Camada inferior dependendo de superior
class Repository {
    @Autowired
    private Controller controller; // ‚ùå Depend√™ncia invertida
}

// ‚ùå L√≥gica de neg√≥cio no Controller
class Controller {
    void criar() {
        // C√°lculos complexos aqui ‚ùå
    }
}
```

### ‚úÖ Fazer

```java
// ‚úÖ Depend√™ncia unidirecional (camada N ‚Üí camada N-1)
class Controller {
    @Autowired
    private Service service; // ‚úÖ Camada imediatamente abaixo
}

class Service {
    @Autowired
    private Repository repository; // ‚úÖ Camada imediatamente abaixo
}

// ‚úÖ L√≥gica no lugar certo
class Service {
    void criarPedido() {
        // L√≥gica de neg√≥cio aqui ‚úÖ
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Depend√™ncia unidirecional**: Camada N depende apenas de N-1
- ‚úÖ **Camadas finas**: Presentation e Persistence m√≠nimas
- ‚úÖ **Camada de neg√≥cio rica**: L√≥gica concentrada
- ‚úÖ **DTOs na apresenta√ß√£o**: N√£o exponha entidades
- ‚úÖ **Transa√ß√µes no servi√ßo**: N√£o no controller/repository
- ‚úÖ **Testes isolados**: Mock camadas inferiores
- ‚úÖ **Open Closed Layers**: Camadas podem pular (com cuidado)

---

## üîó Compara√ß√£o com Outros Padr√µes

| Padr√£o                 | Organiza√ß√£o          | Depend√™ncias                 | Quando Usar             |
| ---------------------- | -------------------- | ---------------------------- | ----------------------- |
| **Layers**             | Horizontal (camadas) | Unidirecional N‚ÜíN-1          | Apps tradicionais, CRUD |
| **Hexagonal**          | Central (dom√≠nio)    | Invertidas (adapters)        | DDD, dom√≠nio complexo   |
| **Clean Architecture** | Circular (regras)    | Invertidas (frameworks fora) | Independ√™ncia total     |
| **Microservices**      | Vertical (servi√ßos)  | Independentes                | Sistemas distribu√≠dos   |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                         | ‚ö†Ô∏è Desvantagens                              |
| ------------------------------------ | -------------------------------------------- |
| Separa√ß√£o clara de responsabilidades | Pode adicionar overhead                      |
| F√°cil testar isoladamente            | Camadas muito finas podem ser desnecess√°rias |
| Manuten√ß√£o simplificada              | Rigidez: mudan√ßas atravessam camadas         |
| Reutiliza√ß√£o de l√≥gica               | Performance: mais chamadas de m√©todo         |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Layers com cache** (adicionar camada de cache entre Business e Persistence)
2. **Layers com eventos** (adicionar Event Bus entre camadas)
3. **Layers com seguran√ßa** (adicionar Security Layer)
4. **Layers relaxed** (permitir camadas pular - ex: Presentation ‚Üí Persistence)
5. **Migrar para Hexagonal** (converter Layers para Ports & Adapters)

---

## üìö Relacionado

- **Hexagonal Architecture**: Evolu√ß√£o com portas e adaptadores
- **Clean Architecture**: Depend√™ncias invertidas
- **MVC**: Camadas para web (Model-View-Controller)
- **Repository Pattern**: Abstra√ß√£o da camada de persist√™ncia

---

**Layers Architecture organiza c√≥digo em camadas test√°veis e manuten√≠veis!** üèóÔ∏è‚ú®
