# 04.10 Dead Letter Queue (DLQ) [M√âDIO] üíÄ

## üéØ Objetivo

Isolar **mensagens problem√°ticas** que falharam processamento ap√≥s m√∫ltiplas tentativas, enviando-as para uma **fila especial** onde podem ser analisadas, reprocessadas ou descartadas sem bloquear o fluxo principal.

---

## üìö O Que √â?

**Dead Letter Queue (DLQ)** √© um padr√£o de mensageria onde mensagens que falharam repetidamente s√£o movidas para uma fila separada ao inv√©s de serem descartadas ou reprocessadas infinitamente.

### Analogia

Como o **setor de "encomendas n√£o entregues"** dos Correios: pacotes que falharam 3x na entrega n√£o voltam para a fila principal bloqueando outras entregas, v√£o para um setor especial onde s√£o analisados para resolu√ß√£o manual.

### Prop√≥sito

- **Isolamento**: Mensagens "venenosas" n√£o travam consumidores
- **Auditoria**: Registra falhas para an√°lise posterior
- **Reprocessamento**: Permite retry manual ap√≥s corre√ß√£o

---

## ‚ùå Problema que Resolve

### Antes (Retry Infinito)

```java
// ‚ùå PROBLEMA: Mensagem ruim trava consumidor
@KafkaListener(topics = "pedidos")
public void processar(Pedido pedido) {
    try {
        validar(pedido); // Schema inv√°lido -> exce√ß√£o
        processar(pedido);
    } catch (Exception e) {
        // Mensagem volta para fila... infinitamente
        throw new RuntimeException(e); // Retry infinito!
    }
}

// Logs saturados:
// ERRO: Falha ao processar pedido-123
// ERRO: Falha ao processar pedido-123
// ERRO: Falha ao processar pedido-123 (x1000)
```

**Problemas**:

- ‚ôæÔ∏è Loop infinito em mensagens inv√°lidas
- üêå Consumidor travado (n√£o processa mensagens v√°lidas)
- üìä Logs saturados com mesma exce√ß√£o
- üî• CPU desperdi√ßada tentando processar inv√°lido

### Depois (Dead Letter Queue)

```java
// ‚úÖ SOLU√á√ÉO: Ap√≥s N tentativas, vai para DLQ
@KafkaListener(topics = "pedidos")
public void processar(Pedido pedido) {
    try {
        validar(pedido);
        processar(pedido);
        ack(); // Sucesso
    } catch (RetryableException e) {
        nack(); // Volta para retry
    } catch (NonRetryableException e) {
        sendToDLQ(pedido, e); // Vai direto para DLQ
        ack(); // Remove da fila principal
    }
}

// Depois de 3 tentativas com falha -> DLQ autom√°tico
```

---

## üîß Implementa√ß√£o Completa

### 1. Modelo de Mensagem e DLQ

```java
// Mensagem imut√°vel
record Mensagem(
    String id,
    String payload,
    Map<String, String> headers,
    Instant timestamp
) {}

// Entrada na DLQ com contexto da falha
record DLQEntry(
    Mensagem mensagem,
    String motivoFalha,
    int tentativasRealizadas,
    Instant dataEnvioDLQ,
    List<String> stackTraces
) {}

// Reposit√≥rio da DLQ
interface DeadLetterStore {
    void add(DLQEntry entry);
    List<DLQEntry> findAll();
    Optional<DLQEntry> findById(String mensagemId);
    void remove(String mensagemId);
    int count();
}

final class InMemoryDeadLetterStore implements DeadLetterStore {
    private final Map<String, DLQEntry> store = new ConcurrentHashMap<>();

    @Override
    public void add(DLQEntry entry) {
        store.put(entry.mensagem().id(), entry);
        System.err.println("üíÄ DLQ: " + entry.mensagem().id() +
            " - Motivo: " + entry.motivoFalha());
    }

    @Override
    public List<DLQEntry> findAll() {
        return new ArrayList<>(store.values());
    }

    @Override
    public Optional<DLQEntry> findById(String mensagemId) {
        return Optional.ofNullable(store.get(mensagemId));
    }

    @Override
    public void remove(String mensagemId) {
        store.remove(mensagemId);
    }

    @Override
    public int count() {
        return store.size();
    }
}
```

### 2. Processor com DLQ

```java
@FunctionalInterface
interface MensagemHandler {
    void process(Mensagem mensagem) throws Exception;
}

// Exce√ß√µes classificadas
class RetryableException extends Exception {
    RetryableException(String msg) { super(msg); }
}

class NonRetryableException extends Exception {
    NonRetryableException(String msg) { super(msg); }
}

final class RetriableProcessor {
    private final MensagemHandler handler;
    private final DeadLetterStore dlqStore;
    private final int maxTentativas;
    private final Duration backoff;

    RetriableProcessor(
        MensagemHandler handler,
        DeadLetterStore dlqStore,
        int maxTentativas,
        Duration backoff
    ) {
        this.handler = handler;
        this.dlqStore = dlqStore;
        this.maxTentativas = maxTentativas;
        this.backoff = backoff;
    }

    public void process(Mensagem mensagem) {
        List<String> stackTraces = new ArrayList<>();

        for (int tentativa = 1; tentativa <= maxTentativas; tentativa++) {
            try {
                handler.process(mensagem);
                System.out.println("‚úÖ Processado: " + mensagem.id() +
                    " (tentativa " + tentativa + ")");
                return; // Sucesso

            } catch (NonRetryableException e) {
                // Falha permanente - vai direto para DLQ
                enviarParaDLQ(mensagem, e.getMessage(), tentativa, stackTraces);
                return;

            } catch (Exception e) {
                stackTraces.add(e.getMessage());
                System.err.println("‚ö†Ô∏è Tentativa " + tentativa + "/" + maxTentativas +
                    " falhou para: " + mensagem.id());

                if (tentativa == maxTentativas) {
                    // Esgotou tentativas - vai para DLQ
                    enviarParaDLQ(mensagem, e.getMessage(), tentativa, stackTraces);
                } else {
                    // Aguarda backoff antes de pr√≥xima tentativa
                    try {
                        Thread.sleep(backoff.toMillis() * tentativa);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }

    private void enviarParaDLQ(
        Mensagem mensagem,
        String motivo,
        int tentativas,
        List<String> stackTraces
    ) {
        DLQEntry entry = new DLQEntry(
            mensagem,
            motivo,
            tentativas,
            Instant.now(),
            List.copyOf(stackTraces)
        );

        dlqStore.add(entry);
    }
}
```

### 3. DLQ Monitor e Reprocessamento

```java
final class DLQMonitor {
    private final DeadLetterStore dlqStore;
    private final int thresholdAlerta;

    DLQMonitor(DeadLetterStore dlqStore, int thresholdAlerta) {
        this.dlqStore = dlqStore;
        this.thresholdAlerta = thresholdAlerta;
    }

    public void verificar() {
        int total = dlqStore.count();

        if (total > thresholdAlerta) {
            System.err.println("üö® ALERTA: DLQ com " + total +
                " mensagens (threshold: " + thresholdAlerta + ")");
        }

        // Analisar padr√µes de falha
        Map<String, Long> motivosPorFrequencia = dlqStore.findAll().stream()
            .collect(Collectors.groupingBy(
                DLQEntry::motivoFalha,
                Collectors.counting()
            ));

        System.out.println("üìä Motivos de falha:");
        motivosPorFrequencia.forEach((motivo, count) ->
            System.out.println("  - " + motivo + ": " + count + "x")
        );
    }

    public List<DLQEntry> getMensagensAntigas(Duration maxAge) {
        Instant cutoff = Instant.now().minus(maxAge);
        return dlqStore.findAll().stream()
            .filter(entry -> entry.dataEnvioDLQ().isBefore(cutoff))
            .toList();
    }
}

final class DLQReprocessor {
    private final RetriableProcessor processor;
    private final DeadLetterStore dlqStore;

    DLQReprocessor(RetriableProcessor processor, DeadLetterStore dlqStore) {
        this.processor = processor;
        this.dlqStore = dlqStore;
    }

    public void reprocessar(String mensagemId) {
        Optional<DLQEntry> entryOpt = dlqStore.findById(mensagemId);

        if (entryOpt.isEmpty()) {
            System.err.println("‚ùå Mensagem n√£o encontrada na DLQ: " + mensagemId);
            return;
        }

        DLQEntry entry = entryOpt.get();
        System.out.println("üîÑ Reprocessando: " + mensagemId);

        // Remove da DLQ antes de reprocessar
        dlqStore.remove(mensagemId);

        // Tenta reprocessar (pode voltar para DLQ se falhar)
        processor.process(entry.mensagem());
    }

    public void reprocessarTodos() {
        List<DLQEntry> entries = dlqStore.findAll();
        System.out.println("üîÑ Reprocessando " + entries.size() + " mensagens da DLQ");

        entries.forEach(entry -> {
            dlqStore.remove(entry.mensagem().id());
            processor.process(entry.mensagem());
        });
    }
}
```

### 4. Exemplo de Uso

```java
public class Application {
    public static void main(String[] args) {
        // Setup
        DeadLetterStore dlqStore = new InMemoryDeadLetterStore();

        MensagemHandler handler = mensagem -> {
            // Simula valida√ß√£o
            if (mensagem.payload().contains("INVALID")) {
                throw new NonRetryableException("Schema inv√°lido");
            }
            if (mensagem.payload().contains("RETRY")) {
                throw new RetryableException("Servi√ßo indispon√≠vel");
            }
            System.out.println("Processado: " + mensagem.payload());
        };

        RetriableProcessor processor = new RetriableProcessor(
            handler,
            dlqStore,
            3,  // max tentativas
            Duration.ofMillis(100) // backoff
        );

        // Processar mensagens
        processor.process(new Mensagem("1", "OK", Map.of(), Instant.now()));
        processor.process(new Mensagem("2", "INVALID", Map.of(), Instant.now()));
        processor.process(new Mensagem("3", "RETRY", Map.of(), Instant.now()));

        // Monitorar DLQ
        DLQMonitor monitor = new DLQMonitor(dlqStore, 5);
        monitor.verificar();

        // Reprocessar se necess√°rio
        DLQReprocessor reprocessor = new DLQReprocessor(processor, dlqStore);
        // reprocessor.reprocessar("2"); // Ap√≥s corrigir handler
    }
}
```

---

## üß™ Como Testar

### 1. Testar Envio para DLQ ap√≥s Falhas

```java
@Test
void deveEnviarParaDLQAposMaxTentativas() throws Exception {
    // Arrange
    MensagemHandler handler = mock(MensagemHandler.class);
    doThrow(new RuntimeException("Erro persistente"))
        .when(handler).process(any());

    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();
    RetriableProcessor processor = new RetriableProcessor(
        handler, dlqStore, 3, Duration.ofMillis(10)
    );

    Mensagem msg = new Mensagem("msg1", "payload", Map.of(), Instant.now());

    // Act
    processor.process(msg);

    // Assert
    verify(handler, times(3)).process(msg);
    assertEquals(1, dlqStore.count());
    assertTrue(dlqStore.findById("msg1").isPresent());
}
```

### 2. Testar Sucesso N√£o Envia para DLQ

```java
@Test
void sucessoNaoDeveEnviarParaDLQ() throws Exception {
    // Arrange
    MensagemHandler handler = mock(MensagemHandler.class);
    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();
    RetriableProcessor processor = new RetriableProcessor(
        handler, dlqStore, 3, Duration.ofMillis(10)
    );

    Mensagem msg = new Mensagem("msg2", "ok", Map.of(), Instant.now());

    // Act
    processor.process(msg);

    // Assert
    verify(handler, times(1)).process(msg);
    assertEquals(0, dlqStore.count());
}
```

### 3. Testar NonRetryableException Vai Direto para DLQ

```java
@Test
void nonRetryableExceptionDeveIrDiretoParaDLQ() throws Exception {
    // Arrange
    MensagemHandler handler = mock(MensagemHandler.class);
    doThrow(new NonRetryableException("Schema inv√°lido"))
        .when(handler).process(any());

    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();
    RetriableProcessor processor = new RetriableProcessor(
        handler, dlqStore, 3, Duration.ofMillis(10)
    );

    Mensagem msg = new Mensagem("msg3", "invalid", Map.of(), Instant.now());

    // Act
    processor.process(msg);

    // Assert
    verify(handler, times(1)).process(msg); // Apenas 1 tentativa
    assertEquals(1, dlqStore.count());

    DLQEntry entry = dlqStore.findById("msg3").get();
    assertTrue(entry.motivoFalha().contains("Schema inv√°lido"));
    assertEquals(1, entry.tentativasRealizadas());
}
```

### 4. Testar Reprocessamento

```java
@Test
void deveReprocessarMensagemDaDLQ() throws Exception {
    // Arrange
    MensagemHandler handler = mock(MensagemHandler.class);
    doThrow(new RuntimeException("Erro"))
        .doNothing(); // Primeira vez falha, segunda sucede

    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();
    RetriableProcessor processor = new RetriableProcessor(
        handler, dlqStore, 1, Duration.ofMillis(10)
    );

    Mensagem msg = new Mensagem("msg4", "payload", Map.of(), Instant.now());

    // Act - primeira tentativa vai para DLQ
    processor.process(msg);
    assertEquals(1, dlqStore.count());

    // Reprocessar
    DLQReprocessor reprocessor = new DLQReprocessor(processor, dlqStore);
    reprocessor.reprocessar("msg4");

    // Assert
    assertEquals(0, dlqStore.count()); // Removido da DLQ
    verify(handler, times(2)).process(msg); // 2 processamentos
}
```

### 5. Testar Monitor de DLQ

```java
@Test
void deveAlertar QuandoDLQAtingirThreshold() {
    // Arrange
    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();

    for (int i = 0; i < 10; i++) {
        dlqStore.add(new DLQEntry(
            new Mensagem("msg" + i, "payload", Map.of(), Instant.now()),
            "Erro " + i,
            3,
            Instant.now(),
            List.of()
        ));
    }

    DLQMonitor monitor = new DLQMonitor(dlqStore, 5);

    // Act & Assert
    ByteArrayOutputStream outContent = new ByteArrayOutputStream();
    System.setErr(new PrintStream(outContent));

    monitor.verificar();

    String output = outContent.toString();
    assertTrue(output.contains("ALERTA: DLQ com 10 mensagens"));
}
```

### 6. Testar An√°lise de Mensagens Antigas

```java
@Test
void deveIdentificarMensagensAntigasNaDLQ() {
    // Arrange
    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();

    // Mensagem antiga (2 dias atr√°s)
    dlqStore.add(new DLQEntry(
        new Mensagem("old", "payload", Map.of(), Instant.now().minus(2, ChronoUnit.DAYS)),
        "Erro antigo",
        3,
        Instant.now().minus(2, ChronoUnit.DAYS),
        List.of()
    ));

    // Mensagem recente
    dlqStore.add(new DLQEntry(
        new Mensagem("new", "payload", Map.of(), Instant.now()),
        "Erro recente",
        3,
        Instant.now(),
        List.of()
    ));

    DLQMonitor monitor = new DLQMonitor(dlqStore, 10);

    // Act
    List<DLQEntry> antigas = monitor.getMensagensAntigas(Duration.ofDays(1));

    // Assert
    assertEquals(1, antigas.size());
    assertEquals("old", antigas.get(0).mensagem().id());
}
```

### 7. Testar Stack Traces na DLQ

```java
@Test
void deveArmazenarStackTracesNaDLQ() throws Exception {
    // Arrange
    MensagemHandler handler = mensagem -> {
        throw new RuntimeException("Erro espec√≠fico: " + mensagem.id());
    };

    DeadLetterStore dlqStore = new InMemoryDeadLetterStore();
    RetriableProcessor processor = new RetriableProcessor(
        handler, dlqStore, 2, Duration.ofMillis(10)
    );

    Mensagem msg = new Mensagem("msg5", "payload", Map.of(), Instant.now());

    // Act
    processor.process(msg);

    // Assert
    DLQEntry entry = dlqStore.findById("msg5").get();
    assertEquals(2, entry.stackTraces().size());
    assertTrue(entry.stackTraces().get(0).contains("Erro espec√≠fico: msg5"));
}
```

---

## ‚ö†Ô∏è Cuidados Importantes

### ‚ùå Evitar

```java
// ‚ùå DLQ sem monitoramento
// Mensagens acumulam silenciosamente

// ‚ùå Retry infinito sem DLQ
while (true) {
    try {
        processar(msg);
        break;
    } catch (Exception e) {
        // Loop infinito!
    }
}

// ‚ùå Descartar mensagens sem log
catch (Exception e) {
    // Silenciosamente perdido
}
```

### ‚úÖ Fazer

```java
// ‚úÖ DLQ com alertas
if (dlqStore.count() > threshold) {
    alertService.enviar("DLQ saturada!");
}

// ‚úÖ Max tentativas configur√°vel
RetriableProcessor processor = new RetriableProcessor(
    handler, dlqStore, config.getMaxRetries(), config.getBackoff()
);

// ‚úÖ Log detalhado na DLQ
dlqStore.add(new DLQEntry(msg, exception.getMessage(), tentativas, now, stacks));
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Threshold de alerta**: Monitorar quantidade na DLQ
- ‚úÖ **TTL**: Mensagens antigas devem expirar ou serem arquivadas
- ‚úÖ **Classifica√ß√£o de erros**: Retryable vs NonRetryable
- ‚úÖ **Stack traces**: Armazenar para debugging
- ‚úÖ **Reprocessamento**: Interface para retry manual
- ‚úÖ **M√©tricas**: Tracking de taxa de DLQ (ex: 1% aceit√°vel)
- ‚úÖ **Persist√™ncia**: DLQ em storage dur√°vel (n√£o apenas mem√≥ria)

---

## üîó Integra√ß√£o com Frameworks

### RabbitMQ

```java
@Bean
Queue deadLetterQueue() {
    return new Queue("pedidos.dlq");
}

@Bean
Queue mainQueue() {
    return QueueBuilder.durable("pedidos")
        .withArgument("x-dead-letter-exchange", "")
        .withArgument("x-dead-letter-routing-key", "pedidos.dlq")
        .withArgument("x-message-ttl", 60000)
        .build();
}
```

### AWS SQS

```java
CreateQueueRequest dlqRequest = CreateQueueRequest.builder()
    .queueName("pedidos-dlq")
    .build();
String dlqUrl = sqs.createQueue(dlqRequest).queueUrl();

CreateQueueRequest mainRequest = CreateQueueRequest.builder()
    .queueName("pedidos")
    .attributes(Map.of(
        QueueAttributeName.REDRIVE_POLICY,
        "{\"maxReceiveCount\":\"3\",\"deadLetterTargetArn\":\"" + dlqArn + "\"}"
    ))
    .build();
```

### Apache Kafka

```java
@KafkaListener(topics = "pedidos.dlq")
public void handleDLQ(ConsumerRecord<String, String> record) {
    // Processar mensagens da DLQ
    log.error("DLQ: key={}, value={}", record.key(), record.value());
}
```

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens                  | ‚ö†Ô∏è Desvantagens              |
| ----------------------------- | ---------------------------- |
| Evita loop infinito           | Requer monitoramento         |
| Isola mensagens problem√°ticas | Overhead de storage          |
| Facilita debugging            | Pode acumular se n√£o tratada |
| Permite reprocessamento       | Complexidade operacional     |
| Auditoria de falhas           | Risco de perder contexto     |

---

## üß† Exerc√≠cios Pr√°ticos

1. **Implementar DLQ com TTL** (expirar mensagens antigas automaticamente)
2. **Criar dashboard** mostrando motivos mais frequentes na DLQ
3. **Adicionar classifica√ß√£o** de erros (tempor√°rio vs permanente)
4. **Implementar reprocessamento em batch** com rate limiting
5. **Integrar com sistema de alertas** (PagerDuty, Slack) quando DLQ crescer

---

## üìö Relacionado

- **Retry Pattern**: Combinado com DLQ para tentativas antes de isolar
- **Circuit Breaker**: Pode enviar para DLQ quando circuito aberto
- **Publisher/Subscriber**: DLQ isola mensagens problem√°ticas de subscribers
- **Idempot√™ncia**: Essencial para reprocessamento seguro de mensagens da DLQ

---

**Dead Letter Queue isola mensagens problem√°ticas para evitar travamento, mas requer monitoramento ativo e estrat√©gia de reprocessamento!** üíÄ‚ú®
