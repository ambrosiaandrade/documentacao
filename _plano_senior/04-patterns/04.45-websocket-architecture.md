# 04.45 WebSocket Architecture [AVAN√áADO] üîÑ

## üéØ Objetivo

Criar comunica√ß√£o **bidirecional em tempo real** entre cliente e servidor usando WebSocket, permitindo **push notifications**, **chat**, **live updates** e **colabora√ß√£o** sem polling.

---

## üìö O Que √â?

**WebSocket** √© um protocolo de comunica√ß√£o full-duplex sobre TCP que permite conex√£o persistente entre cliente e servidor, habilitando troca de mensagens em tempo real nos dois sentidos.

### Analogia

Como **telefone (vs carta)**:

- **HTTP Request**: Carta (envia e espera resposta)
- **WebSocket**: Telefone (conex√£o aberta, conversa bidirecional)
- **Vantagem**: Comunica√ß√£o instant√¢nea sem espera

---

## ‚ùå Problema que Resolve

### Antes (HTTP Polling - Ineficiente)

```java
// ‚ùå PROBLEMA: Polling desperdi√ßa recursos

@RestController
@RequestMapping("/api/notificacoes")
class NotificacaoController {

    private final List<Notificacao> notificacoes = new CopyOnWriteArrayList<>();

    @GetMapping
    List<Notificacao> buscarNovas() {
        // Cliente chama isso a cada 1 segundo ‚ùå
        return notificacoes;
    }
}

// Cliente JavaScript (polling) ‚ùå
setInterval(() => {
    fetch('/api/notificacoes')
        .then(res => res.json())
        .then(data => atualizarUI(data));
}, 1000); // Polling a cada segundo

// Problemas:
// - Requisi√ß√µes constantes (999 vazias, 1 com dados) ‚ùå
// - Alto consumo de banda ‚ùå
// - Lat√™ncia (1-2s de atraso) ‚ùå
// - Sobrecarga no servidor ‚ùå
// - N√£o √© tempo real ‚ùå
```

**Problemas**:

- üîÑ Polling desperdi√ßa recursos (999 requests vazias)
- ‚è±Ô∏è Lat√™ncia alta (1-2s de atraso)
- üì° Banda desperdi√ßada
- üö´ N√£o √© verdadeiro tempo real

### Depois (WebSocket - Push em Tempo Real)

```java
// ‚úÖ SOLU√á√ÉO: WebSocket com push instant√¢neo

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Broker para subscriptions (cliente recebe)
        config.enableSimpleBroker("/topic", "/queue");

        // Prefix para mensagens do cliente (envia)
        config.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Endpoint WebSocket com fallback SockJS
        registry.addEndpoint("/ws")
            .setAllowedOrigins("http://localhost:3000")
            .withSockJS();
    }
}

@Controller
public class NotificacaoWebSocketController {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public NotificacaoWebSocketController(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // Cliente envia para /app/notificacao
    @MessageMapping("/notificacao")
    @SendTo("/topic/notificacoes")
    public Notificacao enviarNotificacao(Notificacao notificacao) {
        System.out.println("üì® Notifica√ß√£o recebida: " + notificacao.getMensagem());

        // Broadcast para todos os clientes conectados ‚úÖ
        return notificacao;
    }

    // Push para usu√°rio espec√≠fico
    public void notificarUsuario(String username, Notificacao notificacao) {
        System.out.println("üîî Push para " + username);

        // Envia para /queue/notificacoes do usu√°rio espec√≠fico ‚úÖ
        messagingTemplate.convertAndSendToUser(
            username,
            "/queue/notificacoes",
            notificacao
        );
    }

    // Evento do sistema - push autom√°tico
    @EventListener
    public void handlePedidoCriado(PedidoCriadoEvent event) {
        Notificacao notificacao = new Notificacao(
            "Pedido #" + event.getPedidoId() + " criado",
            LocalDateTime.now()
        );

        // Push instant√¢neo para todos ‚úÖ
        messagingTemplate.convertAndSend("/topic/pedidos", notificacao);
    }
}

// Cliente JavaScript (WebSocket) ‚úÖ
const socket = new SockJS('/ws');
const stompClient = Stomp.over(socket);

stompClient.connect({}, (frame) => {
    console.log('‚úÖ Conectado ao WebSocket');

    // Subscreve ao t√≥pico de notifica√ß√µes
    stompClient.subscribe('/topic/notificacoes', (message) => {
        const notificacao = JSON.parse(message.body);
        atualizarUI(notificacao); // Instant√¢neo! ‚úÖ
    });
});

// ‚úÖ Vantagens:
// - 1 conex√£o persistente (vs 1000 requests) ‚úÖ
// - Push instant√¢neo (0ms lat√™ncia) ‚úÖ
// - Bidirecional (cliente e servidor enviam) ‚úÖ
// - Eficiente (baixo overhead) ‚úÖ
// - Tempo real verdadeiro ‚úÖ
```

---

## üîß Implementa√ß√£o Completa

### 1. Configura√ß√£o do Projeto

```xml
<!-- pom.xml -->
<dependencies>
    <!-- Spring WebSocket -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>

    <!-- STOMP -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-messaging</artifactId>
    </dependency>

    <!-- JSON -->
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>

    <!-- SockJS (fallback para browsers antigos) -->
    <dependency>
        <groupId>org.webjars</groupId>
        <artifactId>sockjs-client</artifactId>
        <version>1.5.1</version>
    </dependency>
    <dependency>
        <groupId>org.webjars</groupId>
        <artifactId>stomp-websocket</artifactId>
        <version>2.3.4</version>
    </dependency>
</dependencies>
```

```properties
# application.properties

# WebSocket
spring.websocket.max-text-message-size=512000
spring.websocket.max-binary-message-size=512000

# STOMP
spring.websocket.stomp.relay-host=localhost
spring.websocket.stomp.relay-port=61613
```

### 2. Configura√ß√£o WebSocket Completa

```java
// Configura√ß√£o com seguran√ßa e interceptors

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry config) {
        // Simple in-memory broker
        config.enableSimpleBroker(
            "/topic",  // Pub-Sub (broadcast)
            "/queue"   // Point-to-point (usu√°rio espec√≠fico)
        );

        // Prefix para mensagens do cliente
        config.setApplicationDestinationPrefixes("/app");

        // Prefix para mensagens de usu√°rio
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry
            .addEndpoint("/ws")
            .setAllowedOrigins("http://localhost:3000", "https://app.example.com")
            .withSockJS()
            .setClientLibraryUrl("https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js");
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        // Interceptor para autentica√ß√£o
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor =
                    MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);

                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    String token = accessor.getFirstNativeHeader("Authorization");
                    if (token != null && token.startsWith("Bearer ")) {
                        // Validar token JWT
                        String username = validarToken(token.substring(7));
                        accessor.setUser(new UsernamePasswordAuthenticationToken(
                            username, null, Collections.emptyList()
                        ));
                    }
                }
                return message;
            }

            private String validarToken(String token) {
                // Implementar valida√ß√£o JWT
                return "usuario123";
            }
        });
    }
}
```

### 3. Chat em Tempo Real (Completo)

```java
// Modelo

@Data
@AllArgsConstructor
@NoArgsConstructor
public class MensagemChat {
    private String id;
    private String remetenteId;
    private String remetenteNome;
    private String conteudo;
    private String salaId;
    private LocalDateTime dataHora;
    private TipoMensagem tipo;

    public enum TipoMensagem {
        CHAT, JOIN, LEAVE, TYPING
    }
}

// Controller do Chat

@Controller
public class ChatController {

    private final SimpMessagingTemplate messagingTemplate;
    private final ChatService chatService;

    @Autowired
    public ChatController(
        SimpMessagingTemplate messagingTemplate,
        ChatService chatService
    ) {
        this.messagingTemplate = messagingTemplate;
        this.chatService = chatService;
    }

    // Enviar mensagem para sala
    @MessageMapping("/chat.send/{salaId}")
    @SendTo("/topic/chat/{salaId}")
    public MensagemChat enviarMensagem(
        @DestinationVariable String salaId,
        MensagemChat mensagem,
        Principal principal
    ) {
        System.out.println("üí¨ [Chat] Mensagem de " + principal.getName() +
                          " para sala " + salaId);

        // Enriquecer mensagem
        mensagem.setId(UUID.randomUUID().toString());
        mensagem.setRemetenteId(principal.getName());
        mensagem.setDataHora(LocalDateTime.now());
        mensagem.setSalaId(salaId);

        // Salvar no banco
        chatService.salvarMensagem(mensagem);

        return mensagem;
    }

    // Mensagem privada entre usu√°rios
    @MessageMapping("/chat.private")
    public void enviarMensagemPrivada(
        @Payload MensagemChat mensagem,
        Principal principal
    ) {
        System.out.println("üîí [Chat Privado] De " + principal.getName() +
                          " para " + mensagem.getRemetenteId());

        mensagem.setRemetenteId(principal.getName());
        mensagem.setDataHora(LocalDateTime.now());

        // Enviar para destinat√°rio espec√≠fico
        messagingTemplate.convertAndSendToUser(
            mensagem.getRemetenteId(),
            "/queue/messages",
            mensagem
        );
    }

    // Indicador "digitando..."
    @MessageMapping("/chat.typing/{salaId}")
    public void digitando(
        @DestinationVariable String salaId,
        Principal principal
    ) {
        MensagemChat typing = new MensagemChat();
        typing.setRemetenteNome(principal.getName());
        typing.setTipo(MensagemChat.TipoMensagem.TYPING);
        typing.setSalaId(salaId);

        // Broadcast para sala (exceto remetente)
        messagingTemplate.convertAndSend(
            "/topic/chat/" + salaId + "/typing",
            typing
        );
    }

    // Usu√°rio entrou na sala
    @MessageMapping("/chat.join/{salaId}")
    @SendTo("/topic/chat/{salaId}")
    public MensagemChat entrarNaSala(
        @DestinationVariable String salaId,
        Principal principal
    ) {
        System.out.println("üëã [Chat] " + principal.getName() + " entrou na sala " + salaId);

        MensagemChat mensagem = new MensagemChat();
        mensagem.setId(UUID.randomUUID().toString());
        mensagem.setRemetenteNome(principal.getName());
        mensagem.setConteudo(principal.getName() + " entrou na sala");
        mensagem.setTipo(MensagemChat.TipoMensagem.JOIN);
        mensagem.setSalaId(salaId);
        mensagem.setDataHora(LocalDateTime.now());

        return mensagem;
    }

    // Hist√≥rico de mensagens (primeira conex√£o)
    @SubscribeMapping("/chat.history/{salaId}")
    public List<MensagemChat> obterHistorico(@DestinationVariable String salaId) {
        System.out.println("üìú [Chat] Carregando hist√≥rico da sala " + salaId);
        return chatService.obterHistorico(salaId, 50);
    }
}
```

### 4. Live Notifications (Notifica√ß√µes Push)

```java
// Notifica√ß√£o em tempo real

@Service
public class NotificacaoWebSocketService {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public NotificacaoWebSocketService(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // Broadcast para todos os usu√°rios
    public void notificarTodos(Notificacao notificacao) {
        System.out.println("üì¢ [Notifica√ß√£o] Broadcast: " + notificacao.getMensagem());

        messagingTemplate.convertAndSend(
            "/topic/notificacoes",
            notificacao
        );
    }

    // Notifica√ß√£o para usu√°rio espec√≠fico
    public void notificarUsuario(String username, Notificacao notificacao) {
        System.out.println("üîî [Notifica√ß√£o] Para " + username + ": " +
                          notificacao.getMensagem());

        messagingTemplate.convertAndSendToUser(
            username,
            "/queue/notificacoes",
            notificacao
        );
    }

    // Notifica√ß√£o para grupo de usu√°rios
    public void notificarGrupo(List<String> usernames, Notificacao notificacao) {
        System.out.println("üë• [Notifica√ß√£o] Para grupo de " + usernames.size() + " usu√°rios");

        usernames.forEach(username ->
            messagingTemplate.convertAndSendToUser(
                username,
                "/queue/notificacoes",
                notificacao
            )
        );
    }
}

@Data
@AllArgsConstructor
public class Notificacao {
    private String id;
    private String titulo;
    private String mensagem;
    private TipoNotificacao tipo;
    private LocalDateTime dataHora;
    private Map<String, Object> dados;

    public enum TipoNotificacao {
        INFO, SUCCESS, WARNING, ERROR
    }
}

// Integra√ß√£o com eventos do sistema

@Component
public class NotificacaoEventListener {

    private final NotificacaoWebSocketService notificacaoService;

    @Autowired
    public NotificacaoEventListener(NotificacaoWebSocketService notificacaoService) {
        this.notificacaoService = notificacaoService;
    }

    @EventListener
    public void onPedidoCriado(PedidoCriadoEvent event) {
        Notificacao notificacao = new Notificacao(
            UUID.randomUUID().toString(),
            "Novo Pedido",
            "Pedido #" + event.getPedidoId() + " criado com sucesso",
            Notificacao.TipoNotificacao.SUCCESS,
            LocalDateTime.now(),
            Map.of("pedidoId", event.getPedidoId())
        );

        // Notificar usu√°rio que criou o pedido
        notificacaoService.notificarUsuario(event.getUsername(), notificacao);
    }

    @EventListener
    public void onEstoqueBaixo(EstoqueBaixoEvent event) {
        Notificacao notificacao = new Notificacao(
            UUID.randomUUID().toString(),
            "Estoque Baixo",
            "Produto " + event.getProdutoNome() + " com estoque baixo: " + event.getQuantidade(),
            Notificacao.TipoNotificacao.WARNING,
            LocalDateTime.now(),
            Map.of("produtoId", event.getProdutoId())
        );

        // Notificar todos os admins
        notificacaoService.notificarGrupo(event.getAdmins(), notificacao);
    }
}
```

### 5. Live Dashboard (Atualiza√ß√£o em Tempo Real)

```java
// Dashboard com m√©tricas em tempo real

@Controller
public class DashboardWebSocketController {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public DashboardWebSocketController(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // Atualizar m√©tricas em tempo real
    @Scheduled(fixedRate = 2000) // A cada 2 segundos
    public void enviarMetricas() {
        DashboardMetricas metricas = calcularMetricas();

        messagingTemplate.convertAndSend(
            "/topic/dashboard/metricas",
            metricas
        );
    }

    // Atualizar lista de pedidos em tempo real
    @EventListener
    public void onPedidoAtualizado(PedidoAtualizadoEvent event) {
        PedidoDTO pedido = converterParaDTO(event.getPedido());

        messagingTemplate.convertAndSend(
            "/topic/dashboard/pedidos",
            pedido
        );
    }

    // Gr√°fico em tempo real
    @Scheduled(fixedRate = 1000) // A cada 1 segundo
    public void enviarDadosGrafico() {
        GraficoPonto ponto = new GraficoPonto(
            LocalDateTime.now(),
            obterVendasUltimoSegundo()
        );

        messagingTemplate.convertAndSend(
            "/topic/dashboard/grafico",
            ponto
        );
    }

    private DashboardMetricas calcularMetricas() {
        return new DashboardMetricas(
            pedidoRepository.countByStatus(Status.PENDENTE),
            pedidoRepository.sumTotalByDataGreaterThan(LocalDate.now()),
            usuarioRepository.countByConectado(true)
        );
    }
}

@Data
@AllArgsConstructor
class DashboardMetricas {
    private long pedidosPendentes;
    private BigDecimal vendasHoje;
    private long usuariosOnline;
}

@Data
@AllArgsConstructor
class GraficoPonto {
    private LocalDateTime timestamp;
    private BigDecimal valor;
}
```

### 6. Cliente JavaScript (Frontend)

```javascript
// Cliente WebSocket completo

class WebSocketClient {
  constructor(url) {
    this.url = url;
    this.stompClient = null;
    this.subscriptions = new Map();
  }

  // Conectar com autentica√ß√£o
  connect(token) {
    const socket = new SockJS(this.url);
    this.stompClient = Stomp.over(socket);

    // Headers de conex√£o
    const headers = {
      Authorization: `Bearer ${token}`,
    };

    // Conectar
    this.stompClient.connect(
      headers,
      (frame) => this.onConnected(frame),
      (error) => this.onError(error)
    );
  }

  onConnected(frame) {
    console.log("‚úÖ WebSocket conectado:", frame);

    // Subscrever a notifica√ß√µes pessoais
    this.subscribe("/user/queue/notificacoes", (message) => {
      const notificacao = JSON.parse(message.body);
      this.exibirNotificacao(notificacao);
    });

    // Subscrever a broadcasts
    this.subscribe("/topic/notificacoes", (message) => {
      const notificacao = JSON.parse(message.body);
      this.exibirNotificacao(notificacao);
    });
  }

  onError(error) {
    console.error("‚ùå Erro WebSocket:", error);

    // Reconectar ap√≥s 5 segundos
    setTimeout(() => this.reconnect(), 5000);
  }

  // Subscrever a um t√≥pico
  subscribe(destination, callback) {
    if (!this.stompClient?.connected) {
      console.error("‚ùå WebSocket n√£o conectado");
      return;
    }

    const subscription = this.stompClient.subscribe(destination, callback);
    this.subscriptions.set(destination, subscription);

    console.log("üì° Subscrito a:", destination);
  }

  // Cancelar subscri√ß√£o
  unsubscribe(destination) {
    const subscription = this.subscriptions.get(destination);
    if (subscription) {
      subscription.unsubscribe();
      this.subscriptions.delete(destination);
      console.log("‚ùå Dessubscrito de:", destination);
    }
  }

  // Enviar mensagem
  send(destination, message) {
    if (!this.stompClient?.connected) {
      console.error("‚ùå WebSocket n√£o conectado");
      return;
    }

    this.stompClient.send(destination, {}, JSON.stringify(message));
    console.log("üì§ Mensagem enviada para:", destination);
  }

  // Desconectar
  disconnect() {
    if (this.stompClient?.connected) {
      this.stompClient.disconnect(() => {
        console.log("üëã WebSocket desconectado");
      });
    }
  }

  exibirNotificacao(notificacao) {
    // Implementar UI de notifica√ß√£o
    console.log("üîî Notifica√ß√£o:", notificacao);
  }
}

// Uso
const ws = new WebSocketClient("/ws");
ws.connect("seu-jwt-token");

// Chat
ws.subscribe("/topic/chat/sala123", (message) => {
  const msg = JSON.parse(message.body);
  adicionarMensagemNoChat(msg);
});

ws.send("/app/chat.send/sala123", {
  conteudo: "Ol√°, mundo!",
  tipo: "CHAT",
});

// Dashboard
ws.subscribe("/topic/dashboard/metricas", (message) => {
  const metricas = JSON.parse(message.body);
  atualizarDashboard(metricas);
});
```

### 7. Event Listeners e Lifecycle

```java
// Gerenciar conex√µes e desconex√µes

@Component
public class WebSocketEventListener {

    private final SimpMessagingTemplate messagingTemplate;
    private final Map<String, String> usuariosConectados = new ConcurrentHashMap<>();

    @Autowired
    public WebSocketEventListener(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    @EventListener
    public void handleWebSocketConnectListener(SessionConnectedEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String sessionId = headerAccessor.getSessionId();
        String username = headerAccessor.getUser().getName();

        usuariosConectados.put(sessionId, username);

        System.out.println("‚úÖ [WebSocket] Usu√°rio conectado: " + username +
                          " (sess√£o: " + sessionId + ")");

        // Notificar outros usu√°rios
        messagingTemplate.convertAndSend("/topic/usuarios/online",
            new UsuarioOnlineEvent(username, true)
        );
    }

    @EventListener
    public void handleWebSocketDisconnectListener(SessionDisconnectEvent event) {
        StompHeaderAccessor headerAccessor = StompHeaderAccessor.wrap(event.getMessage());
        String sessionId = headerAccessor.getSessionId();
        String username = usuariosConectados.remove(sessionId);

        if (username != null) {
            System.out.println("‚ùå [WebSocket] Usu√°rio desconectado: " + username);

            // Notificar que usu√°rio saiu
            messagingTemplate.convertAndSend("/topic/usuarios/online",
                new UsuarioOnlineEvent(username, false)
            );
        }
    }

    public List<String> getUsuariosOnline() {
        return new ArrayList<>(usuariosConectados.values());
    }
}

@Data
@AllArgsConstructor
class UsuarioOnlineEvent {
    private String username;
    private boolean online;
}
```

---

## üß™ Como Testar

### 1. Teste de Configura√ß√£o WebSocket

```java
@SpringBootTest
class WebSocketConfigTest {

    @Autowired
    private WebSocketConfig config;

    @Test
    void deveConfigurarWebSocketCorretamente() {
        assertNotNull(config);
    }
}
```

### 2. Teste de Chat com WebSocket

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class ChatWebSocketTest {

    @LocalServerPort
    private int port;

    private WebSocketStompClient stompClient;
    private StompSession session;

    @BeforeEach
    void setUp() throws Exception {
        WebSocketClient webSocketClient = new StandardWebSocketClient();

        this.stompClient = new WebSocketStompClient(webSocketClient);
        this.stompClient.setMessageConverter(new MappingJackson2MessageConverter());

        String url = "ws://localhost:" + port + "/ws";
        this.session = stompClient.connect(url, new StompSessionHandlerAdapter() {})
            .get(1, TimeUnit.SECONDS);
    }

    @AfterEach
    void tearDown() {
        if (session != null && session.isConnected()) {
            session.disconnect();
        }
    }

    @Test
    void deveEnviarEReceberMensagemDeChat() throws Exception {
        // Arrange
        CompletableFuture<MensagemChat> future = new CompletableFuture<>();

        session.subscribe("/topic/chat/sala123", new StompFrameHandler() {
            @Override
            public Type getPayloadType(StompHeaders headers) {
                return MensagemChat.class;
            }

            @Override
            public void handleFrame(StompHeaders headers, Object payload) {
                future.complete((MensagemChat) payload);
            }
        });

        // Act
        MensagemChat mensagem = new MensagemChat();
        mensagem.setConteudo("Teste WebSocket");
        mensagem.setTipo(MensagemChat.TipoMensagem.CHAT);

        session.send("/app/chat.send/sala123", mensagem);

        // Assert
        MensagemChat recebida = future.get(3, TimeUnit.SECONDS);
        assertNotNull(recebida);
        assertEquals("Teste WebSocket", recebida.getConteudo());
    }
}
```

### 3. Teste de Notifica√ß√£o Push

```java
@SpringBootTest
class NotificacaoWebSocketServiceTest {

    @Mock
    private SimpMessagingTemplate messagingTemplate;

    @InjectMocks
    private NotificacaoWebSocketService service;

    @Test
    void deveNotificarUsuarioEspecifico() {
        // Arrange
        Notificacao notificacao = new Notificacao(
            "1",
            "Teste",
            "Mensagem de teste",
            Notificacao.TipoNotificacao.INFO,
            LocalDateTime.now(),
            Map.of()
        );

        // Act
        service.notificarUsuario("usuario123", notificacao);

        // Assert
        verify(messagingTemplate).convertAndSendToUser(
            eq("usuario123"),
            eq("/queue/notificacoes"),
            eq(notificacao)
        );
    }

    @Test
    void deveFazerBroadcastParaTodos() {
        // Arrange
        Notificacao notificacao = new Notificacao(
            "2",
            "Broadcast",
            "Mensagem para todos",
            Notificacao.TipoNotificacao.INFO,
            LocalDateTime.now(),
            Map.of()
        );

        // Act
        service.notificarTodos(notificacao);

        // Assert
        verify(messagingTemplate).convertAndSend(
            eq("/topic/notificacoes"),
            eq(notificacao)
        );
    }
}
```

---

## üìä Boas Pr√°ticas

- ‚úÖ **Autentica√ß√£o**: Validar token JWT no CONNECT
- ‚úÖ **Reconnection**: Implementar reconex√£o autom√°tica
- ‚úÖ **Heartbeat**: Configurar ping/pong para manter conex√£o
- ‚úÖ **Rate Limiting**: Limitar mensagens por usu√°rio
- ‚úÖ **Error Handling**: Tratar erros de conex√£o gracefully
- ‚úÖ **Logging**: Logar conex√µes, mensagens e erros
- ‚úÖ **Monitoring**: Monitorar conex√µes ativas e lat√™ncia

---

## üîó WebSocket vs HTTP Polling vs SSE

| Caracter√≠stica   | WebSocket       | HTTP Polling  | SSE           |
| ---------------- | --------------- | ------------- | ------------- |
| **Dire√ß√£o**      | ‚úÖ Bidirecional | Unidirecional | Unidirecional |
| **Lat√™ncia**     | ‚ö° ~0ms         | üêå 1-5s       | üöÄ ~100ms     |
| **Overhead**     | Baixo           | ‚ùå Alto       | M√©dio         |
| **Protocolo**    | ws://           | HTTP          | HTTP          |
| **Browser**      | ‚úÖ Todos        | ‚úÖ Todos      | ‚ö†Ô∏è N√£o IE     |
| **Complexidade** | M√©dia           | Baixa         | Baixa         |

---

## ‚úÖ Vantagens vs ‚ö†Ô∏è Desvantagens

| ‚úÖ Vantagens          | ‚ö†Ô∏è Desvantagens           |
| --------------------- | ------------------------- |
| Tempo real verdadeiro | Complexidade maior        |
| Bidirecional          | Stateful (sess√µes)        |
| Baixa lat√™ncia (~0ms) | Escalabilidade (conex√µes) |
| Baixo overhead        | Load balancing complexo   |
| Push instant√¢neo      | Debugging mais dif√≠cil    |
| Eficiente (1 conex√£o) | Requer WebSocket support  |

---

## üîç Quando Usar vs N√£o Usar

### ‚úÖ Use WebSocket quando:

- Chat em tempo real
- Live notifications
- Collaborative editing
- Gaming online
- Live dashboard/metrics
- Streaming de dados

### ‚ùå Evite WebSocket quando:

- API REST suficiente
- N√£o precisa tempo real
- Dados n√£o mudam frequentemente
- Simplicidade priorit√°ria
- Requisi√ß√µes one-off

---

**WebSocket permite comunica√ß√£o bidirecional em tempo real com lat√™ncia zero!** üîÑ‚ö°
