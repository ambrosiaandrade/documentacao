# 4.4 Timeout Pattern [EXPERT]

üéØ **Objetivo:** Implementar e testar o padr√£o Timeout para limitar tempo m√°ximo de execu√ß√£o de opera√ß√µes, evitando bloqueios indefinidos de recursos.

---

## ‚è± O Que √â Timeout Pattern?

Padr√£o que **limita o tempo m√°ximo** de espera por uma opera√ß√£o, liberando recursos se exceder o limite e permitindo **fail-fast** em vez de bloqueio indefinido.

### Analogia

Como um cron√¥metro de estacionamento: voc√™ tem tempo limitado, e se exceder, a opera√ß√£o √© cancelada para n√£o bloquear outros.

---

## üéØ Problema que Resolve

### Cen√°rio Sem Timeout

```
Thread 1 ‚Üí Chamada HTTP (servidor lento, nunca responde)
  ‚Üì
Thread bloqueada indefinidamente
  ‚Üì
Pool de threads esgota
  ‚Üì
Sistema trava completamente
```

### Com Timeout

```
Thread 1 ‚Üí Chamada HTTP + Timeout(5s)
  ‚Üì
Timeout excedido ap√≥s 5s
  ‚Üì
TimeoutException lan√ßada
  ‚Üì
Thread liberada, sistema continua funcionando
```

---

## üìä Tipos de Timeout

### 1. Connection Timeout

Tempo m√°ximo para **estabelecer conex√£o**.

```java
HttpClient client = HttpClient.newBuilder()
    .connectTimeout(Duration.ofSeconds(5))
    .build();
```

### 2. Read/Response Timeout

Tempo m√°ximo para **receber resposta completa**.

```java
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com"))
    .timeout(Duration.ofSeconds(10))
    .build();
```

### 3. Execution Timeout

Tempo m√°ximo para **executar opera√ß√£o completa**.

```java
ExecutorService executor = Executors.newSingleThreadExecutor();
Future<String> future = executor.submit(() -> operacaoLonga());
String result = future.get(5, TimeUnit.SECONDS); // TimeoutException se exceder
```

---

## üíª Implementa√ß√£o com Java 17

### Estrutura Base com CompletableFuture

```java
import java.util.concurrent.*;
import java.util.function.Supplier;

final class TimeoutExecutor {
    private final ExecutorService executor;

    TimeoutExecutor() {
        this.executor = Executors.newCachedThreadPool();
    }

    public <T> T executarComTimeout(Supplier<T> operacao,
                                     long timeout,
                                     TimeUnit unidade) throws TimeoutException {
        CompletableFuture<T> future = CompletableFuture.supplyAsync(operacao, executor);

        try {
            return future.get(timeout, unidade);
        } catch (TimeoutException e) {
            future.cancel(true);
            throw new TimeoutException(
                String.format("Opera√ß√£o excedeu timeout de %d %s", timeout, unidade)
            );
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("Opera√ß√£o interrompida", e);
        } catch (ExecutionException e) {
            throw new RuntimeException("Erro na execu√ß√£o", e.getCause());
        }
    }

    public void shutdown() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### Implementa√ß√£o com Virtual Threads (Java 21+)

```java
final class TimeoutExecutorVirtual {

    public <T> T executarComTimeout(Supplier<T> operacao,
                                     Duration timeout) throws TimeoutException {
        try {
            return CompletableFuture.supplyAsync(operacao,
                    Executors.newVirtualThreadPerTaskExecutor())
                .orTimeout(timeout.toMillis(), TimeUnit.MILLISECONDS)
                .join();
        } catch (CompletionException e) {
            if (e.getCause() instanceof java.util.concurrent.TimeoutException) {
                throw new TimeoutException("Opera√ß√£o excedeu " + timeout);
            }
            throw new RuntimeException("Erro na execu√ß√£o", e.getCause());
        }
    }
}
```

### Timeout com JUnit 5

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;
import static java.util.concurrent.TimeUnit.*;

class ExemploTimeoutTest {

    @Test
    @Timeout(value = 500, unit = MILLISECONDS)
    void deveExecutarRapidamente() {
        // Se levar mais de 500ms, teste falha
        operacaoRapida();
    }

    @Test
    @Timeout(1)
    void timeoutPadraoEmSegundos() {
        // Timeout padr√£o: 1 segundo
        operacao();
    }
}
```

---

## üß™ Como Testar o Pattern

### Teste 1: Opera√ß√£o Completa Dentro do Timeout

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.AfterEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.concurrent.*;

class TimeoutExecutorTest {

    private TimeoutExecutor executor = new TimeoutExecutor();

    @AfterEach
    void cleanup() {
        executor.shutdown();
    }

    @Test
    void deveCompletarOperacaoDentroDoTimeout() throws TimeoutException {
        Supplier<String> operacaoRapida = () -> {
            sleep(100); // 100ms
            return "OK";
        };

        String resultado = executor.executarComTimeout(
            operacaoRapida,
            500,
            TimeUnit.MILLISECONDS
        );

        assertEquals("OK", resultado);
    }

    private void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

### Teste 2: Timeout Excedido

```java
@Test
void deveLancarTimeoutExceptionSeExceder() {
    Supplier<String> operacaoLenta = () -> {
        sleep(2000); // 2 segundos
        return "NUNCA_RETORNA";
    };

    TimeoutException ex = assertThrows(TimeoutException.class, () -> {
        executor.executarComTimeout(operacaoLenta, 100, TimeUnit.MILLISECONDS);
    });

    assertTrue(ex.getMessage().contains("excedeu timeout"));
}
```

### Teste 3: Validar Tempo de Execu√ß√£o

```java
@Test
void deveRespeitarLimiteDeTempo() {
    Supplier<String> operacaoInfinita = () -> {
        while (true) {
            if (Thread.currentThread().isInterrupted()) {
                break;
            }
        }
        return "IMPOSS√çVEL";
    };

    long inicio = System.currentTimeMillis();

    assertThrows(TimeoutException.class, () -> {
        executor.executarComTimeout(operacaoInfinita, 200, TimeUnit.MILLISECONDS);
    });

    long duracao = System.currentTimeMillis() - inicio;

    // Deve ter parado pr√≥ximo ao timeout
    assertTrue(duracao < 300, "Dura√ß√£o: " + duracao + "ms");
    assertTrue(duracao >= 200, "Dura√ß√£o: " + duracao + "ms");
}
```

### Teste 4: Timeout com Exce√ß√£o na Opera√ß√£o

```java
@Test
void devePropAgarExcecaoDaOperacao() {
    Supplier<String> operacaoComErro = () -> {
        throw new IllegalStateException("Erro interno");
    };

    RuntimeException ex = assertThrows(RuntimeException.class, () -> {
        executor.executarComTimeout(operacaoComErro, 1, TimeUnit.SECONDS);
    });

    assertEquals("Erro na execu√ß√£o", ex.getMessage());
    assertInstanceOf(IllegalStateException.class, ex.getCause());
}
```

### Teste 5: Timeout com JUnit @Timeout

```java
@Test
@Timeout(value = 200, unit = TimeUnit.MILLISECONDS)
void testComAnnotationTimeout() {
    // Este teste falha se levar mais de 200ms
    operacaoRapida();
}

@Test
void testSemAnnotation() {
    // Testar que opera√ß√£o lenta SEM timeout falha corretamente
    assertThrows(Exception.class, () -> {
        // Simular opera√ß√£o que deveria ter timeout
        Thread.sleep(5000);
    });
}
```

### Teste 6: M√∫ltiplas Opera√ß√µes Concorrentes

```java
@Test
void deveHandlerMultiplasOperacoesComTimeout() throws InterruptedException {
    int numOperacoes = 10;
    CountDownLatch latch = new CountDownLatch(numOperacoes);
    AtomicInteger sucessos = new AtomicInteger(0);
    AtomicInteger timeouts = new AtomicInteger(0);

    for (int i = 0; i < numOperacoes; i++) {
        int index = i;
        new Thread(() -> {
            try {
                Supplier<String> op = () -> {
                    sleep(index * 50); // Varia de 0 a 450ms
                    return "OK-" + index;
                };

                executor.executarComTimeout(op, 300, TimeUnit.MILLISECONDS);
                sucessos.incrementAndGet();

            } catch (TimeoutException e) {
                timeouts.incrementAndGet();
            } finally {
                latch.countDown();
            }
        }).start();
    }

    assertTrue(latch.await(2, TimeUnit.SECONDS));

    // Opera√ß√µes 0-6 devem suceder (0-300ms)
    // Opera√ß√µes 7-9 devem dar timeout (350-450ms)
    assertTrue(sucessos.get() >= 6, "Sucessos: " + sucessos.get());
    assertTrue(timeouts.get() >= 3, "Timeouts: " + timeouts.get());
}
```

### Teste 7: Timeout com CompletableFuture

```java
@Test
void testTimeoutComCompletableFuture() {
    CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
        sleep(2000);
        return "LENTO";
    });

    assertThrows(TimeoutException.class, () -> {
        future.get(100, TimeUnit.MILLISECONDS);
    });

    // Verificar que future foi cancelado
    assertTrue(future.isCancelled() || !future.isDone());
}
```

---

## ‚ö† Cuidados Importantes

### 1. Cancelamento de Tarefas

```java
// ‚ùå PROBLEMA - Thread n√£o respeita interrup√ß√£o
Supplier<String> operacaoNaoCancelavel = () -> {
    while (true) {
        // Ignora Thread.interrupted()
        processarAlgo();
    }
};

// ‚úÖ BOM - Verificar interrup√ß√£o
Supplier<String> operacaoCancelavel = () -> {
    while (!Thread.currentThread().isInterrupted()) {
        processarAlgo();
    }
    return "CANCELADO";
};
```

### 2. Recursos N√£o Liberados

```java
// ‚ùå PERIGO - Conex√£o n√£o fechada em timeout
Supplier<String> comVazamento = () -> {
    Connection conn = openConnection();
    // Se timeout, conex√£o fica aberta!
    return processarDados(conn);
};

// ‚úÖ SEGURO - Try-with-resources
Supplier<String> seguro = () -> {
    try (Connection conn = openConnection()) {
        return processarDados(conn);
    }
};
```

### 3. Timeout Muito Curto

```java
// ‚ùå Timeout irrealista
@Timeout(value = 1, unit = TimeUnit.MILLISECONDS) // 1ms √© imposs√≠vel!

// ‚úÖ Timeout realista considerando lat√™ncia
@Timeout(value = 500, unit = TimeUnit.MILLISECONDS) // 500ms razo√°vel
```

---

## üìä Boas Pr√°ticas de Teste

### ‚úÖ O Que Testar

- [ ] Opera√ß√£o **completa dentro** do timeout
- [ ] **TimeoutException** lan√ßada ao exceder
- [ ] **Tempo real** pr√≥ximo ao configurado
- [ ] Exce√ß√µes da opera√ß√£o **propagadas** corretamente
- [ ] **Cancelamento** de opera√ß√£o em progresso
- [ ] **Thread liberada** ap√≥s timeout
- [ ] M√∫ltiplas opera√ß√µes **concorrentes**
- [ ] **Recursos fechados** mesmo em timeout

### ‚ö† Evitar

- ‚ùå Timeouts irrealistas (muito curtos ou longos)
- ‚ùå Ignorar `Thread.interrupted()` em opera√ß√µes
- ‚ùå Vazamento de recursos (conex√µes, arquivos)
- ‚ùå Testes flaky por varia√ß√£o de performance

---

## ‚öô Frameworks de Produ√ß√£o

### Resilience4j TimeLimiter

```java
TimeLimiterConfig config = TimeLimiterConfig.custom()
    .timeoutDuration(Duration.ofSeconds(5))
    .cancelRunningFuture(true)
    .build();

TimeLimiter limiter = TimeLimiter.of("api", config);

Supplier<String> decorated = TimeLimiter.decorateSupplier(
    limiter,
    () -> remoteService.call()
);

String result = decorated.get();
```

### Spring @Timeout

```java
@Service
public class UserService {

    @Async
    @Timeout(value = 5000) // 5 segundos
    public CompletableFuture<User> buscarUsuario(Long id) {
        return CompletableFuture.completedFuture(
            userRepository.findById(id).orElseThrow()
        );
    }
}
```

### HTTP Client Timeout

```java
HttpClient client = HttpClient.newBuilder()
    .connectTimeout(Duration.ofSeconds(5))
    .build();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com"))
    .timeout(Duration.ofSeconds(10))
    .GET()
    .build();

HttpResponse<String> response = client.send(request,
    HttpResponse.BodyHandlers.ofString());
```

---

## üéì Vantagens vs Desvantagens

### ‚úÖ Vantagens

- **Fail-fast**: Falha r√°pida em vez de bloqueio
- **Prote√ß√£o de recursos**: Evita esgotamento de threads
- **Previsibilidade**: SLA definido para opera√ß√µes
- **Detec√ß√£o de problemas**: Identifica opera√ß√µes lentas

### ‚ö† Desvantagens

- **Complexidade**: Gest√£o de threads e cancelamento
- **Falsos positivos**: Timeout pode matar opera√ß√£o leg√≠tima lenta
- **Ajuste fino**: Dif√≠cil encontrar valor ideal
- **Overhead**: Cria√ß√£o de threads/futures

---

## üîç Compara√ß√£o com Outros Patterns

| Pattern             | Comportamento                  | Quando Usar               |
| ------------------- | ------------------------------ | ------------------------- |
| **Timeout**         | Limita tempo m√°ximo            | Sempre em opera√ß√µes I/O   |
| **Circuit Breaker** | Bloqueia ap√≥s padr√£o de falhas | Proteger de instabilidade |
| **Retry**           | Tenta novamente                | Falhas transientes        |
| **Bulkhead**        | Isola pools de recursos        | Evitar contamina√ß√£o       |

### Combina√ß√£o Recomendada

```java
// Timeout + Circuit Breaker + Retry
TimeLimiter limiter = TimeLimiter.of("api", timeoutConfig);
CircuitBreaker cb = CircuitBreaker.of("api", cbConfig);
Retry retry = Retry.of("api", retryConfig);

Supplier<String> resilient = Decorators
    .ofSupplier(() -> remoteService.call())
    .withTimeLimiter(limiter)      // 1. Limitar tempo
    .withCircuitBreaker(cb)         // 2. Proteger instabilidade
    .withRetry(retry)               // 3. Tentar novamente
    .decorate();
```

---

## üß† Exerc√≠cios Pr√°ticos

### 1. Timeout Adaptativo

Implementar timeout que se ajusta baseado em lat√™ncia m√©dia das √∫ltimas N chamadas.

### 2. Timeout com M√©tricas

Adicionar histograma de lat√™ncia, taxa de timeouts, percentil P95/P99.

### 3. Timeout em Cascata

Servi√ßo A chama B que chama C: calcular timeout total considerando cadeia.

### 4. Graceful Degradation

Aumentar timeout gradualmente quando sistema sob carga.

---

## üìö Refer√™ncias

- **Frameworks:**

  - [Resilience4j TimeLimiter](https://resilience4j.readme.io/docs/timeout)
  - [Guava TimeLimiter](https://github.com/google/guava/wiki/ServiceExplained#timelimiter)
  - [Java HttpClient](https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/HttpClient.html)

- **Artigos:**
  - [Martin Fowler - Timeout](https://martinfowler.com/bliki/CircuitBreaker.html)
  - [AWS - Timeouts, Retries and Backoff with Jitter](https://aws.amazon.com/builders-library/timeouts-retries-and-backoff-with-jitter/)

---

## üìö Pr√≥ximos Passos

- [4.1 Circuit Breaker](04.1-circuit-breaker.md) - Prote√ß√£o contra instabilidade
- [4.2 Retry Pattern](04.2-retry.md) - Tentativas autom√°ticas
- [4.3 Fallback Pattern](04.3-fallback.md) - Respostas alternativas
- [4.5 Bulkhead Pattern](04.5-bulkhead.md) - Isolamento de recursos
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [EXPERT]  
**Tempo Estimado:** 2 horas  
**Frameworks:** Resilience4j, Java HttpClient, CompletableFuture
