# 4.3 Fallback Pattern [EXPERT]

üéØ **Objetivo:** Implementar e testar o padr√£o Fallback para fornecer respostas alternativas degradadas quando opera√ß√µes prim√°rias falham, mantendo disponibilidade parcial do servi√ßo.

---

## üõ° O Que √â Fallback Pattern?

Padr√£o que **fornece resposta alternativa** quando a opera√ß√£o prim√°ria falha, permitindo **degrada√ß√£o graciosa** em vez de falha total do sistema.

### Analogia

Como ter um gerador de emerg√™ncia: quando a energia principal falha, o backup assume automaticamente para manter opera√ß√µes essenciais.

---

## üéØ Problema que Resolve

### Cen√°rio Sem Fallback

```
Cliente ‚Üí API Externa (down)
  ‚Üì
ERRO 500 Internal Server Error
  ‚Üì
Usu√°rio recebe tela de erro
  ‚Üì
Experi√™ncia ruim, perda de confian√ßa
```

### Com Fallback

```
Cliente ‚Üí API Externa (down) ‚Üí Cache Local ‚Üí Resposta Degradada
  ‚Üì
Dados levemente desatualizados mas funcionais
  ‚Üì
Usu√°rio continua opera√ß√£o
  ‚Üì
UX mantida, servi√ßo dispon√≠vel
```

---

## üìä Tipos de Fallback

### 1. Cache/Dados Hist√≥ricos

```java
// Tenta API, se falhar usa cache
String resultado = tentarAPI()
    .orElse(buscarDoCache());
```

### 2. Resposta Est√°tica/Padr√£o

```java
// Retorna valor padr√£o conhecido
Usuario usuario = buscarUsuario(id)
    .orElse(Usuario.anonimo());
```

### 3. Funcionalidade Degradada

```java
// Recomenda√ß√µes personalizadas ‚Üí gen√©ricas
List<Produto> recomendacoes = buscarPersonalizadas(userId)
    .orElse(buscarMaisVendidos());
```

### 4. Resposta de Servi√ßo Alternativo

```java
// Provedor prim√°rio ‚Üí secund√°rio
Preco preco = provedorPrincipal.buscar(produto)
    .orElseGet(() -> provedorSecundario.buscar(produto));
```

---

## üíª Implementa√ß√£o com Java 17

### Estrutura Base com Sealed Interfaces

```java
sealed interface Resultado permits ResultadoOk, ResultadoFallback, ResultadoErro {}

record ResultadoOk(String valor, String fonte) implements Resultado {}

record ResultadoFallback(String valor, String motivo, String fonte) implements Resultado {}

record ResultadoErro(String mensagem, Exception causa) implements Resultado {}

@FunctionalInterface
interface Provedor {
    String obter() throws Exception;
}

final class ServicoComFallback {
    private final Provedor primario;
    private final Provedor secundario;
    private final boolean registrarFallback;

    ServicoComFallback(Provedor primario, Provedor secundario) {
        this(primario, secundario, true);
    }

    ServicoComFallback(Provedor primario, Provedor secundario, boolean registrarFallback) {
        this.primario = primario;
        this.secundario = secundario;
        this.registrarFallback = registrarFallback;
    }

    Resultado executar() {
        try {
            String valor = primario.obter();
            return new ResultadoOk(valor, "primario");

        } catch (Exception primarioEx) {
            if (registrarFallback) {
                System.err.println("Fallback ativado: " + primarioEx.getMessage());
            }

            try {
                String valor = secundario.obter();
                return new ResultadoFallback(
                    valor,
                    primarioEx.getClass().getSimpleName(),
                    "secundario"
                );

            } catch (Exception secundarioEx) {
                return new ResultadoErro(
                    "Falha total: primario e secundario indisponiveis",
                    primarioEx
                );
            }
        }
    }
}
```

### Implementa√ß√£o com Optional

```java
import java.util.Optional;

final class ServicoComOptional {
    private final Provedor primario;
    private final Provedor secundario;

    ServicoComOptional(Provedor primario, Provedor secundario) {
        this.primario = primario;
        this.secundario = secundario;
    }

    Optional<String> buscar() {
        try {
            return Optional.of(primario.obter());
        } catch (Exception e) {
            return buscarFallback();
        }
    }

    private Optional<String> buscarFallback() {
        try {
            return Optional.of(secundario.obter());
        } catch (Exception e) {
            return Optional.empty();
        }
    }
}
```

---

## üß™ Como Testar o Pattern

### Teste 1: Sucesso no Provedor Prim√°rio

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class FallbackTest {

    @Test
    void deveRetornarPrimarioQuandoSucesso() throws Exception {
        Provedor primario = mock(Provedor.class);
        Provedor secundario = mock(Provedor.class);
        when(primario.obter()).thenReturn("VALOR_PRIMARIO");

        ServicoComFallback servico = new ServicoComFallback(primario, secundario);

        Resultado resultado = servico.executar();

        assertInstanceOf(ResultadoOk.class, resultado);
        ResultadoOk ok = (ResultadoOk) resultado;
        assertEquals("VALOR_PRIMARIO", ok.valor());
        assertEquals("primario", ok.fonte());

        verify(primario).obter();
        verifyNoInteractions(secundario);
    }
}
```

### Teste 2: Fallback Quando Prim√°rio Falha

```java
@Test
void deveUsarFallbackQuandoPrimarioFalha() throws Exception {
    Provedor primario = mock(Provedor.class);
    Provedor secundario = mock(Provedor.class);
    when(primario.obter()).thenThrow(new RuntimeException("Servi√ßo indispon√≠vel"));
    when(secundario.obter()).thenReturn("CACHE_LOCAL");

    ServicoComFallback servico = new ServicoComFallback(primario, secundario);

    Resultado resultado = servico.executar();

    assertInstanceOf(ResultadoFallback.class, resultado);
    ResultadoFallback fallback = (ResultadoFallback) resultado;
    assertEquals("CACHE_LOCAL", fallback.valor());
    assertEquals("secundario", fallback.fonte());
    assertTrue(fallback.motivo().contains("RuntimeException"));

    verify(primario).obter();
    verify(secundario).obter();
}
```

### Teste 3: Falha Total (Ambos Falham)

```java
@Test
void deveFalharTotalmenteSeAmbosFalham() throws Exception {
    Provedor primario = mock(Provedor.class);
    Provedor secundario = mock(Provedor.class);
    when(primario.obter()).thenThrow(new IllegalStateException("API down"));
    when(secundario.obter()).thenThrow(new IllegalArgumentException("Cache vazio"));

    ServicoComFallback servico = new ServicoComFallback(primario, secundario);

    Resultado resultado = servico.executar();

    assertInstanceOf(ResultadoErro.class, resultado);
    ResultadoErro erro = (ResultadoErro) resultado;
    assertTrue(erro.mensagem().contains("Falha total"));
    assertNotNull(erro.causa());

    verify(primario).obter();
    verify(secundario).obter();
}
```

### Teste 4: Diferentes Tipos de Exce√ß√£o

```java
@Test
void deveTratarDiferentesTiposDeExcecao() throws Exception {
    // Timeout
    Provedor timeout = () -> { throw new TimeoutException("Timeout"); };
    Provedor fallback = () -> "FALLBACK";

    ServicoComFallback servico1 = new ServicoComFallback(timeout, fallback);
    Resultado r1 = servico1.executar();
    assertInstanceOf(ResultadoFallback.class, r1);

    // IOException
    Provedor ioError = () -> { throw new IOException("Network error"); };
    ServicoComFallback servico2 = new ServicoComFallback(ioError, fallback);
    Resultado r2 = servico2.executar();
    assertInstanceOf(ResultadoFallback.class, r2);
}
```

### Teste 5: Verificar Logging de Fallback

```java
@Test
void deveRegistrarAtiva√ß√£oDeFallback() throws Exception {
    ByteArrayOutputStream errContent = new ByteArrayOutputStream();
    System.setErr(new PrintStream(errContent));

    Provedor primario = () -> { throw new RuntimeException("Erro prim√°rio"); };
    Provedor secundario = () -> "FALLBACK";

    ServicoComFallback servico = new ServicoComFallback(primario, secundario, true);
    servico.executar();

    String log = errContent.toString();
    assertTrue(log.contains("Fallback ativado"));
    assertTrue(log.contains("Erro prim√°rio"));

    System.setErr(System.err); // Restaurar
}
```

### Teste 6: Fallback com Cache Expirado

```java
@Test
void deveFalharSeCacheExpirado() throws Exception {
    Provedor apiExterna = () -> { throw new RuntimeException("API down"); };

    // Simular cache com timestamp
    long agora = System.currentTimeMillis();
    long cincoMinutosAtras = agora - (5 * 60 * 1000);

    Provedor cacheExpirado = () -> {
        // Verificar staleness
        if (cincoMinutosAtras < agora - (2 * 60 * 1000)) {
            throw new IllegalStateException("Cache muito antigo");
        }
        return "CACHE";
    };

    ServicoComFallback servico = new ServicoComFallback(apiExterna, cacheExpirado);
    Resultado resultado = servico.executar();

    assertInstanceOf(ResultadoErro.class, resultado);
}
```

### Teste 7: Teste Parametrizado com M√∫ltiplos Cen√°rios

```java
@ParameterizedTest(name = "Cen√°rio {index}: {0}")
@MethodSource("cenariosFallback")
void deveHandlerDiferentesCenarios(String descricao,
                                     Provedor primario,
                                     Provedor secundario,
                                     Class<? extends Resultado> esperado) throws Exception {
    ServicoComFallback servico = new ServicoComFallback(primario, secundario);
    Resultado resultado = servico.executar();
    assertInstanceOf(esperado, resultado);
}

static Stream<Arguments> cenariosFallback() {
    return Stream.of(
        Arguments.of(
            "Sucesso prim√°rio",
            (Provedor) () -> "OK",
            (Provedor) () -> "FB",
            ResultadoOk.class
        ),
        Arguments.of(
            "Fallback ativado",
            (Provedor) () -> { throw new RuntimeException(); },
            (Provedor) () -> "FB",
            ResultadoFallback.class
        ),
        Arguments.of(
            "Falha total",
            (Provedor) () -> { throw new RuntimeException(); },
            (Provedor) () -> { throw new RuntimeException(); },
            ResultadoErro.class
        )
    );
}
```

---

## ‚ö† Cuidados Importantes

### 1. Consist√™ncia de Dados

```java
// ‚ùå PERIGO - Fallback pode retornar dados inconsistentes
@Test
void fallbackComDadosInconsistentes() {
    // Pre√ßo atualizado na API vs pre√ßo desatualizado no cache
    Provedor apiPreco = () -> "R$ 150,00"; // Novo pre√ßo
    Provedor cachePreco = () -> "R$ 100,00"; // Pre√ßo antigo!

    // Se API falhar, usu√°rio v√™ pre√ßo errado
    // SOLU√á√ÉO: Validar staleness, exibir aviso de dados n√£o atualizados
}

// ‚úÖ BOM - Indicar que √© fallback
record PrecoComMetadata(String valor, boolean isFallback, LocalDateTime timestamp) {}
```

### 2. N√£o Mascarar Falhas Cr√≠ticas

```java
// ‚ùå RUIM - Ocultar erro de seguran√ßa
Provedor autenticacao = () -> verificarToken(token);
Provedor fallbackInseguro = () -> "AUTORIZADO"; // ‚ö†Ô∏è PERIGOSO!

// ‚úÖ BOM - Falhar explicitamente em opera√ß√µes cr√≠ticas
if (operacaoCritica) {
    throw new SecurityException("Fallback n√£o permitido para autentica√ß√£o");
}
```

### 3. Custo do Fallback

```java
// ‚ùå Fallback caro
Provedor fallbackPesado = () -> {
    // Reconstruir cache completo do zero
    return construirCacheCompleto(); // Muito lento!
};

// ‚úÖ Fallback r√°pido
Provedor fallbackLeve = () -> {
    return buscarDoBackupPreComputado();
};
```

---

## üìä Boas Pr√°ticas de Teste

### ‚úÖ O Que Testar

- [ ] **Sucesso prim√°rio** n√£o aciona fallback
- [ ] **Fallback acionado** quando prim√°rio falha
- [ ] **Falha total** quando ambos falham
- [ ] **Diferentes tipos** de exce√ß√£o
- [ ] **Logging/M√©tricas** de ativa√ß√£o
- [ ] **Staleness** de cache verificada
- [ ] **Ordem** de execu√ß√£o (prim√°rio antes de fallback)
- [ ] **Thread safety** se compartilhado
- [ ] **Indicadores visuais** (badge "modo degradado")

### ‚ö† Evitar

- ‚ùå Fallback que mascara erros cr√≠ticos
- ‚ùå Fallback mais lento que opera√ß√£o principal
- ‚ùå Silenciar exce√ß√µes sem logging
- ‚ùå Fallback que pode retornar dados perigosos

---

## ‚öô Frameworks de Produ√ß√£o

### Resilience4j Fallback

```java
// Usando decoradores
Supplier<String> decorated = Decorators
    .ofSupplier(() -> remoteService.call())
    .withCircuitBreaker(circuitBreaker)
    .withRetry(retry)
    .withFallback(Arrays.asList(IOException.class, TimeoutException.class),
                  e -> "Fallback: " + e.getMessage())
    .decorate();

String result = decorated.get();
```

### Spring Cloud

```java
@Service
public class UserService {

    @CircuitBreaker(name = "userService", fallbackMethod = "getUserFallback")
    public User getUser(Long id) {
        return restTemplate.getForObject("/api/users/" + id, User.class);
    }

    // M√©todo de fallback com mesma assinatura + Exception
    private User getUserFallback(Long id, Exception e) {
        log.warn("Fallback ativado para user {}: {}", id, e.getMessage());
        return User.anonimo();
    }
}
```

### Java Optional Idiom

```java
public Optional<Preco> buscarPreco(String produto) {
    return tentarAPI(produto)
        .or(() -> tentarCache(produto))
        .or(() -> tentarProveedorSecundario(produto));
}
```

---

## üéì Vantagens vs Desvantagens

### ‚úÖ Vantagens

- **Disponibilidade**: Mant√©m servi√ßo parcialmente funcional
- **UX melhorada**: Evita telas de erro
- **Resili√™ncia**: Tolera falhas de depend√™ncias
- **Tempo de recupera√ß√£o**: Sistema degrada graciosamente

### ‚ö† Desvantagens

- **Complexidade**: L√≥gica adicional, m√∫ltiplas fontes
- **Inconsist√™ncia**: Dados do fallback podem estar desatualizados
- **Mascaramento**: Pode ocultar problemas cr√¥nicos
- **Manuten√ß√£o**: C√≥digo e testes para m√∫ltiplos cen√°rios

---

## üîç Compara√ß√£o com Outros Patterns

| Pattern             | Comportamento                  | Quando Usar                     |
| ------------------- | ------------------------------ | ------------------------------- |
| **Fallback**        | Retorna resposta alternativa   | Sempre que h√° fonte secund√°ria  |
| **Retry**           | Tenta novamente mesma opera√ß√£o | Falhas transientes              |
| **Circuit Breaker** | Bloqueia ap√≥s padr√£o de falhas | Proteger recursos               |
| **Default Value**   | Valor fixo conhecido           | Quando n√£o h√° fonte alternativa |

### Combina√ß√£o Recomendada

```java
// Circuit Breaker ‚Üí Retry ‚Üí Fallback
Supplier<String> resilient = Decorators
    .ofSupplier(() -> api.buscar())
    .withCircuitBreaker(cb)      // 1. Proteger de instabilidade
    .withRetry(retry)             // 2. Tentar recuperar
    .withFallback(Exception.class,
                  e -> cache.buscar()) // 3. Fallback se tudo falhar
    .decorate();
```

---

## üß† Exerc√≠cios Pr√°ticos

### 1. Fallback em Cadeia (Waterfall)

Implementar 3 n√≠veis: API ‚Üí Cache L1 ‚Üí Cache L2 ‚Üí Valor padr√£o

### 2. Fallback com M√©tricas

Adicionar contador de ativa√ß√µes, histograma de lat√™ncia, taxa de sucesso

### 3. Fallback Condicional

Permitir fallback apenas se exce√ß√£o √© de tipo espec√≠fico ou c√≥digo HTTP 5xx

### 4. Fallback com Circuit Breaker Integrado

Abrir circuito ap√≥s N ativa√ß√µes de fallback consecutivas

---

## üìö Refer√™ncias

- **Frameworks:**

  - [Resilience4j Decorators](https://resilience4j.readme.io/docs/getting-started-3)
  - [Spring Cloud Circuit Breaker](https://spring.io/projects/spring-cloud-circuitbreaker)
  - [Netflix Hystrix Fallback](https://github.com/Netflix/Hystrix/wiki/How-To-Use#Fallback) (legacy)

- **Padr√µes:**
  - [Fowler - Circuit Breaker](https://martinfowler.com/bliki/CircuitBreaker.html)
  - [Microsoft - Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)

---

## üìö Pr√≥ximos Passos

- [4.1 Circuit Breaker](04.1-circuit-breaker.md) - Prote√ß√£o contra instabilidade
- [4.2 Retry Pattern](04.2-retry.md) - Tentativas autom√°ticas
- [4.4 Timeout Pattern](04.4-timeout.md) - Limites de tempo
- [4.5 Bulkhead Pattern](04.5-bulkhead.md) - Isolamento de recursos
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [EXPERT]  
**Tempo Estimado:** 2 horas  
**Frameworks:** Resilience4j, Spring Cloud, Java Optional
