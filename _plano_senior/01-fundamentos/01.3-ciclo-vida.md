# 1.3 Ciclo de Vida dos Testes [B√ÅSICO]

üéØ **Objetivo:** Entender e aplicar as anota√ß√µes de ciclo de vida do JUnit 5 para preparar e limpar ambientes de teste, garantindo isolamento e independ√™ncia entre testes.

---

## O Que √© Ciclo de Vida de Testes?

O ciclo de vida de testes define **quando** e **quantas vezes** determinados m√©todos s√£o executados durante a execu√ß√£o da suite de testes. O JUnit 5 oferece anota√ß√µes para executar c√≥digo em pontos espec√≠ficos deste ciclo.

üí° **Por qu√™?** Preparar ambiente, inicializar recursos, limpar estado, evitar interfer√™ncia entre testes.

---

## üîÑ Anota√ß√µes do Ciclo de Vida

### Resumo Visual

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     @BeforeAll (1x - static)        ‚îÇ  ‚Üê Setup global
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   @BeforeEach (antes de cada) ‚îÇ  ‚îÇ  ‚Üê Setup por teste
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ      @Test (Teste 1)          ‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ   @AfterEach (depois de cada) ‚îÇ  ‚îÇ  ‚Üê Cleanup por teste
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   @BeforeEach                 ‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ      @Test (Teste 2)          ‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îÇ
‚îÇ  ‚îÇ   @AfterEach                  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     @AfterAll (1x - static)         ‚îÇ  ‚Üê Cleanup global
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìã Anota√ß√µes Detalhadas

### `@BeforeAll`

- **Quando:** Uma √∫nica vez, **antes** de todos os testes
- **Requisito:** M√©todo deve ser `static`
- **Uso:** Inicializar recursos caros/compartilhados (DB, conex√µes, carga de dados)

### `@AfterAll`

- **Quando:** Uma √∫nica vez, **depois** de todos os testes
- **Requisito:** M√©todo deve ser `static`
- **Uso:** Limpar recursos globais criados no `@BeforeAll`

### `@BeforeEach`

- **Quando:** **Antes de cada** teste individual
- **Requisito:** M√©todo N√ÉO √© static
- **Uso:** Resetar estado, criar inst√¢ncias frescas, garantir isolamento

### `@AfterEach`

- **Quando:** **Depois de cada** teste individual
- **Requisito:** M√©todo N√ÉO √© static
- **Uso:** Limpar recursos espec√≠ficos do teste (fechar conex√µes, deletar arquivos tempor√°rios)

---

## üß™ Exemplo Completo

```java
import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

@DisplayName("Demonstra√ß√£o do Ciclo de Vida")
class CicloDeVidaTest {

    private int contador;
    private static DatabaseConnection dbConnection;

    @BeforeAll
    static void setupGeral() {
        System.out.println("@BeforeAll: Iniciando conex√£o com banco de dados");
        dbConnection = DatabaseConnection.connect("jdbc:h2:mem:test");
        // Executado UMA VEZ antes de todos os testes
    }

    @AfterAll
    static void teardownGeral() {
        System.out.println("@AfterAll: Fechando conex√£o com banco de dados");
        dbConnection.close();
        // Executado UMA VEZ ap√≥s todos os testes
    }

    @BeforeEach
    void setupCadaTeste() {
        contador = 1;
        System.out.println("  @BeforeEach: Resetando contador para " + contador);
        // Executado ANTES DE CADA teste
    }

    @AfterEach
    void teardownCadaTeste() {
        System.out.println("  @AfterEach: Limpeza p√≥s-teste\n");
        // Executado DEPOIS DE CADA teste
    }

    @Test
    @DisplayName("Teste A: Verifica se contador √© 1")
    void testeA() {
        System.out.println("    Executando Teste A");
        assertEquals(1, contador);
    }

    @Test
    @DisplayName("Teste B: Incrementa e verifica contador")
    void testeB() {
        System.out.println("    Executando Teste B");
        contador++;
        assertEquals(2, contador);
        // contador volta a 1 no pr√≥ximo teste (isolamento garantido)
    }
}
```

### üìä Sa√≠da no Console

```
@BeforeAll: Iniciando conex√£o com banco de dados
  @BeforeEach: Resetando contador para 1
    Executando Teste A
  @AfterEach: Limpeza p√≥s-teste

  @BeforeEach: Resetando contador para 1
    Executando Teste B
  @AfterEach: Limpeza p√≥s-teste

@AfterAll: Fechando conex√£o com banco de dados
```

üí° **Observa√ß√£o:** O contador √© resetado para `1` antes de cada teste, garantindo **isolamento completo**.

---

## üéØ Casos de Uso Comuns

### 1. Banco de Dados em Mem√≥ria

```java
class RepositoryTest {
    private static DataSource dataSource;
    private Repository repository;

    @BeforeAll
    static void initDatabase() {
        dataSource = H2DataSource.create();
        DatabaseMigration.run(dataSource); // Flyway/Liquibase
    }

    @BeforeEach
    void setup() {
        repository = new Repository(dataSource);
        DatabaseCleaner.clean(dataSource); // Limpar dados
    }

    @Test
    void deveInserirUsuario() {
        repository.save(new User("Jo√£o"));
        assertEquals(1, repository.count());
    }
}
```

### 2. Mock de Depend√™ncias

```java
class ServiceTest {
    private ExternalApi mockApi;
    private Service service;

    @BeforeEach
    void setup() {
        mockApi = mock(ExternalApi.class);
        service = new Service(mockApi);
        // Cada teste recebe mocks frescos
    }

    @Test
    void deveConsultarApi() {
        when(mockApi.fetch()).thenReturn("data");
        assertEquals("data", service.getData());
    }
}
```

### 3. Arquivos Tempor√°rios

```java
class FileProcessorTest {
    private Path tempDir;

    @BeforeEach
    void criarDiretorioTemp() throws IOException {
        tempDir = Files.createTempDirectory("test");
    }

    @AfterEach
    void limparDiretorioTemp() throws IOException {
        Files.walk(tempDir)
             .sorted(Comparator.reverseOrder())
             .forEach(path -> {
                 try { Files.delete(path); }
                 catch (IOException e) { /* log */ }
             });
    }

    @Test
    void deveProcessarArquivo() throws IOException {
        Path file = tempDir.resolve("test.txt");
        Files.writeString(file, "conte√∫do");
        // ... teste
    }
}
```

---

## ‚ö† Pitfalls Comuns

### 1. Esquecer `static` em @BeforeAll/@AfterAll

```java
// ‚ùå ERRO - M√©todo n√£o √© static
@BeforeAll
void setup() {
    // JUnit lan√ßar√° exce√ß√£o
}

// ‚úÖ CORRETO
@BeforeAll
static void setup() {
    // Funciona
}
```

### 2. Estado Compartilhado Entre Testes

```java
// ‚ùå RUIM - Campo est√°tico compartilhado
private static List<String> lista = new ArrayList<>();

@Test
void testeA() {
    lista.add("A");
    assertEquals(1, lista.size()); // Passa
}

@Test
void testeB() {
    lista.add("B");
    assertEquals(1, lista.size()); // ‚ùå FALHA - lista tem 2 elementos!
}

// ‚úÖ CORRETO - Resetar no @BeforeEach
private List<String> lista;

@BeforeEach
void setup() {
    lista = new ArrayList<>(); // Nova inst√¢ncia a cada teste
}
```

### 3. Limpeza Incompleta

```java
// ‚ùå RUIM - N√£o limpa em caso de falha
@AfterEach
void cleanup() {
    if (testPassed) { // Nunca fa√ßa isso!
        resource.close();
    }
}

// ‚úÖ CORRETO - Sempre limpa
@AfterEach
void cleanup() {
    if (resource != null) {
        resource.close();
    }
}
```

### 4. Ordem de Execu√ß√£o N√£o Garantida

```java
// ‚ö† ATEN√á√ÉO - Ordem dos testes N√ÉO √© garantida
@Test void testeA() { /* ... */ }
@Test void testeB() { /* ... */ }
@Test void testeC() { /* ... */ }

// Se B depende de A, voc√™ tem um problema!
```

üí° **Solu√ß√£o:** Use `@TestMethodOrder` se ordem importar (raro, geralmente code smell).

---

## üìä Comparativo: @BeforeEach vs @BeforeAll

| Aspecto         | @BeforeEach                      | @BeforeAll                 |
| --------------- | -------------------------------- | -------------------------- |
| **Frequ√™ncia**  | Antes de cada teste              | Uma √∫nica vez              |
| **Static?**     | N√£o                              | Sim                        |
| **Uso t√≠pico**  | Resetar estado, criar inst√¢ncias | Inicializar recursos caros |
| **Performance** | Menor (executa N vezes)          | Maior (executa 1x)         |
| **Isolamento**  | ‚úÖ M√°ximo                        | ‚ö† Compartilhado            |

üí° **Regra de Ouro:** Prefira `@BeforeEach` para m√°ximo isolamento. Use `@BeforeAll` s√≥ quando performance √© cr√≠tica E o recurso √© seguro para compartilhamento.

---

## ‚úÖ Checklist de Boas Pr√°ticas

- [ ] Usar `@BeforeEach` para garantir isolamento entre testes
- [ ] Limpar recursos no `@AfterEach`, n√£o apenas no `@AfterAll`
- [ ] M√©todos `@BeforeAll`/`@AfterAll` s√£o `static`
- [ ] N√£o compartilhar estado mut√°vel entre testes
- [ ] Sempre limpar recursos, mesmo se teste falhar
- [ ] Evitar depend√™ncias de ordem de execu√ß√£o entre testes
- [ ] Usar `@DisplayName` para descrever prop√≥sito de cada teste

---

## üß† Perguntas Reflexivas

1. Por que `@BeforeEach` √© prefer√≠vel a `@BeforeAll` para a maioria dos casos?
2. Quando compartilhar recursos com `@BeforeAll` √© aceit√°vel?
3. Como garantir que `@AfterEach` sempre execute, mesmo se o teste falhar?
4. Qual o impacto de n√£o limpar recursos entre testes?

---

## üß™ Exerc√≠cio Pr√°tico

Implemente testes para uma classe `UserService` que:

1. Conecta a banco de dados (H2 in-memory) no `@BeforeAll`
2. Limpa tabela de usu√°rios antes de cada teste
3. Testa inser√ß√£o, busca e remo√ß√£o
4. Fecha conex√£o no `@AfterAll`

---

## üìö Pr√≥ximos Passos

- [1.4 Testes Parametrizados](01.4-testes-parametrizados.md) - @ValueSource, @CsvSource, @MethodSource
- [2.1 Testes Parametrizados Avan√ßados](../02-intermediario/02.1-parametrizados-avancado.md) - Pr√≥ximo n√≠vel
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [B√ÅSICO]  
**Tempo Estimado:** 1 hora
