# 1.4 Testes Parametrizados [B√ÅSICO-M√âDIO]

üéØ **Objetivo:** Executar o mesmo teste m√∫ltiplas vezes com diferentes argumentos, reduzindo duplica√ß√£o de c√≥digo e aumentando cobertura de cen√°rios.

---

## Por Que Usar Testes Parametrizados?

Testes parametrizados permitem executar um mesmo teste v√°rias vezes com diferentes argumentos.

### Benef√≠cios

‚úÖ **Reduz duplica√ß√£o** - Um teste, m√∫ltiplos cen√°rios  
‚úÖ **Aumenta cobertura** - F√°cil testar casos de borda  
‚úÖ **Melhora manuten√ß√£o** - Adicionar novo caso = adicionar linha  
‚úÖ **Clareza** - Separa l√≥gica de teste dos dados de teste

---

## üîß Configura√ß√£o

Adicione a depend√™ncia `junit-jupiter-params`:

### Maven

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <version>5.10.1</version>
    <scope>test</scope>
</dependency>
```

### Gradle

```kotlin
testImplementation("org.junit.jupiter:junit-jupiter-params:5.10.1")
```

---

## üß™ @ValueSource: Valores Simples

A forma mais simples de parametriza√ß√£o. Fornece um array de valores literais.

### Tipos Suportados

- `strings`, `ints`, `longs`, `doubles`, `floats`, `shorts`, `bytes`, `chars`, `booleans`, `classes`

### Exemplo: Validar N√∫meros Pares

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.assertTrue;

class NumerosTest {

    boolean isPar(int numero) {
        return numero % 2 == 0;
    }

    @ParameterizedTest
    @ValueSource(ints = {2, 4, 8, -10, 100})
    @DisplayName("Deve retornar verdadeiro para n√∫meros pares")
    void deveValidarNumerosPares(int numero) {
        assertTrue(isPar(numero));
    }
}
```

**Execu√ß√£o:** O teste roda **5 vezes**, uma para cada valor.

### Exemplo: Validar Strings Vazias

```java
@ParameterizedTest
@ValueSource(strings = {"", "  ", "\t", "\n"})
void deveIdentificarStringsVazias(String texto) {
    assertTrue(texto.isBlank());
}
```

---

## üß™ @CsvSource: M√∫ltiplos Par√¢metros

Quando voc√™ precisa de mais de um argumento, use `@CsvSource`. Define argumentos como strings CSV (separados por v√≠rgula).

### Exemplo: Testar Calculadora

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.assertEquals;

class CalculadoraTest {

    int somar(int a, int b) {
        return a + b;
    }

    @ParameterizedTest(name = "Teste {index}: {0} + {1} = {2}")
    @CsvSource({
        "1, 2, 3",
        "0, 0, 0",
        "-5, 5, 0",
        "10, -3, 7"
    })
    void deveSomarCorretamente(int a, int b, int esperado) {
        assertEquals(esperado, somar(a, b));
    }
}
```

### üéØ Personalizando Nome de Exibi√ß√£o

O atributo `name` aceita placeholders:

- `{index}` - √çndice da execu√ß√£o (come√ßando em 1)
- `{0}`, `{1}`, `{2}` - Argumentos na ordem
- `{arguments}` - Todos os argumentos

```java
@ParameterizedTest(name = "üìä Caso {index}: somar({0}, {1}) = {2}")
@CsvSource({/* ... */})
void teste(int a, int b, int esperado) {
    // ...
}
```

**Sa√≠da:**

```
‚úÖ üìä Caso 1: somar(1, 2) = 3
‚úÖ üìä Caso 2: somar(0, 0) = 0
...
```

### Strings com Aspas

```java
@CsvSource({
    "'Jo√£o Silva', 30, true",
    "'Maria', 25, false"
})
void testeComStrings(String nome, int idade, boolean ativo) {
    // ...
}
```

---

## üß™ @MethodSource: Dados Complexos

Para cen√°rios complexos, use um m√©todo que fornece os dados.

### Requisitos do M√©todo

- ‚úÖ Deve ser `static`
- ‚úÖ Retorna `Stream<Arguments>`, `Stream<?>`, `Iterable`, `Iterator`, ou array
- ‚úÖ Nome padr√£o = nome do teste (ou especificar com `@MethodSource("nomeMetodo")`)

### Exemplo: Validar Usu√°rios

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.junit.jupiter.params.provider.Arguments;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.assertEquals;

class ValidacaoUsuarioTest {

    record Usuario(String nome, String email) {}

    boolean isValido(Usuario usuario) {
        return usuario.nome() != null && !usuario.nome().isEmpty() &&
               usuario.email() != null && usuario.email().contains("@");
    }

    @ParameterizedTest
    @MethodSource("provedorDeUsuarios")
    @DisplayName("Valida diferentes usu√°rios")
    void deveValidarUsuario(Usuario usuario, boolean esperado) {
        assertEquals(esperado, isValido(usuario));
    }

    static Stream<Arguments> provedorDeUsuarios() {
        return Stream.of(
            Arguments.of(new Usuario("Admin", "admin@test.com"), true),
            Arguments.of(new Usuario("", "user@test.com"), false), // Nome vazio
            Arguments.of(new Usuario("User", "usertest.com"), false), // Email sem @
            Arguments.of(new Usuario(null, "email@test.com"), false) // Nome nulo
        );
    }
}
```

### M√©todo em Outra Classe

```java
@ParameterizedTest
@MethodSource("com.exemplo.TestDataFactory#fornecerUsuarios")
void teste(Usuario usuario) {
    // ...
}
```

---

## üß™ Outras Sources √öteis

### @NullSource e @EmptySource

```java
@ParameterizedTest
@NullSource
void deveAceitarNull(String valor) {
    assertNull(valor);
}

@ParameterizedTest
@EmptySource
void deveAceitarVazio(String valor) {
    assertTrue(valor.isEmpty());
}

@ParameterizedTest
@NullAndEmptySource // Combina ambos
void deveAceitarNullOuVazio(String valor) {
    assertTrue(valor == null || valor.isEmpty());
}
```

### @EnumSource

```java
enum Status { ATIVO, INATIVO, PENDENTE }

@ParameterizedTest
@EnumSource(Status.class)
void todosStatusSaoValidos(Status status) {
    assertNotNull(status);
}

// Filtrar apenas alguns valores
@ParameterizedTest
@EnumSource(value = Status.class, names = {"ATIVO", "INATIVO"})
void apenasAtivoOuInativo(Status status) {
    assertNotEquals(Status.PENDENTE, status);
}
```

---

## ‚ö† Pitfalls Comuns

### 1. Esquecer Depend√™ncia junit-jupiter-params

```java
// ‚ùå ERRO: @ParameterizedTest n√£o encontrado
@ParameterizedTest
@ValueSource(ints = {1, 2})
void teste(int n) { }
```

**Solu√ß√£o:** Adicionar depend√™ncia `junit-jupiter-params`.

### 2. M√©todo @MethodSource N√£o Static

```java
// ‚ùå ERRO - M√©todo precisa ser static
Stream<Arguments> dados() {
    return Stream.of(Arguments.of(1));
}
```

### 3. Tipos Incompat√≠veis

```java
// ‚ùå ERRO - String n√£o converte automaticamente para int complexo
@ParameterizedTest
@ValueSource(strings = {"1", "2"})
void teste(int numero) { } // Falha!
```

**Solu√ß√£o:** Use convers√£o expl√≠cita ou @CsvSource com tipos corretos.

### 4. Muitos Dados no @CsvSource

```java
// ‚ùå RUIM - C√≥digo polu√≠do
@CsvSource({
    "1,2,3", "4,5,6", "7,8,9", /* ...100 linhas... */
})
```

**Solu√ß√£o:** Migrar para `@CsvFileSource` ou `@MethodSource`.

### 5. Nome de Teste Gen√©rico

```java
// ‚ùå RUIM - Imposs√≠vel saber qual caso falhou
@ParameterizedTest
@CsvSource({"1,2", "3,4"})
void teste(int a, int b) { }
```

**Solu√ß√£o:** Usar `name` descritivo.

---

## ‚úÖ Checklist de Boas Pr√°ticas

- [ ] Usar `name` personalizado para identificar cada execu√ß√£o
- [ ] Preferir `@MethodSource` para dados complexos ou reutiliz√°veis
- [ ] Usar `@CsvFileSource` quando tiver muitos dados tabulares
- [ ] Testar um conceito por vez (n√£o misturar comportamentos)
- [ ] Incluir casos de borda (null, vazio, negativos, limites)
- [ ] Agrupar dados de teste em classe utilit√°ria quando reutilizados

---

## üìä Comparativo de Sources

| Source             | Quando Usar                           | Complexidade |
| ------------------ | ------------------------------------- | ------------ |
| **@ValueSource**   | 1 par√¢metro, valores simples          | ‚≠ê Baixa     |
| **@CsvSource**     | M√∫ltiplos par√¢metros, dados tabulares | ‚≠ê‚≠ê M√©dia   |
| **@CsvFileSource** | Muitos dados, arquivo externo         | ‚≠ê‚≠ê M√©dia   |
| **@MethodSource**  | Dados complexos, objetos, l√≥gica      | ‚≠ê‚≠ê‚≠ê Alta  |
| **@EnumSource**    | Testar todos/alguns valores de enum   | ‚≠ê Baixa     |

---

## üß† Perguntas Reflexivas

1. Quando voc√™ preferiria `@CsvSource` sobre `@MethodSource`?
2. Como testes parametrizados melhoram a manutenibilidade do c√≥digo?
3. Qual o trade-off entre ter 1 teste parametrizado vs 10 testes simples?
4. Como voc√™ organizaria dados de teste reutilizados em m√∫ltiplas classes?

---

## üß™ Exerc√≠cio Pr√°tico

Crie testes parametrizados para uma classe `Validador`:

```java
class Validador {
    boolean isCPFValido(String cpf) {
        // Valida formato: XXX.XXX.XXX-XX
        if (cpf == null || !cpf.matches("\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}"))
            return false;
        // ... valida√ß√£o de d√≠gitos verificadores
        return true;
    }

    int calcularIdade(LocalDate nascimento) {
        return Period.between(nascimento, LocalDate.now()).getYears();
    }
}
```

**Implemente:**

1. Teste parametrizado para CPFs v√°lidos e inv√°lidos (@ValueSource ou @CsvSource)
2. Teste parametrizado para c√°lculo de idade (@MethodSource com datas)
3. Personalize os nomes de exibi√ß√£o dos testes

---

## üìö Pr√≥ximos Passos

- [2.1 Testes Parametrizados Avan√ßados](../02-intermediario/02.1-parametrizados-avancado.md) - @CsvFileSource, @ArgumentsSource, Aggregators
- [2.2 Testes Din√¢micos](../02-intermediario/02.2-testes-dinamicos.md) - @TestFactory
- [Voltar ao √çndice](../../README.md)

---

**√öltima Atualiza√ß√£o:** 2025-11-14  
**N√≠vel:** [B√ÅSICO-M√âDIO]  
**Tempo Estimado:** 1,5 horas
