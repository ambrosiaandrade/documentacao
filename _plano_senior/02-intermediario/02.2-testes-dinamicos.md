# 02.2 Testes Din√¢micos [INTERMEDI√ÅRIO] üé≠

## üéØ Objetivo

Implementar **testes din√¢micos** com **@TestFactory** para gerar **testes em runtime**, validar **cole√ß√µes**, processar **dados externos** e criar **su√≠tes de testes adaptativas** que se ajustam aos dados dispon√≠veis.

---

## üìö O Que S√£o Testes Din√¢micos?

**Testes din√¢micos** s√£o gerados **em runtime** (n√£o em compile-time) usando **@TestFactory**, permitindo criar **quantidade vari√°vel de testes** baseados em **dados externos**, **APIs**, **arquivos** ou **l√≥gica condicional**.

### Diferen√ßa: @Test vs @ParameterizedTest vs @TestFactory

| Aspecto              | @Test        | @ParameterizedTest | @TestFactory       |
| -------------------- | ------------ | ------------------ | ------------------ |
| **Quantidade**       | 1 teste fixo | N testes fixos     | N testes din√¢micos |
| **Defini√ß√£o**        | Compile-time | Compile-time       | **Runtime**        |
| **Flexibilidade**    | Baixa        | M√©dia              | **Alta**           |
| **Fonte de dados**   | Nenhuma      | Anota√ß√µes          | **C√≥digo Java**    |
| **Usa @DisplayName** | Sim          | Sim (template)     | Sim (din√¢mico)     |

---

## üèóÔ∏è Estrutura B√°sica

### Criando Testes Din√¢micos

```java
@TestFactory
@DisplayName("Factory de testes din√¢micos")
Stream<DynamicTest> testesDinamicos() {
    return Stream.of("Jo√£o", "Maria", "Pedro")
            .map(nome -> DynamicTest.dynamicTest(
                "Valida nome: " + nome,  // Nome do teste
                () -> {
                    // L√≥gica do teste
                    assertNotNull(nome);
                    assertTrue(nome.length() > 2);
                }
            ));
}
```

**Sa√≠da:**

```
‚úì Valida nome: Jo√£o
‚úì Valida nome: Maria
‚úì Valida nome: Pedro
```

---

## üîÑ Gerando Testes de Cole√ß√µes

### Validando Lista de Objetos

```java
@TestFactory
@DisplayName("Valida lista de produtos")
Collection<DynamicTest> deveValidarListaProdutos() {
    // Arrange - Produtos a serem testados
    List<Produto> produtos = List.of(
        new Produto("PROD-001", "Notebook", new BigDecimal("3000.00")),
        new Produto("PROD-002", "Mouse", new BigDecimal("50.00")),
        new Produto("PROD-003", "Teclado", new BigDecimal("150.00"))
    );

    // Act & Assert - Gera um teste para cada produto
    return produtos.stream()
            .map(produto -> DynamicTest.dynamicTest(
                "Valida produto: " + produto.getCodigo(),
                () -> {
                    assertNotNull(produto.getId());
                    assertFalse(produto.getNome().isBlank());
                    assertTrue(produto.getPreco().compareTo(BigDecimal.ZERO) > 0);
                }
            ))
            .collect(Collectors.toList());
}
```

### Validando Mapa

```java
@TestFactory
@DisplayName("Valida configura√ß√µes do sistema")
Stream<DynamicTest> deveValidarConfiguracoes() {
    // Arrange - Configura√ß√µes esperadas
    Map<String, String> configs = Map.of(
        "app.name", "Pedidos API",
        "app.version", "1.0.0",
        "app.environment", "production",
        "database.url", "jdbc:postgresql://localhost:5432/pedidos"
    );

    // Act & Assert
    return configs.entrySet().stream()
            .map(entry -> DynamicTest.dynamicTest(
                "Config: " + entry.getKey(),
                () -> {
                    String valor = configService.get(entry.getKey());
                    assertEquals(entry.getValue(), valor);
                }
            ));
}
```

---

## üìÇ Testes de Arquivos Externos

### Lendo CSV Dinamicamente

```java
@TestFactory
@DisplayName("Valida clientes do CSV")
Stream<DynamicTest> deveValidarClientesDoCSV() throws IOException {
    // Arrange - L√™ arquivo CSV
    Path csvPath = Paths.get("src/test/resources/clientes.csv");

    // Act & Assert
    return Files.lines(csvPath)
            .skip(1)  // Pula header
            .map(linha -> {
                String[] campos = linha.split(",");
                String nome = campos[0];
                String email = campos[1];
                String cpf = campos[2];

                return DynamicTest.dynamicTest(
                    "Cliente: " + nome,
                    () -> {
                        ClienteRequest request = new ClienteRequest(nome, email, cpf);
                        ClienteResponse response = clienteService.salvar(request);

                        assertNotNull(response.getId());
                        assertEquals(nome, response.getNome());
                        assertTrue(EmailValidator.isValid(response.getEmail()));
                        assertTrue(CpfValidator.isValid(response.getCpf()));
                    }
                );
            });
}
```

### Lendo JSON Dinamicamente

```java
@TestFactory
@DisplayName("Valida produtos do JSON")
Stream<DynamicTest> deveValidarProdutosDoJSON() throws IOException {
    // Arrange - L√™ arquivo JSON
    ObjectMapper mapper = new ObjectMapper();
    Path jsonPath = Paths.get("src/test/resources/produtos.json");

    List<ProdutoDTO> produtos = mapper.readValue(
        jsonPath.toFile(),
        new TypeReference<List<ProdutoDTO>>() {}
    );

    // Act & Assert
    return produtos.stream()
            .map(produto -> DynamicTest.dynamicTest(
                "Produto: " + produto.getCodigo(),
                () -> {
                    ProdutoResponse response = produtoService.salvar(produto);

                    assertNotNull(response.getId());
                    assertEquals(produto.getCodigo(), response.getCodigo());
                    assertTrue(response.getEstoque() >= 0);
                    assertTrue(response.getPreco().compareTo(BigDecimal.ZERO) > 0);
                }
            ));
}
```

---

## üåê Testes de APIs Externas

### Validando Endpoints Dinamicamente

```java
@TestFactory
@DisplayName("Valida disponibilidade de endpoints")
Stream<DynamicTest> deveValidarDisponibilidadeEndpoints() {
    // Arrange - Lista de endpoints a testar
    List<String> endpoints = List.of(
        "/api/clientes",
        "/api/produtos",
        "/api/pedidos",
        "/api/pagamentos",
        "/actuator/health"
    );

    // Act & Assert
    return endpoints.stream()
            .map(endpoint -> DynamicTest.dynamicTest(
                "Endpoint: " + endpoint,
                () -> {
                    mockMvc.perform(get(endpoint))
                            .andExpect(status().isOk())
                            .andExpect(content().contentType(MediaType.APPLICATION_JSON));
                }
            ));
}
```

### Validando Status Codes

```java
@TestFactory
@DisplayName("Valida c√≥digos HTTP esperados")
Stream<DynamicTest> deveValidarStatusHTTP() {
    // Arrange - Mapa de endpoint ‚Üí status esperado
    Map<String, Integer> endpoints = Map.of(
        "/api/public/health", 200,
        "/api/clientes/999999", 404,
        "/api/admin/config", 403,  // Sem autentica√ß√£o
        "/api/clientes", 401  // Sem token
    );

    // Act & Assert
    return endpoints.entrySet().stream()
            .map(entry -> DynamicTest.dynamicTest(
                String.format("%s deve retornar %d", entry.getKey(), entry.getValue()),
                () -> {
                    mockMvc.perform(get(entry.getKey()))
                            .andExpect(status().is(entry.getValue()));
                }
            ));
}
```

---

## üîÄ Testes Condicionais

### Gerar Testes Baseado em Configura√ß√£o

```java
@TestFactory
@DisplayName("Testes baseados em ambiente")
Stream<DynamicTest> testesBaseadosEmAmbiente() {
    String ambiente = System.getProperty("ambiente", "dev");

    if ("prod".equals(ambiente)) {
        // Testes espec√≠ficos de produ√ß√£o
        return Stream.of(
            DynamicTest.dynamicTest("Valida cache habilitado", () -> {
                assertTrue(cacheService.isEnabled());
            }),
            DynamicTest.dynamicTest("Valida HTTPS obrigat√≥rio", () -> {
                assertTrue(securityConfig.isHttpsRequired());
            }),
            DynamicTest.dynamicTest("Valida rate limiting ativo", () -> {
                assertTrue(rateLimitService.isActive());
            })
        );
    } else {
        // Testes de desenvolvimento
        return Stream.of(
            DynamicTest.dynamicTest("Valida debug habilitado", () -> {
                assertTrue(applicationConfig.isDebugEnabled());
            }),
            DynamicTest.dynamicTest("Valida swagger dispon√≠vel", () -> {
                mockMvc.perform(get("/swagger-ui/index.html"))
                        .andExpect(status().isOk());
            })
        );
    }
}
```

### Gerar Testes Baseado em Features Habilitadas

```java
@TestFactory
@DisplayName("Testes de features toggles")
Stream<DynamicTest> testesFeatureToggles() {
    Map<String, Boolean> features = featureToggleService.getAllFeatures();

    return features.entrySet().stream()
            .filter(Map.Entry::getValue)  // Apenas features habilitadas
            .map(entry -> DynamicTest.dynamicTest(
                "Feature: " + entry.getKey(),
                () -> {
                    String featureName = entry.getKey();

                    // Valida que feature funciona
                    switch (featureName) {
                        case "payment.pix":
                            assertTrue(pagamentoService.supportsPixPayment());
                            break;
                        case "shipping.express":
                            assertTrue(freteService.supportsExpressShipping());
                            break;
                        case "discount.blackfriday":
                            assertTrue(descontoService.hasBlackFridayDiscount());
                            break;
                    }
                }
            ));
}
```

---

## üéØ DynamicContainer (Testes Aninhados)

### Organizar Testes por Categoria

```java
@TestFactory
@DisplayName("Testes organizados por categoria")
Stream<DynamicNode> testesOrganizados() {
    return Stream.of(
        // Container 1: Valida√ß√µes
        DynamicContainer.dynamicContainer(
            "Valida√ß√µes",
            Stream.of(
                DynamicTest.dynamicTest("Email v√°lido", () -> {
                    assertTrue(EmailValidator.isValid("joao@empresa.com"));
                }),
                DynamicTest.dynamicTest("CPF v√°lido", () -> {
                    assertTrue(CpfValidator.isValid("12345678901"));
                })
            )
        ),

        // Container 2: Business Rules
        DynamicContainer.dynamicContainer(
            "Regras de Neg√≥cio",
            Stream.of(
                DynamicTest.dynamicTest("Desconto VIP aplicado", () -> {
                    BigDecimal desconto = descontoService.calcular(true, new BigDecimal("100"));
                    assertEquals(new BigDecimal("10.00"), desconto);
                }),
                DynamicTest.dynamicTest("Frete gr√°tis acima de R$ 200", () -> {
                    BigDecimal frete = freteService.calcular(new BigDecimal("250"));
                    assertEquals(BigDecimal.ZERO, frete);
                })
            )
        ),

        // Container 3: Integra√ß√µes
        DynamicContainer.dynamicContainer(
            "Integra√ß√µes",
            Stream.of(
                DynamicTest.dynamicTest("API de pagamento responde", () -> {
                    PagamentoResponse response = pagamentoGateway.check();
                    assertEquals("online", response.getStatus());
                }),
                DynamicTest.dynamicTest("API de CEP responde", () -> {
                    EnderecoResponse response = cepService.buscar("01310-100");
                    assertEquals("S√£o Paulo", response.getCidade());
                })
            )
        )
    );
}
```

### Testes Aninhados com Itera√ß√£o

```java
@TestFactory
@DisplayName("Valida produtos por categoria")
Stream<DynamicContainer> testesAninhados() {
    Map<String, List<Produto>> produtosPorCategoria = Map.of(
        "Eletr√¥nicos", List.of(
            new Produto("ELET-001", "Notebook", new BigDecimal("3000")),
            new Produto("ELET-002", "Mouse", new BigDecimal("50"))
        ),
        "Livros", List.of(
            new Produto("LIVR-001", "Clean Code", new BigDecimal("80")),
            new Produto("LIVR-002", "Java Efetivo", new BigDecimal("90"))
        )
    );

    return produtosPorCategoria.entrySet().stream()
            .map(entry -> DynamicContainer.dynamicContainer(
                "Categoria: " + entry.getKey(),
                entry.getValue().stream()
                        .map(produto -> DynamicTest.dynamicTest(
                            "Produto: " + produto.getCodigo(),
                            () -> {
                                assertNotNull(produto.getId());
                                assertTrue(produto.getPreco().compareTo(BigDecimal.ZERO) > 0);
                            }
                        ))
            ));
}
```

---

## üîÑ Gera√ß√£o Din√¢mica com Streams

### Range de Valores

```java
@TestFactory
@DisplayName("Testa range de descontos")
Stream<DynamicTest> testaRangeDescontos() {
    return IntStream.rangeClosed(0, 100)
            .filter(i -> i % 10 == 0)  // 0, 10, 20, ..., 100
            .mapToObj(percentual -> DynamicTest.dynamicTest(
                "Desconto de " + percentual + "%",
                () -> {
                    BigDecimal valor = new BigDecimal("100.00");
                    BigDecimal desconto = descontoService.aplicar(valor, percentual);

                    BigDecimal esperado = valor.multiply(
                        BigDecimal.valueOf(percentual).divide(BigDecimal.valueOf(100))
                    );

                    assertEquals(esperado, desconto);
                }
            ));
}
```

### Combina√ß√µes de Par√¢metros

```java
@TestFactory
@DisplayName("Testa combina√ß√µes de frete")
Stream<DynamicTest> testaCombinacoesFrete() {
    List<String> estados = List.of("SP", "RJ", "MG");
    List<BigDecimal> pesos = List.of(
        new BigDecimal("1.0"),
        new BigDecimal("5.0"),
        new BigDecimal("10.0")
    );

    return estados.stream()
            .flatMap(estado -> pesos.stream()
                    .map(peso -> DynamicTest.dynamicTest(
                        String.format("Frete %s - %.1f kg", estado, peso),
                        () -> {
                            BigDecimal frete = freteService.calcular(estado, peso);

                            assertNotNull(frete);
                            assertTrue(frete.compareTo(BigDecimal.ZERO) >= 0);

                            // Regra: SP √© mais barato
                            if ("SP".equals(estado)) {
                                assertTrue(frete.compareTo(new BigDecimal("50")) <= 0);
                            }
                        }
                    ))
            );
}
```

---

## üìä Testes de Performance Din√¢micos

```java
@TestFactory
@DisplayName("Valida tempos de resposta")
Stream<DynamicTest> validaTemposResposta() {
    Map<String, Long> endpoints = Map.of(
        "/api/clientes", 100L,     // Max 100ms
        "/api/produtos", 150L,     // Max 150ms
        "/api/pedidos", 200L,      // Max 200ms
        "/api/relatorios", 500L    // Max 500ms
    );

    return endpoints.entrySet().stream()
            .map(entry -> DynamicTest.dynamicTest(
                entry.getKey() + " deve responder em < " + entry.getValue() + "ms",
                () -> {
                    long inicio = System.currentTimeMillis();

                    mockMvc.perform(get(entry.getKey()))
                            .andExpect(status().isOk());

                    long duracao = System.currentTimeMillis() - inicio;

                    assertTrue(duracao < entry.getValue(),
                        String.format("Endpoint %s demorou %dms (esperado < %dms)",
                            entry.getKey(), duracao, entry.getValue())
                    );
                }
            ));
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Nomes descritivos din√¢micos
DynamicTest.dynamicTest("Cliente: " + nome, () -> { ... })

// ‚úÖ Validar dados antes de gerar testes
Objects.requireNonNull(produtos, "Lista de produtos n√£o pode ser nula");

// ‚úÖ Usar DynamicContainer para organizar
DynamicContainer.dynamicContainer("Categoria", testes)

// ‚úÖ Lazy evaluation (Stream, n√£o Collection)
Stream<DynamicTest>  // ‚úÖ
Collection<DynamicTest>  // ‚ö†Ô∏è OK, mas menos eficiente

// ‚úÖ Fail-fast em caso de erro
.peek(produto -> {
    if (produto.getPreco() == null) {
        fail("Pre√ßo n√£o pode ser nulo");
    }
})

// ‚úÖ Logs informativos
DynamicTest.dynamicTest(nome, () -> {
    log.info("Testando: {}", nome);
    // test logic
})
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Gerar muitos testes desnecess√°rios
IntStream.range(0, 10000).mapToObj(...)  // ‚ùå 10k testes!

// ‚úÖ Limitar quantidade razo√°vel
IntStream.range(0, 100).mapToObj(...)

// ‚ùå L√≥gica complexa dentro do teste
DynamicTest.dynamicTest(nome, () -> {
    // 100 linhas de c√≥digo
})

// ‚úÖ Extrair para m√©todos auxiliares

// ‚ùå N√£o validar entrada
produtos.stream().map(p -> DynamicTest...)  // E se produtos for null?

// ‚úÖ Validar primeiro
Objects.requireNonNull(produtos);

// ‚ùå Exceptions n√£o tratadas
() -> Files.lines(path)  // Pode lan√ßar IOException

// ‚úÖ Tratar exceptions
() -> {
    try {
        Files.lines(path)...
    } catch (IOException e) {
        fail("Erro ao ler arquivo: " + e.getMessage());
    }
}
```

---

## üéØ Quando Usar @TestFactory?

| Cen√°rio                             | @TestFactory | @ParameterizedTest |
| ----------------------------------- | ------------ | ------------------ |
| Dados externos (CSV, JSON, API)     | ‚úÖ Sim       | ‚ö†Ô∏è Limitado        |
| Quantidade vari√°vel de testes       | ‚úÖ Sim       | ‚ùå N√£o             |
| L√≥gica condicional (if/else)        | ‚úÖ Sim       | ‚ùå N√£o             |
| Testes aninhados (DynamicContainer) | ‚úÖ Sim       | ‚ùå N√£o             |
| Dados conhecidos em compile-time    | ‚ùå N√£o       | ‚úÖ Sim             |
| Melhor performance                  | ‚ùå N√£o       | ‚úÖ Sim             |

---

## üìù Resumo

**Testes Din√¢micos** oferecem:

- ‚úÖ **@TestFactory**: Gera√ß√£o em runtime
- ‚úÖ **DynamicTest**: Testes individuais
- ‚úÖ **DynamicContainer**: Testes aninhados
- ‚úÖ **Streams**: Gera√ß√£o lazy e eficiente
- ‚úÖ **Dados externos**: CSV, JSON, APIs
- ‚úÖ **L√≥gica condicional**: if/else, features toggles
- ‚úÖ **Flexibilidade m√°xima**: Adapta aos dados dispon√≠veis

**Regra de ouro:** Use **@TestFactory** quando a **quantidade ou estrutura dos testes n√£o √© conhecida em compile-time** ou quando precisa **l√≥gica condicional** complexa.
