# 02.1 Testes Parametrizados Avan√ßados [INTERMEDI√ÅRIO] üîÑ

## üéØ Objetivo

Dominar t√©cnicas **avan√ßadas de testes parametrizados** com **@ParameterizedTest**, incluindo **m√∫ltiplas fontes de dados**, **convers√£o customizada**, **agrega√ß√£o de argumentos** e **testes combinatoriais** para maximizar **cobertura** e **reusabilidade**.

---

## üìö O Que S√£o Testes Parametrizados Avan√ßados?

**Testes parametrizados avan√ßados** v√£o al√©m do `@ValueSource`, utilizando **m√∫ltiplas fontes**, **convers√£o customizada**, **argumentos compostos** e **combina√ß√£o de par√¢metros** para testar **cen√°rios complexos** com **c√≥digo reutiliz√°vel**.

### Por Que Usar?

- ‚úÖ **M√∫ltiplas combina√ß√µes**: Testa todas as varia√ß√µes poss√≠veis
- ‚úÖ **Convers√£o customizada**: Transforma strings em objetos complexos
- ‚úÖ **Argumentos compostos**: M√∫ltiplos par√¢metros por execu√ß√£o
- ‚úÖ **C√≥digo reutiliz√°vel**: M√©todos de factory para dados de teste
- ‚úÖ **Cobertura aumentada**: Mais cen√°rios com menos c√≥digo

---

## üîç Fontes de Dados Avan√ßadas

### 1. @CsvSource (Valores Inline)

```java
@ParameterizedTest
@CsvSource({
    "Jo√£o Silva, joao.silva@empresa.com, true",
    "Maria Santos, maria.santos@empresa.com, true",
    "Pedro, pedro@invalido, false",
    "'', vazio@email.com, false",
    "Nome Completo, '', false"
})
@DisplayName("Deve validar cadastro de cliente")
void deveValidarCadastroCliente(String nome, String email, boolean esperado) {
    // Arrange
    ClienteRequest request = new ClienteRequest(nome, email);

    // Act
    boolean resultado = validadorService.validar(request);

    // Assert
    assertEquals(esperado, resultado);
}
```

**Caracter√≠sticas:**

- ‚úÖ Valores inline (f√°cil de ler)
- ‚úÖ Suporta strings vazias com `''`
- ‚úÖ Delimitador padr√£o: v√≠rgula
- ‚úÖ Suporta caracteres especiais

### 2. @CsvFileSource (Arquivo CSV)

```csv
# resources/test-data/clientes.csv
nome,email,cpf,esperado
Jo√£o Silva,joao@empresa.com,12345678901,true
Maria Santos,maria@empresa.com,98765432100,true
Pedro Oliveira,pedro@empresa.com,11111111111,false
Ana Costa,,22222222222,false
Carlos Souza,carlos@empresa.com,,false
```

```java
@ParameterizedTest
@CsvFileSource(
    resources = "/test-data/clientes.csv",
    numLinesToSkip = 1,  // Pula header
    delimiter = ',',
    encoding = "UTF-8"
)
@DisplayName("Deve validar clientes do arquivo CSV")
void deveValidarClientesDoArquivo(
    String nome,
    String email,
    String cpf,
    boolean esperado
) {
    // Arrange
    ClienteRequest request = new ClienteRequest(nome, email, cpf);

    // Act
    boolean resultado = validadorService.validar(request);

    // Assert
    assertEquals(esperado, resultado,
        () -> "Valida√ß√£o falhou para: " + nome);
}
```

**Vantagens:**

- ‚úÖ Dados externos (n√£o no c√≥digo)
- ‚úÖ F√°cil manuten√ß√£o (edita CSV)
- ‚úÖ Compartilh√°vel entre testes
- ‚úÖ Suporta grande volume de dados

### 3. @MethodSource (M√©todos Complexos)

```java
class PedidoServiceTest {

    @ParameterizedTest
    @MethodSource("providerPedidosValidos")
    @DisplayName("Deve processar pedidos v√°lidos")
    void deveProcessarPedidosValidos(PedidoRequest pedido, BigDecimal totalEsperado) {
        // Act
        PedidoResponse response = pedidoService.processar(pedido);

        // Assert
        assertNotNull(response.getId());
        assertEquals(totalEsperado, response.getTotal());
        assertEquals(StatusPedido.CONFIRMADO, response.getStatus());
    }

    // Factory method para testes
    static Stream<Arguments> providerPedidosValidos() {
        return Stream.of(
            // Pedido simples
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(1L)
                    .items(List.of(
                        new ItemRequest("PROD-001", 2, new BigDecimal("50.00"))
                    ))
                    .build(),
                new BigDecimal("100.00")
            ),

            // Pedido com m√∫ltiplos itens
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(2L)
                    .items(List.of(
                        new ItemRequest("PROD-001", 1, new BigDecimal("50.00")),
                        new ItemRequest("PROD-002", 3, new BigDecimal("30.00"))
                    ))
                    .build(),
                new BigDecimal("140.00")
            ),

            // Pedido com desconto
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(3L)
                    .cupomDesconto("DESC10")
                    .items(List.of(
                        new ItemRequest("PROD-001", 1, new BigDecimal("100.00"))
                    ))
                    .build(),
                new BigDecimal("90.00")  // 10% de desconto
            )
        );
    }

    @ParameterizedTest
    @MethodSource("providerPedidosInvalidos")
    @DisplayName("Deve rejeitar pedidos inv√°lidos")
    void deveRejeitarPedidosInvalidos(
        PedidoRequest pedido,
        Class<? extends Exception> exceptionEsperada,
        String mensagemEsperada
    ) {
        // Act & Assert
        Exception exception = assertThrows(exceptionEsperada, () -> {
            pedidoService.processar(pedido);
        });

        assertTrue(exception.getMessage().contains(mensagemEsperada));
    }

    static Stream<Arguments> providerPedidosInvalidos() {
        return Stream.of(
            // Cliente inexistente
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(999L)
                    .items(List.of(new ItemRequest("PROD-001", 1, new BigDecimal("50.00"))))
                    .build(),
                ResourceNotFoundException.class,
                "Cliente n√£o encontrado"
            ),

            // Sem itens
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(1L)
                    .items(List.of())
                    .build(),
                ValidationException.class,
                "Pedido deve ter pelo menos 1 item"
            ),

            // Quantidade inv√°lida
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(1L)
                    .items(List.of(new ItemRequest("PROD-001", 0, new BigDecimal("50.00"))))
                    .build(),
                ValidationException.class,
                "Quantidade deve ser maior que zero"
            ),

            // Cupom inv√°lido
            Arguments.of(
                PedidoRequest.builder()
                    .clienteId(1L)
                    .cupomDesconto("INVALIDO")
                    .items(List.of(new ItemRequest("PROD-001", 1, new BigDecimal("50.00"))))
                    .build(),
                BusinessException.class,
                "Cupom de desconto inv√°lido ou expirado"
            )
        );
    }
}
```

**Vantagens:**

- ‚úÖ Objetos complexos como par√¢metros
- ‚úÖ L√≥gica condicional para gerar dados
- ‚úÖ Reaproveitamento de factory methods
- ‚úÖ M√∫ltiplos tipos de retorno (Arguments)

### 4. @ArgumentsSource (Provedor Customizado)

```java
// Provedor customizado
class ProdutosProvider implements ArgumentsProvider {

    @Override
    public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
        return Stream.of(
            Arguments.of(
                Produto.builder()
                    .codigo("PROD-001")
                    .nome("Notebook")
                    .preco(new BigDecimal("3000.00"))
                    .estoque(10)
                    .build()
            ),
            Arguments.of(
                Produto.builder()
                    .codigo("PROD-002")
                    .nome("Mouse")
                    .preco(new BigDecimal("50.00"))
                    .estoque(100)
                    .build()
            ),
            Arguments.of(
                Produto.builder()
                    .codigo("PROD-003")
                    .nome("Teclado")
                    .preco(new BigDecimal("150.00"))
                    .estoque(50)
                    .build()
            )
        );
    }
}

// Uso
@ParameterizedTest
@ArgumentsSource(ProdutosProvider.class)
@DisplayName("Deve processar produtos v√°lidos")
void deveProcessarProdutosValidos(Produto produto) {
    // Act
    ProdutoResponse response = produtoService.salvar(produto);

    // Assert
    assertNotNull(response.getId());
    assertEquals(produto.getCodigo(), response.getCodigo());
    assertTrue(response.getEstoque() >= 0);
}
```

**Vantagens:**

- ‚úÖ Reutiliz√°vel entre classes de teste
- ‚úÖ L√≥gica complexa de gera√ß√£o
- ‚úÖ Acesso a recursos externos (DB, APIs)
- ‚úÖ Configura√ß√£o din√¢mica

---

## üîÑ Convers√£o Customizada

### @ConvertWith (Converter Customizado)

```java
// Converter customizado
class JsonToClienteConverter implements ArgumentConverter {

    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public Object convert(Object source, ParameterContext context)
            throws ArgumentConversionException {
        if (!(source instanceof String)) {
            throw new ArgumentConversionException("Source must be a String");
        }

        try {
            return mapper.readValue((String) source, Cliente.class);
        } catch (JsonProcessingException e) {
            throw new ArgumentConversionException("Failed to parse JSON", e);
        }
    }
}

// Uso
@ParameterizedTest
@ValueSource(strings = {
    "{\"nome\":\"Jo√£o\",\"email\":\"joao@empresa.com\",\"cpf\":\"12345678901\"}",
    "{\"nome\":\"Maria\",\"email\":\"maria@empresa.com\",\"cpf\":\"98765432100\"}"
})
@DisplayName("Deve converter JSON para Cliente")
void deveConverterJsonParaCliente(
    @ConvertWith(JsonToClienteConverter.class) Cliente cliente
) {
    // Act
    ClienteResponse response = clienteService.salvar(cliente);

    // Assert
    assertNotNull(response.getId());
    assertEquals(cliente.getNome(), response.getNome());
    assertEquals(cliente.getEmail(), response.getEmail());
}
```

### Convers√£o Impl√≠cita

```java
// JUnit converte automaticamente tipos simples
@ParameterizedTest
@ValueSource(strings = {"2024-01-01", "2024-12-31", "2025-06-15"})
@DisplayName("Deve processar datas v√°lidas")
void deveProcessarDatasValidas(LocalDate data) {
    // JUnit converte String ‚Üí LocalDate automaticamente
    assertTrue(data.getYear() >= 2024);
}

@ParameterizedTest
@CsvSource({
    "ATIVO, true",
    "INATIVO, false",
    "PENDENTE, false"
})
@DisplayName("Deve validar status do cliente")
void deveValidarStatusCliente(StatusCliente status, boolean esperaAcesso) {
    // JUnit converte String ‚Üí Enum automaticamente
    boolean temAcesso = clienteService.verificarAcesso(status);
    assertEquals(esperaAcesso, temAcesso);
}
```

---

## üéØ Agrega√ß√£o de Argumentos

### @AggregateWith (Agregar M√∫ltiplos Par√¢metros)

```java
// Aggregator customizado
class ClienteAggregator implements ArgumentsAggregator {

    @Override
    public Object aggregateArguments(
        ArgumentsAccessor accessor,
        ParameterContext context
    ) throws ArgumentsAggregationException {
        return Cliente.builder()
                .nome(accessor.getString(0))
                .email(accessor.getString(1))
                .cpf(accessor.getString(2))
                .dataNascimento(accessor.get(3, LocalDate.class))
                .build();
    }
}

// Uso
@ParameterizedTest
@CsvSource({
    "Jo√£o Silva, joao@empresa.com, 12345678901, 1990-01-15",
    "Maria Santos, maria@empresa.com, 98765432100, 1985-05-20",
    "Pedro Costa, pedro@empresa.com, 11122233344, 2000-12-10"
})
@DisplayName("Deve criar clientes com aggregator")
void deveCriarClientesComAggregator(
    @AggregateWith(ClienteAggregator.class) Cliente cliente
) {
    // Act
    ClienteResponse response = clienteService.salvar(cliente);

    // Assert
    assertNotNull(response.getId());
    assertEquals(cliente.getNome(), response.getNome());
    assertTrue(response.getIdade() >= 18);
}
```

### ArgumentsAccessor (Acesso Direto)

```java
@ParameterizedTest
@CsvSource({
    "1, ATIVO, 100.00, 10",
    "2, INATIVO, 50.00, 0",
    "3, PENDENTE, 200.00, 5"
})
@DisplayName("Deve processar com accessor")
void deveProcessarComAccessor(ArgumentsAccessor args) {
    // Acesso direto aos par√¢metros por √≠ndice
    Long id = args.getLong(0);
    StatusConta status = args.get(1, StatusConta.class);
    BigDecimal saldo = args.get(2, BigDecimal.class);
    int transacoes = args.getInteger(3);

    // Act
    Conta conta = contaService.buscar(id);

    // Assert
    assertEquals(status, conta.getStatus());
    assertEquals(saldo, conta.getSaldo());
    assertEquals(transacoes, conta.getTransacoes().size());
}
```

---

## üîÄ Testes Combinatoriais

### @EnumSource (Combina√ß√£o de Enums)

```java
enum TipoPagamento { CREDITO, DEBITO, BOLETO, PIX }
enum StatusPedido { NOVO, CONFIRMADO, PROCESSANDO, ENVIADO, ENTREGUE }

@ParameterizedTest
@EnumSource(TipoPagamento.class)
@DisplayName("Deve processar todos os tipos de pagamento")
void deveProcessarTodosTiposPagamento(TipoPagamento tipo) {
    // Arrange
    PagamentoRequest request = new PagamentoRequest(
        1L,  // pedidoId
        new BigDecimal("100.00"),
        tipo
    );

    // Act
    PagamentoResponse response = pagamentoService.processar(request);

    // Assert
    assertNotNull(response.getTransacaoId());
    assertEquals(tipo, response.getTipoPagamento());
}

@ParameterizedTest
@EnumSource(
    value = StatusPedido.class,
    names = {"NOVO", "CONFIRMADO"},  // Apenas estes
    mode = EnumSource.Mode.INCLUDE
)
@DisplayName("Deve cancelar pedidos em status permitido")
void deveCancelarPedidosEmStatusPermitido(StatusPedido status) {
    // Arrange
    Pedido pedido = Pedido.builder()
            .id(1L)
            .status(status)
            .build();

    // Act & Assert
    assertDoesNotThrow(() -> pedidoService.cancelar(pedido.getId()));
}

@ParameterizedTest
@EnumSource(
    value = StatusPedido.class,
    names = {"NOVO", "CONFIRMADO"},
    mode = EnumSource.Mode.EXCLUDE  // Todos exceto estes
)
@DisplayName("Deve rejeitar cancelamento de pedidos em processo")
void deveRejeitarCancelamentoPedidosEmProcesso(StatusPedido status) {
    // Arrange
    Pedido pedido = Pedido.builder()
            .id(1L)
            .status(status)
            .build();

    when(pedidoRepository.findById(1L)).thenReturn(Optional.of(pedido));

    // Act & Assert
    assertThrows(BusinessException.class, () -> {
        pedidoService.cancelar(pedido.getId());
    });
}
```

### Combina√ß√£o Cartesiana (Manual)

```java
@ParameterizedTest
@MethodSource("providerCombinacoes")
@DisplayName("Deve testar todas as combina√ß√µes de desconto")
void deveTestarTodasCombinacoes(
    BigDecimal valorPedido,
    String cupom,
    boolean clienteVip,
    BigDecimal descontoEsperado
) {
    // Arrange
    Pedido pedido = Pedido.builder()
            .total(valorPedido)
            .cupomDesconto(cupom)
            .clienteVip(clienteVip)
            .build();

    // Act
    BigDecimal desconto = descontoService.calcular(pedido);

    // Assert
    assertEquals(descontoEsperado, desconto);
}

static Stream<Arguments> providerCombinacoes() {
    List<BigDecimal> valores = List.of(
        new BigDecimal("100.00"),
        new BigDecimal("500.00"),
        new BigDecimal("1000.00")
    );

    List<String> cupons = List.of("DESC10", "DESC20", null);
    List<Boolean> vips = List.of(true, false);

    // Combina√ß√£o cartesiana manual
    List<Arguments> combinacoes = new ArrayList<>();

    for (BigDecimal valor : valores) {
        for (String cupom : cupons) {
            for (Boolean vip : vips) {
                BigDecimal desconto = calcularDescontoEsperado(valor, cupom, vip);
                combinacoes.add(Arguments.of(valor, cupom, vip, desconto));
            }
        }
    }

    return combinacoes.stream();
}

private static BigDecimal calcularDescontoEsperado(
    BigDecimal valor,
    String cupom,
    boolean vip
) {
    BigDecimal desconto = BigDecimal.ZERO;

    // Desconto por cupom
    if ("DESC10".equals(cupom)) {
        desconto = desconto.add(valor.multiply(new BigDecimal("0.10")));
    } else if ("DESC20".equals(cupom)) {
        desconto = desconto.add(valor.multiply(new BigDecimal("0.20")));
    }

    // Desconto adicional VIP
    if (vip) {
        desconto = desconto.add(valor.multiply(new BigDecimal("0.05")));
    }

    return desconto;
}
```

---

## üìã Boas Pr√°ticas

### ‚úÖ Recomenda√ß√µes

```java
// ‚úÖ Nomes descritivos para par√¢metros
@ParameterizedTest
@CsvSource({"10, 20, 30", "5, 5, 10"})
void deveSomarCorretamente(int valor1, int valor2, int somaEsperada) { }

// ‚úÖ @DisplayName din√¢mico
@ParameterizedTest(name = "[{index}] Cliente: {0}, Email: {1}")
@CsvSource({"Jo√£o, joao@empresa.com", "Maria, maria@empresa.com"})
void deveValidarCliente(String nome, String email) { }

// ‚úÖ Factory methods para dados complexos
@MethodSource("providerPedidos")

// ‚úÖ Separar dados v√°lidos e inv√°lidos
@MethodSource("providerPedidosValidos")
@MethodSource("providerPedidosInvalidos")

// ‚úÖ CSV para grande volume
@CsvFileSource(resources = "/test-data/1000-clientes.csv")

// ‚úÖ Validar todos os campos
assertAll(
    () -> assertEquals(esperado.getNome(), resultado.getNome()),
    () -> assertEquals(esperado.getEmail(), resultado.getEmail()),
    () -> assertEquals(esperado.getCpf(), resultado.getCpf())
);
```

### ‚ùå Anti-Patterns

```java
// ‚ùå Muitos par√¢metros inline (ileg√≠vel)
@CsvSource({
    "Jo√£o Silva, joao@empresa.com, 12345678901, Rua A, 123, SP, S√£o Paulo, 01234-567, (11) 98765-4321, true, ATIVO, 2024-01-01"
})

// ‚úÖ Usar @CsvFileSource ou @MethodSource

// ‚ùå L√≥gica complexa no teste
@ParameterizedTest
void teste(String valor) {
    if (valor.contains("A")) {
        // testa X
    } else if (valor.contains("B")) {
        // testa Y
    } else {
        // testa Z
    }
}

// ‚úÖ Separar em testes espec√≠ficos

// ‚ùå Dados hardcoded em m√∫ltiplos testes
@ValueSource(strings = {"Jo√£o", "Maria"})  // repetido em 5 testes

// ‚úÖ Centralizar em @MethodSource compartilhado

// ‚ùå Par√¢metros sem valida√ß√£o
@ParameterizedTest
void teste(String valor) {
    // Usa valor sem verificar se √© v√°lido
}

// ‚úÖ Validar par√¢metros no in√≠cio
assertNotNull(valor);
assertFalse(valor.isBlank());
```

---

## üìù Resumo

**Testes Parametrizados Avan√ßados** oferecem:

- ‚úÖ **@CsvSource / @CsvFileSource**: Dados tabulares
- ‚úÖ **@MethodSource**: Objetos complexos
- ‚úÖ **@ArgumentsSource**: Provedores customizados
- ‚úÖ **@ConvertWith**: Convers√£o customizada
- ‚úÖ **@AggregateWith**: Agrega√ß√£o de argumentos
- ‚úÖ **@EnumSource**: Testes com enums
- ‚úÖ **Combina√ß√µes**: Testes cartesianos

**Regra de ouro:** Use **@CsvFileSource** para grande volume, **@MethodSource** para objetos complexos, e **factory methods** reutiliz√°veis para m√°xima cobertura com m√≠nimo c√≥digo.
