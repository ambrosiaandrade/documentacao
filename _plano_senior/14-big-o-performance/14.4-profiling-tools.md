# ğŸ”¥ MÃ³dulo 14.4: Profiling Tools

> **Objetivo:** Dominar ferramentas de profiling para identificar bottlenecks de performance.

---

## ğŸ¯ O Que VocÃª Vai Aprender

### ğŸ“š ExplicaÃ§Ã£o TÃ©cnica

Profiling Ã© o processo de medir onde seu programa gasta tempo (CPU profiling), aloca memÃ³ria (memory profiling), ou tem contenÃ§Ã£o de threads (concurrency profiling). Ferramentas como JProfiler, YourKit, async-profiler e JFR permitem identificar gargalos sem adivinhar, mostrando exatamente quais mÃ©todos sÃ£o lentos ou consomem muita memÃ³ria.

### ğŸˆ Analogia Simples

Imagine que sua loja demora 1 hora para atender cada cliente, mas vocÃª nÃ£o sabe por quÃª:

**Sem Profiling (AdivinhaÃ§Ã£o):**

- "Acho que Ã© o caixa lento!" âŒ
- "Talvez seja o estoque?" âŒ
- VocÃª fica testando mudanÃ§as Ã s cegas...

**Com Profiling (Detetive com CronÃ´metro):**

- â±ï¸ Entrada do cliente: 1 minuto
- â±ï¸ Escolher produto: 5 minutos
- â±ï¸ **Esperar aprovaÃ§Ã£o do gerente: 50 minutos** ğŸ”´ â† GARGALO!
- â±ï¸ Caixa: 4 minutos

**Descoberta:** 50 dos 60 minutos sÃ£o na aprovaÃ§Ã£o! Agora vocÃª sabe onde otimizar!

**Em cÃ³digo:** Profiling mostra que 80% do tempo estÃ¡ em 1 mÃ©todo especÃ­fico (ex: query SQL lenta). AÃ­ vocÃª otimiza EXATAMENTE o problema, nÃ£o fica adivinhando!

---

## ğŸ“‘ Ãndice

1. [IntroduÃ§Ã£o ao Profiling](#1-introducao-ao-profiling)
2. [JProfiler](#2-jprofiler)
3. [YourKit](#3-yourkit)
4. [async-profiler](#4-async-profiler)
5. [Java Flight Recorder (JFR)](#5-java-flight-recorder-jfr)
6. [Flame Graphs](#6-flame-graphs)

---

## 1. IntroduÃ§Ã£o ao Profiling

### 1.1 Tipos de Profiling

```java
/**
 * CPU PROFILING: Onde o tempo Ã© gasto?
 *
 * TÃ©cnicas:
 * 1. Sampling: Captura stack trace em intervalos (baixo overhead)
 * 2. Instrumentation: Injeta cÃ³digo para medir (alto overhead, preciso)
 *
 * Usa para:
 * - Identificar hot methods (mÃ©todos mais executados)
 * - Analisar call tree (quem chama quem)
 * - Detectar loops ineficientes
 */

/**
 * MEMORY PROFILING: Onde a memÃ³ria Ã© alocada?
 *
 * MÃ©tricas:
 * - Shallow size: Tamanho do objeto em si
 * - Retained size: Tamanho + objetos referenciados (GC liberaria)
 * - Allocation rate: Objetos alocados por segundo
 *
 * Usa para:
 * - Detectar memory leaks
 * - Otimizar alocaÃ§Ãµes (reduzir GC pressure)
 * - Analisar object retention
 */

/**
 * THREAD PROFILING: Como threads estÃ£o sendo usadas?
 *
 * MÃ©tricas:
 * - Thread states (RUNNABLE, WAITING, BLOCKED)
 * - Lock contention (disputas por locks)
 * - Deadlocks
 *
 * Usa para:
 * - Identificar bottlenecks de sincronizaÃ§Ã£o
 * - Detectar deadlocks
 * - Otimizar thread pools
 */

/**
 * I/O PROFILING: Quanto tempo em I/O?
 *
 * MÃ©tricas:
 * - File I/O (leitura/escrita)
 * - Network I/O (sockets)
 * - Database queries
 *
 * Usa para:
 * - Identificar queries lentas
 * - Otimizar file access
 * - Detectar I/O blocking desnecessÃ¡rio
 */
```

---

### 1.2 Overhead Trade-offs

| TÃ©cnica             | Overhead          | PrecisÃ£o   | Quando Usar                |
| ------------------- | ----------------- | ---------- | -------------------------- |
| **Sampling**        | Baixo (~1-2%)     | Aproximado | ProduÃ§Ã£o, overview         |
| **Instrumentation** | Alto (10-50%)     | Exato      | Desenvolvimento, deep dive |
| **JFR**             | Muito baixo (<1%) | Bom        | ProduÃ§Ã£o contÃ­nua          |
| **Heap Dump**       | Alto (pause)      | Snapshot   | InvestigaÃ§Ã£o memory leak   |

---

## 2. JProfiler

### 2.1 Setup

```bash
# Download: https://www.ej-technologies.com/products/jprofiler/overview.html
# Trial: 10 dias

# Attach to running JVM:
# 1. Via GUI: Session â†’ Attach â†’ Select Process
# 2. Via agent:
java -agentpath:/path/to/jprofiler/bin/linux-x64/libjprofilerti.so=port=8849 \
     -jar app.jar

# JProfiler conecta em localhost:8849
```

---

### 2.2 CPU Profiling

```java
/**
 * CENÃRIO: Identificar mÃ©todo lento
 */
@RestController
public class UserController {

    @GetMapping("/users")
    public List<User> getUsers() {
        // JProfiler mostrarÃ¡ que este mÃ©todo Ã© hot spot
        return userService.getAllUsers();  // 80% do tempo aqui
    }
}

@Service
public class UserService {

    public List<User> getAllUsers() {
        var users = userRepository.findAll();

        // JProfiler mostrarÃ¡ que este loop Ã© gargalo
        for (User user : users) {
            enrichUser(user);  // 1000 queries N+1!
        }

        return users;
    }

    private void enrichUser(User user) {
        user.setOrders(orderRepository.findByUserId(user.getId()));
    }
}
```

**JProfiler Output:**

```
Call Tree:
UserController.getUsers()         100% | 5000ms
â””â”€ UserService.getAllUsers()      98%  | 4900ms
   â”œâ”€ UserRepository.findAll()    2%   | 100ms
   â””â”€ enrichUser() (1000 calls)   96%  | 4800ms
      â””â”€ OrderRepository.findByUserId()  | 4.8ms/call
```

**AnÃ¡lise:**

- `enrichUser()` chamado 1000x = N+1 problem
- SoluÃ§Ã£o: Usar JOIN FETCH ou batch loading

---

### 2.3 Memory Profiling

```java
/**
 * CENÃRIO: Memory leak - cache crescendo infinito
 */
@Service
public class CacheService {
    // âŒ LEAK: HashMap nunca limpa
    private final Map<String, byte[]> cache = new HashMap<>();

    public void cacheData(String key, byte[] data) {
        cache.put(key, data);  // Cresce indefinidamente
    }
}
```

**JProfiler - Live Memory:**

1. Views â†’ Live Memory â†’ All Objects
2. Ordena por "Retained Size"
3. VÃª: `HashMap` com 2GB retained

**JProfiler - Allocation Hot Spots:**

```
Allocation Hot Spots:
byte[] (2.1 GB allocated)
â””â”€ CacheService.cacheData()  90%
   â””â”€ called by RestController  (10.000 calls)
```

**Fix:**

```java
// âœ… Usa Caffeine com eviction
@Service
public class CacheService {
    private final Cache<String, byte[]> cache = Caffeine.newBuilder()
        .maximumSize(1000)  // Limita tamanho
        .expireAfterWrite(Duration.ofMinutes(10))  // TTL
        .build();

    public void cacheData(String key, byte[] data) {
        cache.put(key, data);
    }
}
```

---

### 2.4 Thread Profiling

```java
/**
 * CENÃRIO: Lock contention
 */
@Service
public class CounterService {
    private int counter = 0;

    // âŒ synchronized muito granular = contention
    public synchronized void increment() {
        counter++;
    }

    public synchronized int getCounter() {
        return counter;
    }
}
```

**JProfiler - Thread Monitor:**

```
Thread State Analysis:
- RUNNABLE: 10%
- BLOCKED: 80%  â† Problema!
- WAITING: 10%

Lock Contention:
CounterService monitor: 1000 threads blocked
Average wait time: 500ms
```

**Fix:**

```java
// âœ… Usa AtomicInteger (lock-free)
@Service
public class CounterService {
    private final AtomicInteger counter = new AtomicInteger(0);

    public void increment() {
        counter.incrementAndGet();  // Lock-free
    }

    public int getCounter() {
        return counter.get();
    }
}
```

---

## 3. YourKit

### 3.1 Setup

```bash
# Download: https://www.yourkit.com/java/profiler/
# Trial: 15 dias

# Attach via agent:
java -agentpath:/path/to/yourkit/bin/linux-x86-64/libyjpagent.so=port=10001 \
     -jar app.jar

# YourKit conecta em localhost:10001
```

---

### 3.2 CPU Sampling

```java
/**
 * CENÃRIO: API lenta
 */
@RestController
public class ReportController {

    @GetMapping("/report")
    public ReportDto generateReport() {
        var data = fetchData();         // 1000ms
        var processed = process(data);  // 5000ms â† Gargalo!
        return buildReport(processed);  // 100ms
    }

    private List<Data> fetchData() {
        return dataService.fetchAll();
    }

    private List<Data> process(List<Data> data) {
        // âŒ Processamento ineficiente
        return data.stream()
            .map(this::expensiveTransform)  // 5ms/item * 1000 = 5000ms
            .collect(Collectors.toList());
    }

    private Data expensiveTransform(Data d) {
        // SimulaÃ§Ã£o de processamento pesado
        try {
            Thread.sleep(5);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return d;
    }

    private ReportDto buildReport(List<Data> data) {
        return new ReportDto(data);
    }
}
```

**YourKit - CPU Sampling:**

```
Method                              Time    %
ReportController.generateReport()   6100ms  100%
â”œâ”€ fetchData()                      1000ms  16%
â”œâ”€ process()                        5000ms  82%  â† Hot spot
â”‚  â””â”€ expensiveTransform()          5000ms  82%
â””â”€ buildReport()                    100ms   2%
```

**AnÃ¡lise:**

- `process()` consome 82% do tempo
- SoluÃ§Ã£o: Paralelizar com parallel streams

**Fix:**

```java
private List<Data> process(List<Data> data) {
    // âœ… Paraleliza processamento
    return data.parallelStream()  // Usa ForkJoinPool
        .map(this::expensiveTransform)
        .collect(Collectors.toList());
}
// Reduz de 5000ms para ~1250ms (4 cores)
```

---

### 3.3 Allocation Recording

```java
/**
 * CENÃRIO: Muitas alocaÃ§Ãµes temporÃ¡rias
 */
@Service
public class StringProcessor {

    // âŒ Aloca muitas Strings (immutable)
    public String processLegacy(List<String> items) {
        String result = "";
        for (String item : items) {
            result += item + ",";  // Cria nova String a cada iteraÃ§Ã£o!
        }
        return result;
    }
    // n=1000 â†’ 1000 Strings alocadas (500KB)
}
```

**YourKit - Allocation Recording:**

```
Allocated Types:
String: 500KB (1000 instances)
â””â”€ StringProcessor.processLegacy()  100%

Allocation Rate: 50MB/sec  â† Alto!
GC Pressure: Alto (Minor GC a cada 2s)
```

**Fix:**

```java
// âœ… Usa StringBuilder (mutable)
public String processOptimized(List<String> items) {
    var sb = new StringBuilder();
    for (String item : items) {
        sb.append(item).append(",");  // Mesma instÃ¢ncia
    }
    return sb.toString();
}
// n=1000 â†’ 1 StringBuilder + 1 String final (5KB)
```

---

## 4. async-profiler

### 4.1 Setup

```bash
# Download: https://github.com/jvm-profiling-tools/async-profiler
# Open source, production-ready

# Baixar:
wget https://github.com/jvm-profiling-tools/async-profiler/releases/download/v2.9/async-profiler-2.9-linux-x64.tar.gz
tar xzf async-profiler-2.9-linux-x64.tar.gz

# Profiling:
# 1. Encontrar PID do Java:
jps -l

# 2. Iniciar profiling (60s):
./profiler.sh -d 60 -f flamegraph.html <PID>

# 3. Abrir flamegraph.html no browser
```

---

### 4.2 Flame Graph

```java
/**
 * CENÃRIO: Identificar hot path
 */
@RestController
public class SearchController {

    @GetMapping("/search")
    public List<Product> search(@RequestParam String query) {
        var products = productRepository.findAll();  // 100ms

        // âŒ Filtro ineficiente
        return products.stream()
            .filter(p -> matches(p, query))  // 900ms
            .collect(Collectors.toList());
    }

    private boolean matches(Product p, String query) {
        // Regex complexo em cada produto
        return p.getName().matches(".*" + query + ".*") ||
               p.getDescription().matches(".*" + query + ".*");
    }
}
```

**Flame Graph:**

```
     â–¼ SearchController.search (1000ms total)
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                                           â”‚
     â”‚  â–¼ matches() (900ms - 90% width)                         â”‚  findAll() (100ms)
     â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
     â”‚  â”‚ String.matches() (800ms)                   â”‚ filter() â”‚
     â”‚  â”‚ â””â”€ Pattern.compile() (750ms)               â”‚ (100ms)  â”‚
     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**AnÃ¡lise:**

- `matches()` Ã© 90% do tempo (largura no flame graph)
- `Pattern.compile()` chamado repetidamente (nÃ£o cached)

**Fix:**

```java
@RestController
public class SearchController {

    @GetMapping("/search")
    public List<Product> search(@RequestParam String query) {
        // âœ… Compila regex uma vez
        var pattern = Pattern.compile(".*" + Pattern.quote(query) + ".*");

        return productRepository.findAll().stream()
            .filter(p -> pattern.matcher(p.getName()).matches() ||
                         pattern.matcher(p.getDescription()).matches())
            .collect(Collectors.toList());
    }
}
// Reduz de 1000ms para 200ms
```

---

### 4.3 Profiling em ProduÃ§Ã£o

```bash
# async-profiler tem overhead muito baixo (<1%)
# Pode rodar em produÃ§Ã£o com seguranÃ§a

# Profiling durante 60s:
./profiler.sh -d 60 -f cpu-profile.html <PID>

# Profiling de alocaÃ§Ãµes:
./profiler.sh -e alloc -d 60 -f alloc-profile.html <PID>

# Profiling de lock contention:
./profiler.sh -e lock -d 60 -f lock-profile.html <PID>
```

---

## 5. Java Flight Recorder (JFR)

### 5.1 Setup

```bash
# JFR Ã© built-in no JDK 11+
# Overhead muito baixo (<1%)

# Iniciar JFR ao startar aplicaÃ§Ã£o:
java -XX:StartFlightRecording=duration=60s,filename=recording.jfr \
     -jar app.jar

# Ou attach em runtime:
jcmd <PID> JFR.start duration=60s filename=recording.jfr

# Parar recording:
jcmd <PID> JFR.stop

# Analisar com JDK Mission Control (JMC):
jmc recording.jfr
```

---

### 5.2 Exemplo de AnÃ¡lise

```java
/**
 * CENÃRIO: GC pausas longas
 */
@RestController
public class DataController {

    @GetMapping("/data")
    public List<byte[]> getData() {
        var result = new ArrayList<byte[]>();

        // âŒ Aloca muitos arrays grandes
        for (int i = 0; i < 1000; i++) {
            result.add(new byte[1_000_000]);  // 1MB cada = 1GB total
        }

        return result;
    }
}
```

**JFR Analysis (JMC):**

```
Event Browser:
- GC Pause: 15 events
  - Avg duration: 500ms  â† Problema!
  - Max duration: 1200ms
  - Cause: Allocation Failure (Eden full)

Memory:
- Heap: 4GB max
- Eden: 1GB
- Allocation rate: 2GB/sec  â† Muito alto!

Hot Methods:
- DataController.getData(): 90% allocations
```

**Fix:**

```java
// âœ… Usa objeto pool ou lazy loading
@RestController
public class DataController {

    @GetMapping("/data")
    public StreamingResponseBody getData() {
        return outputStream -> {
            // Stream dados ao invÃ©s de carregar tudo
            for (int i = 0; i < 1000; i++) {
                var data = new byte[1_000_000];
                outputStream.write(data);
                // GC pode coletar imediatamente
            }
        };
    }
}
```

---

### 5.3 JFR Custom Events

```java
/**
 * Criar eventos customizados para profiling
 */
@Component
public class OrderService {

    public void processOrder(Order order) {
        // Registra evento customizado
        var event = new OrderProcessingEvent();
        event.orderId = order.getId();
        event.begin();

        try {
            // Processamento
            validateOrder(order);
            chargePayment(order);
            shipOrder(order);

            event.status = "SUCCESS";
        } catch (Exception e) {
            event.status = "FAILED";
            event.errorMessage = e.getMessage();
            throw e;
        } finally {
            event.commit();  // Registra no JFR
        }
    }
}

/**
 * Definir evento JFR
 */
@Category("Application")
@Label("Order Processing")
class OrderProcessingEvent extends jdk.jfr.Event {
    @Label("Order ID")
    String orderId;

    @Label("Status")
    String status;

    @Label("Error Message")
    String errorMessage;
}
```

**JFR Analysis:**

```
Custom Events:
- OrderProcessingEvent: 1000 events
  - SUCCESS: 980 (avg 50ms)
  - FAILED: 20 (avg 500ms)  â† Investigar
    - Error: "Payment timeout" (15 events)
```

---

## 6. Flame Graphs

### 6.1 InterpretaÃ§Ã£o

```
      â–¼ main() [1000ms total width]
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                                                â”‚
      â”‚  â–¼ processRequests() [900ms - 90%]            â”‚  init() [100ms]
      â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
      â”‚  â”‚                                      â”‚      â”‚
      â”‚  â”‚ â–¼ handleRequest() [800ms - 80%]     â”‚ ...  â”‚
      â”‚  â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚      â”‚
      â”‚  â”‚ â”‚                           â”‚        â”‚      â”‚
      â”‚  â”‚ â”‚ â–¼ queryDB() [600ms - 60%]â”‚ parse()â”‚      â”‚
      â”‚  â”‚ â”‚                           â”‚ [200ms]â”‚      â”‚
      â”‚  â””â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INTERPRETAÃ‡ÃƒO:
- Largura = % tempo total
- queryDB() Ã© 60% do tempo total â†’ Principal bottleneck
- Altura = profundidade da call stack
```

---

### 6.2 Dicas de AnÃ¡lise

```java
/**
 * PADRÃ•ES NO FLAME GRAPH:
 */

/**
 * 1. TOWER (Torre alta e estreita):
 * - Call stack profundo
 * - PossÃ­vel recursÃ£o excessiva
 */
public int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);  // Torre de recursÃ£o
}

/**
 * 2. PLATEAU (Plataforma larga):
 * - MÃ©todo executando muito tempo
 * - Principal candidato para otimizaÃ§Ã£o
 */
public void processLargeFile() {
    // Largo no flame graph = hot spot
    for (int i = 0; i < 1_000_000; i++) {
        expensiveOperation();
    }
}

/**
 * 3. JAGGED (Serrilhado):
 * - Muitas funÃ§Ãµes diferentes chamadas
 * - Overhead de function calls
 */
public void manySmallFunctions() {
    for (int i = 0; i < 1000; i++) {
        fn1(); fn2(); fn3(); fn4(); fn5();  // Jagged
    }
}
```

---

## ğŸ“Š Checklist de Qualidade

- [ ] Profiling regular em staging antes de produÃ§Ã£o
- [ ] JFR habilitado em produÃ§Ã£o (overhead <1%)
- [ ] Flame graphs para identificar hot paths rapidamente
- [ ] Memory profiling para detectar leaks cedo
- [ ] Thread profiling quando suspeitar de lock contention
- [ ] Allocation profiling para reduzir GC pressure
- [ ] Baseline benchmarks antes de otimizar (nÃ£o otimize sem dados!)
- [ ] Profiling comparativo (antes/depois de otimizaÃ§Ã£o)
- [ ] Documentar findings de profiling em PRs
- [ ] Alertas automÃ¡ticos para degradaÃ§Ã£o de performance

---

## ğŸ¯ ExercÃ­cios PrÃ¡ticos

1. **BÃ¡sico**: Usar async-profiler para gerar flame graph de aplicaÃ§Ã£o simples
2. **IntermediÃ¡rio**: Identificar memory leak com JProfiler/YourKit
3. **AvanÃ§ado**: Criar JFR custom events para rastrear operaÃ§Ãµes crÃ­ticas

---

## ğŸ“š ReferÃªncias

- [JProfiler Documentation](https://www.ej-technologies.com/resources/jprofiler/help/doc/)
- [YourKit Documentation](https://www.yourkit.com/docs/)
- [async-profiler GitHub](https://github.com/jvm-profiling-tools/async-profiler)
- [Flame Graphs (Brendan Gregg)](https://www.brendangregg.com/flamegraphs.html)
- [JDK Mission Control](https://docs.oracle.com/en/java/java-components/jdk-mission-control/)

---

**PrÃ³ximo:** [14.5 - JMH Benchmarking](14.5-jmh-benchmarking.md)
