# üìê M√≥dulo 14.1: Fundamentos de Big O

> **Objetivo:** Dominar nota√ß√£o assint√≥tica para an√°lise de complexidade de algoritmos.

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

Big O (nota√ß√£o assint√≥tica) √© uma forma matem√°tica de descrever como o tempo de execu√ß√£o ou espa√ßo de mem√≥ria de um algoritmo cresce em rela√ß√£o ao tamanho da entrada. Permite comparar efici√™ncia de algoritmos independente de hardware, focando no comportamento para grandes entradas (n ‚Üí ‚àû).

### üéà Analogia Simples

Imagine que voc√™ precisa organizar sua cole√ß√£o de cards:

**10 cards:** Qualquer m√©todo funciona r√°pido (segundos)

**10.000 cards:** Agora o m√©todo importa MUITO!

- ‚ùå Comparar cada card com todos os outros: **Horas** (voc√™ vai desistir!)
- ‚úÖ Usar gavetinhas organizadas por tipo: **Minutos** (d√° para fazer!)

**Big O responde:** "Se eu tiver 10x mais cards, quanto tempo a mais vai levar?"

- Gavetinhas: 10x mais tempo (linear - bom!)
- Comparar tudo com tudo: 100x mais tempo (quadr√°tico - p√©ssimo!)

**Em c√≥digo:** Big O nos diz qual algoritmo escolher para N√ÉO deixar o sistema lento quando crescer.

---

## üìë √çndice

1. [O Que √â Big O](#1-o-que-e-big-o)
2. [Nota√ß√µes Assint√≥ticas](#2-notacoes-assintoticas)
3. [Complexidades Comuns](#3-complexidades-comuns)
4. [An√°lise Pr√°tica](#4-analise-pratica)
5. [Trade-offs](#5-trade-offs)

---

## 1. O Que √â Big O

### 1.1 Defini√ß√£o

```java
/**
 * BIG O: Nota√ß√£o matem√°tica para descrever comportamento assint√≥tico
 *
 * Mede crescimento de tempo/espa√ßo em rela√ß√£o ao tamanho da entrada (n)
 *
 * Exemplo:
 * - Algoritmo A: 5n¬≤ + 3n + 10 opera√ß√µes
 * - Algoritmo B: 100n opera√ß√µes
 *
 * Para n pequeno (n=10):
 * - A: 5(100) + 30 + 10 = 540 opera√ß√µes
 * - B: 1000 opera√ß√µes
 * - A √© mais r√°pido!
 *
 * Para n grande (n=1000):
 * - A: 5(1.000.000) + 3000 + 10 = 5.003.010 opera√ß√µes
 * - B: 100.000 opera√ß√µes
 * - B √© MUITO mais r√°pido!
 *
 * Big O ignora constantes e termos menores:
 * - A: O(n¬≤)
 * - B: O(n)
 *
 * Big O descreve pior caso (worst-case) por padr√£o
 */

/**
 * POR QUE BIG O?
 *
 * 1. Comparar algoritmos independente de hardware
 * 2. Prever escalabilidade (n=1000 vs n=1.000.000)
 * 3. Identificar gargalos de performance
 * 4. Trade-offs entre tempo e espa√ßo
 */
```

---

### 1.2 Exemplo Pr√°tico

```java
/**
 * Cen√°rio: Buscar item em lista
 */
public class SearchExamples {

    /**
     * Busca linear: O(n)
     *
     * Pior caso: Item no final ou n√£o existe
     * - Precisa checar todos os n elementos
     */
    public boolean linearSearch(List<Integer> list, int target) {
        for (int item : list) {  // n itera√ß√µes
            if (item == target) {
                return true;
            }
        }
        return false;
    }

    /**
     * Busca bin√°ria: O(log n)
     *
     * Pr√©-requisito: Lista ordenada
     * Divide busca pela metade a cada itera√ß√£o
     */
    public boolean binarySearch(List<Integer> sortedList, int target) {
        int left = 0;
        int right = sortedList.size() - 1;

        while (left <= right) {  // log‚ÇÇ(n) itera√ß√µes
            int mid = left + (right - left) / 2;

            if (sortedList.get(mid) == target) {
                return true;
            } else if (sortedList.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return false;
    }
}

/**
 * COMPARA√á√ÉO:
 *
 * n = 1.000:
 * - Linear: ~1.000 compara√ß√µes
 * - Bin√°ria: ~10 compara√ß√µes (log‚ÇÇ(1000) ‚âà 10)
 *
 * n = 1.000.000:
 * - Linear: ~1.000.000 compara√ß√µes
 * - Bin√°ria: ~20 compara√ß√µes (log‚ÇÇ(1.000.000) ‚âà 20)
 *
 * Bin√°ria √© EXPONENCIALMENTE mais r√°pida para grandes n
 */
```

---

## 2. Nota√ß√µes Assint√≥ticas

### 2.1 Big O (Upper Bound)

```java
/**
 * O(g(n)): LIMITE SUPERIOR
 *
 * f(n) = O(g(n)) significa:
 * "f(n) cresce NO M√ÅXIMO t√£o r√°pido quanto g(n)"
 *
 * Descreve pior caso (worst-case)
 */

/**
 * Exemplo: Buscar elemento em array n√£o ordenado
 */
public int find(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {  // n itera√ß√µes (pior caso)
        if (array[i] == target) {
            return i;
        }
    }
    return -1;
}

/**
 * An√°lise:
 * - Melhor caso: O(1) - encontra no primeiro elemento
 * - Pior caso: O(n) - encontra no √∫ltimo ou n√£o existe
 * - Caso m√©dio: O(n/2) = O(n)
 *
 * Big O usa pior caso: O(n)
 */
```

---

### 2.2 Big Œ© (Lower Bound)

```java
/**
 * Œ©(g(n)): LIMITE INFERIOR
 *
 * f(n) = Œ©(g(n)) significa:
 * "f(n) cresce PELO MENOS t√£o r√°pido quanto g(n)"
 *
 * Descreve melhor caso (best-case)
 */

/**
 * Exemplo: Buscar elemento em array n√£o ordenado
 */
public int find(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == target) {
            return i;  // Pode retornar imediatamente
        }
    }
    return -1;
}

/**
 * An√°lise:
 * - Melhor caso: Œ©(1) - encontra no primeiro elemento
 * - Pior caso: ainda O(n)
 */
```

---

### 2.3 Big Œò (Tight Bound)

```java
/**
 * Œò(g(n)): LIMITE EXATO
 *
 * f(n) = Œò(g(n)) significa:
 * "f(n) = O(g(n)) E f(n) = Œ©(g(n))"
 *
 * Melhor e pior caso s√£o iguais
 */

/**
 * Exemplo: Somar todos elementos de array
 */
public int sum(int[] array) {
    int total = 0;
    for (int num : array) {  // SEMPRE n itera√ß√µes
        total += num;
    }
    return total;
}

/**
 * An√°lise:
 * - Melhor caso: Œò(n) - precisa visitar todos
 * - Pior caso: Œò(n) - precisa visitar todos
 * - Caso m√©dio: Œò(n)
 *
 * Complexidade: Œò(n) (tight bound)
 */
```

---

### 2.4 Compara√ß√£o

| Nota√ß√£o           | Significado                   | Uso                    | Exemplo                       |
| ----------------- | ----------------------------- | ---------------------- | ----------------------------- |
| **O** (Big O)     | Limite superior (pior caso)   | Mais comum, pessimista | O(n) = "no m√°ximo linear"     |
| **Œ©** (Big Omega) | Limite inferior (melhor caso) | Otimista               | Œ©(1) = "pelo menos constante" |
| **Œò** (Big Theta) | Limite exato (tight bound)    | Preciso                | Œò(n) = "exatamente linear"    |

```java
/**
 * REGRA PR√ÅTICA:
 *
 * Na pr√°tica, usamos Big O (pior caso) porque:
 * - Garante que algoritmo nunca ser√° pior
 * - Mais √∫til para planejar capacidade
 * - Conservador (melhor surpreender positivamente)
 */
```

---

## 3. Complexidades Comuns

### 3.1 Tabela de Complexidades

| Big O          | Nome         | Exemplo                      | n=10      | n=100     | n=1000        |
| -------------- | ------------ | ---------------------------- | --------- | --------- | ------------- |
| **O(1)**       | Constante    | Acesso a array[i]            | 1         | 1         | 1             |
| **O(log n)**   | Logar√≠tmica  | Busca bin√°ria                | 3         | 7         | 10            |
| **O(n)**       | Linear       | Busca linear                 | 10        | 100       | 1.000         |
| **O(n log n)** | Linear√≠tmica | Mergesort, Quicksort         | 30        | 664       | 9.966         |
| **O(n¬≤)**      | Quadr√°tica   | Bubble sort, loops aninhados | 100       | 10.000    | 1.000.000     |
| **O(n¬≥)**      | C√∫bica       | 3 loops aninhados            | 1.000     | 1.000.000 | 1.000.000.000 |
| **O(2‚Åø)**      | Exponencial  | Fibonacci recursivo          | 1.024     | 1.27e30   | ‚àû             |
| **O(n!)**      | Fatorial     | Traveling salesman           | 3.628.800 | ‚àû         | ‚àû             |

**Gr√°fico de Crescimento:**

```
Opera√ß√µes
    |
10‚Åπ |                                                     O(n!)
    |                                               O(2‚Åø)
10‚Å∂ |                                         O(n¬≥)
    |                                   O(n¬≤)
10¬≥ |                             O(n log n)
    |                       O(n)
  1 |___O(1)___O(log n)________________________
    0          10¬≤         10‚Å¥         10‚Å∂    n
```

---

### 3.2 O(1) - Constante

```java
/**
 * O(1): Tempo constante, independente de n
 */
public class ConstantTimeExamples {

    /**
     * Acesso a array por √≠ndice: O(1)
     */
    public int getElement(int[] array, int index) {
        return array[index];  // Uma opera√ß√£o, sempre
    }

    /**
     * HashMap get/put: O(1) amortizado
     */
    public String getFromMap(Map<String, String> map, String key) {
        return map.get(key);  // Hash lookup = O(1)
    }

    /**
     * Math operation: O(1)
     */
    public int add(int a, int b) {
        return a + b;  // Uma opera√ß√£o aritm√©tica
    }

    /**
     * ‚ö†Ô∏è CUIDADO: M√∫ltiplas opera√ß√µes O(1) ainda √© O(1)
     */
    public int complexConstant(int[] array) {
        int a = array[0];           // O(1)
        int b = array[1];           // O(1)
        int c = array[2];           // O(1)
        return a + b + c;           // O(1)
        // Total: O(1) + O(1) + O(1) + O(1) = O(1)
        // Constantes ignoradas em Big O
    }
}
```

---

### 3.3 O(log n) - Logar√≠tmica

```java
/**
 * O(log n): Divide problema pela metade a cada passo
 */
public class LogarithmicExamples {

    /**
     * Busca bin√°ria: O(log n)
     */
    public int binarySearch(int[] sortedArray, int target) {
        int left = 0;
        int right = sortedArray.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (sortedArray[mid] == target) {
                return mid;
            } else if (sortedArray[mid] < target) {
                left = mid + 1;  // Elimina metade esquerda
            } else {
                right = mid - 1;  // Elimina metade direita
            }
        }

        return -1;
    }
    // n=1000 ‚Üí ~10 itera√ß√µes (log‚ÇÇ(1000))
    // n=1.000.000 ‚Üí ~20 itera√ß√µes (log‚ÇÇ(1.000.000))

    /**
     * Pot√™ncia por exponencia√ß√£o r√°pida: O(log n)
     */
    public long power(int base, int exponent) {
        if (exponent == 0) return 1;

        long half = power(base, exponent / 2);

        if (exponent % 2 == 0) {
            return half * half;
        } else {
            return half * half * base;
        }
    }
    // 2^1000 ‚Üí ~10 recurs√µes (log‚ÇÇ(1000))

    /**
     * TreeMap get/put: O(log n)
     */
    public String getFromTreeMap(TreeMap<String, String> map, String key) {
        return map.get(key);  // Red-Black Tree = O(log n)
    }
}
```

---

### 3.4 O(n) - Linear

```java
/**
 * O(n): Tempo cresce proporcionalmente a n
 */
public class LinearExamples {

    /**
     * Busca linear: O(n)
     */
    public int linearSearch(List<Integer> list, int target) {
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) == target) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Soma de elementos: O(n)
     */
    public int sum(int[] array) {
        int total = 0;
        for (int num : array) {  // n itera√ß√µes
            total += num;
        }
        return total;
    }

    /**
     * Encontrar m√°ximo: O(n)
     */
    public int findMax(int[] array) {
        int max = array[0];
        for (int i = 1; i < array.length; i++) {  // n-1 itera√ß√µes
            if (array[i] > max) {
                max = array[i];
            }
        }
        return max;  // O(n) porque n-1 = O(n)
    }

    /**
     * ‚ö†Ô∏è Dois loops sequenciais: Ainda O(n)
     */
    public int twoLoops(int[] array) {
        int sum = 0;
        for (int num : array) {  // O(n)
            sum += num;
        }

        int max = array[0];
        for (int num : array) {  // O(n)
            max = Math.max(max, num);
        }

        return sum + max;
        // Total: O(n) + O(n) = O(2n) = O(n)
    }
}
```

---

### 3.5 O(n log n) - Linear√≠tmica

```java
/**
 * O(n log n): Algoritmos de ordena√ß√£o eficientes
 */
public class LinearithmicExamples {

    /**
     * Mergesort: O(n log n)
     */
    public void mergeSort(int[] array) {
        if (array.length <= 1) return;

        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);
        int[] right = Arrays.copyOfRange(array, mid, array.length);

        mergeSort(left);   // T(n/2)
        mergeSort(right);  // T(n/2)
        merge(array, left, right);  // O(n)
    }
    // T(n) = 2T(n/2) + O(n) = O(n log n)

    /**
     * Quicksort (caso m√©dio): O(n log n)
     */
    public void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pivot = partition(array, low, high);  // O(n)
            quickSort(array, low, pivot - 1);         // T(n/2)
            quickSort(array, pivot + 1, high);        // T(n/2)
        }
    }

    /**
     * Collections.sort(): O(n log n)
     */
    public List<Integer> sortList(List<Integer> list) {
        Collections.sort(list);  // Timsort = O(n log n)
        return list;
    }
}
```

---

### 3.6 O(n¬≤) - Quadr√°tica

```java
/**
 * O(n¬≤): Loops aninhados
 */
public class QuadraticExamples {

    /**
     * Bubble sort: O(n¬≤)
     */
    public void bubbleSort(int[] array) {
        for (int i = 0; i < array.length; i++) {           // n itera√ß√µes
            for (int j = 0; j < array.length - i - 1; j++) {  // n itera√ß√µes
                if (array[j] > array[j + 1]) {
                    swap(array, j, j + 1);
                }
            }
        }
    }
    // n * n = n¬≤

    /**
     * Verificar duplicatas (naive): O(n¬≤)
     */
    public boolean hasDuplicates(int[] array) {
        for (int i = 0; i < array.length; i++) {       // n
            for (int j = i + 1; j < array.length; j++) {  // n
                if (array[i] == array[j]) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * ‚úÖ Melhor solu√ß√£o: O(n) com HashSet
     */
    public boolean hasDuplicatesOptimized(int[] array) {
        var seen = new HashSet<Integer>();
        for (int num : array) {  // O(n)
            if (!seen.add(num)) {  // HashSet.add() = O(1)
                return true;
            }
        }
        return false;
    }
    // O(n) vs O(n¬≤) para n=10.000: 10.000 vs 100.000.000 opera√ß√µes!
}
```

---

## 4. An√°lise Pr√°tica

### 4.1 Regras de Simplifica√ß√£o

```java
/**
 * REGRA 1: Ignorar constantes
 */
// O(2n) = O(n)
// O(n/2) = O(n)
// O(100n) = O(n)

public void example1(int[] array) {
    // 2 loops de n itera√ß√µes
    for (int i = 0; i < array.length; i++) {  // n
        System.out.println(array[i]);
    }
    for (int i = 0; i < array.length; i++) {  // n
        System.out.println(array[i] * 2);
    }
}
// O(n) + O(n) = O(2n) = O(n)

/**
 * REGRA 2: Ignorar termos menores (dom√≠nio)
 */
// O(n¬≤ + n) = O(n¬≤)
// O(n log n + n) = O(n log n)
// O(n¬≥ + n¬≤ + n + 1) = O(n¬≥)

public void example2(int[] array) {
    // Loop aninhado: n¬≤
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array.length; j++) {
            System.out.println(array[i] + array[j]);
        }
    }

    // Loop simples: n
    for (int i = 0; i < array.length; i++) {
        System.out.println(array[i]);
    }
}
// O(n¬≤) + O(n) = O(n¬≤ + n) = O(n¬≤)

/**
 * REGRA 3: Somar complexidades de opera√ß√µes sequenciais
 */
public void example3(int[] array) {
    linearSearch(array, 10);   // O(n)
    bubbleSort(array);          // O(n¬≤)
    binarySearch(array, 10);    // O(log n)
}
// Total: O(n) + O(n¬≤) + O(log n) = O(n¬≤)
// n¬≤ domina n e log n

/**
 * REGRA 4: Multiplicar complexidades de opera√ß√µes aninhadas
 */
public void example4(int[] array) {
    for (int i = 0; i < array.length; i++) {  // O(n)
        binarySearch(array, i);                 // O(log n)
    }
}
// Total: O(n) * O(log n) = O(n log n)
```

---

### 4.2 An√°lise Passo a Passo

```java
/**
 * EXEMPLO COMPLEXO: Analisar complexidade
 */
public List<Integer> complexAlgorithm(int[] array) {
    var result = new ArrayList<Integer>();

    // 1. Loop simples: O(n)
    for (int i = 0; i < array.length; i++) {
        result.add(array[i]);
    }

    // 2. Ordena√ß√£o: O(n log n)
    Collections.sort(result);

    // 3. Loop aninhado: O(n¬≤)
    for (int i = 0; i < result.size(); i++) {
        for (int j = i + 1; j < result.size(); j++) {
            if (result.get(i) + result.get(j) == 10) {
                System.out.println(result.get(i) + ", " + result.get(j));
            }
        }
    }

    // 4. Busca bin√°ria: O(log n)
    Collections.binarySearch(result, 5);

    return result;
}

/**
 * AN√ÅLISE:
 * 1. O(n)
 * 2. O(n log n)
 * 3. O(n¬≤)
 * 4. O(log n)
 *
 * Total: O(n) + O(n log n) + O(n¬≤) + O(log n)
 * Simplificando: O(n¬≤)  // n¬≤ domina todos os outros termos
 */
```

---

## 5. Trade-offs

### 5.1 Tempo vs Espa√ßo

```java
/**
 * TRADE-OFF: Tempo vs Espa√ßo
 */

/**
 * Fibonacci: O(2‚Åø) tempo, O(n) espa√ßo (call stack)
 */
public int fibonacciRecursive(int n) {
    if (n <= 1) return n;
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

/**
 * Fibonacci com memoization: O(n) tempo, O(n) espa√ßo
 */
public int fibonacciMemo(int n, Map<Integer, Integer> memo) {
    if (n <= 1) return n;
    if (memo.containsKey(n)) return memo.get(n);

    int result = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
    memo.put(n, result);
    return result;
}

/**
 * Fibonacci iterativo: O(n) tempo, O(1) espa√ßo
 */
public int fibonacciIterative(int n) {
    if (n <= 1) return n;

    int prev = 0, curr = 1;
    for (int i = 2; i <= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }
    return curr;
}

/**
 * COMPARA√á√ÉO (n=40):
 * - Recursivo: ~1 segundo, 40 frames de stack
 * - Memoization: ~0.001 segundo, 40 entradas no Map
 * - Iterativo: ~0.001 segundo, 2 vari√°veis
 *
 * Trade-off: Memoization usa mais mem√≥ria, mas mesma performance que iterativo
 */
```

---

### 5.2 Pr√©-processamento

```java
/**
 * TRADE-OFF: Pr√©-processar para queries r√°pidas
 */

/**
 * Naive: O(n) por query
 */
public class NaiveRangeSum {
    private int[] array;

    public int rangeSum(int left, int right) {
        int sum = 0;
        for (int i = left; i <= right; i++) {  // O(n)
            sum += array[i];
        }
        return sum;
    }
}

/**
 * Prefix Sum: O(n) pr√©-processamento, O(1) por query
 */
public class PrefixSumArray {
    private int[] prefixSum;

    public PrefixSumArray(int[] array) {
        prefixSum = new int[array.length + 1];
        for (int i = 0; i < array.length; i++) {  // O(n) pr√©-processamento
            prefixSum[i + 1] = prefixSum[i] + array[i];
        }
    }

    public int rangeSum(int left, int right) {
        return prefixSum[right + 1] - prefixSum[left];  // O(1) query
    }
}

/**
 * COMPARA√á√ÉO:
 *
 * 10.000 queries em array de 10.000 elementos:
 * - Naive: 10.000 * 10.000 = 100.000.000 opera√ß√µes
 * - Prefix Sum: 10.000 (pr√©) + 10.000 (queries) = 20.000 opera√ß√µes
 *
 * Trade-off: Prefix Sum usa O(n) espa√ßo extra, mas 5000x mais r√°pido!
 */
```

---

## üìä Checklist de Qualidade

- [ ] Identificar complexidade de tempo de algoritmos cr√≠ticos
- [ ] Documentar Big O em m√©todos complexos (coment√°rios)
- [ ] Evitar O(n¬≤) ou pior em hot paths (c√≥digo executado frequentemente)
- [ ] Trade-offs tempo vs espa√ßo documentados
- [ ] Pr√©-processamento quando muitas queries (Prefix Sum, √≠ndices)
- [ ] HashMap/HashSet para O(1) lookups (vs O(n) busca linear)
- [ ] Binary search em listas ordenadas (O(log n) vs O(n))
- [ ] Sorting eficiente (Mergesort/Quicksort = O(n log n) vs Bubble = O(n¬≤))
- [ ] Memoization para recurs√£o repetitiva (Fibonacci, DP)
- [ ] Benchmarks para validar complexidade (JMH)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Identificar complexidade de 10 algoritmos comuns
2. **Intermedi√°rio**: Otimizar algoritmo O(n¬≤) para O(n)
3. **Avan√ßado**: Implementar Fibonacci iterativo, memoization e comparar performance

---

## üìö Refer√™ncias

- [Big O Cheat Sheet](https://www.bigocheatsheet.com/)
- [Introduction to Algorithms (CLRS)](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- [Cracking the Coding Interview](https://www.crackingthecodinginterview.com/)

---

**Pr√≥ximo:** [14.2 - An√°lise de Algoritmos](14.2-analise-algoritmos.md)
