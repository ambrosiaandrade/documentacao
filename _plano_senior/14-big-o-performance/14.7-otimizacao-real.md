# üöÄ M√≥dulo 14.7: Otimiza√ß√£o Real

> **Objetivo:** Aplicar t√©cnicas de otimiza√ß√£o em cen√°rios reais com m√©tricas e trade-offs.

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

Otimiza√ß√£o real √© o processo de identificar e resolver gargalos de performance em aplica√ß√µes de produ√ß√£o. Diferente de otimiza√ß√£o prematura, otimiza√ß√£o real √© baseada em dados (profiling, metrics) e foca nos bottlenecks que realmente impactam usu√°rios (APIs lentas, memory leaks, queries N+1). Envolve trade-offs conscientes entre performance, legibilidade e manutenibilidade.

### üéà Analogia Simples

Imagine que sua pizzaria demora 1 hora para entregar pizzas:

**Jeito Errado (Otimiza√ß√£o Sem Dados):**

- üí≠ "Vou comprar forno mais caro!" (R$ 10.000)
- üí≠ "Vou contratar mais cozinheiros!" (R$ 5.000/m√™s)
- ‚ùå Continua demorando 1 hora... üò∞

**Jeito Certo (Com Profiling):**

- üîç Mede cada etapa:
  - Preparar massa: 5 min ‚úÖ
  - Assar pizza: 10 min ‚úÖ
  - **Entregador procurando endere√ßo: 40 min** üî¥ ‚Üê GARGALO!
  - Entregar: 5 min ‚úÖ

**Otimiza√ß√£o Certa:**

- üì± Compra GPS para entregadores (R$ 200)
- ‚è∞ Entrega cai de 1h para 20 min! (3x mais r√°pido)
- üí∞ Gastou 50x menos que forno novo!

**Em c√≥digo:** Profile primeiro, ache o gargalo real (ex: query SQL lenta), otimize APENAS isso (ex: adicionar √≠ndice). Resultado: 10x mais r√°pido gastando 1 hora de trabalho!

---

## üìë √çndice

1. [Metodologia de Otimiza√ß√£o](#1-metodologia-de-otimizacao)
2. [Database Queries](#2-database-queries)
3. [Caching Strategies](#3-caching-strategies)
4. [Parallel Processing](#4-parallel-processing)
5. [Network Optimization](#5-network-optimization)
6. [Case Studies](#6-case-studies)

---

## 1. Metodologia de Otimiza√ß√£o

### 1.1 Processo

```
1. MEASURE (Baseline)
   ‚Üì
2. IDENTIFY (Bottleneck via profiling)
   ‚Üì
3. OPTIMIZE (Implementar fix)
   ‚Üì
4. MEASURE (Comparar com baseline)
   ‚Üì
5. VALIDATE (Testes, code review)
```

---

### 1.2 Regras de Ouro

```java
/**
 * REGRA 1: Nunca otimize sem dados
 * - Sempre profile antes de otimizar
 * - "Premature optimization is the root of all evil" - Donald Knuth
 */

// ‚ùå Otimiza√ß√£o prematura (sem evid√™ncia de problema)
public List<User> getUsers() {
    // "Otimiza√ß√£o": Usa parallel stream (overhead desnecess√°rio)
    return userRepository.findAll().parallelStream()
        .filter(u -> u.isActive())
        .collect(Collectors.toList());
}

// ‚úÖ Profile primeiro, otimize depois (se necess√°rio)
public List<User> getUsers() {
    // Implementa√ß√£o simples primeiro
    return userRepository.findAll().stream()
        .filter(u -> u.isActive())
        .collect(Collectors.toList());
}
// Se profiling mostrar que √© lento, ENT√ÉO otimize

/**
 * REGRA 2: Otimize gargalo (bottleneck)
 * - 80/20 rule: 20% do c√≥digo consome 80% do tempo
 * - Flame graph mostra onde otimizar
 */

/**
 * REGRA 3: Trade-offs s√£o inevit√°veis
 * - Performance vs Legibilidade
 * - Performance vs Manutenibilidade
 * - Tempo vs Espa√ßo
 * - Documente trade-offs!
 */

/**
 * REGRA 4: Medir impacto
 * - Antes: X ops/sec, Y latency p99
 * - Depois: X' ops/sec, Y' latency p99
 * - Improvement: (X'-X)/X * 100%
 */
```

---

## 2. Database Queries

### 2.1 N+1 Problem

```java
/**
 * ‚ùå PROBLEMA: N+1 queries
 */
@Service
public class OrderService {

    public List<OrderDto> getAllOrders() {
        List<Order> orders = orderRepository.findAll();  // 1 query

        return orders.stream()
            .map(order -> {
                // N queries (uma por order)
                User user = userRepository.findById(order.getUserId()).orElse(null);
                List<Item> items = itemRepository.findByOrderId(order.getId());

                return new OrderDto(order, user, items);
            })
            .collect(Collectors.toList());
    }
}
// Total: 1 + N + N = 2N+1 queries

/**
 * ‚úÖ SOLU√á√ÉO 1: JOIN FETCH
 */
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("""
        SELECT o FROM Order o
        JOIN FETCH o.user
        JOIN FETCH o.items
        """)
    List<Order> findAllWithUserAndItems();
}

@Service
public class OrderService {
    public List<OrderDto> getAllOrders() {
        return orderRepository.findAllWithUserAndItems().stream()
            .map(OrderDto::from)
            .collect(Collectors.toList());
    }
}
// Total: 1 query

/**
 * ‚úÖ SOLU√á√ÉO 2: Batch Loading (se JOIN n√£o for vi√°vel)
 */
@Service
public class OrderService {
    public List<OrderDto> getAllOrders() {
        List<Order> orders = orderRepository.findAll();  // 1 query

        // Batch load users
        Set<Long> userIds = orders.stream()
            .map(Order::getUserId)
            .collect(Collectors.toSet());
        Map<Long, User> usersMap = userRepository.findByIdIn(userIds).stream()
            .collect(Collectors.toMap(User::getId, u -> u));  // 1 query

        // Batch load items
        Set<Long> orderIds = orders.stream()
            .map(Order::getId)
            .collect(Collectors.toSet());
        Map<Long, List<Item>> itemsMap = itemRepository.findByOrderIdIn(orderIds)
            .stream()
            .collect(Collectors.groupingBy(Item::getOrderId));  // 1 query

        return orders.stream()
            .map(order -> new OrderDto(
                order,
                usersMap.get(order.getUserId()),
                itemsMap.get(order.getId())
            ))
            .collect(Collectors.toList());
    }
}
// Total: 3 queries (vs 2N+1)
```

**Benchmark:**

```
N=1000 orders:

N+1 approach:
- Queries: 2001
- Time: 5000ms

JOIN FETCH:
- Queries: 1
- Time: 50ms

100x mais r√°pido!
```

---

### 2.2 Pagination

```java
/**
 * ‚ùå PROBLEMA: Carregar todos os dados
 */
@GetMapping("/users")
public List<UserDto> getUsers() {
    return userRepository.findAll().stream()  // 1.000.000 users!
        .map(UserDto::from)
        .collect(Collectors.toList());
}
// 1.000.000 users √ó 1KB = 1GB de mem√≥ria

/**
 * ‚úÖ SOLU√á√ÉO: Pagination
 */
@GetMapping("/users")
public Page<UserDto> getUsers(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "20") int size
) {
    Pageable pageable = PageRequest.of(page, size);
    return userRepository.findAll(pageable)
        .map(UserDto::from);
}
// 20 users √ó 1KB = 20KB de mem√≥ria

/**
 * ‚úÖ SOLU√á√ÉO 2: Cursor-based pagination (melhor para real-time)
 */
@GetMapping("/users")
public List<UserDto> getUsers(
    @RequestParam(required = false) Long cursor,
    @RequestParam(defaultValue = "20") int limit
) {
    List<User> users;
    if (cursor == null) {
        users = userRepository.findTopNOrderById(limit);
    } else {
        users = userRepository.findByIdGreaterThanOrderById(cursor, limit);
    }

    return users.stream()
        .map(UserDto::from)
        .collect(Collectors.toList());
}
```

---

### 2.3 Indexing

```java
/**
 * ‚ùå PROBLEMA: Query lenta sem √≠ndice
 */
@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;

    private String email;  // Busca por email = Full Table Scan
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);  // Lento sem √≠ndice
}

/**
 * Query execution:
 * SELECT * FROM users WHERE email = 'john@example.com';
 *
 * Sem √≠ndice:
 * - Full table scan: O(n)
 * - 1.000.000 users ‚Üí 1.000.000 rows scanned
 * - Time: 5000ms
 */

/**
 * ‚úÖ SOLU√á√ÉO: Criar √≠ndice
 */
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email")  // ‚úÖ √çndice
})
public class User {
    @Id
    private Long id;

    @Column(unique = true)  // Adiciona constraint de unicidade
    private String email;
}

/**
 * Com √≠ndice:
 * - B-Tree lookup: O(log n)
 * - 1.000.000 users ‚Üí ~20 compara√ß√µes
 * - Time: 1ms
 *
 * 5000x mais r√°pido!
 */
```

---

## 3. Caching Strategies

### 3.1 Cache-Aside

```java
/**
 * ‚ùå PROBLEMA: Database hit em toda request
 */
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public User getUser(Long id) {
        return userRepository.findById(id).orElse(null);  // DB hit sempre
    }
}

/**
 * ‚úÖ SOLU√á√ÉO: Cache-Aside com Caffeine
 */
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    private final Cache<Long, User> cache = Caffeine.newBuilder()
        .maximumSize(10_000)
        .expireAfterWrite(Duration.ofMinutes(10))
        .recordStats()  // M√©tricas
        .build();

    public User getUser(Long id) {
        return cache.get(id, key ->
            userRepository.findById(key).orElse(null)
        );
    }

    public void invalidate(Long id) {
        cache.invalidate(id);
    }
}

/**
 * Benchmark:
 *
 * Sem cache (1000 requests):
 * - 1000 DB queries
 * - Avg latency: 10ms
 * - Total time: 10s
 *
 * Com cache (90% hit rate):
 * - 100 DB queries (cold cache)
 * - 900 cache hits
 * - Avg latency: 0.1ms (cache) + 1ms (DB)
 * - Total time: 1.1s
 *
 * 9x mais r√°pido!
 */
```

---

### 3.2 Cache Invalidation

```java
/**
 * PROBLEMA: Cache inconsistente ap√≥s update
 */
@Service
public class UserService {
    private final Cache<Long, User> cache = /* ... */;

    public User getUser(Long id) {
        return cache.get(id, key -> userRepository.findById(key).orElse(null));
    }

    public void updateUser(User user) {
        userRepository.save(user);
        // ‚ùå Cache n√£o invalidado ‚Üí Retorna dados antigos!
    }
}

/**
 * ‚úÖ SOLU√á√ÉO: Invalidar cache ap√≥s update
 */
@Service
public class UserService {

    public void updateUser(User user) {
        userRepository.save(user);
        cache.invalidate(user.getId());  // ‚úÖ Invalida cache
    }

    public void deleteUser(Long id) {
        userRepository.deleteById(id);
        cache.invalidate(id);
    }
}

/**
 * ‚úÖ SOLU√á√ÉO ALTERNATIVA: Write-Through (atualiza cache)
 */
@Service
public class UserService {

    public void updateUser(User user) {
        userRepository.save(user);
        cache.put(user.getId(), user);  // ‚úÖ Atualiza cache
    }
}
```

---

## 4. Parallel Processing

### 4.1 Parallel Streams

```java
/**
 * CEN√ÅRIO: Processar lista grande
 */
@Service
public class ReportService {

    /**
     * ‚ùå Sequential: 10.000 items √ó 10ms = 100s
     */
    public List<ReportRow> generateReportSequential(List<Data> data) {
        return data.stream()
            .map(this::processData)  // 10ms por item
            .collect(Collectors.toList());
    }

    /**
     * ‚úÖ Parallel: 10.000 items / 8 cores = 1250 items por core √ó 10ms = 12.5s
     */
    public List<ReportRow> generateReportParallel(List<Data> data) {
        return data.parallelStream()
            .map(this::processData)
            .collect(Collectors.toList());
    }

    private ReportRow processData(Data data) {
        // Simula√ß√£o de processamento pesado
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return new ReportRow(data);
    }
}

/**
 * ‚ö†Ô∏è CUIDADO: Parallel streams nem sempre s√£o mais r√°pidos!
 *
 * Use parallel streams quando:
 * - Muitos elementos (> 1000)
 * - Processamento pesado por elemento (> 1ms)
 * - Opera√ß√µes stateless e independentes
 * - Custo de splitting/merging < ganho de paraleliza√ß√£o
 *
 * Evite parallel streams quando:
 * - Poucos elementos (< 100)
 * - Processamento r√°pido (< 1Œºs)
 * - I/O bound (DB, network)
 * - Shared mutable state
 */
```

---

### 4.2 CompletableFuture

```java
/**
 * CEN√ÅRIO: Chamar m√∫ltiplos servi√ßos externos
 */
@Service
public class AggregationService {

    /**
     * ‚ùå Sequential: 3 √ó 500ms = 1500ms
     */
    public OrderSummary getOrderSummarySequential(Long orderId) {
        Order order = orderService.getOrder(orderId);        // 500ms
        User user = userService.getUser(order.getUserId());  // 500ms
        Payment payment = paymentService.getPayment(orderId);// 500ms

        return new OrderSummary(order, user, payment);
    }

    /**
     * ‚úÖ Parallel: max(500ms, 500ms, 500ms) = 500ms
     */
    public OrderSummary getOrderSummaryParallel(Long orderId) {
        CompletableFuture<Order> orderFuture =
            CompletableFuture.supplyAsync(() -> orderService.getOrder(orderId));

        CompletableFuture<User> userFuture = orderFuture.thenApplyAsync(order ->
            userService.getUser(order.getUserId())
        );

        CompletableFuture<Payment> paymentFuture =
            CompletableFuture.supplyAsync(() -> paymentService.getPayment(orderId));

        // Aguarda todas completarem
        CompletableFuture.allOf(orderFuture, userFuture, paymentFuture).join();

        return new OrderSummary(
            orderFuture.join(),
            userFuture.join(),
            paymentFuture.join()
        );
    }
}

/**
 * 3x mais r√°pido (1500ms ‚Üí 500ms)
 */
```

---

## 5. Network Optimization

### 5.1 Batch Requests

```java
/**
 * ‚ùå PROBLEMA: Muitas requests HTTP pequenas
 */
@Service
public class NotificationService {

    public void notifyUsers(List<User> users) {
        for (User user : users) {
            // 1000 users = 1000 HTTP requests
            httpClient.post("/notify", new Notification(user));  // 50ms cada
        }
    }
}
// Total: 1000 √ó 50ms = 50s

/**
 * ‚úÖ SOLU√á√ÉO: Batch requests
 */
@Service
public class NotificationService {

    public void notifyUsers(List<User> users) {
        // Batch de 100 users por request
        for (List<User> batch : Lists.partition(users, 100)) {
            httpClient.post("/notify/batch", batch.stream()
                .map(Notification::new)
                .collect(Collectors.toList())
            );  // 100ms por batch
        }
    }
}
// Total: 10 batches √ó 100ms = 1s (50x mais r√°pido!)
```

---

### 5.2 Compression

```java
/**
 * ‚ùå PROBLEMA: Response body grande
 */
@GetMapping("/data")
public List<DataDto> getData() {
    return dataService.getAllData();  // 10MB JSON
}
// Transfer time: 10MB / 10Mbps = 8 segundos

/**
 * ‚úÖ SOLU√á√ÉO: Habilitar GZIP compression
 */
@Configuration
public class CompressionConfig {
    @Bean
    public FilterRegistrationBean<GzipFilter> gzipFilter() {
        var filter = new FilterRegistrationBean<>(new GzipFilter());
        filter.addUrlPatterns("/*");
        return filter;
    }
}

// Spring Boot application.yml:
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain
    min-response-size: 1024  # Compress se > 1KB

/**
 * Resultado:
 * - Original: 10MB
 * - Compressed: 1MB (10:1 ratio para JSON)
 * - Transfer time: 1MB / 10Mbps = 0.8s
 *
 * 10x mais r√°pido!
 */
```

---

## 6. Case Studies

### 6.1 Case Study 1: API Lenta

**Problema:**

```
API /api/products?category=electronics
- Latency p99: 5000ms
- Throughput: 10 req/sec
- Users complaining
```

**Investiga√ß√£o (Profiling):**

```java
@GetMapping("/products")
public List<ProductDto> getProducts(@RequestParam String category) {
    // 1. findByCategory: 100ms
    List<Product> products = productRepository.findByCategory(category);

    // 2. N+1 problem: 4900ms ‚Üê GARGALO!
    return products.stream()
        .map(product -> {
            // Query por product (100 products = 100 queries √ó 50ms)
            var reviews = reviewRepository.findByProductId(product.getId());
            var seller = sellerRepository.findById(product.getSellerId()).orElse(null);
            return new ProductDto(product, reviews, seller);
        })
        .collect(Collectors.toList());
}
```

**Flame Graph:**

```
getProducts (5000ms)
‚îú‚îÄ findByCategory (100ms - 2%)
‚îî‚îÄ stream.map (4900ms - 98%)  ‚Üê GARGALO
   ‚îú‚îÄ reviewRepository.findByProductId (2500ms)
   ‚îî‚îÄ sellerRepository.findById (2400ms)
```

**Fix:**

```java
@GetMapping("/products")
public List<ProductDto> getProducts(@RequestParam String category) {
    List<Product> products = productRepository.findByCategory(category);  // 100ms

    // Batch load reviews
    Set<Long> productIds = products.stream()
        .map(Product::getId)
        .collect(Collectors.toSet());
    Map<Long, List<Review>> reviewsMap =
        reviewRepository.findByProductIdIn(productIds).stream()
            .collect(Collectors.groupingBy(Review::getProductId));  // 50ms

    // Batch load sellers
    Set<Long> sellerIds = products.stream()
        .map(Product::getSellerId)
        .collect(Collectors.toSet());
    Map<Long, Seller> sellersMap =
        sellerRepository.findByIdIn(sellerIds).stream()
            .collect(Collectors.toMap(Seller::getId, s -> s));  // 50ms

    return products.stream()
        .map(product -> new ProductDto(
            product,
            reviewsMap.get(product.getId()),
            sellersMap.get(product.getSellerId())
        ))
        .collect(Collectors.toList());  // 5ms
}
```

**Resultado:**

```
Before:
- Queries: 201 (1 + 100 + 100)
- Latency p99: 5000ms
- Throughput: 10 req/sec

After:
- Queries: 3 (1 + 1 + 1)
- Latency p99: 205ms (100 + 50 + 50 + 5)
- Throughput: 200 req/sec

24x mais r√°pido, 20x mais throughput!
```

---

### 6.2 Case Study 2: Memory Leak

**Problema:**

```
Production server:
- Heap usage: 0% ‚Üí 100% em 6 horas
- Full GC: A cada 5 minutos (5s pause)
- OOMError ap√≥s 6h
```

**Investiga√ß√£o (Heap Dump):**

```
MAT - Leak Suspects:

Problem Suspect 1:
One instance of "EventBus" loaded by "WebAppClassLoader"
occupies 3.2 GB (90% of heap).

Dominator Tree:
EventBus (24 bytes)
‚îî‚îÄ listeners: ArrayList (32 bytes)
   ‚îî‚îÄ Entry[] (3.2 GB)
      ‚îú‚îÄ EventListener (lambda) (344 bytes) √ó 10.000.000

Shortest path to GC root:
EventBus ‚Üí listeners ‚Üí EventListener ‚Üí UserController (captured)
```

**Root Cause:**

```java
@Component
public class EventBus {
    // ‚ùå Listeners nunca removidos
    private final List<EventListener> listeners = new ArrayList<>();

    public void register(EventListener listener) {
        listeners.add(listener);  // LEAK!
    }
}

@RestController
public class UserController {
    @Autowired
    private EventBus eventBus;

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // ‚ùå Cria listener a cada request (10M requests/dia)
        eventBus.register(event -> {
            log.info("User accessed: {}", id);
        });

        return userService.getUser(id);
    }
}
```

**Fix:**

```java
// ‚úÖ OP√á√ÉO 1: Remover listener ap√≥s uso
@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    EventListener listener = event -> log.info("User: {}", id);

    try {
        eventBus.register(listener);
        return userService.getUser(id);
    } finally {
        eventBus.unregister(listener);  // ‚úÖ Remove
    }
}

// ‚úÖ OP√á√ÉO 2: Usar WeakHashMap (auto-cleanup)
@Component
public class EventBus {
    private final Map<EventListener, Object> listeners =
        new WeakHashMap<>();  // Auto GC se listener n√£o referenciado

    public void register(EventListener listener) {
        listeners.put(listener, new Object());
    }
}

// ‚úÖ OP√á√ÉO 3: Log sem listener (mais simples)
@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id) {
    log.info("User accessed: {}", id);  // Sem listener!
    return userService.getUser(id);
}
```

**Resultado:**

```
Before:
- Heap growth: 500MB/hour
- Full GC: Every 5 minutes
- OOM after 6 hours

After:
- Heap stable: 500MB constant
- Full GC: Every 2 hours
- No OOM
```

---

## üìä Checklist de Qualidade

- [ ] Profile antes de otimizar (n√£o adivinhe!)
- [ ] Medir baseline (antes) e resultado (depois)
- [ ] Resolver N+1 queries (JOIN FETCH ou batch loading)
- [ ] Pagination para listas grandes (> 100 items)
- [ ] √çndices em colunas de busca frequente
- [ ] Cache para dados read-heavy (Caffeine, Redis)
- [ ] Invalidar cache ap√≥s updates
- [ ] Parallel streams para processamento pesado (> 1000 items)
- [ ] CompletableFuture para I/O paralelo
- [ ] Batch requests para APIs externas
- [ ] Compression para responses grandes (> 1KB)
- [ ] Documentar trade-offs de performance

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Resolver N+1 problem com JOIN FETCH
2. **Intermedi√°rio**: Implementar cache com Caffeine e medir hit rate
3. **Avan√ßado**: Otimizar API com profiling end-to-end (JMH, flame graph, heap dump)

---

## üìö Refer√™ncias

- [High Performance Java Persistence (Vlad Mihalcea)](https://vladmihalcea.com/)
- [Effective Java (Joshua Bloch)](https://www.oreilly.com/library/view/effective-java/9780134686097/)
- [Java Performance: The Definitive Guide](https://www.oreilly.com/library/view/java-performance-the/9781449363512/)

---

**Pr√≥ximo:** [README.md - √çndice da Fase 14](README.md)
