# üéØ M√≥dulo 14.3: Algoritmos Cl√°ssicos e Complexidade

> **Objetivo:** Analisar complexidade de algoritmos fundamentais (sorting, searching, graphs).

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

Algoritmos cl√°ssicos s√£o solu√ß√µes bem estabelecidas para problemas comuns (ordena√ß√£o, busca, grafos). Conhecer suas complexidades permite escolher o algoritmo certo para cada situa√ß√£o. Por exemplo: QuickSort (O(n log n)) vs BubbleSort (O(n¬≤)) - para 10.000 elementos, diferen√ßa de 133.000 vs 100.000.000 opera√ß√µes.

### üéà Analogia Simples

Imagine que voc√™ tem que organizar 1000 cards de pok√©mon por n√∫mero:

**Bubble Sort (Jeito Ing√™nuo):**

- Pega 2 cards, compara, troca se estiver errado
- Faz isso 1.000 x 1.000 = **1 milh√£o** de compara√ß√µes! üò∞
- **Tempo:** Voc√™ vai desistir no meio!

**QuickSort (Jeito Esperto):**

- Escolhe um card do meio (pivot)
- Separa: menores √† esquerda, maiores √† direita
- Faz isso em grupos menores recursivamente
- **133 mil** compara√ß√µes! ‚ú®
- **Tempo:** Termina em minutos!

**Binary Search (Achar Card Espec√≠fico):**

- Cards j√° organizados? N√£o precisa olhar todos!
- Abre no meio: "Maior ou menor?"
- Elimina metade a cada vez
- 1000 cards ‚Üí apenas **10 tentativas**! üöÄ

**A diferen√ßa entre um algoritmo bom e ruim pode ser HORAS de tempo!**

---

## üìë √çndice

1. [Algoritmos de Ordena√ß√£o](#1-algoritmos-de-ordenacao)
2. [Algoritmos de Busca](#2-algoritmos-de-busca)
3. [Algoritmos de Grafo](#3-algoritmos-de-grafo)
4. [Dynamic Programming](#4-dynamic-programming)
5. [Trade-offs](#5-trade-offs)

---

## 1. Algoritmos de Ordena√ß√£o

### 1.1 QuickSort

```java
/**
 * QuickSort: Divide-and-conquer
 * - Escolhe pivot, particiona, ordena recursivamente
 *
 * Complexidade:
 * - Melhor/M√©dio: O(n log n)
 * - Pior: O(n¬≤) - array j√° ordenado, pivot sempre no extremo
 * - Espa√ßo: O(log n) - call stack
 */
public class QuickSort {
    public void quickSort(int[] array, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(array, low, high);  // O(n)
            quickSort(array, low, pivotIndex - 1);         // T(n/2)
            quickSort(array, pivotIndex + 1, high);        // T(n/2)
        }
    }

    /**
     * Partition: Lomuto scheme
     * - Pivot = array[high]
     * - Move elementos menores que pivot para esquerda
     */
    private int partition(int[] array, int low, int high) {
        int pivot = array[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {  // O(n)
            if (array[j] <= pivot) {
                i++;
                swap(array, i, j);
            }
        }

        swap(array, i + 1, high);
        return i + 1;
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

/**
 * AN√ÅLISE:
 * T(n) = 2T(n/2) + O(n)
 *
 * Master Theorem: T(n) = O(n log n) (caso m√©dio)
 *
 * Por que O(n¬≤) no pior caso?
 * - Se pivot sempre no extremo: T(n) = T(n-1) + O(n) = O(n¬≤)
 *
 * Solu√ß√£o: Randomized QuickSort
 * - Escolhe pivot aleat√≥rio ‚Üí O(n log n) esperado
 */

/**
 * ‚úÖ VANTAGENS:
 * - In-place (O(1) espa√ßo extra, exceto stack)
 * - Cache-friendly (acesso sequencial)
 * - Pr√°tica: Mais r√°pido que MergeSort (menor overhead)
 *
 * ‚ùå DESVANTAGENS:
 * - N√£o est√°vel (elementos iguais podem trocar ordem)
 * - Pior caso O(n¬≤) (raro com randomiza√ß√£o)
 */
```

---

### 1.2 MergeSort

```java
/**
 * MergeSort: Divide-and-conquer
 * - Divide ao meio, ordena recursivamente, merge
 *
 * Complexidade:
 * - Sempre O(n log n) - melhor, m√©dio, pior
 * - Espa√ßo: O(n) - array tempor√°rio
 */
public class MergeSort {
    public void mergeSort(int[] array) {
        if (array.length <= 1) return;

        int mid = array.length / 2;
        int[] left = Arrays.copyOfRange(array, 0, mid);      // O(n/2)
        int[] right = Arrays.copyOfRange(array, mid, array.length);  // O(n/2)

        mergeSort(left);   // T(n/2)
        mergeSort(right);  // T(n/2)

        merge(array, left, right);  // O(n)
    }

    /**
     * Merge: Combina 2 arrays ordenados
     */
    private void merge(int[] array, int[] left, int[] right) {
        int i = 0, j = 0, k = 0;

        while (i < left.length && j < right.length) {  // O(n)
            if (left[i] <= right[j]) {
                array[k++] = left[i++];
            } else {
                array[k++] = right[j++];
            }
        }

        while (i < left.length) {
            array[k++] = left[i++];
        }

        while (j < right.length) {
            array[k++] = right[j++];
        }
    }
}

/**
 * AN√ÅLISE:
 * T(n) = 2T(n/2) + O(n)
 * Master Theorem: T(n) = O(n log n) (sempre!)
 *
 * ‚úÖ VANTAGENS:
 * - Est√°vel (mant√©m ordem de elementos iguais)
 * - Complexidade garantida O(n log n) (pior caso)
 * - Paraleliz√°vel (divide independente)
 *
 * ‚ùå DESVANTAGENS:
 * - O(n) espa√ßo extra (array tempor√°rio)
 * - Overhead de c√≥pia de arrays
 */
```

---

### 1.3 HeapSort

```java
/**
 * HeapSort: Usa heap para ordena√ß√£o
 * - Constr√≥i max-heap, remove max repetidamente
 *
 * Complexidade:
 * - Sempre O(n log n)
 * - Espa√ßo: O(1) - in-place
 */
public class HeapSort {
    public void heapSort(int[] array) {
        int n = array.length;

        // Build max-heap: O(n)
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }

        // Extract max: n * O(log n) = O(n log n)
        for (int i = n - 1; i > 0; i--) {
            swap(array, 0, i);       // Move max para final
            heapify(array, i, 0);    // Rebalanceia heap
        }
    }

    /**
     * Heapify: Mant√©m heap property
     * - O(log n)
     */
    private void heapify(int[] array, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && array[left] > array[largest]) {
            largest = left;
        }

        if (right < n && array[right] > array[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(array, i, largest);
            heapify(array, n, largest);  // Recursivo: O(log n) depth
        }
    }

    private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}

/**
 * ‚úÖ VANTAGENS:
 * - O(n log n) garantido (pior caso)
 * - In-place (O(1) espa√ßo)
 * - N√£o recursivo (sem stack overflow)
 *
 * ‚ùå DESVANTAGENS:
 * - N√£o est√°vel
 * - Cache-unfriendly (saltos aleat√≥rios)
 * - Pr√°tica: Mais lento que QuickSort (overhead de heap)
 */
```

---

### 1.4 TimSort (Java Default)

```java
/**
 * TimSort: H√≠brido de MergeSort + InsertionSort
 * - Usado por Arrays.sort(), Collections.sort()
 *
 * Estrat√©gia:
 * 1. Divide array em "runs" (subsequ√™ncias ordenadas)
 * 2. Usa InsertionSort para runs pequenos (< 64)
 * 3. Usa MergeSort para combinar runs
 *
 * Complexidade:
 * - Melhor: O(n) - array j√° ordenado
 * - M√©dio/Pior: O(n log n)
 * - Espa√ßo: O(n)
 * - Est√°vel
 */
public class TimSortExample {
    public void sort(int[] array) {
        Arrays.sort(array);  // TimSort para primitivos (DualPivotQuicksort)
    }

    public void sortObjects(List<Integer> list) {
        Collections.sort(list);  // TimSort para objetos
    }
}

/**
 * POR QUE TimSort?
 *
 * 1. Performance real-world:
 *    - Detecta runs existentes (aproveitamento)
 *    - InsertionSort eficiente para pequenas por√ß√µes
 *
 * 2. Est√°vel:
 *    - Importante para objetos (mant√©m ordem de campos secund√°rios)
 *
 * 3. Adaptativo:
 *    - O(n) para arrays parcialmente ordenados
 */
```

---

### 1.5 Compara√ß√£o

| Algoritmo         | Melhor     | M√©dio      | Pior       | Espa√ßo   | Est√°vel | Uso                 |
| ----------------- | ---------- | ---------- | ---------- | -------- | ------- | ------------------- |
| **QuickSort**     | O(n log n) | O(n log n) | O(n¬≤)      | O(log n) | N√£o     | R√°pido, in-place    |
| **MergeSort**     | O(n log n) | O(n log n) | O(n log n) | O(n)     | Sim     | Garantido, est√°vel  |
| **HeapSort**      | O(n log n) | O(n log n) | O(n log n) | O(1)     | N√£o     | In-place, garantido |
| **TimSort**       | O(n)       | O(n log n) | O(n log n) | O(n)     | Sim     | Default Java        |
| **InsertionSort** | O(n)       | O(n¬≤)      | O(n¬≤)      | O(1)     | Sim     | Pequenos arrays     |
| **BubbleSort**    | O(n)       | O(n¬≤)      | O(n¬≤)      | O(1)     | Sim     | Nunca usar!         |

---

## 2. Algoritmos de Busca

### 2.1 Binary Search

```java
/**
 * Binary Search: Divide-and-conquer em array ordenado
 * - O(log n)
 */
public class BinarySearch {
    /**
     * Iterativo: O(log n) tempo, O(1) espa√ßo
     */
    public int binarySearchIterative(int[] sortedArray, int target) {
        int left = 0;
        int right = sortedArray.length - 1;

        while (left <= right) {  // log‚ÇÇ(n) itera√ß√µes
            int mid = left + (right - left) / 2;  // Evita overflow

            if (sortedArray[mid] == target) {
                return mid;
            } else if (sortedArray[mid] < target) {
                left = mid + 1;  // Elimina metade esquerda
            } else {
                right = mid - 1;  // Elimina metade direita
            }
        }

        return -1;  // N√£o encontrado
    }

    /**
     * Recursivo: O(log n) tempo, O(log n) espa√ßo (call stack)
     */
    public int binarySearchRecursive(int[] sortedArray, int target, int left, int right) {
        if (left > right) {
            return -1;
        }

        int mid = left + (right - left) / 2;

        if (sortedArray[mid] == target) {
            return mid;
        } else if (sortedArray[mid] < target) {
            return binarySearchRecursive(sortedArray, target, mid + 1, right);
        } else {
            return binarySearchRecursive(sortedArray, target, left, mid - 1);
        }
    }

    /**
     * Java built-in: O(log n)
     */
    public int binarySearchBuiltIn(int[] sortedArray, int target) {
        return Arrays.binarySearch(sortedArray, target);
    }
}

/**
 * AN√ÅLISE:
 * T(n) = T(n/2) + O(1)
 * Master Theorem: T(n) = O(log n)
 *
 * n = 1.000.000 ‚Üí ~20 compara√ß√µes (log‚ÇÇ(1.000.000))
 * n = 1.000.000.000 ‚Üí ~30 compara√ß√µes
 */
```

---

### 2.2 Binary Search Variants

```java
/**
 * VARIANTES: Binary Search para cases especiais
 */
public class BinarySearchVariants {
    /**
     * Encontrar primeira ocorr√™ncia
     * - Array pode ter duplicatas
     */
    public int findFirst(int[] array, int target) {
        int left = 0, right = array.length - 1;
        int result = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (array[mid] == target) {
                result = mid;
                right = mid - 1;  // Continue procurando √† esquerda
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    /**
     * Encontrar √∫ltima ocorr√™ncia
     */
    public int findLast(int[] array, int target) {
        int left = 0, right = array.length - 1;
        int result = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (array[mid] == target) {
                result = mid;
                left = mid + 1;  // Continue procurando √† direita
            } else if (array[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }

    /**
     * Encontrar menor elemento maior que target
     * - "Ceiling"
     */
    public int findCeiling(int[] array, int target) {
        int left = 0, right = array.length - 1;
        int result = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (array[mid] > target) {
                result = mid;
                right = mid - 1;  // Pode existir menor √† esquerda
            } else {
                left = mid + 1;
            }
        }

        return result;
    }
}
```

---

## 3. Algoritmos de Grafo

### 3.1 BFS (Breadth-First Search)

```java
/**
 * BFS: Busca em largura
 * - Explora n√≠vel por n√≠vel
 * - Usa Queue
 *
 * Complexidade:
 * - Tempo: O(V + E) - V = v√©rtices, E = arestas
 * - Espa√ßo: O(V) - queue + visited
 */
public class BFS {
    public void bfs(int start, List<List<Integer>> graph) {
        boolean[] visited = new boolean[graph.size()];
        Queue<Integer> queue = new LinkedList<>();

        queue.add(start);
        visited[start] = true;

        while (!queue.isEmpty()) {  // O(V) - cada v√©rtice visitado uma vez
            int node = queue.poll();
            System.out.println("Visiting: " + node);

            for (int neighbor : graph.get(node)) {  // O(E) total - todas arestas
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.add(neighbor);
                }
            }
        }
    }

    /**
     * BFS para encontrar caminho mais curto
     * - Em grafo n√£o ponderado
     */
    public int shortestPath(int start, int end, List<List<Integer>> graph) {
        boolean[] visited = new boolean[graph.size()];
        Queue<Integer> queue = new LinkedList<>();
        int[] distance = new int[graph.size()];

        queue.add(start);
        visited[start] = true;
        distance[start] = 0;

        while (!queue.isEmpty()) {
            int node = queue.poll();

            if (node == end) {
                return distance[node];
            }

            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    distance[neighbor] = distance[node] + 1;
                    queue.add(neighbor);
                }
            }
        }

        return -1;  // N√£o existe caminho
    }
}

/**
 * QUANDO USAR BFS:
 * - Caminho mais curto (grafo n√£o ponderado)
 * - N√≠veis/dist√¢ncia de n√≥
 * - Conectividade (verificar se grafo √© conectado)
 * - Topological sort (com modifica√ß√µes)
 */
```

---

### 3.2 DFS (Depth-First Search)

```java
/**
 * DFS: Busca em profundidade
 * - Explora o mais longe poss√≠vel antes de backtrack
 * - Usa Stack (recurs√£o ou expl√≠cito)
 *
 * Complexidade:
 * - Tempo: O(V + E)
 * - Espa√ßo: O(V) - call stack ou visited
 */
public class DFS {
    /**
     * DFS recursivo
     */
    public void dfsRecursive(int node, List<List<Integer>> graph, boolean[] visited) {
        visited[node] = true;
        System.out.println("Visiting: " + node);

        for (int neighbor : graph.get(node)) {
            if (!visited[neighbor]) {
                dfsRecursive(neighbor, graph, visited);
            }
        }
    }

    /**
     * DFS iterativo (com Stack expl√≠cito)
     */
    public void dfsIterative(int start, List<List<Integer>> graph) {
        boolean[] visited = new boolean[graph.size()];
        Stack<Integer> stack = new Stack<>();

        stack.push(start);

        while (!stack.isEmpty()) {
            int node = stack.pop();

            if (visited[node]) continue;

            visited[node] = true;
            System.out.println("Visiting: " + node);

            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    stack.push(neighbor);
                }
            }
        }
    }

    /**
     * DFS para detectar ciclo
     */
    public boolean hasCycle(int node, List<List<Integer>> graph,
                            boolean[] visited, boolean[] inStack) {
        visited[node] = true;
        inStack[node] = true;

        for (int neighbor : graph.get(node)) {
            if (!visited[neighbor]) {
                if (hasCycle(neighbor, graph, visited, inStack)) {
                    return true;
                }
            } else if (inStack[neighbor]) {
                return true;  // Back edge = ciclo
            }
        }

        inStack[node] = false;
        return false;
    }
}

/**
 * QUANDO USAR DFS:
 * - Detectar ciclo
 * - Topological sort
 * - Encontrar componentes conectados
 * - Pathfinding (n√£o necessariamente mais curto)
 * - Maze solving
 */
```

---

### 3.3 Dijkstra

```java
/**
 * Dijkstra: Caminho mais curto em grafo ponderado
 * - Usa PriorityQueue (min-heap)
 * - N√£o funciona com pesos negativos
 *
 * Complexidade:
 * - Tempo: O((V + E) log V) com binary heap
 * - Espa√ßo: O(V)
 */
public class Dijkstra {
    static class Node implements Comparable<Node> {
        int vertex;
        int distance;

        public Node(int vertex, int distance) {
            this.vertex = vertex;
            this.distance = distance;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.distance, other.distance);
        }
    }

    public int[] dijkstra(int start, List<List<Node>> graph) {
        int n = graph.size();
        int[] distances = new int[n];
        Arrays.fill(distances, Integer.MAX_VALUE);
        distances[start] = 0;

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(start, 0));

        while (!pq.isEmpty()) {  // O(V) iterations
            Node current = pq.poll();  // O(log V)
            int u = current.vertex;

            if (current.distance > distances[u]) continue;

            for (Node neighbor : graph.get(u)) {  // O(E) total
                int v = neighbor.vertex;
                int weight = neighbor.distance;

                if (distances[u] + weight < distances[v]) {
                    distances[v] = distances[u] + weight;
                    pq.add(new Node(v, distances[v]));  // O(log V)
                }
            }
        }

        return distances;
    }
}

/**
 * AN√ÅLISE:
 * - PriorityQueue operations: O(log V)
 * - Cada v√©rtice processado uma vez: O(V log V)
 * - Cada aresta relaxada: O(E log V)
 * - Total: O((V + E) log V)
 */
```

---

## 4. Dynamic Programming

### 4.1 Fibonacci

```java
/**
 * COMPARA√á√ÉO: Recurs√£o vs Memoization vs Tabulation
 */
public class Fibonacci {
    /**
     * Recurs√£o naive: O(2‚Åø) - NUNCA usar!
     */
    public int fibRecursive(int n) {
        if (n <= 1) return n;
        return fibRecursive(n - 1) + fibRecursive(n - 2);
    }
    // fib(40) = 102.334.155 chamadas!

    /**
     * Memoization (top-down): O(n) tempo, O(n) espa√ßo
     */
    public int fibMemo(int n, Map<Integer, Integer> memo) {
        if (n <= 1) return n;
        if (memo.containsKey(n)) return memo.get(n);

        int result = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
        memo.put(n, result);
        return result;
    }

    /**
     * Tabulation (bottom-up): O(n) tempo, O(n) espa√ßo
     */
    public int fibTabulation(int n) {
        if (n <= 1) return n;

        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }

    /**
     * Space-optimized: O(n) tempo, O(1) espa√ßo
     */
    public int fibOptimized(int n) {
        if (n <= 1) return n;

        int prev = 0, curr = 1;
        for (int i = 2; i <= n; i++) {
            int next = prev + curr;
            prev = curr;
            curr = next;
        }

        return curr;
    }
}

/**
 * BENCHMARK (n=40):
 * - Recursivo: ~1.000 ms
 * - Memoization: ~1 ms
 * - Tabulation: ~1 ms
 * - Optimized: ~1 ms
 *
 * 1000x mais r√°pido!
 */
```

---

### 4.2 Longest Common Subsequence (LCS)

```java
/**
 * LCS: Maior subsequ√™ncia comum entre 2 strings
 * - DP cl√°ssico
 *
 * Complexidade: O(m * n) tempo, O(m * n) espa√ßo
 */
public class LCS {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();

        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[m][n];
    }

    /**
     * Space-optimized: O(m * n) tempo, O(n) espa√ßo
     * - Usa apenas 2 rows (current e previous)
     */
    public int lcsOptimized(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();

        int[] prev = new int[n + 1];
        int[] curr = new int[n + 1];

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    curr[j] = prev[j - 1] + 1;
                } else {
                    curr[j] = Math.max(prev[j], curr[j - 1]);
                }
            }

            int[] temp = prev;
            prev = curr;
            curr = temp;
        }

        return prev[n];
    }
}
```

---

## 5. Trade-offs

### 5.1 Sorting Trade-offs

```java
/**
 * CEN√ÅRIO: Escolher algoritmo de ordena√ß√£o
 */
public class SortingChoice {
    /**
     * Caso 1: Array grande, mem√≥ria limitada
     * ‚Üí HeapSort (O(1) espa√ßo extra)
     */
    public void limitedMemory(int[] array) {
        heapSort(array);  // O(n log n), O(1) espa√ßo
    }

    /**
     * Caso 2: Precisar estabilidade (manter ordem de iguais)
     * ‚Üí MergeSort ou TimSort
     */
    public void needStability(Integer[] array) {
        Arrays.sort(array);  // TimSort (est√°vel)
    }

    /**
     * Caso 3: Performance m√°xima (arrays aleat√≥rios)
     * ‚Üí QuickSort ou TimSort
     */
    public void maxPerformance(int[] array) {
        Arrays.sort(array);  // DualPivotQuicksort (primitivos)
    }

    /**
     * Caso 4: Array pequeno (< 50 elementos)
     * ‚Üí InsertionSort
     */
    public void smallArray(int[] array) {
        insertionSort(array);  // O(n¬≤), mas r√°pido para pequenos n
    }

    /**
     * Caso 5: Array quase ordenado
     * ‚Üí TimSort (adaptativo, O(n) melhor caso)
     */
    public void nearSorted(int[] array) {
        Arrays.sort(array);  // TimSort detecta runs
    }
}
```

---

### 5.2 Search Trade-offs

```java
/**
 * CEN√ÅRIO: Escolher algoritmo de busca
 */
public class SearchChoice {
    /**
     * Caso 1: Array n√£o ordenado, busca √∫nica
     * ‚Üí Linear search (O(n))
     */
    public int singleSearch(int[] array, int target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == target) return i;
        }
        return -1;
    }

    /**
     * Caso 2: Array n√£o ordenado, m√∫ltiplas buscas
     * ‚Üí HashSet (O(n) pr√©-processamento, O(1) busca)
     */
    public boolean multipleSearches(int[] array, int target) {
        var set = new HashSet<Integer>();
        for (int num : array) {
            set.add(num);  // O(n)
        }
        return set.contains(target);  // O(1)
    }

    /**
     * Caso 3: Array ordenado, m√∫ltiplas buscas
     * ‚Üí Binary search (O(log n))
     */
    public int sortedSearch(int[] sortedArray, int target) {
        return Arrays.binarySearch(sortedArray, target);  // O(log n)
    }

    /**
     * Caso 4: Busca por range
     * ‚Üí TreeSet (O(log n))
     */
    public List<Integer> rangeSearch(TreeSet<Integer> set, int low, int high) {
        return new ArrayList<>(set.subSet(low, high));  // O(log n + k)
    }
}
```

---

## üìä Checklist de Qualidade

- [ ] Usar Arrays.sort() / Collections.sort() (TimSort otimizado)
- [ ] Binary search em arrays ordenados (O(log n) vs O(n))
- [ ] HashSet/HashMap para lookups frequentes (O(1) vs O(n))
- [ ] BFS para caminho mais curto (grafo n√£o ponderado)
- [ ] Dijkstra para caminho mais curto (grafo ponderado positivo)
- [ ] Memoization para problemas com subproblemas repetidos (DP)
- [ ] Space optimization em DP quando poss√≠vel (rolling array)
- [ ] QuickSort para arrays aleat√≥rios in-place
- [ ] MergeSort quando precisar estabilidade ou garantia O(n log n)
- [ ] Evitar algoritmos O(2‚Åø) (recurs√£o naive sem memoization)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Implementar QuickSort e MergeSort, comparar performance
2. **Intermedi√°rio**: Implementar BFS e DFS para encontrar caminho em maze
3. **Avan√ßado**: Resolver Longest Increasing Subsequence com DP

---

## üìö Refer√™ncias

- [Introduction to Algorithms (CLRS)](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)
- [Algorithms 4th Edition (Sedgewick)](https://algs4.cs.princeton.edu/home/)
- [LeetCode Patterns](https://seanprashad.com/leetcode-patterns/)

---

**Pr√≥ximo:** [14.4 - Profiling Tools](14.4-profiling-tools.md)
