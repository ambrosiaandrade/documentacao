# ‚ö° M√≥dulo 14.5: JMH Benchmarking

> **Objetivo:** Criar microbenchmarks precisos com JMH (Java Microbenchmark Harness).

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

JMH (Java Microbenchmark Harness) √© uma ferramenta oficial da OpenJDK para medir performance de c√≥digo Java de forma precisa. Resolve problemas de benchmarks naive como JIT warmup, dead code elimination, constant folding e GC interference. Permite comparar implementa√ß√µes com precis√£o estat√≠stica (m√©dia, desvio padr√£o, percentis).

### üéà Analogia Simples

Imagine que voc√™ quer saber qual atleta √© mais r√°pido: Jo√£o ou Maria.

**Jeito Errado (Naive Benchmark):**

- üèÉ Faz 1 corrida s√≥
- Jo√£o acordou cansado hoje = resultado injusto!
- Pista estava molhada = n√£o vale!
- "Jo√£o: 10s, Maria: 11s" ‚ùå (n√£o confi√°vel)

**Jeito Certo (JMH):**

- üèÉ Aquecimento: 3 corridas para treinar
- üèÉ Medi√ß√£o: 10 corridas oficiais
- üèÉ Cada um corre em dias diferentes (evita cansa√ßo)
- üèÉ Mesma pista, mesmo hor√°rio, mesmas condi√ß√µes
- **Resultado:** "Jo√£o: 10.2s ¬± 0.3s, Maria: 9.8s ¬± 0.2s" ‚úÖ
- **Conclus√£o:** Maria √© mais r√°pida (com certeza estat√≠stica!)

**Em c√≥digo:** JMH garante que voc√™ compara algoritmos de forma justa, sem truques do compilador atrapalhando!

---

## üìë √çndice

1. [Introdu√ß√£o ao JMH](#1-introducao-ao-jmh)
2. [Setup e Configura√ß√£o](#2-setup-e-configuracao)
3. [Annotations](#3-annotations)
4. [Pitfalls Comuns](#4-pitfalls-comuns)
5. [Benchmarks Avan√ßados](#5-benchmarks-avancados)
6. [An√°lise de Resultados](#6-analise-de-resultados)

---

## 1. Introdu√ß√£o ao JMH

### 1.1 Por Que JMH?

```java
/**
 * ‚ùå MICROBENCHMARK NAIVE (ERRADO!)
 */
public class NaiveBenchmark {
    public static void main(String[] args) {
        long start = System.nanoTime();

        // Testar performance de ArrayList vs LinkedList
        for (int i = 0; i < 1000; i++) {
            var list = new ArrayList<Integer>();
            for (int j = 0; j < 100; j++) {
                list.add(j);
            }
        }

        long end = System.nanoTime();
        System.out.println("Tempo: " + (end - start) + "ns");
    }
}

/**
 * PROBLEMAS:
 * 1. JIT n√£o warming up: Primeiras itera√ß√µes interpretadas
 * 2. Dead Code Elimination: JIT pode remover c√≥digo n√£o usado
 * 3. Constant Folding: JIT pode pr√©-calcular constantes
 * 4. GC interference: GC pode rodar durante benchmark
 * 5. Falta de estat√≠sticas: Sem m√©dia, desvio padr√£o, percentis
 */

/**
 * ‚úÖ JMH RESOLVE TUDO ISSO:
 * - Warm-up autom√°tico (JIT optimization)
 * - Dead code elimination protection (Blackhole)
 * - Fork isolado (evita GC interference)
 * - Estat√≠sticas completas (m√©dia, p50, p99)
 * - Controle de par√¢metros (@Param)
 */
```

---

## 2. Setup e Configura√ß√£o

### 2.1 Maven Setup

```xml
<!-- pom.xml -->
<dependencies>
    <!-- JMH Core -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-core</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>

    <!-- JMH Annotation Processor -->
    <dependency>
        <groupId>org.openjdk.jmh</groupId>
        <artifactId>jmh-generator-annprocess</artifactId>
        <version>1.37</version>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <!-- Maven Compiler -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
                <source>17</source>
                <target>17</target>
            </configuration>
        </plugin>
    </plugins>
</build>
```

---

### 2.2 Gradle Setup

```kotlin
// build.gradle.kts
plugins {
    java
    id("me.champeau.jmh") version "0.7.2"
}

dependencies {
    jmh("org.openjdk.jmh:jmh-core:1.37")
    jmh("org.openjdk.jmh:jmh-generator-annprocess:1.37")
}

jmh {
    iterations = 5          // Measurement iterations
    warmupIterations = 3    // Warmup iterations
    fork = 2                // Number of forks
    threads = 1             // Threads per fork
}
```

---

### 2.3 Primeiro Benchmark

```java
/**
 * Benchmark b√°sico: Comparar ArrayList vs LinkedList
 */
@BenchmarkMode(Mode.AverageTime)  // Medir tempo m√©dio
@OutputTimeUnit(TimeUnit.NANOSECONDS)  // Unidade de sa√≠da
@State(Scope.Thread)  // Estado por thread
@Warmup(iterations = 3, time = 1)  // 3 warm-up de 1s cada
@Measurement(iterations = 5, time = 1)  // 5 medi√ß√µes de 1s cada
@Fork(2)  // 2 JVMs isoladas
public class ListBenchmark {

    private List<Integer> arrayList;
    private List<Integer> linkedList;

    @Setup
    public void setup() {
        arrayList = new ArrayList<>();
        linkedList = new LinkedList<>();

        // Populate
        for (int i = 0; i < 1000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
    }

    @Benchmark
    public int arrayListGet() {
        return arrayList.get(500);  // O(1)
    }

    @Benchmark
    public int linkedListGet() {
        return linkedList.get(500);  // O(n)
    }
}

/**
 * EXECUTAR:
 * mvn clean install
 * java -jar target/benchmarks.jar
 */
```

**Resultado Esperado:**

```
Benchmark                    Mode  Cnt   Score   Error  Units
ListBenchmark.arrayListGet   avgt   10   3.5 ¬±  0.1  ns/op
ListBenchmark.linkedListGet  avgt   10  850.0 ¬± 15.0  ns/op
```

**An√°lise:**

- ArrayList: 3.5ns (O(1) - acesso direto)
- LinkedList: 850ns (O(n) - percorre lista)
- **243x mais lento!**

---

## 3. Annotations

### 3.1 @Benchmark

```java
/**
 * Marca m√©todo como benchmark
 */
@Benchmark
public void testMethod() {
    // C√≥digo a ser benchmarked
}
```

---

### 3.2 @BenchmarkMode

```java
/**
 * Define o que medir
 */
@BenchmarkMode(Mode.Throughput)  // ops/second
public class ThroughputBenchmark {
    @Benchmark
    public void test() { /* ... */ }
}

@BenchmarkMode(Mode.AverageTime)  // tempo m√©dio
public class AverageTimeBenchmark {
    @Benchmark
    public void test() { /* ... */ }
}

@BenchmarkMode(Mode.SampleTime)  // percentis (p50, p90, p99)
public class SampleTimeBenchmark {
    @Benchmark
    public void test() { /* ... */ }
}

@BenchmarkMode(Mode.SingleShotTime)  // cold start (sem warmup)
public class ColdStartBenchmark {
    @Benchmark
    public void test() { /* ... */ }
}

@BenchmarkMode({Mode.Throughput, Mode.AverageTime})  // m√∫ltiplos
public class MultipleModesBenchmark {
    @Benchmark
    public void test() { /* ... */ }
}
```

---

### 3.3 @State

```java
/**
 * Gerencia estado do benchmark
 */

/**
 * Scope.Thread: Estado por thread
 * - Cada thread tem sua pr√≥pria inst√¢ncia
 */
@State(Scope.Thread)
public class ThreadState {
    List<Integer> list = new ArrayList<>();

    @Setup
    public void setup() {
        for (int i = 0; i < 1000; i++) {
            list.add(i);
        }
    }
}

/**
 * Scope.Benchmark: Estado compartilhado entre threads
 * - Uma inst√¢ncia para todo benchmark
 */
@State(Scope.Benchmark)
public class BenchmarkState {
    List<Integer> sharedList = new ArrayList<>();
}

/**
 * Scope.Group: Estado compartilhado dentro de grupo
 */
@State(Scope.Group)
public class GroupState {
    AtomicInteger counter = new AtomicInteger();
}
```

---

### 3.4 @Setup e @TearDown

```java
/**
 * Setup e cleanup
 */
@State(Scope.Thread)
public class DatabaseBenchmark {

    private Connection connection;

    /**
     * Level.Trial: Uma vez por fork
     */
    @Setup(Level.Trial)
    public void setupTrial() {
        connection = DriverManager.getConnection("jdbc:h2:mem:test");
        System.out.println("Database connected");
    }

    /**
     * Level.Iteration: Uma vez por iteration (warmup ou measurement)
     */
    @Setup(Level.Iteration)
    public void setupIteration() {
        // Limpa dados
        connection.createStatement().execute("TRUNCATE TABLE users");
    }

    /**
     * Level.Invocation: Uma vez por invoca√ß√£o do benchmark
     * - Muito overhead, evitar!
     */
    @Setup(Level.Invocation)
    public void setupInvocation() {
        // Executado antes de CADA chamada do benchmark
    }

    @Benchmark
    public void insertUser() {
        // ...
    }

    @TearDown(Level.Trial)
    public void tearDown() {
        connection.close();
    }
}
```

---

### 3.5 @Param

```java
/**
 * Parametrizar benchmarks
 */
@State(Scope.Thread)
public class CollectionBenchmark {

    @Param({"10", "100", "1000", "10000"})
    private int size;

    @Param({"ArrayList", "LinkedList", "Vector"})
    private String listType;

    private List<Integer> list;

    @Setup
    public void setup() {
        list = switch (listType) {
            case "ArrayList" -> new ArrayList<>();
            case "LinkedList" -> new LinkedList<>();
            case "Vector" -> new Vector<>();
            default -> throw new IllegalArgumentException();
        };

        for (int i = 0; i < size; i++) {
            list.add(i);
        }
    }

    @Benchmark
    public int getMiddle() {
        return list.get(size / 2);
    }
}

/**
 * RESULTADO: Testa 4 sizes √ó 3 types = 12 combina√ß√µes
 */
```

**Resultado Esperado:**

```
Benchmark                           (listType)  (size)  Score   Units
CollectionBenchmark.getMiddle       ArrayList      10   3.2   ns/op
CollectionBenchmark.getMiddle       ArrayList     100   3.3   ns/op
CollectionBenchmark.getMiddle       ArrayList    1000   3.4   ns/op
CollectionBenchmark.getMiddle       ArrayList   10000   3.5   ns/op
CollectionBenchmark.getMiddle      LinkedList      10  15.0   ns/op
CollectionBenchmark.getMiddle      LinkedList     100 150.0   ns/op
CollectionBenchmark.getMiddle      LinkedList    1000 1500.0  ns/op
CollectionBenchmark.getMiddle      LinkedList   10000 15000.0 ns/op
```

---

## 4. Pitfalls Comuns

### 4.1 Dead Code Elimination

```java
/**
 * ‚ùå PROBLEMA: JIT elimina c√≥digo n√£o usado
 */
@Benchmark
public void deadCode() {
    int result = 2 + 2;  // JIT: "result nunca usado, eliminar c√≥digo!"
}
// Benchmark mede NADA (c√≥digo eliminado)

/**
 * ‚úÖ SOLU√á√ÉO: Retornar resultado
 */
@Benchmark
public int returnResult() {
    return 2 + 2;  // JMH consome resultado
}

/**
 * ‚úÖ SOLU√á√ÉO ALTERNATIVA: Blackhole
 */
@Benchmark
public void useBlackhole(Blackhole bh) {
    int result = 2 + 2;
    bh.consume(result);  // For√ßa JIT a n√£o eliminar
}
```

---

### 4.2 Constant Folding

```java
/**
 * ‚ùå PROBLEMA: JIT pr√©-calcula constantes
 */
@Benchmark
public int constantFolding() {
    return 2 + 2;  // JIT: "sempre 4, retornar 4 direto!"
}
// Benchmark n√£o mede opera√ß√£o, s√≥ retorno de constante

/**
 * ‚úÖ SOLU√á√ÉO: Usar @State com valores vari√°veis
 */
@State(Scope.Thread)
public class ConstantFoldingBenchmark {
    int a = 2;
    int b = 2;

    @Benchmark
    public int noConstantFolding() {
        return a + b;  // JIT n√£o pode pr√©-calcular (vari√°veis)
    }
}
```

---

### 4.3 Loop Unrolling

```java
/**
 * ‚ùå PROBLEMA: JIT otimiza loops
 */
@Benchmark
public int loopUnrolling() {
    int sum = 0;
    for (int i = 0; i < 4; i++) {
        sum += i;
    }
    return sum;
}
// JIT pode transformar em: return 0 + 1 + 2 + 3 = 6

/**
 * ‚úÖ SOLU√á√ÉO: Usar @Param para size vari√°vel
 */
@State(Scope.Thread)
public class LoopBenchmark {
    @Param({"10", "100", "1000"})
    int size;

    @Benchmark
    public int loop() {
        int sum = 0;
        for (int i = 0; i < size; i++) {
            sum += i;
        }
        return sum;
    }
}
```

---

### 4.4 GC Interference

```java
/**
 * ‚ùå PROBLEMA: GC pode rodar durante benchmark
 */
@Benchmark
public List<byte[]> allocateMemory() {
    var list = new ArrayList<byte[]>();
    for (int i = 0; i < 1000; i++) {
        list.add(new byte[1_000_000]);  // 1GB alocado
    }
    return list;
}
// GC pode pausar durante benchmark, distorcendo resultados

/**
 * ‚úÖ SOLU√á√ÉO: Usar m√∫ltiplos forks e estat√≠sticas
 */
@Fork(value = 3, jvmArgs = {"-Xms2G", "-Xmx2G"})  // Heap fixo
@Measurement(iterations = 10)  // Mais medi√ß√µes
public class GCBenchmark {
    @Benchmark
    public List<byte[]> allocateMemory() {
        // ...
    }
}
// Estat√≠sticas revelam vari√¢ncia por GC
```

---

## 5. Benchmarks Avan√ßados

### 5.1 Comparar Implementa√ß√µes

```java
/**
 * CEN√ÅRIO: StringBuilder vs String concatenation
 */
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@State(Scope.Thread)
@Warmup(iterations = 3)
@Measurement(iterations = 5)
@Fork(2)
public class StringBenchmark {

    @Param({"10", "100", "1000"})
    private int iterations;

    /**
     * ‚ùå String concatenation: O(n¬≤)
     */
    @Benchmark
    public String stringConcat() {
        String result = "";
        for (int i = 0; i < iterations; i++) {
            result += "item" + i;  // Cria nova String a cada itera√ß√£o
        }
        return result;
    }

    /**
     * ‚úÖ StringBuilder: O(n)
     */
    @Benchmark
    public String stringBuilder() {
        var sb = new StringBuilder();
        for (int i = 0; i < iterations; i++) {
            sb.append("item").append(i);
        }
        return sb.toString();
    }
}
```

**Resultado Esperado:**

```
Benchmark                       (iterations)  Score     Units
StringBenchmark.stringConcat              10    0.5   us/op
StringBenchmark.stringConcat             100   50.0   us/op
StringBenchmark.stringConcat            1000 5000.0   us/op  ‚Üê O(n¬≤)
StringBenchmark.stringBuilder             10    0.1   us/op
StringBenchmark.stringBuilder            100    1.0   us/op
StringBenchmark.stringBuilder           1000   10.0   us/op  ‚Üê O(n)
```

---

### 5.2 Concurrent Benchmarks

```java
/**
 * CEN√ÅRIO: Testar lock contention
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
@Warmup(iterations = 3)
@Measurement(iterations = 5)
@Fork(1)
public class ConcurrencyBenchmark {

    private int synchronizedCounter = 0;
    private final AtomicInteger atomicCounter = new AtomicInteger(0);

    /**
     * synchronized: Lock contention
     */
    @Benchmark
    @Threads(4)  // 4 threads concorrentes
    public synchronized void synchronizedIncrement() {
        synchronizedCounter++;
    }

    /**
     * AtomicInteger: Lock-free
     */
    @Benchmark
    @Threads(4)
    public void atomicIncrement() {
        atomicCounter.incrementAndGet();
    }
}
```

**Resultado Esperado:**

```
Benchmark                                 Score        Units
ConcurrencyBenchmark.synchronizedIncrement  50.000.000  ops/s
ConcurrencyBenchmark.atomicIncrement       200.000.000  ops/s
```

**An√°lise:**

- AtomicInteger √© 4x mais r√°pido (lock-free)
- synchronized tem lock contention com 4 threads

---

### 5.3 Group Benchmarks

```java
/**
 * CEN√ÅRIO: Producer-Consumer
 */
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Group)
@Warmup(iterations = 3)
@Measurement(iterations = 5)
@Fork(1)
public class ProducerConsumerBenchmark {

    private final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(100);

    @Benchmark
    @Group("producerConsumer")
    @GroupThreads(2)  // 2 producers
    public void produce() throws InterruptedException {
        queue.put(1);
    }

    @Benchmark
    @Group("producerConsumer")
    @GroupThreads(2)  // 2 consumers
    public void consume() throws InterruptedException {
        queue.take();
    }
}
```

---

## 6. An√°lise de Resultados

### 6.1 Interpretar Output

```
Benchmark                    Mode  Cnt    Score    Error  Units
StringBenchmark.stringConcat avgt   10  5000.0 ¬± 250.0  us/op
```

**Interpreta√ß√£o:**

- **Mode**: `avgt` = Average Time (tempo m√©dio)
- **Cnt**: 10 = 10 medi√ß√µes (5 iterations √ó 2 forks)
- **Score**: 5000.0 Œºs/op = 5ms por opera√ß√£o
- **Error**: ¬±250.0 = margem de erro (95% confidence)
- **Units**: Œºs/op = microsegundos por opera√ß√£o

---

### 6.2 Percentis

```java
@BenchmarkMode(Mode.SampleTime)  // Medir percentis
@OutputTimeUnit(TimeUnit.MILLISECONDS)
public class PercentileBenchmark {
    @Benchmark
    public void test() {
        // Simula√ß√£o de lat√™ncia vari√°vel
        try {
            Thread.sleep((long) (Math.random() * 100));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**Output:**

```
Benchmark            Mode   Cnt  Score   Error  Units
PercentileBenchmark  sample 1000  50.0         ms/op
PercentileBenchmark:p0.50   sample       40.0         ms/op  ‚Üê Mediana
PercentileBenchmark:p0.90   sample       80.0         ms/op
PercentileBenchmark:p0.99   sample       95.0         ms/op
PercentileBenchmark:p0.999  sample       99.0         ms/op
PercentileBenchmark:p1.00   sample      100.0         ms/op  ‚Üê Max
```

---

### 6.3 Comparar Resultados

```bash
# Rodar baseline:
java -jar target/benchmarks.jar -rf json -rff baseline.json

# Fazer mudan√ßas no c√≥digo...

# Rodar novamente:
java -jar target/benchmarks.jar -rf json -rff optimized.json

# Comparar:
# Use https://jmh.morethan.io/ ou scripts custom
```

---

## üìä Checklist de Qualidade

- [ ] Usar JMH para microbenchmarks (n√£o System.nanoTime())
- [ ] Warmup suficiente (m√≠nimo 3 iterations, 1s cada)
- [ ] M√∫ltiplos forks (m√≠nimo 2) para isolar GC
- [ ] Retornar ou usar Blackhole para evitar DCE
- [ ] @State para evitar constant folding
- [ ] @Param para testar m√∫ltiplos tamanhos
- [ ] Medir throughput E latency (percentis)
- [ ] Documentar findings em c√≥digo
- [ ] Baseline benchmark antes de otimizar
- [ ] CI/CD para detectar regress√µes

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Benchmark ArrayList.add() vs LinkedList.add()
2. **Intermedi√°rio**: Comparar HashMap vs TreeMap para diferentes tamanhos
3. **Avan√ßado**: Benchmark custom cache implementation vs Caffeine

---

## üìö Refer√™ncias

- [JMH Official Samples](https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples)
- [JMH Documentation](https://github.com/openjdk/jmh)
- [Avoiding Benchmarking Pitfalls (Aleksey Shipil√´v)](https://shipilev.net/)

---

**Pr√≥ximo:** [14.6 - Memory Analysis](14.6-memory-analysis.md)
