# üîç M√≥dulo 14.2: Estruturas de Dados e Complexidade

> **Objetivo:** Analisar complexidade de estruturas de dados Java para escolhas informadas.

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

Estruturas de dados s√£o formas diferentes de organizar informa√ß√µes na mem√≥ria, cada uma com trade-offs espec√≠ficos entre tempo de acesso, inser√ß√£o, remo√ß√£o e uso de mem√≥ria. Escolher a estrutura errada pode transformar uma opera√ß√£o O(1) em O(n), causando gargalos de performance.

### üéà Analogia Simples

Pense em organizar seus livros:

**ArrayList (Estante Numerada):**

- ‚úÖ Pegar livro da posi√ß√£o 5: **Instant√¢neo** (voc√™ sabe exatamente onde est√°!)
- ‚ùå Inserir livro no meio: **Demorado** (precisa empurrar todos os outros!)

**LinkedList (Corrente de Livros):**

- ‚ùå Pegar livro da posi√ß√£o 5: **Demorado** (precisa seguir a corrente: 1‚Üí2‚Üí3‚Üí4‚Üí5)
- ‚úÖ Inserir livro no in√≠cio: **Instant√¢neo** (s√≥ muda o primeiro elo!)

**HashMap (Fich√°rio com Etiquetas):**

- ‚úÖ Achar livro "Java": **Instant√¢neo** (olha direto na gaveta "J"!)
- ‚úÖ Sem ordem definida (como ficaram nas gavetas)

**TreeMap (Biblioteca Ordenada):**

- üü° Achar livro: **R√°pido** (mas n√£o t√£o r√°pido quanto HashMap)
- ‚úÖ Livros sempre em ordem alfab√©tica (extra!)

**Escolha certa = Performance 100x melhor!**

---

## üìë √çndice

1. [Collections Framework](#1-collections-framework)
2. [Lists](#2-lists)
3. [Sets](#3-sets)
4. [Maps](#4-maps)
5. [Queues](#5-queues)
6. [Trade-offs](#6-trade-offs)

---

## 1. Collections Framework

### 1.1 Hierarquia

```
Collection
‚îú‚îÄ‚îÄ List
‚îÇ   ‚îú‚îÄ‚îÄ ArrayList        (O(1) get, O(n) add/remove)
‚îÇ   ‚îú‚îÄ‚îÄ LinkedList       (O(n) get, O(1) add/remove nas pontas)
‚îÇ   ‚îî‚îÄ‚îÄ Vector           (thread-safe, synchronized)
‚îú‚îÄ‚îÄ Set
‚îÇ   ‚îú‚îÄ‚îÄ HashSet          (O(1) add/contains, sem ordem)
‚îÇ   ‚îú‚îÄ‚îÄ LinkedHashSet    (O(1) add/contains, ordem de inser√ß√£o)
‚îÇ   ‚îî‚îÄ‚îÄ TreeSet          (O(log n) add/contains, ordenado)
‚îî‚îÄ‚îÄ Queue
    ‚îú‚îÄ‚îÄ PriorityQueue    (O(log n) add/poll, heap)
    ‚îú‚îÄ‚îÄ ArrayDeque       (O(1) add/poll nas pontas)
    ‚îî‚îÄ‚îÄ LinkedList       (implementa Queue)

Map
‚îú‚îÄ‚îÄ HashMap              (O(1) get/put, sem ordem)
‚îú‚îÄ‚îÄ LinkedHashMap        (O(1) get/put, ordem de inser√ß√£o)
‚îú‚îÄ‚îÄ TreeMap              (O(log n) get/put, ordenado)
‚îî‚îÄ‚îÄ Hashtable            (thread-safe, synchronized)
```

---

## 2. Lists

### 2.1 ArrayList vs LinkedList

```java
/**
 * COMPARA√á√ÉO: ArrayList vs LinkedList
 */

/**
 * ArrayList: Array din√¢mico
 * - Backing store: Array cont√≠guo na mem√≥ria
 * - Redimensiona quando cheio (dobra capacidade)
 */
public class ArrayListAnalysis {
    /**
     * get(index): O(1)
     * - Acesso direto: array[index]
     */
    public void testGet() {
        var list = new ArrayList<Integer>();
        // ... populate
        int value = list.get(5000);  // O(1) - acesso direto
    }

    /**
     * add(element): O(1) amortizado
     * - Caso comum: adiciona no final, O(1)
     * - Resize: Quando cheio, aloca novo array 2x maior, copia todos = O(n)
     * - Amortizado: Resize raro, ent√£o O(1) na m√©dia
     */
    public void testAdd() {
        var list = new ArrayList<Integer>();
        list.add(10);  // O(1) amortizado
    }

    /**
     * add(index, element): O(n)
     * - Precisa deslocar elementos √† direita do √≠ndice
     */
    public void testAddAtIndex() {
        var list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        list.add(2, 99);  // O(n) - desloca [3, 4, 5] para direita
    }

    /**
     * remove(index): O(n)
     * - Precisa deslocar elementos √† esquerda
     */
    public void testRemove() {
        var list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        list.remove(2);  // O(n) - desloca [4, 5] para esquerda
    }

    /**
     * contains(element): O(n)
     * - Busca linear
     */
    public void testContains() {
        var list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        boolean has = list.contains(3);  // O(n) - itera at√© encontrar
    }
}

/**
 * LinkedList: Lista duplamente encadeada
 * - Cada n√≥ cont√©m: data, next, prev
 */
public class LinkedListAnalysis {
    /**
     * get(index): O(n)
     * - Precisa percorrer lista at√© √≠ndice
     * - Otimiza√ß√£o: Come√ßa do in√≠cio ou fim (menor dist√¢ncia)
     */
    public void testGet() {
        var list = new LinkedList<Integer>();
        // ... populate
        int value = list.get(5000);  // O(n) - percorre 5000 n√≥s
    }

    /**
     * addFirst/addLast: O(1)
     * - Manipula apenas ponteiros
     */
    public void testAdd() {
        var list = new LinkedList<Integer>();
        list.addFirst(10);  // O(1)
        list.addLast(20);   // O(1)
    }

    /**
     * add(index, element): O(n)
     * - Precisa percorrer at√© √≠ndice, ent√£o O(1) para inserir
     */
    public void testAddAtIndex() {
        var list = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
        list.add(2, 99);  // O(n) para navegar + O(1) para inserir
    }

    /**
     * removeFirst/removeLast: O(1)
     * - Manipula apenas ponteiros
     */
    public void testRemove() {
        var list = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
        list.removeFirst();  // O(1)
    }

    /**
     * contains(element): O(n)
     * - Busca linear
     */
    public void testContains() {
        var list = new LinkedList<>(Arrays.asList(1, 2, 3, 4, 5));
        boolean has = list.contains(3);  // O(n)
    }
}
```

---

### 2.2 Tabela Comparativa

| Opera√ß√£o                | ArrayList | LinkedList              | Quando Usar                        |
| ----------------------- | --------- | ----------------------- | ---------------------------------- |
| **get(index)**          | O(1)      | O(n)                    | ArrayList para acesso aleat√≥rio    |
| **add(element)**        | O(1)\*    | O(1)                    | ArrayList geralmente               |
| **add(0, element)**     | O(n)      | O(1)                    | LinkedList para inser√ß√£o no in√≠cio |
| **add(index, element)** | O(n)      | O(n)                    | ArrayList (menor overhead)         |
| **remove(0)**           | O(n)      | O(1)                    | LinkedList para remo√ß√£o no in√≠cio  |
| **remove(index)**       | O(n)      | O(n)                    | ArrayList (melhor cache locality)  |
| **contains(element)**   | O(n)      | O(n)                    | ArrayList (cache locality)         |
| **iterator.remove()**   | O(n)      | O(1)                    | LinkedList durante itera√ß√£o        |
| **Mem√≥ria**             | Compacta  | 2x overhead (prev/next) | ArrayList                          |

\*O(1) amortizado (ocasionalmente O(n) para resize)

---

### 2.3 Exemplo Pr√°tico

```java
/**
 * CEN√ÅRIO: Fila de processamento
 */
public class TaskQueue {
    /**
     * ‚ùå MAU: ArrayList para fila
     * - remove(0) = O(n) - desloca todos elementos
     */
    public void badQueue() {
        var queue = new ArrayList<String>();
        queue.add("task1");
        queue.add("task2");
        queue.add("task3");

        while (!queue.isEmpty()) {
            String task = queue.remove(0);  // O(n) - desloca array inteiro!
            process(task);
        }
    }

    /**
     * ‚úÖ BOM: LinkedList para fila
     * - removeFirst() = O(1)
     */
    public void goodQueue() {
        var queue = new LinkedList<String>();
        queue.add("task1");
        queue.add("task2");
        queue.add("task3");

        while (!queue.isEmpty()) {
            String task = queue.removeFirst();  // O(1)
            process(task);
        }
    }

    /**
     * ‚úÖ MELHOR: ArrayDeque (otimizada para fila)
     * - poll() = O(1) amortizado
     * - Mais eficiente que LinkedList (sem overhead de ponteiros)
     */
    public void bestQueue() {
        var queue = new ArrayDeque<String>();
        queue.add("task1");
        queue.add("task2");
        queue.add("task3");

        while (!queue.isEmpty()) {
            String task = queue.poll();  // O(1) amortizado
            process(task);
        }
    }

    private void process(String task) {
        // ...
    }
}
```

---

## 3. Sets

### 3.1 HashSet

```java
/**
 * HashSet: Hash table
 * - Backing store: HashMap<E, PRESENT>
 * - Sem ordem garantida
 */
public class HashSetAnalysis {
    /**
     * add(element): O(1) amortizado
     * - Hash function: O(1)
     * - Collision resolution: O(1) esperado
     */
    public void testAdd() {
        var set = new HashSet<String>();
        set.add("apple");   // O(1)
        set.add("banana");  // O(1)
    }

    /**
     * contains(element): O(1) amortizado
     * - Hash lookup
     */
    public void testContains() {
        var set = new HashSet<>(Arrays.asList("a", "b", "c"));
        boolean has = set.contains("b");  // O(1)
    }

    /**
     * remove(element): O(1) amortizado
     */
    public void testRemove() {
        var set = new HashSet<>(Arrays.asList("a", "b", "c"));
        set.remove("b");  // O(1)
    }

    /**
     * ‚ö†Ô∏è Hash collision: Pior caso O(n)
     * - Se todos elementos t√™m mesmo hash
     * - Java 8+: Usa TreeNode ap√≥s 8 colis√µes = O(log n)
     */
    public void hashCollision() {
        var set = new HashSet<BadHash>();
        // Se BadHash.hashCode() retorna constante:
        // Todos elementos na mesma bucket = O(n) ou O(log n)
    }
}

/**
 * QUANDO USAR HashSet:
 * - Precisa de O(1) add/contains/remove
 * - Ordem n√£o importa
 * - Elementos t√™m bom hashCode()
 */
```

---

### 3.2 TreeSet

```java
/**
 * TreeSet: Red-Black Tree (√°rvore balanceada)
 * - Backing store: TreeMap<E, PRESENT>
 * - Elementos ordenados
 */
public class TreeSetAnalysis {
    /**
     * add(element): O(log n)
     * - Insere mantendo √°rvore balanceada
     */
    public void testAdd() {
        var set = new TreeSet<Integer>();
        set.add(5);  // O(log n)
        set.add(2);  // O(log n)
        set.add(8);  // O(log n)

        System.out.println(set);  // [2, 5, 8] - ordenado!
    }

    /**
     * contains(element): O(log n)
     * - Binary search na √°rvore
     */
    public void testContains() {
        var set = new TreeSet<>(Arrays.asList(1, 2, 3, 4, 5));
        boolean has = set.contains(3);  // O(log n)
    }

    /**
     * first/last: O(log n)
     * - Navega para extremos da √°rvore
     */
    public void testFirstLast() {
        var set = new TreeSet<>(Arrays.asList(5, 2, 8, 1, 9));
        int first = set.first();  // O(log n) ‚Üí 1
        int last = set.last();    // O(log n) ‚Üí 9
    }

    /**
     * subSet/headSet/tailSet: O(log n)
     * - Retorna view de range
     */
    public void testSubSet() {
        var set = new TreeSet<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));
        var subSet = set.subSet(3, 7);  // O(log n) ‚Üí [3, 4, 5, 6]
    }
}

/**
 * QUANDO USAR TreeSet:
 * - Precisa de elementos ordenados
 * - Range queries (subSet, headSet, tailSet)
 * - first(), last() frequentes
 * - Trade-off: O(log n) vs O(1), mas com ordena√ß√£o
 */
```

---

### 3.3 Compara√ß√£o

```java
/**
 * COMPARA√á√ÉO: HashSet vs TreeSet vs LinkedHashSet
 */
public class SetComparison {
    @Test
    void comparePerformance() {
        int n = 100_000;

        // HashSet: O(1) add, sem ordem
        var hashSet = new HashSet<Integer>();
        for (int i = 0; i < n; i++) {
            hashSet.add(i);  // O(1) cada = O(n) total
        }

        // TreeSet: O(log n) add, ordenado
        var treeSet = new TreeSet<Integer>();
        for (int i = 0; i < n; i++) {
            treeSet.add(i);  // O(log n) cada = O(n log n) total
        }

        // LinkedHashSet: O(1) add, ordem de inser√ß√£o
        var linkedHashSet = new LinkedHashSet<Integer>();
        for (int i = 0; i < n; i++) {
            linkedHashSet.add(i);  // O(1) cada = O(n) total
        }

        System.out.println("HashSet:       " + hashSet);         // ordem aleat√≥ria
        System.out.println("TreeSet:       " + treeSet);         // [0, 1, 2, ...]
        System.out.println("LinkedHashSet: " + linkedHashSet);  // [0, 1, 2, ...]
    }
}

/**
 * ESCOLHA:
 * - HashSet: Performance m√°xima, ordem n√£o importa
 * - TreeSet: Precisa ordena√ß√£o ou range queries
 * - LinkedHashSet: Ordem de inser√ß√£o (raro)
 */
```

---

## 4. Maps

### 4.1 HashMap

```java
/**
 * HashMap: Hash table
 * - Array de buckets, cada bucket √© lista/√°rvore
 */
public class HashMapAnalysis {
    /**
     * put(key, value): O(1) amortizado
     * - hashCode(key) ‚Üí bucket index
     * - Collision: Linear probing ou chaining
     */
    public void testPut() {
        var map = new HashMap<String, Integer>();
        map.put("apple", 10);   // O(1)
        map.put("banana", 20);  // O(1)
    }

    /**
     * get(key): O(1) amortizado
     * - Hash lookup
     */
    public void testGet() {
        var map = new HashMap<String, Integer>();
        map.put("apple", 10);
        int value = map.get("apple");  // O(1) ‚Üí 10
    }

    /**
     * containsKey(key): O(1) amortizado
     * - Same as get()
     */
    public void testContainsKey() {
        var map = new HashMap<String, Integer>();
        map.put("apple", 10);
        boolean has = map.containsKey("apple");  // O(1) ‚Üí true
    }

    /**
     * containsValue(value): O(n)
     * - Precisa iterar todos buckets
     */
    public void testContainsValue() {
        var map = new HashMap<String, Integer>();
        map.put("apple", 10);
        map.put("banana", 20);
        boolean has = map.containsValue(10);  // O(n) - busca linear
    }

    /**
     * ‚ö†Ô∏è Load factor: Controla resize
     * - Default: 0.75 (resize quando 75% cheio)
     * - Trade-off: Espa√ßo vs colis√µes
     */
    public void loadFactor() {
        // Capacity inicial: 16, load factor: 0.75
        var map = new HashMap<String, Integer>();

        // Resize quando size > 16 * 0.75 = 12
        for (int i = 0; i < 13; i++) {
            map.put("key" + i, i);
        }
        // Ap√≥s 13¬∫ put: resize para capacity 32
    }
}
```

---

### 4.2 TreeMap

```java
/**
 * TreeMap: Red-Black Tree
 * - Chaves ordenadas
 */
public class TreeMapAnalysis {
    /**
     * put(key, value): O(log n)
     * - Insere mantendo √°rvore balanceada
     */
    public void testPut() {
        var map = new TreeMap<Integer, String>();
        map.put(3, "three");  // O(log n)
        map.put(1, "one");    // O(log n)
        map.put(2, "two");    // O(log n)

        System.out.println(map);  // {1=one, 2=two, 3=three} - ordenado!
    }

    /**
     * get(key): O(log n)
     * - Binary search na √°rvore
     */
    public void testGet() {
        var map = new TreeMap<Integer, String>();
        map.put(1, "one");
        map.put(2, "two");
        String value = map.get(1);  // O(log n) ‚Üí "one"
    }

    /**
     * firstKey/lastKey: O(log n)
     */
    public void testFirstLast() {
        var map = new TreeMap<Integer, String>();
        map.put(5, "five");
        map.put(2, "two");
        map.put(8, "eight");

        int first = map.firstKey();  // O(log n) ‚Üí 2
        int last = map.lastKey();    // O(log n) ‚Üí 8
    }

    /**
     * subMap/headMap/tailMap: O(log n)
     * - Range views
     */
    public void testSubMap() {
        var map = new TreeMap<Integer, String>();
        for (int i = 1; i <= 10; i++) {
            map.put(i, "value" + i);
        }

        var subMap = map.subMap(3, 7);  // O(log n) ‚Üí {3, 4, 5, 6}
        System.out.println(subMap);
    }
}

/**
 * QUANDO USAR TreeMap:
 * - Precisa chaves ordenadas
 * - Range queries frequentes
 * - firstKey(), lastKey() necess√°rios
 * - Trade-off: O(log n) vs O(1), mas com ordena√ß√£o
 */
```

---

### 4.3 Compara√ß√£o

| Opera√ß√£o             | HashMap   | TreeMap           | LinkedHashMap   | Quando Usar                |
| -------------------- | --------- | ----------------- | --------------- | -------------------------- |
| **put(k, v)**        | O(1)      | O(log n)          | O(1)            | HashMap para performance   |
| **get(k)**           | O(1)      | O(log n)          | O(1)            | HashMap para lookup r√°pido |
| **containsKey(k)**   | O(1)      | O(log n)          | O(1)            | HashMap                    |
| **containsValue(v)** | O(n)      | O(n)              | O(n)            | Evitar se poss√≠vel         |
| **firstKey/lastKey** | N/A       | O(log n)          | N/A             | TreeMap                    |
| **Ordem**            | Aleat√≥ria | Ordenada          | Inser√ß√£o        | TreeMap/LinkedHashMap      |
| **Mem√≥ria**          | Boa       | TreeNode overhead | Linked overhead | HashMap                    |

---

## 5. Queues

### 5.1 PriorityQueue

```java
/**
 * PriorityQueue: Min-heap (por padr√£o)
 * - Elementos removidos em ordem de prioridade
 */
public class PriorityQueueAnalysis {
    /**
     * add/offer: O(log n)
     * - Insere mantendo heap property
     */
    public void testAdd() {
        var pq = new PriorityQueue<Integer>();
        pq.add(5);  // O(log n)
        pq.add(2);  // O(log n) - sobe se menor que pai
        pq.add(8);  // O(log n)

        System.out.println(pq.poll());  // 2 (menor)
        System.out.println(pq.poll());  // 5
        System.out.println(pq.poll());  // 8
    }

    /**
     * poll/remove: O(log n)
     * - Remove raiz, move √∫ltimo para raiz, rebalanceia
     */
    public void testPoll() {
        var pq = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1, 9));
        int min = pq.poll();  // O(log n) ‚Üí 1
    }

    /**
     * peek: O(1)
     * - Retorna raiz sem remover
     */
    public void testPeek() {
        var pq = new PriorityQueue<>(Arrays.asList(5, 2, 8, 1, 9));
        int min = pq.peek();  // O(1) ‚Üí 1
    }

    /**
     * Custom comparator: Max-heap
     */
    public void maxHeap() {
        var maxPq = new PriorityQueue<Integer>(Comparator.reverseOrder());
        maxPq.add(5);
        maxPq.add(2);
        maxPq.add(8);

        System.out.println(maxPq.poll());  // 8 (maior)
    }
}

/**
 * QUANDO USAR PriorityQueue:
 * - Precisa processar elementos por prioridade
 * - Top K problemas (K maiores/menores)
 * - Dijkstra, A* (algoritmos de grafo)
 * - Merge K sorted lists
 */
```

---

### 5.2 ArrayDeque

```java
/**
 * ArrayDeque: Array circular
 * - Mais eficiente que LinkedList para queue/stack
 */
public class ArrayDequeAnalysis {
    /**
     * addFirst/addLast: O(1) amortizado
     * - Array resize ocasional
     */
    public void testAdd() {
        var deque = new ArrayDeque<Integer>();
        deque.addFirst(1);  // O(1)
        deque.addLast(2);   // O(1)
    }

    /**
     * pollFirst/pollLast: O(1)
     */
    public void testPoll() {
        var deque = new ArrayDeque<>(Arrays.asList(1, 2, 3));
        int first = deque.pollFirst();  // O(1) ‚Üí 1
        int last = deque.pollLast();    // O(1) ‚Üí 3
    }

    /**
     * peekFirst/peekLast: O(1)
     */
    public void testPeek() {
        var deque = new ArrayDeque<>(Arrays.asList(1, 2, 3));
        int first = deque.peekFirst();  // O(1) ‚Üí 1
    }
}

/**
 * QUANDO USAR ArrayDeque:
 * - Queue: FIFO (pollFirst depois addLast)
 * - Stack: LIFO (pollLast depois addLast)
 * - Sliding window problems
 * - Mais eficiente que LinkedList (sem overhead de ponteiros)
 */
```

---

## 6. Trade-offs

### 6.1 Exemplo Pr√°tico: Remover Duplicatas

```java
/**
 * CEN√ÅRIO: Remover duplicatas de lista
 */
public class RemoveDuplicates {
    /**
     * ‚ùå Naive: O(n¬≤)
     * - Nested loops
     */
    public List<Integer> naive(List<Integer> list) {
        var result = new ArrayList<Integer>();
        for (int num : list) {  // O(n)
            if (!result.contains(num)) {  // O(n) - busca linear
                result.add(num);
            }
        }
        return result;  // O(n¬≤)
    }

    /**
     * ‚úÖ HashSet: O(n)
     * - Usa HashSet para O(1) lookup
     */
    public List<Integer> withHashSet(List<Integer> list) {
        var seen = new HashSet<Integer>();
        var result = new ArrayList<Integer>();

        for (int num : list) {  // O(n)
            if (seen.add(num)) {  // HashSet.add() = O(1)
                result.add(num);
            }
        }
        return result;  // O(n)
    }

    /**
     * ‚úÖ Stream: O(n)
     * - Usa HashSet internamente
     */
    public List<Integer> withStream(List<Integer> list) {
        return list.stream()
                .distinct()  // O(n) - HashSet
                .collect(Collectors.toList());
    }
}

/**
 * BENCHMARK (n=10.000):
 * - Naive: ~50.000.000 opera√ß√µes (n¬≤)
 * - HashSet: ~10.000 opera√ß√µes (n)
 * - 5000x mais r√°pido!
 */
```

---

### 6.2 Exemplo: Top K Elementos

```java
/**
 * CEN√ÅRIO: Encontrar K maiores elementos
 */
public class TopK {
    /**
     * ‚ùå Naive: O(n log n) - ordenar tudo
     */
    public List<Integer> naive(int[] array, int k) {
        Arrays.sort(array);  // O(n log n)
        return Arrays.stream(array)
                .skip(array.length - k)
                .boxed()
                .collect(Collectors.toList());
    }

    /**
     * ‚úÖ Min-Heap: O(n log k)
     * - Mant√©m heap de tamanho k
     */
    public List<Integer> withHeap(int[] array, int k) {
        var minHeap = new PriorityQueue<Integer>(k);

        for (int num : array) {  // O(n)
            if (minHeap.size() < k) {
                minHeap.add(num);  // O(log k)
            } else if (num > minHeap.peek()) {
                minHeap.poll();  // O(log k)
                minHeap.add(num);  // O(log k)
            }
        }

        return new ArrayList<>(minHeap);  // O(k)
    }
    // Total: O(n log k) vs O(n log n)
}

/**
 * COMPARA√á√ÉO (n=1.000.000, k=10):
 * - Naive: 1.000.000 * log(1.000.000) ‚âà 20.000.000 ops
 * - Heap: 1.000.000 * log(10) ‚âà 3.300.000 ops
 * - 6x mais r√°pido!
 */
```

---

## üìä Checklist de Qualidade

- [ ] Usar ArrayList para acesso aleat√≥rio frequente (get)
- [ ] Usar LinkedList para inser√ß√µes/remo√ß√µes no in√≠cio (addFirst/removeFirst)
- [ ] Usar ArrayDeque para queues/stacks (mais eficiente que LinkedList)
- [ ] Usar HashSet/HashMap para O(1) lookup (vs TreeSet/TreeMap O(log n))
- [ ] Usar TreeSet/TreeMap quando precisar ordena√ß√£o ou range queries
- [ ] Usar PriorityQueue para top K ou processamento por prioridade
- [ ] Evitar contains() em ArrayList (O(n)) - usar HashSet se poss√≠vel
- [ ] Evitar containsValue() em HashMap (O(n)) - inverter map se frequente
- [ ] Dimensionar capacidade inicial (HashMap, ArrayList) para evitar resizes
- [ ] Implementar hashCode() correto para chaves de HashMap/HashSet

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Implementar cache LRU com LinkedHashMap
2. **Intermedi√°rio**: Top K frequent elements com PriorityQueue
3. **Avan√ßado**: Sliding window maximum com ArrayDeque

---

## üìö Refer√™ncias

- [Java Collections Framework](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/doc-files/coll-overview.html)
- [Big O Cheat Sheet](https://www.bigocheatsheet.com/)

---

**Pr√≥ximo:** [14.3 - Algoritmos Cl√°ssicos](14.3-algoritmos-classicos.md)
