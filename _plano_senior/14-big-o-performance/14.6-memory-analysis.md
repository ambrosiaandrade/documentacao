# üß† M√≥dulo 14.6: Memory Analysis

> **Objetivo:** Diagnosticar memory leaks e otimizar consumo de mem√≥ria com heap dumps e GC logs.

---

## üéØ O Que Voc√™ Vai Aprender

### üìö Explica√ß√£o T√©cnica

Memory analysis √© o processo de investigar como a aplica√ß√£o usa mem√≥ria RAM (heap). Heap dumps s√£o snapshots da mem√≥ria mostrando todos os objetos vivos. GC logs mostram quando o Garbage Collector roda e quanto tempo demora. Memory leaks acontecem quando objetos n√£o s√£o liberados (GC n√£o consegue coletar), causando OutOfMemoryError ap√≥s horas/dias de execu√ß√£o.

### üéà Analogia Simples

Imagine sua casa como a mem√≥ria do computador:

**Uso Normal de Mem√≥ria:**

- üè† Voc√™ compra coisas (objetos criados)
- üóëÔ∏è Joga fora o que n√£o usa mais (Garbage Collector)
- üè† Casa sempre limpa e com espa√ßo!

**Memory Leak (Vazamento):**

- üè† Voc√™ compra coisas TODO DIA
- ‚ùå Esquece de jogar fora (objetos n√£o liberados)
- üì¶üì¶üì¶ Caixas acumulando, acumulando...
- üè†üí• Casa cheia! N√£o cabe mais nada! (OutOfMemoryError)

**Heap Dump (Foto da Casa):**

- üì∏ Tira foto de TUDO que est√° na casa
- üîç Investiga: "Por que tem 10.000 caixas de sapatos vazias?"
- üéØ Descobre: "Ah, estou guardando todas as caixas que comprei!"
- ‚úÖ Solu√ß√£o: Jogar caixas vazias fora!

**Em c√≥digo:** Memory leak √© guardar objetos sem necessidade (ex: lista que cresce infinito). Heap dump mostra EXATAMENTE o que est√° ocupando mem√≥ria!

---

## üìë √çndice

1. [Heap Dumps](#1-heap-dumps)
2. [Memory Analyzer Tool (MAT)](#2-memory-analyzer-tool-mat)
3. [GC Logs](#3-gc-logs)
4. [Memory Leaks](#4-memory-leaks)
5. [Reference Types](#5-reference-types)
6. [Otimiza√ß√£o de Mem√≥ria](#6-otimizacao-de-memoria)

---

## 1. Heap Dumps

### 1.1 Capturar Heap Dump

```bash
# 1. Via jmap (pausa JVM):
jmap -dump:format=b,file=heap.hprof <PID>

# 2. Via jcmd (preferido):
jcmd <PID> GC.heap_dump heap.hprof

# 3. Autom√°tico em OutOfMemoryError:
java -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/tmp/heap.hprof \
     -jar app.jar

# 4. Via VisualVM:
# Attach ‚Üí Monitor ‚Üí Heap Dump

# 5. Via JProfiler/YourKit:
# Memory ‚Üí Heap Dump
```

---

### 1.2 Shallow vs Retained Size

```java
/**
 * SHALLOW SIZE: Tamanho do objeto em si
 * RETAINED SIZE: Tamanho + objetos referenciados (GC liberaria)
 */

class User {
    private Long id;           // 8 bytes (reference)
    private String name;       // 8 bytes (reference)
    private List<Order> orders; // 8 bytes (reference)
}

/**
 * AN√ÅLISE:
 *
 * Shallow size of User:
 * - Object header: 16 bytes
 * - id reference: 8 bytes
 * - name reference: 8 bytes
 * - orders reference: 8 bytes
 * Total: 40 bytes
 *
 * Retained size of User:
 * - User: 40 bytes
 * - Long (id): 24 bytes
 * - String (name): 48 bytes ("John Doe")
 * - ArrayList (orders): 32 bytes
 * - Order[0]: 100 bytes
 * - Order[1]: 100 bytes
 * Total: 344 bytes
 *
 * Se User for GC'ed, 344 bytes s√£o liberados
 */
```

---

### 1.3 Dominator Tree

```java
/**
 * DOMINATOR TREE: Objetos que "seguram" mem√≥ria
 */

/**
 * CEN√ÅRIO: Memory leak em cache
 */
@Service
public class UserCache {
    // ‚ùå HashMap nunca limpa = MEMORY LEAK
    private final Map<Long, User> cache = new HashMap<>();

    public void cacheUser(User user) {
        cache.put(user.getId(), user);
    }
}

/**
 * DOMINATOR TREE (heap dump):
 *
 * UserCache (24 bytes)
 * ‚îî‚îÄ HashMap (32 bytes)
 *    ‚îî‚îÄ Entry[] (1.2 GB)  ‚Üê DOMINATOR
 *       ‚îú‚îÄ Entry 0 ‚Üí User (344 bytes)
 *       ‚îú‚îÄ Entry 1 ‚Üí User (344 bytes)
 *       ‚îî‚îÄ ... (10.000 users)
 *
 * UserCache "domina" 1.2 GB de mem√≥ria
 * Se UserCache for GC'ed, 1.2 GB s√£o liberados
 */
```

---

## 2. Memory Analyzer Tool (MAT)

### 2.1 Instalar MAT

```bash
# Download: https://www.eclipse.org/mat/downloads.php
# Standalone ou plugin Eclipse

# Executar:
./MemoryAnalyzer heap.hprof
```

---

### 2.2 Leak Suspects Report

```java
/**
 * CEN√ÅRIO: Memory leak com listeners
 */
@Component
public class EventBus {
    // ‚ùå Listeners nunca removidos
    private final List<EventListener> listeners = new ArrayList<>();

    public void register(EventListener listener) {
        listeners.add(listener);  // LEAK!
    }

    public void publish(Event event) {
        listeners.forEach(l -> l.onEvent(event));
    }
}

@Controller
public class UserController {
    @Autowired
    private EventBus eventBus;

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        // ‚ùå Cria listener a cada request!
        eventBus.register(event -> {
            System.out.println("User accessed: " + id);
        });

        return userService.getUser(id);
    }
}
```

**MAT - Leak Suspects:**

```
Problem Suspect 1:
----------------------------------------------------------------------------
One instance of "EventBus" loaded by "WebAppClassLoader" occupies 245 MB (85% of total heap).

Keywords:
EventBus, ArrayList, EventListener

Details:
- EventBus.listeners: ArrayList with 100,000 instances
- Each EventListener retains lambda context (UserController instance)
- Prevents GC of UserController instances

Recommendation:
Inspect EventBus.listeners retention. Consider using WeakReferences or
unregistering listeners.
```

---

### 2.3 Histogram

```java
/**
 * CEN√ÅRIO: Muitas Strings duplicadas
 */
@Service
public class ReportService {

    public List<ReportRow> generateReport() {
        var rows = new ArrayList<ReportRow>();

        // ‚ùå Cria 10.000 Strings "ACTIVE" duplicadas
        for (int i = 0; i < 10000; i++) {
            rows.add(new ReportRow(
                i,
                "ACTIVE",  // String literal (interned)
                new String("ACTIVE")  // ‚ùå Nova String a cada vez!
            ));
        }

        return rows;
    }
}
```

**MAT - Histogram:**

```
Class Name              | Objects | Shallow Heap | Retained Heap
------------------------------------------------------------------------
java.lang.String        | 10,000  | 240 KB       | 400 KB
char[]                  | 10,000  | 160 KB       | 160 KB
ReportRow               | 10,000  | 320 KB       | 900 KB
```

**An√°lise:**

- 10.000 Strings "ACTIVE" duplicadas
- 400 KB desperdi√ßados

**Fix:**

```java
// ‚úÖ Usa String literal (interned)
rows.add(new ReportRow(i, "ACTIVE", "ACTIVE"));
// Ou usa enum:
rows.add(new ReportRow(i, Status.ACTIVE, Status.ACTIVE));
```

---

### 2.4 Thread Overview

```java
/**
 * CEN√ÅRIO: Thread leak (threads n√£o terminam)
 */
@Service
public class TaskService {

    public void executeTask(Runnable task) {
        // ‚ùå Cria thread sem pool
        new Thread(task).start();  // LEAK!
    }
}
```

**MAT - Thread Overview:**

```
Thread Name          | Shallow | Retained | State
-------------------------------------------------
pool-1-thread-1      | 1 KB    | 500 KB   | RUNNABLE
pool-1-thread-2      | 1 KB    | 500 KB   | WAITING
...
pool-1-thread-1000   | 1 KB    | 500 KB   | BLOCKED

Total: 1000 threads, 500 MB retained
```

**Fix:**

```java
// ‚úÖ Usa ExecutorService com pool limitado
@Configuration
public class ThreadPoolConfig {
    @Bean
    public ExecutorService taskExecutor() {
        return Executors.newFixedThreadPool(10);
    }
}
```

---

## 3. GC Logs

### 3.1 Habilitar GC Logging

```bash
# Java 11+:
java -Xlog:gc*:file=gc.log:time,level,tags \
     -Xms2G -Xmx2G \
     -jar app.jar

# Java 8:
java -XX:+PrintGCDetails \
     -XX:+PrintGCDateStamps \
     -Xloggc:gc.log \
     -Xms2G -Xmx2G \
     -jar app.jar
```

---

### 3.2 Interpretar GC Logs

```
[2024-01-15T10:30:45.123+0000][info][gc] GC(123) Pause Young (Allocation Failure) 1024M->256M(2048M) 50.123ms
```

**Interpreta√ß√£o:**

- `GC(123)`: GC n√∫mero 123
- `Pause Young`: Minor GC (coleta Young Generation)
- `Allocation Failure`: Causa (Eden cheio)
- `1024M->256M`: Heap antes ‚Üí depois
- `(2048M)`: Heap total
- `50.123ms`: Dura√ß√£o da pausa

---

### 3.3 GC Patterns

```java
/**
 * PATTERN 1: Allocation Rate Alto
 */
@RestController
public class HighAllocationController {

    @GetMapping("/data")
    public List<String> getData() {
        var list = new ArrayList<String>();

        // ‚ùå Aloca 1GB por request
        for (int i = 0; i < 1_000_000; i++) {
            list.add(new String("data" + i));  // 1KB cada
        }

        return list;
    }
}
```

**GC Log:**

```
[gc] GC(1) Pause Young 512M->100M(2048M) 20ms
[gc] GC(2) Pause Young 512M->100M(2048M) 22ms  ‚Üê 0.5s depois
[gc] GC(3) Pause Young 512M->100M(2048M) 21ms  ‚Üê 0.5s depois
[gc] GC(4) Pause Young 512M->100M(2048M) 23ms  ‚Üê 0.5s depois

Allocation Rate: 1GB/sec  ‚Üê MUITO ALTO!
Minor GC frequency: 2 per second
```

**An√°lise:**

- Minor GC a cada 0.5s = allocation rate muito alto
- Solu√ß√£o: Reduzir aloca√ß√µes ou aumentar Eden

---

```java
/**
 * PATTERN 2: Memory Leak (Old Gen crescendo)
 */
@Service
public class CacheService {
    // ‚ùå Cache sem eviction
    private final Map<String, byte[]> cache = new HashMap<>();

    public void cache(String key, byte[] data) {
        cache.put(key, data);  // Acumula indefinidamente
    }
}
```

**GC Log:**

```
[gc] GC(1) Pause Young 512M->200M(2048M) 20ms  | Old: 0M
[gc] GC(2) Pause Young 512M->200M(2048M) 21ms  | Old: 50M  ‚Üê Crescendo
[gc] GC(3) Pause Young 512M->200M(2048M) 22ms  | Old: 100M ‚Üê Crescendo
[gc] GC(4) Pause Young 512M->200M(2048M) 23ms  | Old: 150M ‚Üê Crescendo
...
[gc] GC(50) Pause Full 1900M->1850M(2048M) 5000ms  ‚Üê Full GC!

Old Generation: 0M ‚Üí 1850M em 10 minutos
Full GC duration: 5 segundos  ‚Üê PROBLEMA!
```

**An√°lise:**

- Old Gen crescendo linearmente = memory leak
- Full GC n√£o libera mem√≥ria (1900M ‚Üí 1850M)
- Solu√ß√£o: Heap dump e identificar leak

---

## 4. Memory Leaks

### 4.1 Padr√µes Comuns

```java
/**
 * LEAK 1: Static collections
 */
public class UserRegistry {
    // ‚ùå Static = nunca GC'ed
    private static final List<User> USERS = new ArrayList<>();

    public static void register(User user) {
        USERS.add(user);  // LEAK!
    }
}

/**
 * FIX: Usar WeakHashMap ou cache com eviction
 */
public class UserRegistry {
    // ‚úÖ WeakHashMap: Entries GC'ed se key n√£o referenciado
    private static final Map<Long, WeakReference<User>> USERS =
        new WeakHashMap<>();
}
```

---

```java
/**
 * LEAK 2: Listeners n√£o removidos
 */
@Component
public class NotificationService {
    private final List<NotificationListener> listeners = new ArrayList<>();

    public void addListener(NotificationListener listener) {
        listeners.add(listener);  // LEAK se n√£o remover
    }

    // ‚ùå Falta m√©todo remove!
}

/**
 * FIX: Adicionar m√©todo remove
 */
@Component
public class NotificationService {
    private final List<NotificationListener> listeners = new CopyOnWriteArrayList<>();

    public void addListener(NotificationListener listener) {
        listeners.add(listener);
    }

    // ‚úÖ Remove listener
    public void removeListener(NotificationListener listener) {
        listeners.remove(listener);
    }
}
```

---

```java
/**
 * LEAK 3: ThreadLocal n√£o limpo
 */
@Component
public class RequestContext {
    // ‚ùå ThreadLocal nunca limpo
    private static final ThreadLocal<User> CURRENT_USER = new ThreadLocal<>();

    public static void setCurrentUser(User user) {
        CURRENT_USER.set(user);  // LEAK em thread pool!
    }
}

/**
 * FIX: Limpar ThreadLocal
 */
@Component
public class RequestContext {
    private static final ThreadLocal<User> CURRENT_USER = new ThreadLocal<>();

    public static void setCurrentUser(User user) {
        CURRENT_USER.set(user);
    }

    // ‚úÖ Limpar ap√≥s uso
    public static void clear() {
        CURRENT_USER.remove();
    }
}

@RestController
public class UserController {
    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        try {
            RequestContext.setCurrentUser(currentUser);
            return userService.getUser(id);
        } finally {
            RequestContext.clear();  // ‚úÖ Sempre limpar
        }
    }
}
```

---

## 5. Reference Types

### 5.1 Strong Reference (Default)

```java
/**
 * STRONG REFERENCE: Objeto n√£o √© GC'ed enquanto refer√™ncia existir
 */
User user = new User("John");
// user n√£o ser√° GC'ed enquanto vari√°vel existir
```

---

### 5.2 Weak Reference

```java
/**
 * WEAK REFERENCE: Objeto √© GC'ed se n√£o houver strong reference
 */
import java.lang.ref.WeakReference;

User user = new User("John");
WeakReference<User> weakRef = new WeakReference<>(user);

// Ainda existe strong reference (user)
System.out.println(weakRef.get());  // User("John")

// Remove strong reference
user = null;

// Ap√≥s GC, weak reference retorna null
System.gc();
System.out.println(weakRef.get());  // null

/**
 * USO: Cache que permite GC sob memory pressure
 */
public class WeakCache<K, V> {
    private final Map<K, WeakReference<V>> cache = new HashMap<>();

    public void put(K key, V value) {
        cache.put(key, new WeakReference<>(value));
    }

    public V get(K key) {
        WeakReference<V> ref = cache.get(key);
        return ref != null ? ref.get() : null;  // null se GC'ed
    }
}
```

---

### 5.3 Soft Reference

```java
/**
 * SOFT REFERENCE: Objeto √© GC'ed APENAS se JVM precisar de mem√≥ria
 * - Mais "forte" que WeakReference
 * - Ideal para caches
 */
import java.lang.ref.SoftReference;

byte[] data = new byte[1_000_000];  // 1MB
SoftReference<byte[]> softRef = new SoftReference<>(data);

data = null;  // Remove strong reference

// GC n√£o coleta imediatamente (ainda h√° mem√≥ria)
System.gc();
System.out.println(softRef.get());  // byte[1_000_000]

// Simula memory pressure (aloca muito)
for (int i = 0; i < 100; i++) {
    byte[] temp = new byte[10_000_000];  // 10MB cada
}

// Agora GC coleta soft references
System.out.println(softRef.get());  // null (GC'ed por memory pressure)

/**
 * USO: Image cache, computed results
 */
public class ImageCache {
    private final Map<String, SoftReference<BufferedImage>> cache = new HashMap<>();

    public BufferedImage get(String path) {
        SoftReference<BufferedImage> ref = cache.get(path);
        BufferedImage image = ref != null ? ref.get() : null;

        if (image == null) {
            image = loadImage(path);  // Recarrega se GC'ed
            cache.put(path, new SoftReference<>(image));
        }

        return image;
    }
}
```

---

### 5.4 Phantom Reference

```java
/**
 * PHANTOM REFERENCE: Notifica√ß√£o AP√ìS GC
 * - Sempre retorna null em get()
 * - Usado para cleanup avan√ßado
 */
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

ReferenceQueue<User> queue = new ReferenceQueue<>();
User user = new User("John");
PhantomReference<User> phantomRef = new PhantomReference<>(user, queue);

System.out.println(phantomRef.get());  // SEMPRE null

user = null;  // Remove strong reference
System.gc();

// Ap√≥s GC, reference aparece na queue
PhantomReference<User> ref = (PhantomReference<User>) queue.poll();
if (ref != null) {
    System.out.println("User was GC'ed, cleanup resources");
    // Cleanup (ex: fechar file handles)
}
```

---

## 6. Otimiza√ß√£o de Mem√≥ria

### 6.1 Object Pooling

```java
/**
 * CEN√ÅRIO: Muitas aloca√ß√µes de objetos pesados
 */

// ‚ùå Cria novo ByteBuffer a cada request
@RestController
public class DataController {
    @GetMapping("/data")
    public byte[] getData() {
        ByteBuffer buffer = ByteBuffer.allocate(1024);  // Aloca sempre
        // ... processa dados
        return buffer.array();
    }
}

// ‚úÖ Usa pool de ByteBuffers
@RestController
public class DataController {
    private final ObjectPool<ByteBuffer> bufferPool =
        new GenericObjectPool<>(new ByteBufferFactory());

    @GetMapping("/data")
    public byte[] getData() throws Exception {
        ByteBuffer buffer = bufferPool.borrowObject();
        try {
            buffer.clear();
            // ... processa dados
            return Arrays.copyOf(buffer.array(), buffer.position());
        } finally {
            bufferPool.returnObject(buffer);
        }
    }
}

class ByteBufferFactory extends BasePooledObjectFactory<ByteBuffer> {
    @Override
    public ByteBuffer create() {
        return ByteBuffer.allocate(1024);
    }

    @Override
    public PooledObject<ByteBuffer> wrap(ByteBuffer buffer) {
        return new DefaultPooledObject<>(buffer);
    }
}
```

---

### 6.2 Lazy Loading

```java
/**
 * CEN√ÅRIO: Carregar dados sob demanda
 */

// ‚ùå Carrega tudo antecipadamente
@Entity
public class User {
    @Id
    private Long id;

    @OneToMany(fetch = FetchType.EAGER)  // ‚ùå Carrega sempre
    private List<Order> orders;  // 1000 orders √ó 10KB = 10MB
}

// ‚úÖ Lazy loading
@Entity
public class User {
    @Id
    private Long id;

    @OneToMany(fetch = FetchType.LAZY)  // ‚úÖ Carrega sob demanda
    private List<Order> orders;
}

/**
 * Acessa orders apenas se necess√°rio:
 */
User user = userRepository.findById(1L);
// orders n√£o carregados ainda (0 memory)

if (needsOrders) {
    user.getOrders().size();  // Trigger lazy load
}
```

---

### 6.3 String Interning

```java
/**
 * CEN√ÅRIO: Muitas Strings duplicadas
 */

// ‚ùå Cria 10.000 Strings "ACTIVE" duplicadas
List<User> users = new ArrayList<>();
for (int i = 0; i < 10000; i++) {
    users.add(new User(i, new String("ACTIVE")));  // 10.000 √ó 48 bytes = 480KB
}

// ‚úÖ Usa String literal (interned)
for (int i = 0; i < 10000; i++) {
    users.add(new User(i, "ACTIVE"));  // 1 String compartilhada = 48 bytes
}

// ‚úÖ Ou intern manualmente:
String status = new String("ACTIVE").intern();  // Reusa String da pool
```

---

## üìä Checklist de Qualidade

- [ ] Habilitar heap dump em OOM (`-XX:+HeapDumpOnOutOfMemoryError`)
- [ ] GC logging habilitado em produ√ß√£o
- [ ] Monitorar Old Gen growth (leak detector)
- [ ] Evitar static collections sem bounded size
- [ ] Remover listeners ap√≥s uso
- [ ] Limpar ThreadLocal em thread pools
- [ ] Usar SoftReference para caches (permite GC sob pressure)
- [ ] Object pooling para objetos pesados (ByteBuffer, Connection)
- [ ] Lazy loading em relacionamentos JPA
- [ ] String interning para valores repetidos
- [ ] Heap dump peri√≥dico em staging (detectar leaks cedo)

---

## üéØ Exerc√≠cios Pr√°ticos

1. **B√°sico**: Capturar heap dump e analisar no MAT
2. **Intermedi√°rio**: Identificar memory leak com GC logs
3. **Avan√ßado**: Implementar cache com SoftReference e medir GC behavior

---

## üìö Refer√™ncias

- [Eclipse MAT](https://www.eclipse.org/mat/)
- [Java Memory Management (Oracle)](https://docs.oracle.com/en/java/javase/17/gctuning/)
- [GC Logging (Baeldung)](https://www.baeldung.com/java-gc-logging-to-file)

---

**Pr√≥ximo:** [14.7 - Otimiza√ß√£o Real](14.7-otimizacao-real.md)
